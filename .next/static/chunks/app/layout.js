/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fapp%2Fcomponents%2FApolloWrapper.js&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.js%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fstyles%2Fglobals.css&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fapp%2Fcomponents%2FApolloWrapper.js&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.js%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fstyles%2Fglobals.css&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/ApolloWrapper.js */ \"(app-pages-browser)/./app/components/ApolloWrapper.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app/layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app/layout.js\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./styles/globals.css */ \"(app-pages-browser)/./styles/globals.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRm1hbnVlbG5hdmFycm8lMkZyb2FyLWhlYWRsZXNzJTJGYXBwJTJGY29tcG9uZW50cyUyRkFwb2xsb1dyYXBwZXIuanMmbW9kdWxlcz0lMkZVc2VycyUyRm1hbnVlbG5hdmFycm8lMkZyb2FyLWhlYWRsZXNzJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMmFwcCUyRmxheW91dC5qcyUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMkludGVyJTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmxhdGluJTIyJTVEJTdEJTVEJTJDJTIydmFyaWFibGVOYW1lJTIyJTNBJTIyaW50ZXIlMjIlN0QmbW9kdWxlcz0lMkZVc2VycyUyRm1hbnVlbG5hdmFycm8lMkZyb2FyLWhlYWRsZXNzJTJGc3R5bGVzJTJGZ2xvYmFscy5jc3Mmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw0TEFBdUc7QUFDdkcsZ2JBQXVPO0FBQ3ZPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/Yzc4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9tYW51ZWxuYXZhcnJvL3JvYXItaGVhZGxlc3MvYXBwL2NvbXBvbmVudHMvQXBvbGxvV3JhcHBlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL21hbnVlbG5hdmFycm8vcm9hci1oZWFkbGVzcy9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcImFwcC9sYXlvdXQuanNcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJJbnRlclxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcImludGVyXFxcIn1cIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9tYW51ZWxuYXZhcnJvL3JvYXItaGVhZGxlc3Mvc3R5bGVzL2dsb2JhbHMuY3NzXCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fapp%2Fcomponents%2FApolloWrapper.js&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.js%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fstyles%2Fglobals.css&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    var e = {\n        686: (e, r, t)=>{\n            var n = t(808);\n            var i = Object.create(null);\n            var a = typeof document === \"undefined\";\n            var o = Array.prototype.forEach;\n            function debounce(e, r) {\n                var t = 0;\n                return function() {\n                    var n = this;\n                    var i = arguments;\n                    var a = function functionCall() {\n                        return e.apply(n, i);\n                    };\n                    clearTimeout(t);\n                    t = setTimeout(a, r);\n                };\n            }\n            function noop() {}\n            function getCurrentScriptUrl(e) {\n                var r = i[e];\n                if (!r) {\n                    if (document.currentScript) {\n                        r = document.currentScript.src;\n                    } else {\n                        var t = document.getElementsByTagName(\"script\");\n                        var a = t[t.length - 1];\n                        if (a) {\n                            r = a.src;\n                        }\n                    }\n                    i[e] = r;\n                }\n                return function(e) {\n                    if (!r) {\n                        return null;\n                    }\n                    var t = r.split(/([^\\\\/]+)\\.js$/);\n                    var i = t && t[1];\n                    if (!i) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    if (!e) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    return e.split(\",\").map(function(e) {\n                        var t = new RegExp(\"\".concat(i, \"\\\\.js$\"), \"g\");\n                        return n(r.replace(t, \"\".concat(e.replace(/{fileName}/g, i), \".css\")));\n                    });\n                };\n            }\n            function updateCss(e, r) {\n                if (!r) {\n                    if (!e.href) {\n                        return;\n                    }\n                    r = e.href.split(\"?\")[0];\n                }\n                if (!isUrlRequest(r)) {\n                    return;\n                }\n                if (e.isLoaded === false) {\n                    return;\n                }\n                if (!r || !(r.indexOf(\".css\") > -1)) {\n                    return;\n                }\n                e.visited = true;\n                var t = e.cloneNode();\n                t.isLoaded = false;\n                t.addEventListener(\"load\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.addEventListener(\"error\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.href = \"\".concat(r, \"?\").concat(Date.now());\n                if (e.nextSibling) {\n                    e.parentNode.insertBefore(t, e.nextSibling);\n                } else {\n                    e.parentNode.appendChild(t);\n                }\n            }\n            function getReloadUrl(e, r) {\n                var t;\n                e = n(e, {\n                    stripWWW: false\n                });\n                r.some(function(n) {\n                    if (e.indexOf(r) > -1) {\n                        t = n;\n                    }\n                });\n                return t;\n            }\n            function reloadStyle(e) {\n                if (!e) {\n                    return false;\n                }\n                var r = document.querySelectorAll(\"link\");\n                var t = false;\n                o.call(r, function(r) {\n                    if (!r.href) {\n                        return;\n                    }\n                    var n = getReloadUrl(r.href, e);\n                    if (!isUrlRequest(n)) {\n                        return;\n                    }\n                    if (r.visited === true) {\n                        return;\n                    }\n                    if (n) {\n                        updateCss(r, n);\n                        t = true;\n                    }\n                });\n                return t;\n            }\n            function reloadAll() {\n                var e = document.querySelectorAll(\"link\");\n                o.call(e, function(e) {\n                    if (e.visited === true) {\n                        return;\n                    }\n                    updateCss(e);\n                });\n            }\n            function isUrlRequest(e) {\n                if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)) {\n                    return false;\n                }\n                return true;\n            }\n            e.exports = function(e, r) {\n                if (a) {\n                    console.log(\"no window.document found, will not HMR CSS\");\n                    return noop;\n                }\n                var t = getCurrentScriptUrl(e);\n                function update() {\n                    var e = t(r.filename);\n                    var n = reloadStyle(e);\n                    if (r.locals) {\n                        console.log(\"[HMR] Detected local css modules. Reload all css\");\n                        reloadAll();\n                        return;\n                    }\n                    if (n) {\n                        console.log(\"[HMR] css reload %s\", e.join(\" \"));\n                    } else {\n                        console.log(\"[HMR] Reload all css\");\n                        reloadAll();\n                    }\n                }\n                return debounce(update, 50);\n            };\n        },\n        808: (e)=>{\n            function normalizeUrl(e) {\n                return e.reduce(function(e, r) {\n                    switch(r){\n                        case \"..\":\n                            e.pop();\n                            break;\n                        case \".\":\n                            break;\n                        default:\n                            e.push(r);\n                    }\n                    return e;\n                }, []).join(\"/\");\n            }\n            e.exports = function(e) {\n                e = e.trim();\n                if (/^data:/i.test(e)) {\n                    return e;\n                }\n                var r = e.indexOf(\"//\") !== -1 ? e.split(\"//\")[0] + \"//\" : \"\";\n                var t = e.replace(new RegExp(r, \"i\"), \"\").split(\"/\");\n                var n = t[0].toLowerCase().replace(/\\.$/, \"\");\n                t[0] = \"\";\n                var i = normalizeUrl(t);\n                return r + n + i;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var n = r[t];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](i, i.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(686);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBSztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLENBQUNBLEdBQUVDLEdBQUVDO1lBQUssSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlFLElBQUVDLE9BQU9DLE1BQU0sQ0FBQztZQUFNLElBQUlDLElBQUUsT0FBT0MsYUFBVztZQUFZLElBQUlDLElBQUVDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztZQUFDLFNBQVNDLFNBQVNiLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFFLE9BQU87b0JBQVcsSUFBSUMsSUFBRSxJQUFJO29CQUFDLElBQUlDLElBQUVVO29CQUFVLElBQUlQLElBQUUsU0FBU1E7d0JBQWUsT0FBT2YsRUFBRWdCLEtBQUssQ0FBQ2IsR0FBRUM7b0JBQUU7b0JBQUVhLGFBQWFmO29CQUFHQSxJQUFFZ0IsV0FBV1gsR0FBRU47Z0JBQUU7WUFBQztZQUFDLFNBQVNrQixRQUFPO1lBQUMsU0FBU0Msb0JBQW9CcEIsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRyxDQUFDLENBQUNKLEVBQUU7Z0JBQUMsSUFBRyxDQUFDQyxHQUFFO29CQUFDLElBQUdPLFNBQVNhLGFBQWEsRUFBQzt3QkFBQ3BCLElBQUVPLFNBQVNhLGFBQWEsQ0FBQ0MsR0FBRztvQkFBQSxPQUFLO3dCQUFDLElBQUlwQixJQUFFTSxTQUFTZSxvQkFBb0IsQ0FBQzt3QkFBVSxJQUFJaEIsSUFBRUwsQ0FBQyxDQUFDQSxFQUFFc0IsTUFBTSxHQUFDLEVBQUU7d0JBQUMsSUFBR2pCLEdBQUU7NEJBQUNOLElBQUVNLEVBQUVlLEdBQUc7d0JBQUE7b0JBQUM7b0JBQUNsQixDQUFDLENBQUNKLEVBQUUsR0FBQ0M7Z0JBQUM7Z0JBQUMsT0FBTyxTQUFT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Q0FBQ0MsRUFBRSxHQUFDO1lBQUNtRCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUk5QyxJQUFFO1FBQUssSUFBRztZQUFDUCxDQUFDLENBQUNFLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRWlELE9BQU8sRUFBQ2E7WUFBcUIzRCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFaUQsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPYSx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJbkUsSUFBRWdFLG9CQUFvQjtJQUFLSSxPQUFPakIsT0FBTyxHQUFDbkQ7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz81ZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsInIiLCJ0IiwibiIsImkiLCJPYmplY3QiLCJjcmVhdGUiLCJhIiwiZG9jdW1lbnQiLCJvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGVib3VuY2UiLCJhcmd1bWVudHMiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJub29wIiwiZ2V0Q3VycmVudFNjcmlwdFVybCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInNwbGl0IiwicmVwbGFjZSIsIm1hcCIsIlJlZ0V4cCIsImNvbmNhdCIsInVwZGF0ZUNzcyIsImhyZWYiLCJpc1VybFJlcXVlc3QiLCJpc0xvYWRlZCIsImluZGV4T2YiLCJ2aXNpdGVkIiwiY2xvbmVOb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZ2V0UmVsb2FkVXJsIiwic3RyaXBXV1ciLCJzb21lIiwicmVsb2FkU3R5bGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FsbCIsInJlbG9hZEFsbCIsInRlc3QiLCJleHBvcnRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZSIsImZpbGVuYW1lIiwibG9jYWxzIiwiam9pbiIsIm5vcm1hbGl6ZVVybCIsInJlZHVjZSIsInBvcCIsInB1c2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rehackt/index.js":
/*!***************************************!*\
  !*** ./node_modules/rehackt/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {}\n// We don't want bundlers to error when they encounter usage of any of these exports.\n// It's up to the package author to ensure that if they access React internals,\n// they do so in a safe way that won't break if React changes how they use these internals.\n// (e.g. only access them in development, and only in an optional way that won't\n// break if internals are not there or do not have the expected structure)\n// @ts-ignore\nmodule.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = undefined;\n// @ts-ignore\nmodule.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;\n// @ts-ignore\nmodule.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = undefined;\n// Here we actually pull in the React library and add everything\n// it exports to our own `module.exports`.\n// If React suddenly were to add one of the above \"polyfilled\" exports,\n// the React version would overwrite our version, so this should be\n// future-proof.\nObject.assign(module.exports, __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWhhY2t0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSSxLQUFDLEVBQUUsRUFLTjtBQUNELHFGQUFxRjtBQUNyRiwrRUFBK0U7QUFDL0UsMkZBQTJGO0FBQzNGLGdGQUFnRjtBQUNoRiwwRUFBMEU7QUFDMUUsYUFBYTtBQUNiQSxpRUFBaUUsR0FBR0k7QUFDcEUsYUFBYTtBQUNiSiw4RUFBOEUsR0FBR0k7QUFDakYsYUFBYTtBQUNiSiw4RUFBOEUsR0FBR0k7QUFDakYsZ0VBQWdFO0FBQ2hFLDBDQUEwQztBQUMxQyx1RUFBdUU7QUFDdkUsbUVBQW1FO0FBQ25FLGdCQUFnQjtBQUNoQkcsT0FBT0MsTUFBTSxDQUFDUixPQUFPQyxPQUFPLEVBQUVDLG1CQUFPQSxDQUFDLG1GQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWhhY2t0L2luZGV4LmpzPzY5NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pZiAoMCkge1xuICAvLyBUcmljayBjanMtbW9kdWxlLWxleGVyIGludG8gYWRkaW5nIG5hbWVkIGV4cG9ydHMgZm9yIGFsbCBSZWFjdCBleHBvcnRzLlxuICAvLyAoaWYgaW1wb3J0ZWQgd2l0aCBgaW1wb3J0KClgLCB0aGV5IHdpbGwgYXBwZWFyIGluIGAuZGVmYXVsdGAgYXMgd2VsbC4pXG4gIC8vIFRoaXMgd2F5LCBjanMtbW9kdWxlLWxleGVyIHdpbGwgbGV0IGFsbCBvZiByZWFjdCdzIChuYW1lZCkgZXhwb3J0cyB0aHJvdWdoIHVuY2hhbmdlZC5cbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7XG59XG4vLyBXZSBkb24ndCB3YW50IGJ1bmRsZXJzIHRvIGVycm9yIHdoZW4gdGhleSBlbmNvdW50ZXIgdXNhZ2Ugb2YgYW55IG9mIHRoZXNlIGV4cG9ydHMuXG4vLyBJdCdzIHVwIHRvIHRoZSBwYWNrYWdlIGF1dGhvciB0byBlbnN1cmUgdGhhdCBpZiB0aGV5IGFjY2VzcyBSZWFjdCBpbnRlcm5hbHMsXG4vLyB0aGV5IGRvIHNvIGluIGEgc2FmZSB3YXkgdGhhdCB3b24ndCBicmVhayBpZiBSZWFjdCBjaGFuZ2VzIGhvdyB0aGV5IHVzZSB0aGVzZSBpbnRlcm5hbHMuXG4vLyAoZS5nLiBvbmx5IGFjY2VzcyB0aGVtIGluIGRldmVsb3BtZW50LCBhbmQgb25seSBpbiBhbiBvcHRpb25hbCB3YXkgdGhhdCB3b24ndFxuLy8gYnJlYWsgaWYgaW50ZXJuYWxzIGFyZSBub3QgdGhlcmUgb3IgZG8gbm90IGhhdmUgdGhlIGV4cGVjdGVkIHN0cnVjdHVyZSlcbi8vIEB0cy1pZ25vcmVcbm1vZHVsZS5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gdW5kZWZpbmVkO1xuLy8gQHRzLWlnbm9yZVxubW9kdWxlLmV4cG9ydHMuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID0gdW5kZWZpbmVkO1xuLy8gQHRzLWlnbm9yZVxubW9kdWxlLmV4cG9ydHMuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID0gdW5kZWZpbmVkO1xuLy8gSGVyZSB3ZSBhY3R1YWxseSBwdWxsIGluIHRoZSBSZWFjdCBsaWJyYXJ5IGFuZCBhZGQgZXZlcnl0aGluZ1xuLy8gaXQgZXhwb3J0cyB0byBvdXIgb3duIGBtb2R1bGUuZXhwb3J0c2AuXG4vLyBJZiBSZWFjdCBzdWRkZW5seSB3ZXJlIHRvIGFkZCBvbmUgb2YgdGhlIGFib3ZlIFwicG9seWZpbGxlZFwiIGV4cG9ydHMsXG4vLyB0aGUgUmVhY3QgdmVyc2lvbiB3b3VsZCBvdmVyd3JpdGUgb3VyIHZlcnNpb24sIHNvIHRoaXMgc2hvdWxkIGJlXG4vLyBmdXR1cmUtcHJvb2YuXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCByZXF1aXJlKFwicmVhY3RcIikpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ1bmRlZmluZWQiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJfX1NFUlZFUl9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rehackt/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"a8114156dcfc\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0eWxlcy9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzPzE4NjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhODExNDE1NmRjZmNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./styles/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/ApolloWrapper.js":
/*!*****************************************!*\
  !*** ./app/components/ApolloWrapper.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ApolloWrapper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @apollo/client */ \"(app-pages-browser)/./node_modules/@apollo/client/core/ApolloClient.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @apollo/client */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/inMemoryCache.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @apollo/client */ \"(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloProvider.js\");\n// components/ApolloWrapper.js\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst client = new _apollo_client__WEBPACK_IMPORTED_MODULE_1__.ApolloClient({\n    uri: \"https://headlessroadev.wpengine.com/graphql\",\n    cache: new _apollo_client__WEBPACK_IMPORTED_MODULE_2__.InMemoryCache()\n});\nfunction ApolloWrapper(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_apollo_client__WEBPACK_IMPORTED_MODULE_3__.ApolloProvider, {\n        client: client,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/manuelnavarro/roar-headless/app/components/ApolloWrapper.js\",\n        lineNumber: 12,\n        columnNumber: 10\n    }, this);\n}\n_c = ApolloWrapper;\nvar _c;\n$RefreshReg$(_c, \"ApolloWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0Fwb2xsb1dyYXBwZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSw4QkFBOEI7O0FBRytDO0FBRTdFLE1BQU1HLFNBQVMsSUFBSUgsd0RBQVlBLENBQUM7SUFDOUJJLEtBQUtDLDZDQUF5QztJQUM5Q0csT0FBTyxJQUFJTix5REFBYUE7QUFDMUI7QUFFZSxTQUFTTyxjQUFjLEtBQVk7UUFBWixFQUFFQyxRQUFRLEVBQUUsR0FBWjtJQUNwQyxxQkFBTyw4REFBQ1QsMERBQWNBO1FBQUNFLFFBQVFBO2tCQUFTTzs7Ozs7O0FBQzFDO0tBRndCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9BcG9sbG9XcmFwcGVyLmpzP2QzOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tcG9uZW50cy9BcG9sbG9XcmFwcGVyLmpzXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IEFwb2xsb0NsaWVudCwgQXBvbGxvUHJvdmlkZXIsIEluTWVtb3J5Q2FjaGUgfSBmcm9tICdAYXBvbGxvL2NsaWVudCc7XG5cbmNvbnN0IGNsaWVudCA9IG5ldyBBcG9sbG9DbGllbnQoe1xuICB1cmk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dPUkRQUkVTU19BUElfVVJMLFxuICBjYWNoZTogbmV3IEluTWVtb3J5Q2FjaGUoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcG9sbG9XcmFwcGVyKHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gPEFwb2xsb1Byb3ZpZGVyIGNsaWVudD17Y2xpZW50fT57Y2hpbGRyZW59PC9BcG9sbG9Qcm92aWRlcj47XG59XG4iXSwibmFtZXMiOlsiQXBvbGxvQ2xpZW50IiwiQXBvbGxvUHJvdmlkZXIiLCJJbk1lbW9yeUNhY2hlIiwiY2xpZW50IiwidXJpIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1dPUkRQUkVTU19BUElfVVJMIiwiY2FjaGUiLCJBcG9sbG9XcmFwcGVyIiwiY2hpbGRyZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/ApolloWrapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app/layout.js","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_d65c78', '__Inter_Fallback_d65c78'\",\"fontStyle\":\"normal\"},\"className\":\"__className_d65c78\"};\n    if(true) {\n      // 1736950003678\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwL2xheW91dC5qc1wiLFwiaW1wb3J0XCI6XCJJbnRlclwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJpbnRlclwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdGQUFnRjtBQUMzRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBd0gsY0FBYyxzREFBc0Q7QUFDMU4sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzPzQ0YjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fSW50ZXJfZDY1Yzc4JywgJ19fSW50ZXJfRmFsbGJhY2tfZDY1Yzc4J1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2Q2NWM3OFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzM2OTUwMDAzNjc4XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9tYW51ZWxuYXZhcnJvL3JvYXItaGVhZGxlc3Mvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.js\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/core/cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/@apollo/client/cache/core/cache.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloCache: function() { return /* binding */ ApolloCache; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/weak.js\");\n/* harmony import */ var _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n/* harmony import */ var _core_equalByQuery_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/equalByQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js\");\n\n\n\n\n\n\nvar ApolloCache = /** @class */ function() {\n    function ApolloCache() {\n        this.assumeImmutableResults = false;\n        // Make sure we compute the same (===) fragment query document every\n        // time we receive the same fragment in readFragment.\n        this.getFragmentDoc = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.getFragmentQueryDocument, {\n            max: _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */ ,\n            cache: _wry_caches__WEBPACK_IMPORTED_MODULE_3__.WeakCache\n        });\n    }\n    // Transactional API\n    // The batch method is intended to replace/subsume both performTransaction\n    // and recordOptimisticTransaction, but performTransaction came first, so we\n    // provide a default batch implementation that's just another way of calling\n    // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n    // override the batch method to do more interesting things with its options.\n    ApolloCache.prototype.batch = function(options) {\n        var _this = this;\n        var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n        var updateResult;\n        this.performTransaction(function() {\n            return updateResult = options.update(_this);\n        }, optimisticId);\n        return updateResult;\n    };\n    ApolloCache.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {\n        this.performTransaction(transaction, optimisticId);\n    };\n    // Optional API\n    // Called once per input document, allowing the cache to make static changes\n    // to the query, such as adding __typename fields.\n    ApolloCache.prototype.transformDocument = function(document) {\n        return document;\n    };\n    // Called before each ApolloLink request, allowing the cache to make dynamic\n    // changes to the query, such as filling in missing fragment definitions.\n    ApolloCache.prototype.transformForLink = function(document) {\n        return document;\n    };\n    ApolloCache.prototype.identify = function(object) {\n        return;\n    };\n    ApolloCache.prototype.gc = function() {\n        return [];\n    };\n    ApolloCache.prototype.modify = function(options) {\n        return false;\n    };\n    // DataProxy API\n    ApolloCache.prototype.readQuery = function(options, optimistic) {\n        if (optimistic === void 0) {\n            optimistic = !!options.optimistic;\n        }\n        return this.read((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n            rootId: options.id || \"ROOT_QUERY\",\n            optimistic: optimistic\n        }));\n    };\n    /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */ ApolloCache.prototype.watchFragment = function(options) {\n        var _this = this;\n        var fragment = options.fragment, fragmentName = options.fragmentName, from = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, otherOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n            \"fragment\",\n            \"fragmentName\",\n            \"from\",\n            \"optimistic\"\n        ]);\n        var query = this.getFragmentDoc(fragment, fragmentName);\n        var diffOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, otherOptions), {\n            returnPartialData: true,\n            id: // While our TypeScript types do not allow for `undefined` as a valid\n            // `from`, its possible `useFragment` gives us an `undefined` since it\n            // calls` cache.identify` and provides that value to `from`. We are\n            // adding this fix here however to ensure those using plain JavaScript\n            // and using `cache.identify` themselves will avoid seeing the obscure\n            // warning.\n            typeof from === \"undefined\" || typeof from === \"string\" ? from : this.identify(from),\n            query: query,\n            optimistic: optimistic\n        });\n        var latestDiff;\n        return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.Observable(function(observer) {\n            return _this.watch((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, diffOptions), {\n                immediate: true,\n                callback: function(diff) {\n                    if (// Always ensure we deliver the first result\n                    latestDiff && (0,_core_equalByQuery_js__WEBPACK_IMPORTED_MODULE_6__.equalByQuery)(query, {\n                        data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result\n                    }, {\n                        data: diff.result\n                    })) {\n                        return;\n                    }\n                    var result = {\n                        data: diff.result,\n                        complete: !!diff.complete\n                    };\n                    if (diff.missing) {\n                        result.missing = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.mergeDeepArray)(diff.missing.map(function(error) {\n                            return error.missing;\n                        }));\n                    }\n                    latestDiff = diff;\n                    observer.next(result);\n                }\n            }));\n        });\n    };\n    ApolloCache.prototype.readFragment = function(options, optimistic) {\n        if (optimistic === void 0) {\n            optimistic = !!options.optimistic;\n        }\n        return this.read((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n            query: this.getFragmentDoc(options.fragment, options.fragmentName),\n            rootId: options.id,\n            optimistic: optimistic\n        }));\n    };\n    ApolloCache.prototype.writeQuery = function(_a) {\n        var id = _a.id, data = _a.data, options = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\n            \"id\",\n            \"data\"\n        ]);\n        return this.write(Object.assign(options, {\n            dataId: id || \"ROOT_QUERY\",\n            result: data\n        }));\n    };\n    ApolloCache.prototype.writeFragment = function(_a) {\n        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\n            \"id\",\n            \"data\",\n            \"fragment\",\n            \"fragmentName\"\n        ]);\n        return this.write(Object.assign(options, {\n            query: this.getFragmentDoc(fragment, fragmentName),\n            dataId: id,\n            result: data\n        }));\n    };\n    ApolloCache.prototype.updateQuery = function(options, update) {\n        return this.batch({\n            update: function(cache) {\n                var value = cache.readQuery(options);\n                var data = update(value);\n                if (data === void 0 || data === null) return value;\n                cache.writeQuery((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n                    data: data\n                }));\n                return data;\n            }\n        });\n    };\n    ApolloCache.prototype.updateFragment = function(options, update) {\n        return this.batch({\n            update: function(cache) {\n                var value = cache.readFragment(options);\n                var data = update(value);\n                if (data === void 0 || data === null) return value;\n                cache.writeFragment((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n                    data: data\n                }));\n                return data;\n            }\n        });\n    };\n    return ApolloCache;\n}();\n\nif (globalThis.__DEV__ !== false) {\n    ApolloCache.prototype.getMemoryInternals = _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_8__.getApolloCacheMemoryInternals;\n} //# sourceMappingURL=cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9jb3JlL2NhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDVDtBQUM2RTtBQUNyRTtBQUNzRDtBQUNwQztBQUMxRCxJQUFJVSxjQUFjLFdBQVcsR0FBSTtJQUM3QixTQUFTQTtRQUNMLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUc7UUFDOUIsb0VBQW9FO1FBQ3BFLHFEQUFxRDtRQUNyRCxJQUFJLENBQUNDLGNBQWMsR0FBR1YsOENBQUlBLENBQUNHLHlFQUF3QkEsRUFBRTtZQUNqRFEsS0FBS1QsMkRBQVUsQ0FBQywrQkFBK0IsSUFDM0MsS0FBSyxxREFBcUQ7WUFDOURVLE9BQU9QLGtEQUFTQTtRQUNwQjtJQUNKO0lBQ0Esb0JBQW9CO0lBQ3BCLDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUVHLFlBQVlLLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVVDLE9BQU87UUFDM0MsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUlDLGVBQWUsT0FBT0YsUUFBUUcsVUFBVSxLQUFLLFdBQVdILFFBQVFHLFVBQVUsR0FDeEVILFFBQVFHLFVBQVUsS0FBSyxRQUFRLE9BQzNCLEtBQUs7UUFDZixJQUFJQztRQUNKLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7WUFBYyxPQUFRRCxlQUFlSixRQUFRTSxNQUFNLENBQUNMO1FBQVMsR0FBR0M7UUFDeEYsT0FBT0U7SUFDWDtJQUNBWCxZQUFZSyxTQUFTLENBQUNTLDJCQUEyQixHQUFHLFNBQVVDLFdBQVcsRUFBRU4sWUFBWTtRQUNuRixJQUFJLENBQUNHLGtCQUFrQixDQUFDRyxhQUFhTjtJQUN6QztJQUNBLGVBQWU7SUFDZiw0RUFBNEU7SUFDNUUsa0RBQWtEO0lBQ2xEVCxZQUFZSyxTQUFTLENBQUNXLGlCQUFpQixHQUFHLFNBQVVDLFFBQVE7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LE1BQU07UUFDekQsT0FBTyxJQUFJLENBQUNQLEtBQUssQ0FBQztZQUNkTyxRQUFRLFNBQVVULEtBQUs7Z0JBQ25CLElBQUlxRCxRQUFRckQsTUFBTW1CLFNBQVMsQ0FBQ2hCO2dCQUM1QixJQUFJbUMsT0FBTzdCLE9BQU80QztnQkFDbEIsSUFBSWYsU0FBUyxLQUFLLEtBQUtBLFNBQVMsTUFDNUIsT0FBT2U7Z0JBQ1hyRCxNQUFNOEMsVUFBVSxDQUFDNUQsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR2lCLFVBQVU7b0JBQUVtQyxNQUFNQTtnQkFBSztnQkFDOUQsT0FBT0E7WUFDWDtRQUNKO0lBQ0o7SUFDQTFDLFlBQVlLLFNBQVMsQ0FBQ3FELGNBQWMsR0FBRyxTQUFVbkQsT0FBTyxFQUFFTSxNQUFNO1FBQzVELE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUM7WUFDZE8sUUFBUSxTQUFVVCxLQUFLO2dCQUNuQixJQUFJcUQsUUFBUXJELE1BQU02QyxZQUFZLENBQUMxQztnQkFDL0IsSUFBSW1DLE9BQU83QixPQUFPNEM7Z0JBQ2xCLElBQUlmLFNBQVMsS0FBSyxLQUFLQSxTQUFTLE1BQzVCLE9BQU9lO2dCQUNYckQsTUFBTW1ELGFBQWEsQ0FBQ2pFLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdpQixVQUFVO29CQUFFbUMsTUFBTUE7Z0JBQUs7Z0JBQ2pFLE9BQU9BO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsT0FBTzFDO0FBQ1g7QUFDdUI7QUFDdkIsSUFBSTJELFdBQVdDLE9BQU8sS0FBSyxPQUFPO0lBQzlCNUQsWUFBWUssU0FBUyxDQUFDd0Qsa0JBQWtCLEdBQUcvRCxtR0FBNkJBO0FBQzVFLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9jb3JlL2NhY2hlLmpzP2I5N2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gXCJvcHRpbWlzbVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgY2FjaGVTaXplcywgZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50LCBtZXJnZURlZXBBcnJheSwgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBXZWFrQ2FjaGUgfSBmcm9tIFwiQHdyeS9jYWNoZXNcIjtcbmltcG9ydCB7IGdldEFwb2xsb0NhY2hlTWVtb3J5SW50ZXJuYWxzIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9jYWNoaW5nL2dldE1lbW9yeUludGVybmFscy5qc1wiO1xuaW1wb3J0IHsgZXF1YWxCeVF1ZXJ5IH0gZnJvbSBcIi4uLy4uL2NvcmUvZXF1YWxCeVF1ZXJ5LmpzXCI7XG52YXIgQXBvbGxvQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBvbGxvQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA9IGZhbHNlO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY29tcHV0ZSB0aGUgc2FtZSAoPT09KSBmcmFnbWVudCBxdWVyeSBkb2N1bWVudCBldmVyeVxuICAgICAgICAvLyB0aW1lIHdlIHJlY2VpdmUgdGhlIHNhbWUgZnJhZ21lbnQgaW4gcmVhZEZyYWdtZW50LlxuICAgICAgICB0aGlzLmdldEZyYWdtZW50RG9jID0gd3JhcChnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG1heDogY2FjaGVTaXplc1tcImNhY2hlLmZyYWdtZW50UXVlcnlEb2N1bWVudHNcIl0gfHxcbiAgICAgICAgICAgICAgICAxMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiY2FjaGUuZnJhZ21lbnRRdWVyeURvY3VtZW50c1wiXSAqLyxcbiAgICAgICAgICAgIGNhY2hlOiBXZWFrQ2FjaGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbmFsIEFQSVxuICAgIC8vIFRoZSBiYXRjaCBtZXRob2QgaXMgaW50ZW5kZWQgdG8gcmVwbGFjZS9zdWJzdW1lIGJvdGggcGVyZm9ybVRyYW5zYWN0aW9uXG4gICAgLy8gYW5kIHJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbiwgYnV0IHBlcmZvcm1UcmFuc2FjdGlvbiBjYW1lIGZpcnN0LCBzbyB3ZVxuICAgIC8vIHByb3ZpZGUgYSBkZWZhdWx0IGJhdGNoIGltcGxlbWVudGF0aW9uIHRoYXQncyBqdXN0IGFub3RoZXIgd2F5IG9mIGNhbGxpbmdcbiAgICAvLyBwZXJmb3JtVHJhbnNhY3Rpb24uIFN1YmNsYXNzZXMgb2YgQXBvbGxvQ2FjaGUgKHN1Y2ggYXMgSW5NZW1vcnlDYWNoZSkgY2FuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGJhdGNoIG1ldGhvZCB0byBkbyBtb3JlIGludGVyZXN0aW5nIHRoaW5ncyB3aXRoIGl0cyBvcHRpb25zLlxuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpbWlzdGljSWQgPSB0eXBlb2Ygb3B0aW9ucy5vcHRpbWlzdGljID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5vcHRpbWlzdGljXG4gICAgICAgICAgICA6IG9wdGlvbnMub3B0aW1pc3RpYyA9PT0gZmFsc2UgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgIHZhciB1cGRhdGVSZXN1bHQ7XG4gICAgICAgIHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh1cGRhdGVSZXN1bHQgPSBvcHRpb25zLnVwZGF0ZShfdGhpcykpOyB9LCBvcHRpbWlzdGljSWQpO1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVzdWx0O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgb3B0aW1pc3RpY0lkKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpbWlzdGljSWQpO1xuICAgIH07XG4gICAgLy8gT3B0aW9uYWwgQVBJXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGlucHV0IGRvY3VtZW50LCBhbGxvd2luZyB0aGUgY2FjaGUgdG8gbWFrZSBzdGF0aWMgY2hhbmdlc1xuICAgIC8vIHRvIHRoZSBxdWVyeSwgc3VjaCBhcyBhZGRpbmcgX190eXBlbmFtZSBmaWVsZHMuXG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnRyYW5zZm9ybURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuICAgIC8vIENhbGxlZCBiZWZvcmUgZWFjaCBBcG9sbG9MaW5rIHJlcXVlc3QsIGFsbG93aW5nIHRoZSBjYWNoZSB0byBtYWtlIGR5bmFtaWNcbiAgICAvLyBjaGFuZ2VzIHRvIHRoZSBxdWVyeSwgc3VjaCBhcyBmaWxsaW5nIGluIG1pc3NpbmcgZnJhZ21lbnQgZGVmaW5pdGlvbnMuXG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnRyYW5zZm9ybUZvckxpbmsgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBEYXRhUHJveHkgQVBJXG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnJlYWRRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9ICEhb3B0aW9ucy5vcHRpbWlzdGljOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWQoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHJvb3RJZDogb3B0aW9ucy5pZCB8fCBcIlJPT1RfUVVFUllcIiwgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyB9KSk7XG4gICAgfTtcbiAgICAvKioge0Bpbmhlcml0RG9jIEBhcG9sbG8vY2xpZW50IUFwb2xsb0NsaWVudCN3YXRjaEZyYWdtZW50Om1lbWJlcigxKX0gKi9cbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUud2F0Y2hGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IG9wdGlvbnMuZnJhZ21lbnQsIGZyYWdtZW50TmFtZSA9IG9wdGlvbnMuZnJhZ21lbnROYW1lLCBmcm9tID0gb3B0aW9ucy5mcm9tLCBfYSA9IG9wdGlvbnMub3B0aW1pc3RpYywgb3B0aW1pc3RpYyA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIG90aGVyT3B0aW9ucyA9IF9fcmVzdChvcHRpb25zLCBbXCJmcmFnbWVudFwiLCBcImZyYWdtZW50TmFtZVwiLCBcImZyb21cIiwgXCJvcHRpbWlzdGljXCJdKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5nZXRGcmFnbWVudERvYyhmcmFnbWVudCwgZnJhZ21lbnROYW1lKTtcbiAgICAgICAgdmFyIGRpZmZPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG90aGVyT3B0aW9ucyksIHsgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsIGlkOiBcbiAgICAgICAgICAgIC8vIFdoaWxlIG91ciBUeXBlU2NyaXB0IHR5cGVzIGRvIG5vdCBhbGxvdyBmb3IgYHVuZGVmaW5lZGAgYXMgYSB2YWxpZFxuICAgICAgICAgICAgLy8gYGZyb21gLCBpdHMgcG9zc2libGUgYHVzZUZyYWdtZW50YCBnaXZlcyB1cyBhbiBgdW5kZWZpbmVkYCBzaW5jZSBpdFxuICAgICAgICAgICAgLy8gY2FsbHNgIGNhY2hlLmlkZW50aWZ5YCBhbmQgcHJvdmlkZXMgdGhhdCB2YWx1ZSB0byBgZnJvbWAuIFdlIGFyZVxuICAgICAgICAgICAgLy8gYWRkaW5nIHRoaXMgZml4IGhlcmUgaG93ZXZlciB0byBlbnN1cmUgdGhvc2UgdXNpbmcgcGxhaW4gSmF2YVNjcmlwdFxuICAgICAgICAgICAgLy8gYW5kIHVzaW5nIGBjYWNoZS5pZGVudGlmeWAgdGhlbXNlbHZlcyB3aWxsIGF2b2lkIHNlZWluZyB0aGUgb2JzY3VyZVxuICAgICAgICAgICAgLy8gd2FybmluZy5cbiAgICAgICAgICAgIHR5cGVvZiBmcm9tID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBmcm9tID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBmcm9tXG4gICAgICAgICAgICAgICAgOiB0aGlzLmlkZW50aWZ5KGZyb20pLCBxdWVyeTogcXVlcnksIG9wdGltaXN0aWM6IG9wdGltaXN0aWMgfSk7XG4gICAgICAgIHZhciBsYXRlc3REaWZmO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMud2F0Y2goX19hc3NpZ24oX19hc3NpZ24oe30sIGRpZmZPcHRpb25zKSwgeyBpbW1lZGlhdGU6IHRydWUsIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGlmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBlbnN1cmUgd2UgZGVsaXZlciB0aGUgZmlyc3QgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdERpZmYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsQnlRdWVyeShxdWVyeSwgeyBkYXRhOiBsYXRlc3REaWZmID09PSBudWxsIHx8IGxhdGVzdERpZmYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdERpZmYucmVzdWx0IH0sIHsgZGF0YTogZGlmZi5yZXN1bHQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGlmZi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogISFkaWZmLmNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZi5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWlzc2luZyA9IG1lcmdlRGVlcEFycmF5KGRpZmYubWlzc2luZy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5taXNzaW5nOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0RGlmZiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVhZEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gISFvcHRpb25zLm9wdGltaXN0aWM7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgcXVlcnk6IHRoaXMuZ2V0RnJhZ21lbnREb2Mob3B0aW9ucy5mcmFnbWVudCwgb3B0aW9ucy5mcmFnbWVudE5hbWUpLCByb290SWQ6IG9wdGlvbnMuaWQsIG9wdGltaXN0aWM6IG9wdGltaXN0aWMgfSkpO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLndyaXRlUXVlcnkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlkID0gX2EuaWQsIGRhdGEgPSBfYS5kYXRhLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJpZFwiLCBcImRhdGFcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGRhdGFJZDogaWQgfHwgXCJST09UX1FVRVJZXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGRhdGEsXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS53cml0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpZCA9IF9hLmlkLCBkYXRhID0gX2EuZGF0YSwgZnJhZ21lbnQgPSBfYS5mcmFnbWVudCwgZnJhZ21lbnROYW1lID0gX2EuZnJhZ21lbnROYW1lLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJpZFwiLCBcImRhdGFcIiwgXCJmcmFnbWVudFwiLCBcImZyYWdtZW50TmFtZVwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuZ2V0RnJhZ21lbnREb2MoZnJhZ21lbnQsIGZyYWdtZW50TmFtZSksXG4gICAgICAgICAgICBkYXRhSWQ6IGlkLFxuICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUudXBkYXRlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgdXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoKHtcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FjaGUucmVhZFF1ZXJ5KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwIHx8IGRhdGEgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYWNoZS53cml0ZVF1ZXJ5KF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkYXRhOiBkYXRhIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnVwZGF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaCh7XG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhY2hlLnJlYWRGcmFnbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCB8fCBkYXRhID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgY2FjaGUud3JpdGVGcmFnbWVudChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZGF0YTogZGF0YSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcG9sbG9DYWNoZTtcbn0oKSk7XG5leHBvcnQgeyBBcG9sbG9DYWNoZSB9O1xuaWYgKGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UpIHtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUuZ2V0TWVtb3J5SW50ZXJuYWxzID0gZ2V0QXBvbGxvQ2FjaGVNZW1vcnlJbnRlcm5hbHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX3Jlc3QiLCJ3cmFwIiwiT2JzZXJ2YWJsZSIsImNhY2hlU2l6ZXMiLCJnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQiLCJtZXJnZURlZXBBcnJheSIsIldlYWtDYWNoZSIsImdldEFwb2xsb0NhY2hlTWVtb3J5SW50ZXJuYWxzIiwiZXF1YWxCeVF1ZXJ5IiwiQXBvbGxvQ2FjaGUiLCJhc3N1bWVJbW11dGFibGVSZXN1bHRzIiwiZ2V0RnJhZ21lbnREb2MiLCJtYXgiLCJjYWNoZSIsInByb3RvdHlwZSIsImJhdGNoIiwib3B0aW9ucyIsIl90aGlzIiwib3B0aW1pc3RpY0lkIiwib3B0aW1pc3RpYyIsInVwZGF0ZVJlc3VsdCIsInBlcmZvcm1UcmFuc2FjdGlvbiIsInVwZGF0ZSIsInJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwidHJhbnNmb3JtRG9jdW1lbnQiLCJkb2N1bWVudCIsInRyYW5zZm9ybUZvckxpbmsiLCJpZGVudGlmeSIsIm9iamVjdCIsImdjIiwibW9kaWZ5IiwicmVhZFF1ZXJ5IiwicmVhZCIsInJvb3RJZCIsImlkIiwid2F0Y2hGcmFnbWVudCIsImZyYWdtZW50IiwiZnJhZ21lbnROYW1lIiwiZnJvbSIsIl9hIiwib3RoZXJPcHRpb25zIiwicXVlcnkiLCJkaWZmT3B0aW9ucyIsInJldHVyblBhcnRpYWxEYXRhIiwibGF0ZXN0RGlmZiIsIm9ic2VydmVyIiwid2F0Y2giLCJpbW1lZGlhdGUiLCJjYWxsYmFjayIsImRpZmYiLCJkYXRhIiwicmVzdWx0IiwiY29tcGxldGUiLCJtaXNzaW5nIiwibWFwIiwiZXJyb3IiLCJuZXh0IiwicmVhZEZyYWdtZW50Iiwid3JpdGVRdWVyeSIsIndyaXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiZGF0YUlkIiwid3JpdGVGcmFnbWVudCIsInVwZGF0ZVF1ZXJ5IiwidmFsdWUiLCJ1cGRhdGVGcmFnbWVudCIsImdsb2JhbFRoaXMiLCJfX0RFVl9fIiwiZ2V0TWVtb3J5SW50ZXJuYWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/core/cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/core/types/common.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/core/types/common.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MissingFieldError: function() { return /* binding */ MissingFieldError; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n\nvar MissingFieldError = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MissingFieldError, _super);\n    function MissingFieldError(message, path, query, variables) {\n        var _a;\n        // 'Error' breaks prototype chain here\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        _this.path = path;\n        _this.query = query;\n        _this.variables = variables;\n        if (Array.isArray(_this.path)) {\n            _this.missing = _this.message;\n            for(var i = _this.path.length - 1; i >= 0; --i){\n                _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);\n            }\n        } else {\n            _this.missing = _this.path;\n        }\n        // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n        // on Android (see issue #3236).\n        _this.__proto__ = MissingFieldError.prototype;\n        return _this;\n    }\n    return MissingFieldError;\n}(Error);\n //# sourceMappingURL=common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9jb3JlL3R5cGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUNsQyxJQUFJQyxvQkFBb0IsV0FBVyxHQUFJLFNBQVVDLE1BQU07SUFDbkRGLGdEQUFTQSxDQUFDQyxtQkFBbUJDO0lBQzdCLFNBQVNELGtCQUFrQkUsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsU0FBUztRQUN0RCxJQUFJQztRQUNKLHNDQUFzQztRQUN0QyxJQUFJQyxRQUFRTixPQUFPTyxJQUFJLENBQUMsSUFBSSxFQUFFTixZQUFZLElBQUk7UUFDOUNLLE1BQU1MLE9BQU8sR0FBR0E7UUFDaEJLLE1BQU1KLElBQUksR0FBR0E7UUFDYkksTUFBTUgsS0FBSyxHQUFHQTtRQUNkRyxNQUFNRixTQUFTLEdBQUdBO1FBQ2xCLElBQUlJLE1BQU1DLE9BQU8sQ0FBQ0gsTUFBTUosSUFBSSxHQUFHO1lBQzNCSSxNQUFNSSxPQUFPLEdBQUdKLE1BQU1MLE9BQU87WUFDN0IsSUFBSyxJQUFJVSxJQUFJTCxNQUFNSixJQUFJLENBQUNVLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUcsRUFBRUEsRUFBRztnQkFDN0NMLE1BQU1JLE9BQU8sR0FBSUwsQ0FBQUEsS0FBSyxDQUFDLEdBQUdBLEVBQUUsQ0FBQ0MsTUFBTUosSUFBSSxDQUFDUyxFQUFFLENBQUMsR0FBR0wsTUFBTUksT0FBTyxFQUFFTCxFQUFDO1lBQ2xFO1FBQ0osT0FDSztZQUNEQyxNQUFNSSxPQUFPLEdBQUdKLE1BQU1KLElBQUk7UUFDOUI7UUFDQSwyRUFBMkU7UUFDM0UsZ0NBQWdDO1FBQ2hDSSxNQUFNTyxTQUFTLEdBQUdkLGtCQUFrQmUsU0FBUztRQUM3QyxPQUFPUjtJQUNYO0lBQ0EsT0FBT1A7QUFDWCxFQUFFZ0I7QUFDMkIsQ0FDN0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9jb3JlL3R5cGVzL2NvbW1vbi5qcz82YWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xudmFyIE1pc3NpbmdGaWVsZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXNzaW5nRmllbGRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaXNzaW5nRmllbGRFcnJvcihtZXNzYWdlLCBwYXRoLCBxdWVyeSwgdmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gJ0Vycm9yJyBicmVha3MgcHJvdG90eXBlIGNoYWluIGhlcmVcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBfdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICBfdGhpcy5taXNzaW5nID0gX3RoaXMubWVzc2FnZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBfdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWlzc2luZyA9IChfYSA9IHt9LCBfYVtfdGhpcy5wYXRoW2ldXSA9IF90aGlzLm1pc3NpbmcsIF9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm1pc3NpbmcgPSBfdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIG5vdCB1c2luZyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBoZXJlIGFzIGl0IGlzbid0IGZ1bGx5IHN1cHBvcnRlZFxuICAgICAgICAvLyBvbiBBbmRyb2lkIChzZWUgaXNzdWUgIzMyMzYpLlxuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBNaXNzaW5nRmllbGRFcnJvci5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1pc3NpbmdGaWVsZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgTWlzc2luZ0ZpZWxkRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiTWlzc2luZ0ZpZWxkRXJyb3IiLCJfc3VwZXIiLCJtZXNzYWdlIiwicGF0aCIsInF1ZXJ5IiwidmFyaWFibGVzIiwiX2EiLCJfdGhpcyIsImNhbGwiLCJBcnJheSIsImlzQXJyYXkiLCJtaXNzaW5nIiwiaSIsImxlbmd0aCIsIl9fcHJvdG9fXyIsInByb3RvdHlwZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/core/types/common.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/entityStore.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/entityStore.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EntityStore: function() { return /* binding */ EntityStore; },\n/* harmony export */   maybeDependOnExistenceOfEntity: function() { return /* binding */ maybeDependOnExistenceOfEntity; },\n/* harmony export */   supportsResultCaching: function() { return /* binding */ supportsResultCaching; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n\n\n\n\n\n\n\nvar DELETE = Object.create(null);\nvar delModifier = function() {\n    return DELETE;\n};\nvar INVALIDATE = Object.create(null);\nvar EntityStore = /** @class */ function() {\n    function EntityStore(policies, group) {\n        var _this = this;\n        this.policies = policies;\n        this.group = group;\n        this.data = Object.create(null);\n        // Maps root entity IDs to the number of times they have been retained, minus\n        // the number of times they have been released. Retained entities keep other\n        // entities they reference (even indirectly) from being garbage collected.\n        this.rootIds = Object.create(null);\n        // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n        this.refs = Object.create(null);\n        // Bound function that can be passed around to provide easy access to fields\n        // of Reference objects as well as ordinary objects.\n        this.getFieldValue = function(objectOrReference, storeFieldName) {\n            return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.maybeDeepFreeze)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n        };\n        // Returns true for non-normalized StoreObjects and non-dangling\n        // References, indicating that readField(name, objOrRef) has a chance of\n        // working. Useful for filtering out dangling references from lists.\n        this.canRead = function(objOrRef) {\n            return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n        };\n        // Bound function that converts an id or an object with a __typename and\n        // primary key fields to a Reference object. If called with a Reference object,\n        // that same Reference object is returned. Pass true for mergeIntoStore to persist\n        // an object into the store.\n        this.toReference = function(objOrIdOrRef, mergeIntoStore) {\n            if (typeof objOrIdOrRef === \"string\") {\n                return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.makeReference)(objOrIdOrRef);\n            }\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(objOrIdOrRef)) {\n                return objOrIdOrRef;\n            }\n            var id = _this.policies.identify(objOrIdOrRef)[0];\n            if (id) {\n                var ref = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.makeReference)(id);\n                if (mergeIntoStore) {\n                    _this.merge(id, objOrIdOrRef);\n                }\n                return ref;\n            }\n        };\n    }\n    // Although the EntityStore class is abstract, it contains concrete\n    // implementations of the various NormalizedCache interface methods that\n    // are inherited by the Root and Layer subclasses.\n    EntityStore.prototype.toObject = function() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, this.data);\n    };\n    EntityStore.prototype.has = function(dataId) {\n        return this.lookup(dataId, true) !== void 0;\n    };\n    EntityStore.prototype.get = function(dataId, fieldName) {\n        this.group.depend(dataId, fieldName);\n        if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.data, dataId)) {\n            var storeObject = this.data[dataId];\n            if (storeObject && _helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(storeObject, fieldName)) {\n                return storeObject[fieldName];\n            }\n        }\n        if (fieldName === \"__typename\" && _helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n            return this.policies.rootTypenamesById[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.get(dataId, fieldName);\n        }\n    };\n    EntityStore.prototype.lookup = function(dataId, dependOnExistence) {\n        // The has method (above) calls lookup with dependOnExistence = true, so\n        // that it can later be invalidated when we add or remove a StoreObject for\n        // this dataId. Any consumer who cares about the contents of the StoreObject\n        // should not rely on this dependency, since the contents could change\n        // without the object being added or removed.\n        if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n        if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.data, dataId)) {\n            return this.data[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.lookup(dataId, dependOnExistence);\n        }\n        if (this.policies.rootTypenamesById[dataId]) {\n            return Object.create(null);\n        }\n    };\n    EntityStore.prototype.merge = function(older, newer) {\n        var _this = this;\n        var dataId;\n        // Convert unexpected references to ID strings.\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(older)) older = older.__ref;\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(newer)) newer = newer.__ref;\n        var existing = typeof older === \"string\" ? this.lookup(dataId = older) : older;\n        var incoming = typeof newer === \"string\" ? this.lookup(dataId = newer) : newer;\n        // If newer was a string ID, but that ID was not defined in this store,\n        // then there are no fields to be merged, so we're done.\n        if (!incoming) return;\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof dataId === \"string\", 1);\n        var merged = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.DeepMerger(storeObjectReconciler).merge(existing, incoming);\n        // Even if merged === existing, existing may have come from a lower\n        // layer, so we always need to set this.data[dataId] on this level.\n        this.data[dataId] = merged;\n        if (merged !== existing) {\n            delete this.refs[dataId];\n            if (this.group.caching) {\n                var fieldsToDirty_1 = Object.create(null);\n                // If we added a new StoreObject where there was previously none, dirty\n                // anything that depended on the existence of this dataId, such as the\n                // EntityStore#has method.\n                if (!existing) fieldsToDirty_1.__exists = 1;\n                // Now invalidate dependents who called getFieldValue for any fields\n                // that are changing as a result of this merge.\n                Object.keys(incoming).forEach(function(storeFieldName) {\n                    if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n                        // Always dirty the full storeFieldName, which may include\n                        // serialized arguments following the fieldName prefix.\n                        fieldsToDirty_1[storeFieldName] = 1;\n                        // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n                        // different from storeFieldName and this field does not have\n                        // keyArgs configured, because that means the cache can't make\n                        // any assumptions about how field values with the same field\n                        // name but different arguments might be interrelated, so it\n                        // must err on the side of invalidating all field values that\n                        // share the same short fieldName, regardless of arguments.\n                        var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_7__.fieldNameFromStoreName)(storeFieldName);\n                        if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                            fieldsToDirty_1[fieldName] = 1;\n                        }\n                        // If merged[storeFieldName] has become undefined, and this is the\n                        // Root layer, actually delete the property from the merged object,\n                        // which is guaranteed to have been created fresh in this method.\n                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n                            delete merged[storeFieldName];\n                        }\n                    }\n                });\n                if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings\n                // automatically from store.get, we don't need to dirty the\n                // ROOT_QUERY.__typename field if merged.__typename is equal\n                // to the default string (usually \"Query\").\n                this.policies.rootTypenamesById[dataId] === merged.__typename) {\n                    delete fieldsToDirty_1.__typename;\n                }\n                Object.keys(fieldsToDirty_1).forEach(function(fieldName) {\n                    return _this.group.dirty(dataId, fieldName);\n                });\n            }\n        }\n    };\n    EntityStore.prototype.modify = function(dataId, fields) {\n        var _this = this;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var changedFields_1 = Object.create(null);\n            var needToMerge_1 = false;\n            var allDeleted_1 = true;\n            var sharedDetails_1 = {\n                DELETE: DELETE,\n                INVALIDATE: INVALIDATE,\n                isReference: _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference,\n                toReference: this.toReference,\n                canRead: this.canRead,\n                readField: function(fieldNameOrOptions, from) {\n                    return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n                        fieldName: fieldNameOrOptions,\n                        from: from || (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.makeReference)(dataId)\n                    } : fieldNameOrOptions, {\n                        store: _this\n                    });\n                }\n            };\n            Object.keys(storeObject).forEach(function(storeFieldName) {\n                var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_7__.fieldNameFromStoreName)(storeFieldName);\n                var fieldValue = storeObject[storeFieldName];\n                if (fieldValue === void 0) return;\n                var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n                if (modify) {\n                    var newValue = modify === delModifier ? DELETE : modify((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.maybeDeepFreeze)(fieldValue), (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, sharedDetails_1), {\n                        fieldName: fieldName,\n                        storeFieldName: storeFieldName,\n                        storage: _this.getStorage(dataId, storeFieldName)\n                    }));\n                    if (newValue === INVALIDATE) {\n                        _this.group.dirty(dataId, storeFieldName);\n                    } else {\n                        if (newValue === DELETE) newValue = void 0;\n                        if (newValue !== fieldValue) {\n                            changedFields_1[storeFieldName] = newValue;\n                            needToMerge_1 = true;\n                            fieldValue = newValue;\n                            if (globalThis.__DEV__ !== false) {\n                                var checkReference = function(ref) {\n                                    if (_this.lookup(ref.__ref) === undefined) {\n                                        globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(2, ref);\n                                        return true;\n                                    }\n                                };\n                                if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(newValue)) {\n                                    checkReference(newValue);\n                                } else if (Array.isArray(newValue)) {\n                                    // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                                    var seenReference = false;\n                                    var someNonReference = void 0;\n                                    for(var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++){\n                                        var value = newValue_1[_i];\n                                        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(value)) {\n                                            seenReference = true;\n                                            if (checkReference(value)) break;\n                                        } else {\n                                            // Do not warn on primitive values, since those could never be represented\n                                            // by a reference. This is a valid (albeit uncommon) use case.\n                                            if (typeof value === \"object\" && !!value) {\n                                                var id = _this.policies.identify(value)[0];\n                                                // check if object could even be referenced, otherwise we are not interested in it for this warning\n                                                if (id) {\n                                                    someNonReference = value;\n                                                }\n                                            }\n                                        }\n                                        if (seenReference && someNonReference !== undefined) {\n                                            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(3, someNonReference);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (fieldValue !== void 0) {\n                    allDeleted_1 = false;\n                }\n            });\n            if (needToMerge_1) {\n                this.merge(dataId, changedFields_1);\n                if (allDeleted_1) {\n                    if (this instanceof Layer) {\n                        this.data[dataId] = void 0;\n                    } else {\n                        delete this.data[dataId];\n                    }\n                    this.group.dirty(dataId, \"__exists\");\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    // If called with only one argument, removes the entire entity\n    // identified by dataId. If called with a fieldName as well, removes all\n    // fields of that entity whose names match fieldName according to the\n    // fieldNameFromStoreName helper function. If called with a fieldName\n    // and variables, removes all fields of that entity whose names match fieldName\n    // and whose arguments when cached exactly match the variables passed.\n    EntityStore.prototype.delete = function(dataId, fieldName, args) {\n        var _a;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var typename = this.getFieldValue(storeObject, \"__typename\");\n            var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({\n                typename: typename,\n                fieldName: fieldName,\n                args: args\n            }) : fieldName;\n            return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n        }\n        return false;\n    };\n    EntityStore.prototype.evict = function(options, limit) {\n        var evicted = false;\n        if (options.id) {\n            if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.data, options.id)) {\n                evicted = this.delete(options.id, options.fieldName, options.args);\n            }\n            if (this instanceof Layer && this !== limit) {\n                evicted = this.parent.evict(options, limit) || evicted;\n            }\n            // Always invalidate the field to trigger rereading of watched\n            // queries, even if no cache data was modified by the eviction,\n            // because queries may depend on computed fields with custom read\n            // functions, whose values are not stored in the EntityStore.\n            if (options.fieldName || evicted) {\n                this.group.dirty(options.id, options.fieldName || \"__exists\");\n            }\n        }\n        return evicted;\n    };\n    EntityStore.prototype.clear = function() {\n        this.replace(null);\n    };\n    EntityStore.prototype.extract = function() {\n        var _this = this;\n        var obj = this.toObject();\n        var extraRootIds = [];\n        this.getRootIdSet().forEach(function(id) {\n            if (!_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(_this.policies.rootTypenamesById, id)) {\n                extraRootIds.push(id);\n            }\n        });\n        if (extraRootIds.length) {\n            obj.__META = {\n                extraRootIds: extraRootIds.sort()\n            };\n        }\n        return obj;\n    };\n    EntityStore.prototype.replace = function(newData) {\n        var _this = this;\n        Object.keys(this.data).forEach(function(dataId) {\n            if (!(newData && _helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(newData, dataId))) {\n                _this.delete(dataId);\n            }\n        });\n        if (newData) {\n            var __META = newData.__META, rest_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(newData, [\n                \"__META\"\n            ]);\n            Object.keys(rest_1).forEach(function(dataId) {\n                _this.merge(dataId, rest_1[dataId]);\n            });\n            if (__META) {\n                __META.extraRootIds.forEach(this.retain, this);\n            }\n        }\n    };\n    EntityStore.prototype.retain = function(rootId) {\n        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n    };\n    EntityStore.prototype.release = function(rootId) {\n        if (this.rootIds[rootId] > 0) {\n            var count = --this.rootIds[rootId];\n            if (!count) delete this.rootIds[rootId];\n            return count;\n        }\n        return 0;\n    };\n    // Return a Set<string> of all the ID strings that have been retained by\n    // this layer/root *and* any layers/roots beneath it.\n    EntityStore.prototype.getRootIdSet = function(ids) {\n        if (ids === void 0) {\n            ids = new Set();\n        }\n        Object.keys(this.rootIds).forEach(ids.add, ids);\n        if (this instanceof Layer) {\n            this.parent.getRootIdSet(ids);\n        } else {\n            // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n            // always considered roots for garbage collection, regardless of\n            // their retainment counts in this.rootIds.\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n        }\n        return ids;\n    };\n    // The goal of garbage collection is to remove IDs from the Root layer of the\n    // store that are no longer reachable starting from any IDs that have been\n    // explicitly retained (see retain and release, above). Returns an array of\n    // dataId strings that were removed from the store.\n    EntityStore.prototype.gc = function() {\n        var _this = this;\n        var ids = this.getRootIdSet();\n        var snapshot = this.toObject();\n        ids.forEach(function(id) {\n            if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(snapshot, id)) {\n                // Because we are iterating over an ECMAScript Set, the IDs we add here\n                // will be visited in later iterations of the forEach loop only if they\n                // were not previously contained by the Set.\n                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n                // By removing IDs from the snapshot object here, we protect them from\n                // getting removed from the root store layer below.\n                delete snapshot[id];\n            }\n        });\n        var idsToRemove = Object.keys(snapshot);\n        if (idsToRemove.length) {\n            var root_1 = this;\n            while(root_1 instanceof Layer)root_1 = root_1.parent;\n            idsToRemove.forEach(function(id) {\n                return root_1.delete(id);\n            });\n        }\n        return idsToRemove;\n    };\n    EntityStore.prototype.findChildRefIds = function(dataId) {\n        if (!_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.refs, dataId)) {\n            var found_1 = this.refs[dataId] = Object.create(null);\n            var root = this.data[dataId];\n            if (!root) return found_1;\n            var workSet_1 = new Set([\n                root\n            ]);\n            // Within the store, only arrays and objects can contain child entity\n            // references, so we can prune the traversal using this predicate:\n            workSet_1.forEach(function(obj) {\n                if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isReference)(obj)) {\n                    found_1[obj.__ref] = true;\n                // In rare cases, a { __ref } Reference object may have other fields.\n                // This often indicates a mismerging of References with StoreObjects,\n                // but garbage collection should not be fooled by a stray __ref\n                // property in a StoreObject (ignoring all the other fields just\n                // because the StoreObject looks like a Reference). To avoid this\n                // premature termination of findChildRefIds recursion, we fall through\n                // to the code below, which will handle any other properties of obj.\n                }\n                if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isNonNullObject)(obj)) {\n                    Object.keys(obj).forEach(function(key) {\n                        var child = obj[key];\n                        // No need to add primitive values to the workSet, since they cannot\n                        // contain reference objects.\n                        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isNonNullObject)(child)) {\n                            workSet_1.add(child);\n                        }\n                    });\n                }\n            });\n        }\n        return this.refs[dataId];\n    };\n    EntityStore.prototype.makeCacheKey = function() {\n        return this.group.keyMaker.lookupArray(arguments);\n    };\n    return EntityStore;\n}();\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nvar CacheGroup = /** @class */ function() {\n    function CacheGroup(caching, parent) {\n        if (parent === void 0) {\n            parent = null;\n        }\n        this.caching = caching;\n        this.parent = parent;\n        this.d = null;\n        this.resetCaching();\n    }\n    CacheGroup.prototype.resetCaching = function() {\n        this.d = this.caching ? (0,optimism__WEBPACK_IMPORTED_MODULE_1__.dep)() : null;\n        this.keyMaker = new _wry_trie__WEBPACK_IMPORTED_MODULE_3__.Trie(_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.canUseWeakMap);\n    };\n    CacheGroup.prototype.depend = function(dataId, storeFieldName) {\n        if (this.d) {\n            this.d(makeDepKey(dataId, storeFieldName));\n            var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_7__.fieldNameFromStoreName)(storeFieldName);\n            if (fieldName !== storeFieldName) {\n                // Fields with arguments that contribute extra identifying\n                // information to the fieldName (thus forming the storeFieldName)\n                // depend not only on the full storeFieldName but also on the\n                // short fieldName, so the field can be invalidated using either\n                // level of specificity.\n                this.d(makeDepKey(dataId, fieldName));\n            }\n            if (this.parent) {\n                this.parent.depend(dataId, storeFieldName);\n            }\n        }\n    };\n    CacheGroup.prototype.dirty = function(dataId, storeFieldName) {\n        if (this.d) {\n            this.d.dirty(makeDepKey(dataId, storeFieldName), // When storeFieldName === \"__exists\", that means the entity identified\n            // by dataId has either disappeared from the cache or was newly added,\n            // so the result caching system would do well to \"forget everything it\n            // knows\" about that object. To achieve that kind of invalidation, we\n            // not only dirty the associated result cache entry, but also remove it\n            // completely from the dependency graph. For the optimism implementation\n            // details, see https://github.com/benjamn/optimism/pull/195.\n            storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n        }\n    };\n    return CacheGroup;\n}();\nfunction makeDepKey(dataId, storeFieldName) {\n    // Since field names cannot have '#' characters in them, this method\n    // of joining the field name and the ID should be unambiguous, and much\n    // cheaper than JSON.stringify([dataId, fieldName]).\n    return storeFieldName + \"#\" + dataId;\n}\nfunction maybeDependOnExistenceOfEntity(store, entityId) {\n    if (supportsResultCaching(store)) {\n        // We use this pseudo-field __exists elsewhere in the EntityStore code to\n        // represent changes in the existence of the entity object identified by\n        // entityId. This dependency gets reliably dirtied whenever an object with\n        // this ID is deleted (or newly created) within this group, so any result\n        // cache entries (for example, StoreReader#executeSelectionSet results) that\n        // depend on __exists for this entityId will get dirtied as well, leading to\n        // the eventual recomputation (instead of reuse) of those result objects the\n        // next time someone reads them from the cache.\n        store.group.depend(entityId, \"__exists\");\n    }\n}\n(function(EntityStore) {\n    // Refer to this class as EntityStore.Root outside this namespace.\n    var Root = /** @class */ function(_super) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__extends)(Root, _super);\n        function Root(_a) {\n            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\n            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n            _this.stump = new Stump(_this);\n            _this.storageTrie = new _wry_trie__WEBPACK_IMPORTED_MODULE_3__.Trie(_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.canUseWeakMap);\n            if (seed) _this.replace(seed);\n            return _this;\n        }\n        Root.prototype.addLayer = function(layerId, replay) {\n            // Adding an optimistic Layer on top of the Root actually adds the Layer\n            // on top of the Stump, so the Stump always comes between the Root and\n            // any Layer objects that we've added.\n            return this.stump.addLayer(layerId, replay);\n        };\n        Root.prototype.removeLayer = function() {\n            // Never remove the root layer.\n            return this;\n        };\n        Root.prototype.getStorage = function() {\n            return this.storageTrie.lookupArray(arguments);\n        };\n        return Root;\n    }(EntityStore);\n    EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nvar Layer = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__extends)(Layer, _super);\n    function Layer(id, parent, replay, group) {\n        var _this = _super.call(this, parent.policies, group) || this;\n        _this.id = id;\n        _this.parent = parent;\n        _this.replay = replay;\n        _this.group = group;\n        replay(_this);\n        return _this;\n    }\n    Layer.prototype.addLayer = function(layerId, replay) {\n        return new Layer(layerId, this, replay, this.group);\n    };\n    Layer.prototype.removeLayer = function(layerId) {\n        var _this = this;\n        // Remove all instances of the given id, not just the first one.\n        var parent = this.parent.removeLayer(layerId);\n        if (layerId === this.id) {\n            if (this.group.caching) {\n                // Dirty every ID we're removing. Technically we might be able to avoid\n                // dirtying fields that have values in higher layers, but we don't have\n                // easy access to higher layers here, and we're about to recreate those\n                // layers anyway (see parent.addLayer below).\n                Object.keys(this.data).forEach(function(dataId) {\n                    var ownStoreObject = _this.data[dataId];\n                    var parentStoreObject = parent[\"lookup\"](dataId);\n                    if (!parentStoreObject) {\n                        // The StoreObject identified by dataId was defined in this layer\n                        // but will be undefined in the parent layer, so we can delete the\n                        // whole entity using this.delete(dataId). Since we're about to\n                        // throw this layer away, the only goal of this deletion is to dirty\n                        // the removed fields.\n                        _this.delete(dataId);\n                    } else if (!ownStoreObject) {\n                        // This layer had an entry for dataId but it was undefined, which\n                        // means the entity was deleted in this layer, and it's about to\n                        // become undeleted when we remove this layer, so we need to dirty\n                        // all fields that are about to be reexposed.\n                        _this.group.dirty(dataId, \"__exists\");\n                        Object.keys(parentStoreObject).forEach(function(storeFieldName) {\n                            _this.group.dirty(dataId, storeFieldName);\n                        });\n                    } else if (ownStoreObject !== parentStoreObject) {\n                        // If ownStoreObject is not exactly the same as parentStoreObject,\n                        // dirty any fields whose values will change as a result of this\n                        // removal.\n                        Object.keys(ownStoreObject).forEach(function(storeFieldName) {\n                            if (!(0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                                _this.group.dirty(dataId, storeFieldName);\n                            }\n                        });\n                    }\n                });\n            }\n            return parent;\n        }\n        // No changes are necessary if the parent chain remains identical.\n        if (parent === this.parent) return this;\n        // Recreate this layer on top of the new parent.\n        return parent.addLayer(this.id, this.replay);\n    };\n    Layer.prototype.toObject = function() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, this.parent.toObject()), this.data);\n    };\n    Layer.prototype.findChildRefIds = function(dataId) {\n        var fromParent = this.parent.findChildRefIds(dataId);\n        return _helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(this.data, dataId) ? (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n    };\n    Layer.prototype.getStorage = function() {\n        var p = this.parent;\n        while(p.parent)p = p.parent;\n        return p.getStorage.apply(p, // @ts-expect-error\n        arguments);\n    };\n    return Layer;\n}(EntityStore);\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nvar Stump = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__extends)(Stump, _super);\n    function Stump(root) {\n        return _super.call(this, \"EntityStore.Stump\", root, function() {}, new CacheGroup(root.group.caching, root.group)) || this;\n    }\n    Stump.prototype.removeLayer = function() {\n        // Never remove the Stump layer.\n        return this;\n    };\n    Stump.prototype.merge = function(older, newer) {\n        // We never want to write any data into the Stump, so we forward any merge\n        // calls to the Root instead. Another option here would be to throw an\n        // exception, but the toReference(object, true) function can sometimes\n        // trigger Stump writes (which used to be Root writes, before the Stump\n        // concept was introduced).\n        return this.parent.merge(older, newer);\n    };\n    return Stump;\n}(Layer);\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n    var existingValue = existingObject[property];\n    var incomingValue = incomingObject[property];\n    // Wherever there is a key collision, prefer the incoming value, unless\n    // it is deeply equal to the existing value. It's worth checking deep\n    // equality here (even though blindly returning incoming would be\n    // logically correct) because preserving the referential identity of\n    // existing data can prevent needless rereading and rerendering.\n    return (0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nfunction supportsResultCaching(store) {\n    // When result caching is disabled, store.depend will be null.\n    return !!(store instanceof EntityStore && store.group.caching);\n} //# sourceMappingURL=entityStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9lbnRpdHlTdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNTO0FBQzlCO0FBQ087QUFDTDtBQUNtRztBQUN0RTtBQUM5RCxJQUFJZSxTQUFTQyxPQUFPQyxNQUFNLENBQUM7QUFDM0IsSUFBSUMsY0FBYztJQUFjLE9BQU9IO0FBQVE7QUFDL0MsSUFBSUksYUFBYUgsT0FBT0MsTUFBTSxDQUFDO0FBQy9CLElBQUlHLGNBQWMsV0FBVyxHQUFJO0lBQzdCLFNBQVNBLFlBQVlDLFFBQVEsRUFBRUMsS0FBSztRQUNoQyxJQUFJQyxRQUFRLElBQUk7UUFDaEIsSUFBSSxDQUFDRixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsSUFBSSxHQUFHUixPQUFPQyxNQUFNLENBQUM7UUFDMUIsNkVBQTZFO1FBQzdFLDRFQUE0RTtRQUM1RSwwRUFBMEU7UUFDMUUsSUFBSSxDQUFDUSxPQUFPLEdBQUdULE9BQU9DLE1BQU0sQ0FBQztRQUM3Qiw0RUFBNEU7UUFDNUUsSUFBSSxDQUFDUyxJQUFJLEdBQUdWLE9BQU9DLE1BQU0sQ0FBQztRQUMxQiw0RUFBNEU7UUFDNUUsb0RBQW9EO1FBQ3BELElBQUksQ0FBQ1UsYUFBYSxHQUFHLFNBQVVDLGlCQUFpQixFQUFFQyxjQUFjO1lBQzVELE9BQU9uQixvRUFBZUEsQ0FBQ0gsZ0VBQVdBLENBQUNxQixxQkFDL0JMLE1BQU1PLEdBQUcsQ0FBQ0Ysa0JBQWtCRyxLQUFLLEVBQUVGLGtCQUNqQ0QscUJBQXFCQSxpQkFBaUIsQ0FBQ0MsZUFBZTtRQUNoRTtRQUNBLGdFQUFnRTtRQUNoRSx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBQ3BFLElBQUksQ0FBQ0csT0FBTyxHQUFHLFNBQVVDLFFBQVE7WUFDN0IsT0FBTzFCLGdFQUFXQSxDQUFDMEIsWUFD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Y2xpZW50L2NhY2hlL2lubWVtb3J5L2VudGl0eVN0b3JlLmpzPzUwOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcywgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGRlcCB9IGZyb20gXCJvcHRpbWlzbVwiO1xuaW1wb3J0IHsgZXF1YWwgfSBmcm9tIFwiQHdyeS9lcXVhbGl0eVwiO1xuaW1wb3J0IHsgVHJpZSB9IGZyb20gXCJAd3J5L3RyaWVcIjtcbmltcG9ydCB7IGlzUmVmZXJlbmNlLCBtYWtlUmVmZXJlbmNlLCBEZWVwTWVyZ2VyLCBtYXliZURlZXBGcmVlemUsIGNhblVzZVdlYWtNYXAsIGlzTm9uTnVsbE9iamVjdCwgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoYXNPd24sIGZpZWxkTmFtZUZyb21TdG9yZU5hbWUgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG52YXIgREVMRVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBkZWxNb2RpZmllciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERFTEVURTsgfTtcbnZhciBJTlZBTElEQVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBFbnRpdHlTdG9yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbnRpdHlTdG9yZShwb2xpY2llcywgZ3JvdXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wb2xpY2llcyA9IHBvbGljaWVzO1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIE1hcHMgcm9vdCBlbnRpdHkgSURzIHRvIHRoZSBudW1iZXIgb2YgdGltZXMgdGhleSBoYXZlIGJlZW4gcmV0YWluZWQsIG1pbnVzXG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgdGltZXMgdGhleSBoYXZlIGJlZW4gcmVsZWFzZWQuIFJldGFpbmVkIGVudGl0aWVzIGtlZXAgb3RoZXJcbiAgICAgICAgLy8gZW50aXRpZXMgdGhleSByZWZlcmVuY2UgKGV2ZW4gaW5kaXJlY3RseSkgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgdGhpcy5yb290SWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gTGF6aWx5IHRyYWNrcyB7IF9fcmVmOiA8ZGF0YUlkPiB9IHN0cmluZ3MgY29udGFpbmVkIGJ5IHRoaXMuZGF0YVtkYXRhSWRdLlxuICAgICAgICB0aGlzLnJlZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBCb3VuZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwYXNzZWQgYXJvdW5kIHRvIHByb3ZpZGUgZWFzeSBhY2Nlc3MgdG8gZmllbGRzXG4gICAgICAgIC8vIG9mIFJlZmVyZW5jZSBvYmplY3RzIGFzIHdlbGwgYXMgb3JkaW5hcnkgb2JqZWN0cy5cbiAgICAgICAgdGhpcy5nZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlRGVlcEZyZWV6ZShpc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSkgP1xuICAgICAgICAgICAgICAgIF90aGlzLmdldChvYmplY3RPclJlZmVyZW5jZS5fX3JlZiwgc3RvcmVGaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgOiBvYmplY3RPclJlZmVyZW5jZSAmJiBvYmplY3RPclJlZmVyZW5jZVtzdG9yZUZpZWxkTmFtZV0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXR1cm5zIHRydWUgZm9yIG5vbi1ub3JtYWxpemVkIFN0b3JlT2JqZWN0cyBhbmQgbm9uLWRhbmdsaW5nXG4gICAgICAgIC8vIFJlZmVyZW5jZXMsIGluZGljYXRpbmcgdGhhdCByZWFkRmllbGQobmFtZSwgb2JqT3JSZWYpIGhhcyBhIGNoYW5jZSBvZlxuICAgICAgICAvLyB3b3JraW5nLiBVc2VmdWwgZm9yIGZpbHRlcmluZyBvdXQgZGFuZ2xpbmcgcmVmZXJlbmNlcyBmcm9tIGxpc3RzLlxuICAgICAgICB0aGlzLmNhblJlYWQgPSBmdW5jdGlvbiAob2JqT3JSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlZmVyZW5jZShvYmpPclJlZikgP1xuICAgICAgICAgICAgICAgIF90aGlzLmhhcyhvYmpPclJlZi5fX3JlZilcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmpPclJlZiA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQm91bmQgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBhbiBpZCBvciBhbiBvYmplY3Qgd2l0aCBhIF9fdHlwZW5hbWUgYW5kXG4gICAgICAgIC8vIHByaW1hcnkga2V5IGZpZWxkcyB0byBhIFJlZmVyZW5jZSBvYmplY3QuIElmIGNhbGxlZCB3aXRoIGEgUmVmZXJlbmNlIG9iamVjdCxcbiAgICAgICAgLy8gdGhhdCBzYW1lIFJlZmVyZW5jZSBvYmplY3QgaXMgcmV0dXJuZWQuIFBhc3MgdHJ1ZSBmb3IgbWVyZ2VJbnRvU3RvcmUgdG8gcGVyc2lzdFxuICAgICAgICAvLyBhbiBvYmplY3QgaW50byB0aGUgc3RvcmUuXG4gICAgICAgIHRoaXMudG9SZWZlcmVuY2UgPSBmdW5jdGlvbiAob2JqT3JJZE9yUmVmLCBtZXJnZUludG9TdG9yZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpPcklkT3JSZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlZmVyZW5jZShvYmpPcklkT3JSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKG9iak9ySWRPclJlZikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqT3JJZE9yUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMucG9saWNpZXMuaWRlbnRpZnkob2JqT3JJZE9yUmVmKVswXTtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBtYWtlUmVmZXJlbmNlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbnRvU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoaWQsIG9iak9ySWRPclJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEFsdGhvdWdoIHRoZSBFbnRpdHlTdG9yZSBjbGFzcyBpcyBhYnN0cmFjdCwgaXQgY29udGFpbnMgY29uY3JldGVcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIHZhcmlvdXMgTm9ybWFsaXplZENhY2hlIGludGVyZmFjZSBtZXRob2RzIHRoYXRcbiAgICAvLyBhcmUgaW5oZXJpdGVkIGJ5IHRoZSBSb290IGFuZCBMYXllciBzdWJjbGFzc2VzLlxuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCB0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwKGRhdGFJZCwgdHJ1ZSkgIT09IHZvaWQgMDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGF0YUlkLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdGhpcy5ncm91cC5kZXBlbmQoZGF0YUlkLCBmaWVsZE5hbWUpO1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwodGhpcy5kYXRhLCBkYXRhSWQpKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmIChzdG9yZU9iamVjdCAmJiBoYXNPd24uY2FsbChzdG9yZU9iamVjdCwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZU9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT09IFwiX190eXBlbmFtZVwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkLCBkYXRhSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZFtkYXRhSWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQoZGF0YUlkLCBmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKGRhdGFJZCwgZGVwZW5kT25FeGlzdGVuY2UpIHtcbiAgICAgICAgLy8gVGhlIGhhcyBtZXRob2QgKGFib3ZlKSBjYWxscyBsb29rdXAgd2l0aCBkZXBlbmRPbkV4aXN0ZW5jZSA9IHRydWUsIHNvXG4gICAgICAgIC8vIHRoYXQgaXQgY2FuIGxhdGVyIGJlIGludmFsaWRhdGVkIHdoZW4gd2UgYWRkIG9yIHJlbW92ZSBhIFN0b3JlT2JqZWN0IGZvclxuICAgICAgICAvLyB0aGlzIGRhdGFJZC4gQW55IGNvbnN1bWVyIHdobyBjYXJlcyBhYm91dCB0aGUgY29udGVudHMgb2YgdGhlIFN0b3JlT2JqZWN0XG4gICAgICAgIC8vIHNob3VsZCBub3QgcmVseSBvbiB0aGlzIGRlcGVuZGVuY3ksIHNpbmNlIHRoZSBjb250ZW50cyBjb3VsZCBjaGFuZ2VcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgb2JqZWN0IGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgIGlmIChkZXBlbmRPbkV4aXN0ZW5jZSlcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGVwZW5kKGRhdGFJZCwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKHRoaXMuZGF0YSwgZGF0YUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5sb29rdXAoZGF0YUlkLCBkZXBlbmRPbkV4aXN0ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9saWNpZXMucm9vdFR5cGVuYW1lc0J5SWRbZGF0YUlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvbGRlciwgbmV3ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGFJZDtcbiAgICAgICAgLy8gQ29udmVydCB1bmV4cGVjdGVkIHJlZmVyZW5jZXMgdG8gSUQgc3RyaW5ncy5cbiAgICAgICAgaWYgKGlzUmVmZXJlbmNlKG9sZGVyKSlcbiAgICAgICAgICAgIG9sZGVyID0gb2xkZXIuX19yZWY7XG4gICAgICAgIGlmIChpc1JlZmVyZW5jZShuZXdlcikpXG4gICAgICAgICAgICBuZXdlciA9IG5ld2VyLl9fcmVmO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0eXBlb2Ygb2xkZXIgPT09IFwic3RyaW5nXCIgPyB0aGlzLmxvb2t1cCgoZGF0YUlkID0gb2xkZXIpKSA6IG9sZGVyO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSB0eXBlb2YgbmV3ZXIgPT09IFwic3RyaW5nXCIgPyB0aGlzLmxvb2t1cCgoZGF0YUlkID0gbmV3ZXIpKSA6IG5ld2VyO1xuICAgICAgICAvLyBJZiBuZXdlciB3YXMgYSBzdHJpbmcgSUQsIGJ1dCB0aGF0IElEIHdhcyBub3QgZGVmaW5lZCBpbiB0aGlzIHN0b3JlLFxuICAgICAgICAvLyB0aGVuIHRoZXJlIGFyZSBubyBmaWVsZHMgdG8gYmUgbWVyZ2VkLCBzbyB3ZSdyZSBkb25lLlxuICAgICAgICBpZiAoIWluY29taW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGRhdGFJZCA9PT0gXCJzdHJpbmdcIiwgMSk7XG4gICAgICAgIHZhciBtZXJnZWQgPSBuZXcgRGVlcE1lcmdlcihzdG9yZU9iamVjdFJlY29uY2lsZXIpLm1lcmdlKGV4aXN0aW5nLCBpbmNvbWluZyk7XG4gICAgICAgIC8vIEV2ZW4gaWYgbWVyZ2VkID09PSBleGlzdGluZywgZXhpc3RpbmcgbWF5IGhhdmUgY29tZSBmcm9tIGEgbG93ZXJcbiAgICAgICAgLy8gbGF5ZXIsIHNvIHdlIGFsd2F5cyBuZWVkIHRvIHNldCB0aGlzLmRhdGFbZGF0YUlkXSBvbiB0aGlzIGxldmVsLlxuICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IG1lcmdlZDtcbiAgICAgICAgaWYgKG1lcmdlZCAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzVG9EaXJ0eV8xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhZGRlZCBhIG5ldyBTdG9yZU9iamVjdCB3aGVyZSB0aGVyZSB3YXMgcHJldmlvdXNseSBub25lLCBkaXJ0eVxuICAgICAgICAgICAgICAgIC8vIGFueXRoaW5nIHRoYXQgZGVwZW5kZWQgb24gdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIGRhdGFJZCwgc3VjaCBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyBFbnRpdHlTdG9yZSNoYXMgbWV0aG9kLlxuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcpXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1RvRGlydHlfMS5fX2V4aXN0cyA9IDE7XG4gICAgICAgICAgICAgICAgLy8gTm93IGludmFsaWRhdGUgZGVwZW5kZW50cyB3aG8gY2FsbGVkIGdldEZpZWxkVmFsdWUgZm9yIGFueSBmaWVsZHNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFyZSBjaGFuZ2luZyBhcyBhIHJlc3VsdCBvZiB0aGlzIG1lcmdlLlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1tzdG9yZUZpZWxkTmFtZV0gIT09IG1lcmdlZFtzdG9yZUZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBkaXJ0eSB0aGUgZnVsbCBzdG9yZUZpZWxkTmFtZSwgd2hpY2ggbWF5IGluY2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZWQgYXJndW1lbnRzIGZvbGxvd2luZyB0aGUgZmllbGROYW1lIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1RvRGlydHlfMVtzdG9yZUZpZWxkTmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBkaXJ0eSBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKSBpZiBpdCdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgZnJvbSBzdG9yZUZpZWxkTmFtZSBhbmQgdGhpcyBmaWVsZCBkb2VzIG5vdCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlBcmdzIGNvbmZpZ3VyZWQsIGJlY2F1c2UgdGhhdCBtZWFucyB0aGUgY2FjaGUgY2FuJ3QgbWFrZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IGFzc3VtcHRpb25zIGFib3V0IGhvdyBmaWVsZCB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBidXQgZGlmZmVyZW50IGFyZ3VtZW50cyBtaWdodCBiZSBpbnRlcnJlbGF0ZWQsIHNvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGVyciBvbiB0aGUgc2lkZSBvZiBpbnZhbGlkYXRpbmcgYWxsIGZpZWxkIHZhbHVlcyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGFyZSB0aGUgc2FtZSBzaG9ydCBmaWVsZE5hbWUsIHJlZ2FyZGxlc3Mgb2YgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gc3RvcmVGaWVsZE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMucG9saWNpZXMuaGFzS2V5QXJncyhtZXJnZWQuX190eXBlbmFtZSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1RvRGlydHlfMVtmaWVsZE5hbWVdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG1lcmdlZFtzdG9yZUZpZWxkTmFtZV0gaGFzIGJlY29tZSB1bmRlZmluZWQsIGFuZCB0aGlzIGlzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9vdCBsYXllciwgYWN0dWFsbHkgZGVsZXRlIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBtZXJnZWQgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgZ3VhcmFudGVlZCB0byBoYXZlIGJlZW4gY3JlYXRlZCBmcmVzaCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWRbc3RvcmVGaWVsZE5hbWVdID09PSB2b2lkIDAgJiYgIShfdGhpcyBpbnN0YW5jZW9mIExheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXJnZWRbc3RvcmVGaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkc1RvRGlydHlfMS5fX3R5cGVuYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX190eXBlbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgcmV0dXJuIGRlZmF1bHQgcm9vdCBfX3R5cGVuYW1lIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBmcm9tIHN0b3JlLmdldCwgd2UgZG9uJ3QgbmVlZCB0byBkaXJ0eSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gUk9PVF9RVUVSWS5fX3R5cGVuYW1lIGZpZWxkIGlmIG1lcmdlZC5fX3R5cGVuYW1lIGlzIGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBkZWZhdWx0IHN0cmluZyAodXN1YWxseSBcIlF1ZXJ5XCIpLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0gPT09IG1lcmdlZC5fX3R5cGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNUb0RpcnR5XzEuX190eXBlbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzVG9EaXJ0eV8xKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChkYXRhSWQsIGZpZWxkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSB0aGlzLmxvb2t1cChkYXRhSWQpO1xuICAgICAgICBpZiAoc3RvcmVPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRmllbGRzXzEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIG5lZWRUb01lcmdlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhbGxEZWxldGVkXzEgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNoYXJlZERldGFpbHNfMSA9IHtcbiAgICAgICAgICAgICAgICBERUxFVEU6IERFTEVURSxcbiAgICAgICAgICAgICAgICBJTlZBTElEQVRFOiBJTlZBTElEQVRFLFxuICAgICAgICAgICAgICAgIGlzUmVmZXJlbmNlOiBpc1JlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICB0b1JlZmVyZW5jZTogdGhpcy50b1JlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICBjYW5SZWFkOiB0aGlzLmNhblJlYWQsXG4gICAgICAgICAgICAgICAgcmVhZEZpZWxkOiBmdW5jdGlvbiAoZmllbGROYW1lT3JPcHRpb25zLCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb2xpY2llcy5yZWFkRmllbGQodHlwZW9mIGZpZWxkTmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWVPck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSB8fCBtYWtlUmVmZXJlbmNlKGRhdGFJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkTmFtZU9yT3B0aW9ucywgeyBzdG9yZTogX3RoaXMgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkVmFsdWUgPSBzdG9yZU9iamVjdFtzdG9yZUZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZnkgPSB0eXBlb2YgZmllbGRzID09PSBcImZ1bmN0aW9uXCIgPyBmaWVsZHMgOiAoZmllbGRzW3N0b3JlRmllbGROYW1lXSB8fCBmaWVsZHNbZmllbGROYW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBtb2RpZnkgPT09IGRlbE1vZGlmaWVyID8gREVMRVRFIDogKG1vZGlmeShtYXliZURlZXBGcmVlemUoZmllbGRWYWx1ZSksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaGFyZWREZXRhaWxzXzEpLCB7IGZpZWxkTmFtZTogZmllbGROYW1lLCBzdG9yZUZpZWxkTmFtZTogc3RvcmVGaWVsZE5hbWUsIHN0b3JhZ2U6IF90aGlzLmdldFN0b3JhZ2UoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBJTlZBTElEQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xW3N0b3JlRmllbGROYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb01lcmdlXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubG9va3VwKHJlZi5fX3JlZikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oMiwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSZWZlcmVuY2UobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXJuIGFib3V0IHdyaXRpbmcgXCJtaXhlZFwiIGFycmF5cyBvZiBSZWZlcmVuY2UgYW5kIG5vbi1SZWZlcmVuY2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlZW5SZWZlcmVuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb21lTm9uUmVmZXJlbmNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXdWYWx1ZV8xID0gbmV3VmFsdWU7IF9pIDwgbmV3VmFsdWVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdWYWx1ZV8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5SZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZWZlcmVuY2UodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgd2FybiBvbiBwcmltaXRpdmUgdmFsdWVzLCBzaW5jZSB0aG9zZSBjb3VsZCBuZXZlciBiZSByZXByZXNlbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBhIHJlZmVyZW5jZS4gVGhpcyBpcyBhIHZhbGlkIChhbGJlaXQgdW5jb21tb24pIHVzZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICEhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLnBvbGljaWVzLmlkZW50aWZ5KHZhbHVlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG9iamVjdCBjb3VsZCBldmVuIGJlIHJlZmVyZW5jZWQsIG90aGVyd2lzZSB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gaXQgZm9yIHRoaXMgd2FybmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29tZU5vblJlZmVyZW5jZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUmVmZXJlbmNlICYmIHNvbWVOb25SZWZlcmVuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmIGludmFyaWFudC53YXJuKDMsIHNvbWVOb25SZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEZWxldGVkXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuZWVkVG9NZXJnZV8xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZShkYXRhSWQsIGNoYW5nZWRGaWVsZHNfMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbERlbGV0ZWRfMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gSWYgY2FsbGVkIHdpdGggb25seSBvbmUgYXJndW1lbnQsIHJlbW92ZXMgdGhlIGVudGlyZSBlbnRpdHlcbiAgICAvLyBpZGVudGlmaWVkIGJ5IGRhdGFJZC4gSWYgY2FsbGVkIHdpdGggYSBmaWVsZE5hbWUgYXMgd2VsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBmaWVsZHMgb2YgdGhhdCBlbnRpdHkgd2hvc2UgbmFtZXMgbWF0Y2ggZmllbGROYW1lIGFjY29yZGluZyB0byB0aGVcbiAgICAvLyBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lIGhlbHBlciBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggYSBmaWVsZE5hbWVcbiAgICAvLyBhbmQgdmFyaWFibGVzLCByZW1vdmVzIGFsbCBmaWVsZHMgb2YgdGhhdCBlbnRpdHkgd2hvc2UgbmFtZXMgbWF0Y2ggZmllbGROYW1lXG4gICAgLy8gYW5kIHdob3NlIGFyZ3VtZW50cyB3aGVuIGNhY2hlZCBleGFjdGx5IG1hdGNoIHRoZSB2YXJpYWJsZXMgcGFzc2VkLlxuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZGF0YUlkLCBmaWVsZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSB0aGlzLmxvb2t1cChkYXRhSWQpO1xuICAgICAgICBpZiAoc3RvcmVPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IHRoaXMuZ2V0RmllbGRWYWx1ZShzdG9yZU9iamVjdCwgXCJfX3R5cGVuYW1lXCIpO1xuICAgICAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lID0gZmllbGROYW1lICYmIGFyZ3MgP1xuICAgICAgICAgICAgICAgIHRoaXMucG9saWNpZXMuZ2V0U3RvcmVGaWVsZE5hbWUoeyB0eXBlbmFtZTogdHlwZW5hbWUsIGZpZWxkTmFtZTogZmllbGROYW1lLCBhcmdzOiBhcmdzIH0pXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSA/IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW3N0b3JlRmllbGROYW1lXSA9IGRlbE1vZGlmaWVyLFxuICAgICAgICAgICAgICAgIF9hKSA6IGRlbE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZXZpY3QgPSBmdW5jdGlvbiAob3B0aW9ucywgbGltaXQpIHtcbiAgICAgICAgdmFyIGV2aWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbCh0aGlzLmRhdGEsIG9wdGlvbnMuaWQpKSB7XG4gICAgICAgICAgICAgICAgZXZpY3RlZCA9IHRoaXMuZGVsZXRlKG9wdGlvbnMuaWQsIG9wdGlvbnMuZmllbGROYW1lLCBvcHRpb25zLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBMYXllciAmJiB0aGlzICE9PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGV2aWN0ZWQgPSB0aGlzLnBhcmVudC5ldmljdChvcHRpb25zLCBsaW1pdCkgfHwgZXZpY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsd2F5cyBpbnZhbGlkYXRlIHRoZSBmaWVsZCB0byB0cmlnZ2VyIHJlcmVhZGluZyBvZiB3YXRjaGVkXG4gICAgICAgICAgICAvLyBxdWVyaWVzLCBldmVuIGlmIG5vIGNhY2hlIGRhdGEgd2FzIG1vZGlmaWVkIGJ5IHRoZSBldmljdGlvbixcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgcXVlcmllcyBtYXkgZGVwZW5kIG9uIGNvbXB1dGVkIGZpZWxkcyB3aXRoIGN1c3RvbSByZWFkXG4gICAgICAgICAgICAvLyBmdW5jdGlvbnMsIHdob3NlIHZhbHVlcyBhcmUgbm90IHN0b3JlZCBpbiB0aGUgRW50aXR5U3RvcmUuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWVsZE5hbWUgfHwgZXZpY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGlydHkob3B0aW9ucy5pZCwgb3B0aW9ucy5maWVsZE5hbWUgfHwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZpY3RlZDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIHZhciBleHRyYVJvb3RJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRSb290SWRTZXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChfdGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCwgaWQpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFSb290SWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4dHJhUm9vdElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5fX01FVEEgPSB7IGV4dHJhUm9vdElkczogZXh0cmFSb290SWRzLnNvcnQoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICBpZiAoIShuZXdEYXRhICYmIGhhc093bi5jYWxsKG5ld0RhdGEsIGRhdGFJZCkpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgdmFyIF9fTUVUQSA9IG5ld0RhdGEuX19NRVRBLCByZXN0XzEgPSBfX3Jlc3QobmV3RGF0YSwgW1wiX19NRVRBXCJdKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3RfMSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoZGF0YUlkLCByZXN0XzFbZGF0YUlkXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfX01FVEEpIHtcbiAgICAgICAgICAgICAgICBfX01FVEEuZXh0cmFSb290SWRzLmZvckVhY2godGhpcy5yZXRhaW4sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJvb3RJZCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucm9vdElkc1tyb290SWRdID0gKHRoaXMucm9vdElkc1tyb290SWRdIHx8IDApICsgMSk7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChyb290SWQpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkc1tyb290SWRdID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gLS10aGlzLnJvb3RJZHNbcm9vdElkXTtcbiAgICAgICAgICAgIGlmICghY291bnQpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucm9vdElkc1tyb290SWRdO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLy8gUmV0dXJuIGEgU2V0PHN0cmluZz4gb2YgYWxsIHRoZSBJRCBzdHJpbmdzIHRoYXQgaGF2ZSBiZWVuIHJldGFpbmVkIGJ5XG4gICAgLy8gdGhpcyBsYXllci9yb290ICphbmQqIGFueSBsYXllcnMvcm9vdHMgYmVuZWF0aCBpdC5cbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZ2V0Um9vdElkU2V0ID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICBpZiAoaWRzID09PSB2b2lkIDApIHsgaWRzID0gbmV3IFNldCgpOyB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucm9vdElkcykuZm9yRWFjaChpZHMuYWRkLCBpZHMpO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRSb290SWRTZXQoaWRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9mZmljaWFsIHNpbmdsZXRvbiBJRHMgbGlrZSBST09UX1FVRVJZIGFuZCBST09UX01VVEFUSU9OIGFyZVxuICAgICAgICAgICAgLy8gYWx3YXlzIGNvbnNpZGVyZWQgcm9vdHMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gdGhlaXIgcmV0YWlubWVudCBjb3VudHMgaW4gdGhpcy5yb290SWRzLlxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCkuZm9yRWFjaChpZHMuYWRkLCBpZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfTtcbiAgICAvLyBUaGUgZ29hbCBvZiBnYXJiYWdlIGNvbGxlY3Rpb24gaXMgdG8gcmVtb3ZlIElEcyBmcm9tIHRoZSBSb290IGxheWVyIG9mIHRoZVxuICAgIC8vIHN0b3JlIHRoYXQgYXJlIG5vIGxvbmdlciByZWFjaGFibGUgc3RhcnRpbmcgZnJvbSBhbnkgSURzIHRoYXQgaGF2ZSBiZWVuXG4gICAgLy8gZXhwbGljaXRseSByZXRhaW5lZCAoc2VlIHJldGFpbiBhbmQgcmVsZWFzZSwgYWJvdmUpLiBSZXR1cm5zIGFuIGFycmF5IG9mXG4gICAgLy8gZGF0YUlkIHN0cmluZ3MgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmdjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5nZXRSb290SWRTZXQoKTtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChzbmFwc2hvdCwgaWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIgYW4gRUNNQVNjcmlwdCBTZXQsIHRoZSBJRHMgd2UgYWRkIGhlcmVcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHZpc2l0ZWQgaW4gbGF0ZXIgaXRlcmF0aW9ucyBvZiB0aGUgZm9yRWFjaCBsb29wIG9ubHkgaWYgdGhleVxuICAgICAgICAgICAgICAgIC8vIHdlcmUgbm90IHByZXZpb3VzbHkgY29udGFpbmVkIGJ5IHRoZSBTZXQuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuZmluZENoaWxkUmVmSWRzKGlkKSkuZm9yRWFjaChpZHMuYWRkLCBpZHMpO1xuICAgICAgICAgICAgICAgIC8vIEJ5IHJlbW92aW5nIElEcyBmcm9tIHRoZSBzbmFwc2hvdCBvYmplY3QgaGVyZSwgd2UgcHJvdGVjdCB0aGVtIGZyb21cbiAgICAgICAgICAgICAgICAvLyBnZXR0aW5nIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBzdG9yZSBsYXllciBiZWxvdy5cbiAgICAgICAgICAgICAgICBkZWxldGUgc25hcHNob3RbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMoc25hcHNob3QpO1xuICAgICAgICBpZiAoaWRzVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdF8xID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChyb290XzEgaW5zdGFuY2VvZiBMYXllcilcbiAgICAgICAgICAgICAgICByb290XzEgPSByb290XzEucGFyZW50O1xuICAgICAgICAgICAgaWRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJvb3RfMS5kZWxldGUoaWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzVG9SZW1vdmU7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZmluZENoaWxkUmVmSWRzID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRoaXMucmVmcywgZGF0YUlkKSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kXzEgPSAodGhpcy5yZWZzW2RhdGFJZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kXzE7XG4gICAgICAgICAgICB2YXIgd29ya1NldF8xID0gbmV3IFNldChbcm9vdF0pO1xuICAgICAgICAgICAgLy8gV2l0aGluIHRoZSBzdG9yZSwgb25seSBhcnJheXMgYW5kIG9iamVjdHMgY2FuIGNvbnRhaW4gY2hpbGQgZW50aXR5XG4gICAgICAgICAgICAvLyByZWZlcmVuY2VzLCBzbyB3ZSBjYW4gcHJ1bmUgdGhlIHRyYXZlcnNhbCB1c2luZyB0aGlzIHByZWRpY2F0ZTpcbiAgICAgICAgICAgIHdvcmtTZXRfMS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2Uob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZF8xW29iai5fX3JlZl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiByYXJlIGNhc2VzLCBhIHsgX19yZWYgfSBSZWZlcmVuY2Ugb2JqZWN0IG1heSBoYXZlIG90aGVyIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvZnRlbiBpbmRpY2F0ZXMgYSBtaXNtZXJnaW5nIG9mIFJlZmVyZW5jZXMgd2l0aCBTdG9yZU9iamVjdHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBnYXJiYWdlIGNvbGxlY3Rpb24gc2hvdWxkIG5vdCBiZSBmb29sZWQgYnkgYSBzdHJheSBfX3JlZlxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBpbiBhIFN0b3JlT2JqZWN0IChpZ25vcmluZyBhbGwgdGhlIG90aGVyIGZpZWxkcyBqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIFN0b3JlT2JqZWN0IGxvb2tzIGxpa2UgYSBSZWZlcmVuY2UpLiBUbyBhdm9pZCB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZW1hdHVyZSB0ZXJtaW5hdGlvbiBvZiBmaW5kQ2hpbGRSZWZJZHMgcmVjdXJzaW9uLCB3ZSBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIGNvZGUgYmVsb3csIHdoaWNoIHdpbGwgaGFuZGxlIGFueSBvdGhlciBwcm9wZXJ0aWVzIG9mIG9iai5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHByaW1pdGl2ZSB2YWx1ZXMgdG8gdGhlIHdvcmtTZXQsIHNpbmNlIHRoZXkgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250YWluIHJlZmVyZW5jZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrU2V0XzEuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmc1tkYXRhSWRdO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLm1ha2VDYWNoZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAua2V5TWFrZXIubG9va3VwQXJyYXkoYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHJldHVybiBFbnRpdHlTdG9yZTtcbn0oKSk7XG5leHBvcnQgeyBFbnRpdHlTdG9yZSB9O1xuLy8gQSBzaW5nbGUgQ2FjaGVHcm91cCByZXByZXNlbnRzIGEgc2V0IG9mIG9uZSBvciBtb3JlIEVudGl0eVN0b3JlIG9iamVjdHMsXG4vLyB0eXBpY2FsbHkgdGhlIFJvb3Qgc3RvcmUgaW4gYSBDYWNoZUdyb3VwIGJ5IGl0c2VsZiwgYW5kIGFsbCBhY3RpdmUgTGF5ZXJcbi8vIHN0b3JlcyBpbiBhIGdyb3VwIHRvZ2V0aGVyLiBBIHNpbmdsZSBFbnRpdHlTdG9yZSBvYmplY3QgYmVsb25ncyB0byBvbmx5XG4vLyBvbmUgQ2FjaGVHcm91cCwgc3RvcmUuZ3JvdXAuIFRoZSBDYWNoZUdyb3VwIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFja2luZ1xuLy8gZGVwZW5kZW5jaWVzLCBzbyBzdG9yZS5ncm91cCBpcyBoZWxwZnVsIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBrZXlzIGZvclxuLy8gY2FjaGVkIHJlc3VsdHMgdGhhdCBuZWVkIHRvIGJlIGludmFsaWRhdGVkIHdoZW4vaWYgdGhvc2UgZGVwZW5kZW5jaWVzXG4vLyBjaGFuZ2UuIElmIHdlIHVzZWQgdGhlIEVudGl0eVN0b3JlIG9iamVjdHMgdGhlbXNlbHZlcyBhcyBjYWNoZSBrZXlzICh0aGF0XG4vLyBpcywgc3RvcmUgcmF0aGVyIHRoYW4gc3RvcmUuZ3JvdXApLCB0aGUgY2FjaGUgd291bGQgYmVjb21lIHVubmVjZXNzYXJpbHlcbi8vIGZyYWdtZW50ZWQgYnkgYWxsIHRoZSBkaWZmZXJlbnQgTGF5ZXIgb2JqZWN0cy4gSW5zdGVhZCwgdGhlIENhY2hlR3JvdXBcbi8vIGFwcHJvYWNoIGFsbG93cyBhbGwgb3B0aW1pc3RpYyBMYXllciBvYmplY3RzIGluIHRoZSBzYW1lIGxpbmtlZCBsaXN0IHRvXG4vLyBiZWxvbmcgdG8gb25lIENhY2hlR3JvdXAsIHdpdGggdGhlIG5vbi1vcHRpbWlzdGljIFJvb3Qgb2JqZWN0IGJlbG9uZ2luZ1xuLy8gdG8gYW5vdGhlciBDYWNoZUdyb3VwLCBhbGxvd2luZyByZXN1bHRDYWNoaW5nIGRlcGVuZGVuY2llcyB0byBiZSB0cmFja2VkXG4vLyBzZXBhcmF0ZWx5IGZvciBvcHRpbWlzdGljIGFuZCBub24tb3B0aW1pc3RpYyBlbnRpdHkgZGF0YS5cbnZhciBDYWNoZUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlR3JvdXAoY2FjaGluZywgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuY2FjaGluZyA9IGNhY2hpbmc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0Q2FjaGluZygpO1xuICAgIH1cbiAgICBDYWNoZUdyb3VwLnByb3RvdHlwZS5yZXNldENhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZCA9IHRoaXMuY2FjaGluZyA/IGRlcCgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5rZXlNYWtlciA9IG5ldyBUcmllKGNhblVzZVdlYWtNYXApO1xuICAgIH07XG4gICAgQ2FjaGVHcm91cC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZCkge1xuICAgICAgICAgICAgdGhpcy5kKG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWVsZHMgd2l0aCBhcmd1bWVudHMgdGhhdCBjb250cmlidXRlIGV4dHJhIGlkZW50aWZ5aW5nXG4gICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gdG8gdGhlIGZpZWxkTmFtZSAodGh1cyBmb3JtaW5nIHRoZSBzdG9yZUZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmQgbm90IG9ubHkgb24gdGhlIGZ1bGwgc3RvcmVGaWVsZE5hbWUgYnV0IGFsc28gb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2hvcnQgZmllbGROYW1lLCBzbyB0aGUgZmllbGQgY2FuIGJlIGludmFsaWRhdGVkIHVzaW5nIGVpdGhlclxuICAgICAgICAgICAgICAgIC8vIGxldmVsIG9mIHNwZWNpZmljaXR5LlxuICAgICAgICAgICAgICAgIHRoaXMuZChtYWtlRGVwS2V5KGRhdGFJZCwgZmllbGROYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5kZXBlbmQoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhY2hlR3JvdXAucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZCkge1xuICAgICAgICAgICAgdGhpcy5kLmRpcnR5KG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSksIFxuICAgICAgICAgICAgLy8gV2hlbiBzdG9yZUZpZWxkTmFtZSA9PT0gXCJfX2V4aXN0c1wiLCB0aGF0IG1lYW5zIHRoZSBlbnRpdHkgaWRlbnRpZmllZFxuICAgICAgICAgICAgLy8gYnkgZGF0YUlkIGhhcyBlaXRoZXIgZGlzYXBwZWFyZWQgZnJvbSB0aGUgY2FjaGUgb3Igd2FzIG5ld2x5IGFkZGVkLFxuICAgICAgICAgICAgLy8gc28gdGhlIHJlc3VsdCBjYWNoaW5nIHN5c3RlbSB3b3VsZCBkbyB3ZWxsIHRvIFwiZm9yZ2V0IGV2ZXJ5dGhpbmcgaXRcbiAgICAgICAgICAgIC8vIGtub3dzXCIgYWJvdXQgdGhhdCBvYmplY3QuIFRvIGFjaGlldmUgdGhhdCBraW5kIG9mIGludmFsaWRhdGlvbiwgd2VcbiAgICAgICAgICAgIC8vIG5vdCBvbmx5IGRpcnR5IHRoZSBhc3NvY2lhdGVkIHJlc3VsdCBjYWNoZSBlbnRyeSwgYnV0IGFsc28gcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGZyb20gdGhlIGRlcGVuZGVuY3kgZ3JhcGguIEZvciB0aGUgb3B0aW1pc20gaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIGRldGFpbHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtbi9vcHRpbWlzbS9wdWxsLzE5NS5cbiAgICAgICAgICAgIHN0b3JlRmllbGROYW1lID09PSBcIl9fZXhpc3RzXCIgPyBcImZvcmdldFwiIDogXCJzZXREaXJ0eVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhY2hlR3JvdXA7XG59KCkpO1xuZnVuY3Rpb24gbWFrZURlcEtleShkYXRhSWQsIHN0b3JlRmllbGROYW1lKSB7XG4gICAgLy8gU2luY2UgZmllbGQgbmFtZXMgY2Fubm90IGhhdmUgJyMnIGNoYXJhY3RlcnMgaW4gdGhlbSwgdGhpcyBtZXRob2RcbiAgICAvLyBvZiBqb2luaW5nIHRoZSBmaWVsZCBuYW1lIGFuZCB0aGUgSUQgc2hvdWxkIGJlIHVuYW1iaWd1b3VzLCBhbmQgbXVjaFxuICAgIC8vIGNoZWFwZXIgdGhhbiBKU09OLnN0cmluZ2lmeShbZGF0YUlkLCBmaWVsZE5hbWVdKS5cbiAgICByZXR1cm4gc3RvcmVGaWVsZE5hbWUgKyBcIiNcIiArIGRhdGFJZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXliZURlcGVuZE9uRXhpc3RlbmNlT2ZFbnRpdHkoc3RvcmUsIGVudGl0eUlkKSB7XG4gICAgaWYgKHN1cHBvcnRzUmVzdWx0Q2FjaGluZyhzdG9yZSkpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgcHNldWRvLWZpZWxkIF9fZXhpc3RzIGVsc2V3aGVyZSBpbiB0aGUgRW50aXR5U3RvcmUgY29kZSB0b1xuICAgICAgICAvLyByZXByZXNlbnQgY2hhbmdlcyBpbiB0aGUgZXhpc3RlbmNlIG9mIHRoZSBlbnRpdHkgb2JqZWN0IGlkZW50aWZpZWQgYnlcbiAgICAgICAgLy8gZW50aXR5SWQuIFRoaXMgZGVwZW5kZW5jeSBnZXRzIHJlbGlhYmx5IGRpcnRpZWQgd2hlbmV2ZXIgYW4gb2JqZWN0IHdpdGhcbiAgICAgICAgLy8gdGhpcyBJRCBpcyBkZWxldGVkIChvciBuZXdseSBjcmVhdGVkKSB3aXRoaW4gdGhpcyBncm91cCwgc28gYW55IHJlc3VsdFxuICAgICAgICAvLyBjYWNoZSBlbnRyaWVzIChmb3IgZXhhbXBsZSwgU3RvcmVSZWFkZXIjZXhlY3V0ZVNlbGVjdGlvblNldCByZXN1bHRzKSB0aGF0XG4gICAgICAgIC8vIGRlcGVuZCBvbiBfX2V4aXN0cyBmb3IgdGhpcyBlbnRpdHlJZCB3aWxsIGdldCBkaXJ0aWVkIGFzIHdlbGwsIGxlYWRpbmcgdG9cbiAgICAgICAgLy8gdGhlIGV2ZW50dWFsIHJlY29tcHV0YXRpb24gKGluc3RlYWQgb2YgcmV1c2UpIG9mIHRob3NlIHJlc3VsdCBvYmplY3RzIHRoZVxuICAgICAgICAvLyBuZXh0IHRpbWUgc29tZW9uZSByZWFkcyB0aGVtIGZyb20gdGhlIGNhY2hlLlxuICAgICAgICBzdG9yZS5ncm91cC5kZXBlbmQoZW50aXR5SWQsIFwiX19leGlzdHNcIik7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChFbnRpdHlTdG9yZSkge1xuICAgIC8vIFJlZmVyIHRvIHRoaXMgY2xhc3MgYXMgRW50aXR5U3RvcmUuUm9vdCBvdXRzaWRlIHRoaXMgbmFtZXNwYWNlLlxuICAgIHZhciBSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUm9vdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUm9vdChfYSkge1xuICAgICAgICAgICAgdmFyIHBvbGljaWVzID0gX2EucG9saWNpZXMsIF9iID0gX2EucmVzdWx0Q2FjaGluZywgcmVzdWx0Q2FjaGluZyA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIHNlZWQgPSBfYS5zZWVkO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9saWNpZXMsIG5ldyBDYWNoZUdyb3VwKHJlc3VsdENhY2hpbmcpKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuc3R1bXAgPSBuZXcgU3R1bXAoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuc3RvcmFnZVRyaWUgPSBuZXcgVHJpZShjYW5Vc2VXZWFrTWFwKTtcbiAgICAgICAgICAgIGlmIChzZWVkKVxuICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2Uoc2VlZCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgUm9vdC5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJJZCwgcmVwbGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgYW4gb3B0aW1pc3RpYyBMYXllciBvbiB0b3Agb2YgdGhlIFJvb3QgYWN0dWFsbHkgYWRkcyB0aGUgTGF5ZXJcbiAgICAgICAgICAgIC8vIG9uIHRvcCBvZiB0aGUgU3R1bXAsIHNvIHRoZSBTdHVtcCBhbHdheXMgY29tZXMgYmV0d2VlbiB0aGUgUm9vdCBhbmRcbiAgICAgICAgICAgIC8vIGFueSBMYXllciBvYmplY3RzIHRoYXQgd2UndmUgYWRkZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHVtcC5hZGRMYXllcihsYXllcklkLCByZXBsYXkpO1xuICAgICAgICB9O1xuICAgICAgICBSb290LnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5ldmVyIHJlbW92ZSB0aGUgcm9vdCBsYXllci5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBSb290LnByb3RvdHlwZS5nZXRTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVRyaWUubG9va3VwQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJvb3Q7XG4gICAgfShFbnRpdHlTdG9yZSkpO1xuICAgIEVudGl0eVN0b3JlLlJvb3QgPSBSb290O1xufSkoRW50aXR5U3RvcmUgfHwgKEVudGl0eVN0b3JlID0ge30pKTtcbi8vIE5vdCBleHBvcnRlZCwgc2luY2UgYWxsIExheWVyIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBieSB0aGUgYWRkTGF5ZXIgbWV0aG9kXG4vLyBvZiB0aGUgRW50aXR5U3RvcmUuUm9vdCBjbGFzcy5cbnZhciBMYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5ZXIoaWQsIHBhcmVudCwgcmVwbGF5LCBncm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQucG9saWNpZXMsIGdyb3VwKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgX3RoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgcmVwbGF5KF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXllci5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJJZCwgcmVwbGF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXIobGF5ZXJJZCwgdGhpcywgcmVwbGF5LCB0aGlzLmdyb3VwKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIChsYXllcklkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBpZCwgbm90IGp1c3QgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LnJlbW92ZUxheWVyKGxheWVySWQpO1xuICAgICAgICBpZiAobGF5ZXJJZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXAuY2FjaGluZykge1xuICAgICAgICAgICAgICAgIC8vIERpcnR5IGV2ZXJ5IElEIHdlJ3JlIHJlbW92aW5nLiBUZWNobmljYWxseSB3ZSBtaWdodCBiZSBhYmxlIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gZGlydHlpbmcgZmllbGRzIHRoYXQgaGF2ZSB2YWx1ZXMgaW4gaGlnaGVyIGxheWVycywgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyBlYXN5IGFjY2VzcyB0byBoaWdoZXIgbGF5ZXJzIGhlcmUsIGFuZCB3ZSdyZSBhYm91dCB0byByZWNyZWF0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIC8vIGxheWVycyBhbnl3YXkgKHNlZSBwYXJlbnQuYWRkTGF5ZXIgYmVsb3cpLlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvd25TdG9yZU9iamVjdCA9IF90aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0b3JlT2JqZWN0ID0gcGFyZW50W1wibG9va3VwXCJdKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50U3RvcmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTdG9yZU9iamVjdCBpZGVudGlmaWVkIGJ5IGRhdGFJZCB3YXMgZGVmaW5lZCBpbiB0aGlzIGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSB1bmRlZmluZWQgaW4gdGhlIHBhcmVudCBsYXllciwgc28gd2UgY2FuIGRlbGV0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdob2xlIGVudGl0eSB1c2luZyB0aGlzLmRlbGV0ZShkYXRhSWQpLiBTaW5jZSB3ZSdyZSBhYm91dCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdGhpcyBsYXllciBhd2F5LCB0aGUgb25seSBnb2FsIG9mIHRoaXMgZGVsZXRpb24gaXMgdG8gZGlydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZW1vdmVkIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvd25TdG9yZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsYXllciBoYWQgYW4gZW50cnkgZm9yIGRhdGFJZCBidXQgaXQgd2FzIHVuZGVmaW5lZCwgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIHRoZSBlbnRpdHkgd2FzIGRlbGV0ZWQgaW4gdGhpcyBsYXllciwgYW5kIGl0J3MgYWJvdXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY29tZSB1bmRlbGV0ZWQgd2hlbiB3ZSByZW1vdmUgdGhpcyBsYXllciwgc28gd2UgbmVlZCB0byBkaXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGZpZWxkcyB0aGF0IGFyZSBhYm91dCB0byBiZSByZWV4cG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIFwiX19leGlzdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRTdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG93blN0b3JlT2JqZWN0ICE9PSBwYXJlbnRTdG9yZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb3duU3RvcmVPYmplY3QgaXMgbm90IGV4YWN0bHkgdGhlIHNhbWUgYXMgcGFyZW50U3RvcmVPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXJ0eSBhbnkgZmllbGRzIHdob3NlIHZhbHVlcyB3aWxsIGNoYW5nZSBhcyBhIHJlc3VsdCBvZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3duU3RvcmVPYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbChvd25TdG9yZU9iamVjdFtzdG9yZUZpZWxkTmFtZV0sIHBhcmVudFN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ3JvdXAuZGlydHkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gY2hhbmdlcyBhcmUgbmVjZXNzYXJ5IGlmIHRoZSBwYXJlbnQgY2hhaW4gcmVtYWlucyBpZGVudGljYWwuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8vIFJlY3JlYXRlIHRoaXMgbGF5ZXIgb24gdG9wIG9mIHRoZSBuZXcgcGFyZW50LlxuICAgICAgICByZXR1cm4gcGFyZW50LmFkZExheWVyKHRoaXMuaWQsIHRoaXMucmVwbGF5KTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnBhcmVudC50b09iamVjdCgpKSwgdGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5maW5kQ2hpbGRSZWZJZHMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHZhciBmcm9tUGFyZW50ID0gdGhpcy5wYXJlbnQuZmluZENoaWxkUmVmSWRzKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiBoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnJvbVBhcmVudCksIF9zdXBlci5wcm90b3R5cGUuZmluZENoaWxkUmVmSWRzLmNhbGwodGhpcywgZGF0YUlkKSkgOiBmcm9tUGFyZW50O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwLnBhcmVudClcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHAuZ2V0U3RvcmFnZS5hcHBseShwLCBcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIExheWVyO1xufShFbnRpdHlTdG9yZSkpO1xuLy8gUmVwcmVzZW50cyBhIExheWVyIHBlcm1hbmVudGx5IGluc3RhbGxlZCBqdXN0IGFib3ZlIHRoZSBSb290LCB3aGljaCBhbGxvd3Ncbi8vIHJlYWRpbmcgb3B0aW1pc3RpY2FsbHkgKGFuZCByZWdpc3RlcmluZyBvcHRpbWlzdGljIGRlcGVuZGVuY2llcykgZXZlbiB3aGVuXG4vLyBubyBvcHRpbWlzdGljIGxheWVycyBhcmUgY3VycmVudGx5IGFjdGl2ZS4gVGhlIHN0dW1wLmdyb3VwIENhY2hlR3JvdXAgb2JqZWN0XG4vLyBpcyBzaGFyZWQgYnkgYW55L2FsbCBMYXllciBvYmplY3RzIGFkZGVkIG9uIHRvcCBvZiB0aGUgU3R1bXAuXG52YXIgU3R1bXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0dW1wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0dW1wKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiRW50aXR5U3RvcmUuU3R1bXBcIiwgcm9vdCwgZnVuY3Rpb24gKCkgeyB9LCBuZXcgQ2FjaGVHcm91cChyb290Lmdyb3VwLmNhY2hpbmcsIHJvb3QuZ3JvdXApKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdHVtcC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5ldmVyIHJlbW92ZSB0aGUgU3R1bXAgbGF5ZXIuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3R1bXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG9sZGVyLCBuZXdlcikge1xuICAgICAgICAvLyBXZSBuZXZlciB3YW50IHRvIHdyaXRlIGFueSBkYXRhIGludG8gdGhlIFN0dW1wLCBzbyB3ZSBmb3J3YXJkIGFueSBtZXJnZVxuICAgICAgICAvLyBjYWxscyB0byB0aGUgUm9vdCBpbnN0ZWFkLiBBbm90aGVyIG9wdGlvbiBoZXJlIHdvdWxkIGJlIHRvIHRocm93IGFuXG4gICAgICAgIC8vIGV4Y2VwdGlvbiwgYnV0IHRoZSB0b1JlZmVyZW5jZShvYmplY3QsIHRydWUpIGZ1bmN0aW9uIGNhbiBzb21ldGltZXNcbiAgICAgICAgLy8gdHJpZ2dlciBTdHVtcCB3cml0ZXMgKHdoaWNoIHVzZWQgdG8gYmUgUm9vdCB3cml0ZXMsIGJlZm9yZSB0aGUgU3R1bXBcbiAgICAgICAgLy8gY29uY2VwdCB3YXMgaW50cm9kdWNlZCkuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5tZXJnZShvbGRlciwgbmV3ZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0dW1wO1xufShMYXllcikpO1xuZnVuY3Rpb24gc3RvcmVPYmplY3RSZWNvbmNpbGVyKGV4aXN0aW5nT2JqZWN0LCBpbmNvbWluZ09iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICB2YXIgaW5jb21pbmdWYWx1ZSA9IGluY29taW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAvLyBXaGVyZXZlciB0aGVyZSBpcyBhIGtleSBjb2xsaXNpb24sIHByZWZlciB0aGUgaW5jb21pbmcgdmFsdWUsIHVubGVzc1xuICAgIC8vIGl0IGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZXhpc3RpbmcgdmFsdWUuIEl0J3Mgd29ydGggY2hlY2tpbmcgZGVlcFxuICAgIC8vIGVxdWFsaXR5IGhlcmUgKGV2ZW4gdGhvdWdoIGJsaW5kbHkgcmV0dXJuaW5nIGluY29taW5nIHdvdWxkIGJlXG4gICAgLy8gbG9naWNhbGx5IGNvcnJlY3QpIGJlY2F1c2UgcHJlc2VydmluZyB0aGUgcmVmZXJlbnRpYWwgaWRlbnRpdHkgb2ZcbiAgICAvLyBleGlzdGluZyBkYXRhIGNhbiBwcmV2ZW50IG5lZWRsZXNzIHJlcmVhZGluZyBhbmQgcmVyZW5kZXJpbmcuXG4gICAgcmV0dXJuIGVxdWFsKGV4aXN0aW5nVmFsdWUsIGluY29taW5nVmFsdWUpID8gZXhpc3RpbmdWYWx1ZSA6IGluY29taW5nVmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNSZXN1bHRDYWNoaW5nKHN0b3JlKSB7XG4gICAgLy8gV2hlbiByZXN1bHQgY2FjaGluZyBpcyBkaXNhYmxlZCwgc3RvcmUuZGVwZW5kIHdpbGwgYmUgbnVsbC5cbiAgICByZXR1cm4gISEoc3RvcmUgaW5zdGFuY2VvZiBFbnRpdHlTdG9yZSAmJiBzdG9yZS5ncm91cC5jYWNoaW5nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudGl0eVN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fZXh0ZW5kcyIsIl9fcmVzdCIsImludmFyaWFudCIsImRlcCIsImVxdWFsIiwiVHJpZSIsImlzUmVmZXJlbmNlIiwibWFrZVJlZmVyZW5jZSIsIkRlZXBNZXJnZXIiLCJtYXliZURlZXBGcmVlemUiLCJjYW5Vc2VXZWFrTWFwIiwiaXNOb25OdWxsT2JqZWN0IiwiaGFzT3duIiwiZmllbGROYW1lRnJvbVN0b3JlTmFtZSIsIkRFTEVURSIsIk9iamVjdCIsImNyZWF0ZSIsImRlbE1vZGlmaWVyIiwiSU5WQUxJREFURSIsIkVudGl0eVN0b3JlIiwicG9saWNpZXMiLCJncm91cCIsIl90aGlzIiwiZGF0YSIsInJvb3RJZHMiLCJyZWZzIiwiZ2V0RmllbGRWYWx1ZSIsIm9iamVjdE9yUmVmZXJlbmNlIiwic3RvcmVGaWVsZE5hbWUiLCJnZXQiLCJfX3JlZiIsImNhblJlYWQiLCJvYmpPclJlZiIsImhhcyIsInRvUmVmZXJlbmNlIiwib2JqT3JJZE9yUmVmIiwibWVyZ2VJbnRvU3RvcmUiLCJpZCIsImlkZW50aWZ5IiwicmVmIiwibWVyZ2UiLCJwcm90b3R5cGUiLCJ0b09iamVjdCIsImRhdGFJZCIsImxvb2t1cCIsImZpZWxkTmFtZSIsImRlcGVuZCIsImNhbGwiLCJzdG9yZU9iamVjdCIsInJvb3RUeXBlbmFtZXNCeUlkIiwiTGF5ZXIiLCJwYXJlbnQiLCJkZXBlbmRPbkV4aXN0ZW5jZSIsIm9sZGVyIiwibmV3ZXIiLCJleGlzdGluZyIsImluY29taW5nIiwibWVyZ2VkIiwic3RvcmVPYmplY3RSZWNvbmNpbGVyIiwiY2FjaGluZyIsImZpZWxkc1RvRGlydHlfMSIsIl9fZXhpc3RzIiwia2V5cyIsImZvckVhY2giLCJoYXNLZXlBcmdzIiwiX190eXBlbmFtZSIsImRpcnR5IiwibW9kaWZ5IiwiZmllbGRzIiwiY2hhbmdlZEZpZWxkc18xIiwibmVlZFRvTWVyZ2VfMSIsImFsbERlbGV0ZWRfMSIsInNoYXJlZERldGFpbHNfMSIsInJlYWRGaWVsZCIsImZpZWxkTmFtZU9yT3B0aW9ucyIsImZyb20iLCJzdG9yZSIsImZpZWxkVmFsdWUiLCJuZXdWYWx1ZSIsInN0b3JhZ2UiLCJnZXRTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJjaGVja1JlZmVyZW5jZSIsInVuZGVmaW5lZCIsIndhcm4iLCJBcnJheSIsImlzQXJyYXkiLCJzZWVuUmVmZXJlbmNlIiwic29tZU5vblJlZmVyZW5jZSIsIl9pIiwibmV3VmFsdWVfMSIsImxlbmd0aCIsInZhbHVlIiwiZGVsZXRlIiwiYXJncyIsIl9hIiwidHlwZW5hbWUiLCJnZXRTdG9yZUZpZWxkTmFtZSIsImV2aWN0Iiwib3B0aW9ucyIsImxpbWl0IiwiZXZpY3RlZCIsImNsZWFyIiwicmVwbGFjZSIsImV4dHJhY3QiLCJvYmoiLCJleHRyYVJvb3RJZHMiLCJnZXRSb290SWRTZXQiLCJwdXNoIiwiX19NRVRBIiwic29ydCIsIm5ld0RhdGEiLCJyZXN0XzEiLCJyZXRhaW4iLCJyb290SWQiLCJyZWxlYXNlIiwiY291bnQiLCJpZHMiLCJTZXQiLCJhZGQiLCJnYyIsInNuYXBzaG90IiwiZmluZENoaWxkUmVmSWRzIiwiaWRzVG9SZW1vdmUiLCJyb290XzEiLCJmb3VuZF8xIiwicm9vdCIsIndvcmtTZXRfMSIsImtleSIsImNoaWxkIiwibWFrZUNhY2hlS2V5Iiwia2V5TWFrZXIiLCJsb29rdXBBcnJheSIsImFyZ3VtZW50cyIsIkNhY2hlR3JvdXAiLCJkIiwicmVzZXRDYWNoaW5nIiwibWFrZURlcEtleSIsIm1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eSIsImVudGl0eUlkIiwic3VwcG9ydHNSZXN1bHRDYWNoaW5nIiwiUm9vdCIsIl9zdXBlciIsIl9iIiwicmVzdWx0Q2FjaGluZyIsInNlZWQiLCJzdHVtcCIsIlN0dW1wIiwic3RvcmFnZVRyaWUiLCJhZGRMYXllciIsImxheWVySWQiLCJyZXBsYXkiLCJyZW1vdmVMYXllciIsIm93blN0b3JlT2JqZWN0IiwicGFyZW50U3RvcmVPYmplY3QiLCJmcm9tUGFyZW50IiwicCIsImFwcGx5IiwiZXhpc3RpbmdPYmplY3QiLCJpbmNvbWluZ09iamVjdCIsInByb3BlcnR5IiwiZXhpc3RpbmdWYWx1ZSIsImluY29taW5nVmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/entityStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/helpers.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypeOrFieldNameRegExp: function() { return /* binding */ TypeOrFieldNameRegExp; },\n/* harmony export */   defaultDataIdFromObject: function() { return /* binding */ defaultDataIdFromObject; },\n/* harmony export */   extractFragmentContext: function() { return /* binding */ extractFragmentContext; },\n/* harmony export */   fieldNameFromStoreName: function() { return /* binding */ fieldNameFromStoreName; },\n/* harmony export */   getTypenameFromStoreObject: function() { return /* binding */ getTypenameFromStoreObject; },\n/* harmony export */   hasOwn: function() { return /* binding */ hasOwn; },\n/* harmony export */   isArray: function() { return /* reexport safe */ _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.isArray; },\n/* harmony export */   isNullish: function() { return /* binding */ isNullish; },\n/* harmony export */   makeProcessedFieldsMerger: function() { return /* binding */ makeProcessedFieldsMerger; },\n/* harmony export */   normalizeConfig: function() { return /* binding */ normalizeConfig; },\n/* harmony export */   selectionSetMatchesResult: function() { return /* binding */ selectionSetMatchesResult; },\n/* harmony export */   shouldCanonizeResults: function() { return /* binding */ shouldCanonizeResults; },\n/* harmony export */   storeValueIsStoreObject: function() { return /* binding */ storeValueIsStoreObject; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction isNullish(value) {\n    return value === null || value === void 0;\n}\n\nfunction defaultDataIdFromObject(_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject = !isNullish(id) ? {\n                id: id\n            } : !isNullish(_id) ? {\n                _id: _id\n            } : void 0;\n        }\n        // If there is no object.id, fall back to object._id.\n        if (isNullish(id) && !isNullish(_id)) {\n            id = _id;\n        }\n        if (!isNullish(id)) {\n            return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n        }\n    }\n}\nvar defaultConfig = {\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    // Thanks to the shouldCanonizeResults helper, this should be the only line\n    // you have to change to reenable canonization by default in the future.\n    canonizeResults: false\n};\nfunction normalizeConfig(config) {\n    return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.compact)(defaultConfig, config);\n}\nfunction shouldCanonizeResults(config) {\n    var value = config.canonizeResults;\n    return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nfunction getTypenameFromStoreObject(store, objectOrReference) {\n    return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isReference)(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nvar TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nfunction fieldNameFromStoreName(storeFieldName) {\n    var match = storeFieldName.match(TypeOrFieldNameRegExp);\n    return match ? match[0] : storeFieldName;\n}\nfunction selectionSetMatchesResult(selectionSet, result, variables) {\n    if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.isNonNullObject)(result)) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(result) ? result.every(function(item) {\n            return selectionSetMatchesResult(selectionSet, item, variables);\n        }) : selectionSet.selections.every(function(field) {\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isField)(field) && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.shouldInclude)(field, variables)) {\n                var key = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.resultKeyNameFromField)(field);\n                return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n            }\n            // If the selection has been skipped with @skip(true) or\n            // @include(false), it should not count against the matching. If\n            // the selection is not a field, it must be a fragment (inline or\n            // named). We will determine if selectionSetMatchesResult for that\n            // fragment when we get to it, so for now we return true.\n            return true;\n        });\n    }\n    return false;\n}\nfunction storeValueIsStoreObject(value) {\n    return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.isNonNullObject)(value) && !(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isReference)(value) && !(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(value);\n}\nfunction makeProcessedFieldsMerger() {\n    return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.DeepMerger();\n}\nfunction extractFragmentContext(document, fragments) {\n    // FragmentMap consisting only of fragments defined directly in document, not\n    // including other fragments registered in the FragmentRegistry.\n    var fragmentMap = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.createFragmentMap)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.getFragmentDefinitions)(document));\n    return {\n        fragmentMap: fragmentMap,\n        lookupFragment: function(name) {\n            var def = fragmentMap[name];\n            if (!def && fragments) {\n                def = fragments.lookup(name);\n            }\n            return def || null;\n        }\n    };\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrTTtBQUMzTCxJQUFJVSxTQUFTQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQztBQUM3QyxTQUFTQyxVQUFVQyxLQUFLO0lBQzNCLE9BQU9BLFVBQVUsUUFBUUEsVUFBVSxLQUFLO0FBQzVDO0FBQ21CO0FBQ1osU0FBU0Msd0JBQXdCQyxFQUFFLEVBQUVDLE9BQU87SUFDL0MsSUFBSUMsYUFBYUYsR0FBR0UsVUFBVSxFQUFFQyxLQUFLSCxHQUFHRyxFQUFFLEVBQUVDLE1BQU1KLEdBQUdJLEdBQUc7SUFDeEQsSUFBSSxPQUFPRixlQUFlLFVBQVU7UUFDaEMsSUFBSUQsU0FBUztZQUNUQSxRQUFRSSxTQUFTLEdBQ2IsQ0FBQ1IsVUFBVU0sTUFBTTtnQkFBRUEsSUFBSUE7WUFBRyxJQUNwQixDQUFDTixVQUFVTyxPQUFPO2dCQUFFQSxLQUFLQTtZQUFJLElBQ3pCLEtBQUs7UUFDdkI7UUFDQSxxREFBcUQ7UUFDckQsSUFBSVAsVUFBVU0sT0FBTyxDQUFDTixVQUFVTyxNQUFNO1lBQ2xDRCxLQUFLQztRQUNUO1FBQ0EsSUFBSSxDQUFDUCxVQUFVTSxLQUFLO1lBQ2hCLE9BQU8sR0FBR0csTUFBTSxDQUFDSixZQUFZLEtBQUtJLE1BQU0sQ0FBQyxPQUFPSCxPQUFPLFlBQVksT0FBT0EsT0FBTyxXQUM3RUEsS0FDRUksS0FBS0MsU0FBUyxDQUFDTDtRQUN6QjtJQUNKO0FBQ0o7QUFDQSxJQUFJTSxnQkFBZ0I7SUFDaEJDLGtCQUFrQlg7SUFDbEJZLGFBQWE7SUFDYkMsZUFBZTtJQUNmLDJFQUEyRTtJQUMzRSx3RUFBd0U7SUFDeEVDLGlCQUFpQjtBQUNyQjtBQUNPLFNBQVNDLGdCQUFnQkMsTUFBTTtJQUNsQyxPQUFPMUIsNERBQU9BLENBQUNvQixlQUFlTTtBQUNsQztBQUNPLFNBQVNDLHNCQUFzQkQsTUFBTTtJQUN4QyxJQUFJakIsUUFBUWlCLE9BQU9GLGVBQWU7SUFDbEMsT0FBT2YsVUFBVSxLQUFLLElBQUlXLGNBQWNJLGVBQWUsR0FBR2Y7QUFDOUQ7QUFDTyxTQUFTbUIsMkJBQTJCQyxLQUFLLEVBQUVDLGlCQUFpQjtJQUMvRCxPQUFPcEMsZ0VBQVdBLENBQUNvQyxxQkFDZkQsTUFBTUUsR0FBRyxDQUFDRCxrQkFBa0JFLEtBQUssRUFBRSxnQkFDakNGLHFCQUFxQkEsa0JBQWtCakIsVUFBVTtBQUMzRDtBQUNPLElBQUlvQix3QkFBd0IscUJBQXFCO0FBQ2pELFNBQVNDLHVCQUF1QkMsY0FBYztJQUNqRCxJQUFJQyxRQUFRRCxlQUFlQyxLQUFLLENBQUNIO0lBQ2pDLE9BQU9HLFFBQVFBLEtBQUssQ0FBQyxFQUFFLEdBQUdEO0FBQzlCO0FBQ08sU0FBU0UsMEJBQTBCQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsU0FBUztJQUNyRSxJQUFJekMsb0VBQWVBLENBQUN3QyxTQUFTO1FBQ3pCLE9BQU9wQyw0REFBT0EsQ0FBQ29DLFVBQ1hBLE9BQU9FLEtBQUssQ0FBQyxTQUFVQyxJQUFJO1lBQ3ZCLE9BQU9MLDBCQUEwQkMsY0FBY0ksTUFBTUY7UUFDekQsS0FDRUYsYUFBYUssVUFBVSxDQUFDRixLQUFLLENBQUMsU0FBVUcsS0FBSztZQUMzQyxJQUFJakQsNERBQU9BLENBQUNpRCxVQUFVOUMsa0VBQWFBLENBQUM4QyxPQUFPSixZQUFZO2dCQUNuRCxJQUFJSyxNQUFNaEQsMkVBQXNCQSxDQUFDK0M7Z0JBQ2pDLE9BQVF4QyxPQUFPMEMsSUFBSSxDQUFDUCxRQUFRTSxRQUN2QixFQUFDRCxNQUFNTixZQUFZLElBQ2hCRCwwQkFBMEJPLE1BQU1OLFlBQVksRUFBRUMsTUFBTSxDQUFDTSxJQUFJLEVBQUVMLFVBQVM7WUFDaEY7WUFDQSx3REFBd0Q7WUFDeEQsZ0VBQWdFO1lBQ2hFLGlFQUFpRTtZQUNqRSxrRUFBa0U7WUFDbEUseURBQXlEO1lBQ3pELE9BQU87UUFDWDtJQUNSO0lBQ0EsT0FBTztBQUNYO0FBQ08sU0FBU08sd0JBQXdCdEMsS0FBSztJQUN6QyxPQUFPVixvRUFBZUEsQ0FBQ1UsVUFBVSxDQUFDZixnRUFBV0EsQ0FBQ2UsVUFBVSxDQUFDTiw0REFBT0EsQ0FBQ007QUFDckU7QUFDTyxTQUFTdUM7SUFDWixPQUFPLElBQUlwRCwyREFBVUE7QUFDekI7QUFDTyxTQUFTcUQsdUJBQXVCQyxRQUFRLEVBQUVDLFNBQVM7SUFDdEQsNkVBQTZFO0lBQzdFLGdFQUFnRTtJQUNoRSxJQUFJQyxjQUFjbkQsc0VBQWlCQSxDQUFDQywyRUFBc0JBLENBQUNnRDtJQUMzRCxPQUFPO1FBQ0hFLGFBQWFBO1FBQ2JDLGdCQUFnQixTQUFVQyxJQUFJO1lBQzFCLElBQUlDLE1BQU1ILFdBQVcsQ0FBQ0UsS0FBSztZQUMzQixJQUFJLENBQUNDLE9BQU9KLFdBQVc7Z0JBQ25CSSxNQUFNSixVQUFVSyxNQUFNLENBQUNGO1lBQzNCO1lBQ0EsT0FBT0MsT0FBTztRQUNsQjtJQUNKO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2NhY2hlL2lubWVtb3J5L2hlbHBlcnMuanM/MTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1JlZmVyZW5jZSwgaXNGaWVsZCwgRGVlcE1lcmdlciwgcmVzdWx0S2V5TmFtZUZyb21GaWVsZCwgc2hvdWxkSW5jbHVkZSwgaXNOb25OdWxsT2JqZWN0LCBjb21wYWN0LCBjcmVhdGVGcmFnbWVudE1hcCwgZ2V0RnJhZ21lbnREZWZpbml0aW9ucywgaXNBcnJheSwgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5leHBvcnQgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDA7XG59XG5leHBvcnQgeyBpc0FycmF5IH07XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdERhdGFJZEZyb21PYmplY3QoX2EsIGNvbnRleHQpIHtcbiAgICB2YXIgX190eXBlbmFtZSA9IF9hLl9fdHlwZW5hbWUsIGlkID0gX2EuaWQsIF9pZCA9IF9hLl9pZDtcbiAgICBpZiAodHlwZW9mIF9fdHlwZW5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQua2V5T2JqZWN0ID1cbiAgICAgICAgICAgICAgICAhaXNOdWxsaXNoKGlkKSA/IHsgaWQ6IGlkIH1cbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOdWxsaXNoKF9pZCkgPyB7IF9pZDogX2lkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9iamVjdC5pZCwgZmFsbCBiYWNrIHRvIG9iamVjdC5faWQuXG4gICAgICAgIGlmIChpc051bGxpc2goaWQpICYmICFpc051bGxpc2goX2lkKSkge1xuICAgICAgICAgICAgaWQgPSBfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bGxpc2goaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoX190eXBlbmFtZSwgXCI6XCIpLmNvbmNhdCh0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGlkID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGRhdGFJZEZyb21PYmplY3Q6IGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0LFxuICAgIGFkZFR5cGVuYW1lOiB0cnVlLFxuICAgIHJlc3VsdENhY2hpbmc6IHRydWUsXG4gICAgLy8gVGhhbmtzIHRvIHRoZSBzaG91bGRDYW5vbml6ZVJlc3VsdHMgaGVscGVyLCB0aGlzIHNob3VsZCBiZSB0aGUgb25seSBsaW5lXG4gICAgLy8geW91IGhhdmUgdG8gY2hhbmdlIHRvIHJlZW5hYmxlIGNhbm9uaXphdGlvbiBieSBkZWZhdWx0IGluIHRoZSBmdXR1cmUuXG4gICAgY2Fub25pemVSZXN1bHRzOiBmYWxzZSxcbn07XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBjb21wYWN0KGRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQ2Fub25pemVSZXN1bHRzKGNvbmZpZykge1xuICAgIHZhciB2YWx1ZSA9IGNvbmZpZy5jYW5vbml6ZVJlc3VsdHM7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBkZWZhdWx0Q29uZmlnLmNhbm9uaXplUmVzdWx0cyA6IHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVuYW1lRnJvbVN0b3JlT2JqZWN0KHN0b3JlLCBvYmplY3RPclJlZmVyZW5jZSkge1xuICAgIHJldHVybiBpc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSkgP1xuICAgICAgICBzdG9yZS5nZXQob2JqZWN0T3JSZWZlcmVuY2UuX19yZWYsIFwiX190eXBlbmFtZVwiKVxuICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlICYmIG9iamVjdE9yUmVmZXJlbmNlLl9fdHlwZW5hbWU7XG59XG5leHBvcnQgdmFyIFR5cGVPckZpZWxkTmFtZVJlZ0V4cCA9IC9eW19hLXpdW18wLTlhLXpdKi9pO1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBzdG9yZUZpZWxkTmFtZS5tYXRjaChUeXBlT3JGaWVsZE5hbWVSZWdFeHApO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogc3RvcmVGaWVsZE5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdChzZWxlY3Rpb25TZXQsIHJlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGlzTm9uTnVsbE9iamVjdChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHJlc3VsdCkgP1xuICAgICAgICAgICAgcmVzdWx0LmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQoc2VsZWN0aW9uU2V0LCBpdGVtLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGQoZmllbGQpICYmIHNob3VsZEluY2x1ZGUoZmllbGQsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGhhc093bi5jYWxsKHJlc3VsdCwga2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmaWVsZC5zZWxlY3Rpb25TZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXRNYXRjaGVzUmVzdWx0KGZpZWxkLnNlbGVjdGlvblNldCwgcmVzdWx0W2tleV0sIHZhcmlhYmxlcykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBoYXMgYmVlbiBza2lwcGVkIHdpdGggQHNraXAodHJ1ZSkgb3JcbiAgICAgICAgICAgICAgICAvLyBAaW5jbHVkZShmYWxzZSksIGl0IHNob3VsZCBub3QgY291bnQgYWdhaW5zdCB0aGUgbWF0Y2hpbmcuIElmXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGlvbiBpcyBub3QgYSBmaWVsZCwgaXQgbXVzdCBiZSBhIGZyYWdtZW50IChpbmxpbmUgb3JcbiAgICAgICAgICAgICAgICAvLyBuYW1lZCkuIFdlIHdpbGwgZGV0ZXJtaW5lIGlmIHNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQgZm9yIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCB3aGVuIHdlIGdldCB0byBpdCwgc28gZm9yIG5vdyB3ZSByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RvcmVWYWx1ZUlzU3RvcmVPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJiAhaXNSZWZlcmVuY2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCkge1xuICAgIHJldHVybiBuZXcgRGVlcE1lcmdlcigpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudENvbnRleHQoZG9jdW1lbnQsIGZyYWdtZW50cykge1xuICAgIC8vIEZyYWdtZW50TWFwIGNvbnNpc3Rpbmcgb25seSBvZiBmcmFnbWVudHMgZGVmaW5lZCBkaXJlY3RseSBpbiBkb2N1bWVudCwgbm90XG4gICAgLy8gaW5jbHVkaW5nIG90aGVyIGZyYWdtZW50cyByZWdpc3RlcmVkIGluIHRoZSBGcmFnbWVudFJlZ2lzdHJ5LlxuICAgIHZhciBmcmFnbWVudE1hcCA9IGNyZWF0ZUZyYWdtZW50TWFwKGdldEZyYWdtZW50RGVmaW5pdGlvbnMoZG9jdW1lbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFnbWVudE1hcDogZnJhZ21lbnRNYXAsXG4gICAgICAgIGxvb2t1cEZyYWdtZW50OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGZyYWdtZW50TWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFkZWYgJiYgZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gZnJhZ21lbnRzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWYgfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiaXNSZWZlcmVuY2UiLCJpc0ZpZWxkIiwiRGVlcE1lcmdlciIsInJlc3VsdEtleU5hbWVGcm9tRmllbGQiLCJzaG91bGRJbmNsdWRlIiwiaXNOb25OdWxsT2JqZWN0IiwiY29tcGFjdCIsImNyZWF0ZUZyYWdtZW50TWFwIiwiZ2V0RnJhZ21lbnREZWZpbml0aW9ucyIsImlzQXJyYXkiLCJoYXNPd24iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzTnVsbGlzaCIsInZhbHVlIiwiZGVmYXVsdERhdGFJZEZyb21PYmplY3QiLCJfYSIsImNvbnRleHQiLCJfX3R5cGVuYW1lIiwiaWQiLCJfaWQiLCJrZXlPYmplY3QiLCJjb25jYXQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVmYXVsdENvbmZpZyIsImRhdGFJZEZyb21PYmplY3QiLCJhZGRUeXBlbmFtZSIsInJlc3VsdENhY2hpbmciLCJjYW5vbml6ZVJlc3VsdHMiLCJub3JtYWxpemVDb25maWciLCJjb25maWciLCJzaG91bGRDYW5vbml6ZVJlc3VsdHMiLCJnZXRUeXBlbmFtZUZyb21TdG9yZU9iamVjdCIsInN0b3JlIiwib2JqZWN0T3JSZWZlcmVuY2UiLCJnZXQiLCJfX3JlZiIsIlR5cGVPckZpZWxkTmFtZVJlZ0V4cCIsImZpZWxkTmFtZUZyb21TdG9yZU5hbWUiLCJzdG9yZUZpZWxkTmFtZSIsIm1hdGNoIiwic2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdCIsInNlbGVjdGlvblNldCIsInJlc3VsdCIsInZhcmlhYmxlcyIsImV2ZXJ5IiwiaXRlbSIsInNlbGVjdGlvbnMiLCJmaWVsZCIsImtleSIsImNhbGwiLCJzdG9yZVZhbHVlSXNTdG9yZU9iamVjdCIsIm1ha2VQcm9jZXNzZWRGaWVsZHNNZXJnZXIiLCJleHRyYWN0RnJhZ21lbnRDb250ZXh0IiwiZG9jdW1lbnQiLCJmcmFnbWVudHMiLCJmcmFnbWVudE1hcCIsImxvb2t1cEZyYWdtZW50IiwibmFtZSIsImRlZiIsImxvb2t1cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/inMemoryCache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/inMemoryCache.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InMemoryCache: function() { return /* binding */ InMemoryCache; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _core_cache_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../core/cache.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/core/cache.js\");\n/* harmony import */ var _core_types_common_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/types/common.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/core/types/common.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/DocumentTransform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/print.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _readFromStore_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./readFromStore.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/readFromStore.js\");\n/* harmony import */ var _writeToStore_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./writeToStore.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/writeToStore.js\");\n/* harmony import */ var _entityStore_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./entityStore.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/entityStore.js\");\n/* harmony import */ var _reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reactiveVars.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/reactiveVars.js\");\n/* harmony import */ var _policies_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./policies.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/policies.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n/* harmony import */ var _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar InMemoryCache = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) {\n            config = {};\n        }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.addTypenameTransform = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.DocumentTransform(_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.addTypenameToDocument);\n        // Override the default value, since InMemoryCache result objects are frozen\n        // in development and expected to remain logically immutable in production.\n        _this.assumeImmutableResults = true;\n        _this.makeVar = _reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__.makeVar;\n        _this.txCount = 0;\n        _this.config = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_7__.normalizeConfig)(config);\n        _this.addTypename = !!_this.config.addTypename;\n        _this.policies = new _policies_js__WEBPACK_IMPORTED_MODULE_8__.Policies({\n            cache: _this,\n            dataIdFromObject: _this.config.dataIdFromObject,\n            possibleTypes: _this.config.possibleTypes,\n            typePolicies: _this.config.typePolicies\n        });\n        _this.init();\n        return _this;\n    }\n    InMemoryCache.prototype.init = function() {\n        // Passing { resultCaching: false } in the InMemoryCache constructor options\n        // will completely disable dependency tracking, which will improve memory\n        // usage but worsen the performance of repeated reads.\n        var rootStore = this.data = new _entityStore_js__WEBPACK_IMPORTED_MODULE_9__.EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching\n        });\n        // When no optimistic writes are currently active, cache.optimisticData ===\n        // cache.data, so there are no additional layers on top of the actual data.\n        // When an optimistic update happens, this.optimisticData will become a\n        // linked list of EntityStore Layer objects that terminates with the\n        // original this.data cache object.\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    };\n    InMemoryCache.prototype.resetResultCache = function(resetResultIdentities) {\n        var _this = this;\n        var previousReader = this.storeReader;\n        var fragments = this.config.fragments;\n        // The StoreWriter is mostly stateless and so doesn't really need to be\n        // reset, but it does need to have its writer.storeReader reference updated,\n        // so it's simpler to update this.storeWriter as well.\n        this.storeWriter = new _writeToStore_js__WEBPACK_IMPORTED_MODULE_10__.StoreWriter(this, this.storeReader = new _readFromStore_js__WEBPACK_IMPORTED_MODULE_11__.StoreReader({\n            cache: this,\n            addTypename: this.addTypename,\n            resultCacheMaxSize: this.config.resultCacheMaxSize,\n            canonizeResults: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_7__.shouldCanonizeResults)(this.config),\n            canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,\n            fragments: fragments\n        }), fragments);\n        this.maybeBroadcastWatch = (0,optimism__WEBPACK_IMPORTED_MODULE_1__.wrap)(function(c, options) {\n            return _this.broadcastWatch(c, options);\n        }, {\n            max: this.config.resultCacheMaxSize || _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__.cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] || 5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */ ,\n            makeCacheKey: function(c) {\n                // Return a cache key (thus enabling result caching) only if we're\n                // currently using a data store that can track cache dependencies.\n                var store = c.optimistic ? _this.optimisticData : _this.data;\n                if ((0,_entityStore_js__WEBPACK_IMPORTED_MODULE_9__.supportsResultCaching)(store)) {\n                    var optimistic = c.optimistic, id = c.id, variables = c.variables;\n                    return store.makeCacheKey(c.query, // Different watches can have the same query, optimistic\n                    // status, rootId, and variables, but if their callbacks are\n                    // different, the (identical) result needs to be delivered to\n                    // each distinct callback. The easiest way to achieve that\n                    // separation is to include c.callback in the cache key for\n                    // maybeBroadcastWatch calls. See issue #5733.\n                    c.callback, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.canonicalStringify)({\n                        optimistic: optimistic,\n                        id: id,\n                        variables: variables\n                    }));\n                }\n            }\n        });\n        // Since we have thrown away all the cached functions that depend on the\n        // CacheGroup dependencies maintained by EntityStore, we should also reset\n        // all CacheGroup dependency information.\n        new Set([\n            this.data.group,\n            this.optimisticData.group\n        ]).forEach(function(group) {\n            return group.resetCaching();\n        });\n    };\n    InMemoryCache.prototype.restore = function(data) {\n        this.init();\n        // Since calling this.init() discards/replaces the entire StoreReader, along\n        // with the result caches it maintains, this.data.replace(data) won't have\n        // to bother deleting the old data.\n        if (data) this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function(optimistic) {\n        if (optimistic === void 0) {\n            optimistic = false;\n        }\n        return (optimistic ? this.optimisticData : this.data).extract();\n    };\n    InMemoryCache.prototype.read = function(options) {\n        var // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        _a = options.returnPartialData, // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        returnPartialData = _a === void 0 ? false : _a;\n        try {\n            return this.storeReader.diffQueryAgainstStore((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n                store: options.optimistic ? this.optimisticData : this.data,\n                config: this.config,\n                returnPartialData: returnPartialData\n            })).result || null;\n        } catch (e) {\n            if (e instanceof _core_types_common_js__WEBPACK_IMPORTED_MODULE_14__.MissingFieldError) {\n                // Swallow MissingFieldError and return null, so callers do not need to\n                // worry about catching \"normal\" exceptions resulting from incomplete\n                // cache data. Unexpected errors will be re-thrown. If you need more\n                // information about which fields were missing, use cache.diff instead,\n                // and examine diffResult.missing.\n                return null;\n            }\n            throw e;\n        }\n    };\n    InMemoryCache.prototype.write = function(options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        } finally{\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.modify = function(options) {\n        if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(options, \"id\") && !options.id) {\n            // To my knowledge, TypeScript does not currently provide a way to\n            // enforce that an optional property?:type must *not* be undefined\n            // when present. That ability would be useful here, because we want\n            // options.id to default to ROOT_QUERY only when no options.id was\n            // provided. If the caller attempts to pass options.id with a\n            // falsy/undefined value (perhaps because cache.identify failed), we\n            // should not assume the goal was to modify the ROOT_QUERY object.\n            // We could throw, but it seems natural to return false to indicate\n            // that nothing was modified.\n            return false;\n        }\n        var store = options.optimistic // Defaults to false.\n         ? this.optimisticData : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n        } finally{\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.diff = function(options) {\n        return this.storeReader.diffQueryAgainstStore((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n            store: options.optimistic ? this.optimisticData : this.data,\n            rootId: options.id || \"ROOT_QUERY\",\n            config: this.config\n        }));\n    };\n    InMemoryCache.prototype.watch = function(watch) {\n        var _this = this;\n        if (!this.watches.size) {\n            // In case we previously called forgetCache(this) because\n            // this.watches became empty (see below), reattach this cache to any\n            // reactive variables on which it previously depended. It might seem\n            // paradoxical that we're able to recall something we supposedly\n            // forgot, but the point of calling forgetCache(this) is to silence\n            // useless broadcasts while this.watches is empty, and to allow the\n            // cache to be garbage collected. If, however, we manage to call\n            // recallCache(this) here, this cache object must not have been\n            // garbage collected yet, and should resume receiving updates from\n            // reactive variables, now that it has a watcher to notify.\n            (0,_reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__.recallCache)(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return function() {\n            // Once we remove the last watch from this.watches, cache.broadcastWatches\n            // no longer does anything, so we preemptively tell the reactive variable\n            // system to exclude this cache from future broadcasts.\n            if (_this.watches.delete(watch) && !_this.watches.size) {\n                (0,_reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__.forgetCache)(_this);\n            }\n            // Remove this watch from the LRU cache managed by the\n            // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n            // leaks involving the closure of watch.callback.\n            _this.maybeBroadcastWatch.forget(watch);\n        };\n    };\n    InMemoryCache.prototype.gc = function(options) {\n        var _a;\n        _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.canonicalStringify.reset();\n        _utilities_index_js__WEBPACK_IMPORTED_MODULE_15__.print.reset();\n        this.addTypenameTransform.resetCache();\n        (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n        var ids = this.optimisticData.gc();\n        if (options && !this.txCount) {\n            if (options.resetResultCache) {\n                this.resetResultCache(options.resetResultIdentities);\n            } else if (options.resetResultIdentities) {\n                this.storeReader.resetCanon();\n            }\n        }\n        return ids;\n    };\n    // Call this method to ensure the given root ID remains in the cache after\n    // garbage collection, along with its transitive child entities. Note that\n    // the cache automatically retains all directly written entities. By default,\n    // the retainment persists after optimistic updates are removed. Pass true\n    // for the optimistic argument if you would prefer for the retainment to be\n    // discarded when the top-most optimistic layer is removed. Returns the\n    // resulting (non-negative) retainment count.\n    InMemoryCache.prototype.retain = function(rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    };\n    // Call this method to undo the effect of the retain method, above. Once the\n    // retainment count falls to zero, the given ID will no longer be preserved\n    // during garbage collection, though it may still be preserved by other safe\n    // entities that refer to it. Returns the resulting (non-negative) retainment\n    // count, in case that's useful.\n    InMemoryCache.prototype.release = function(rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    };\n    // Returns the canonical ID for a given StoreObject, obeying typePolicies\n    // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n    // the object must contain a __typename and any primary key fields required\n    // to identify entities of that type. If you pass a query result object, be\n    // sure that none of the primary key fields have been renamed by aliasing.\n    // If you pass a Reference object, its __ref ID string will be returned.\n    InMemoryCache.prototype.identify = function(object) {\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_16__.isReference)(object)) return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        } catch (e) {\n            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(e);\n        }\n    };\n    InMemoryCache.prototype.evict = function(options) {\n        if (!options.id) {\n            if (_helpers_js__WEBPACK_IMPORTED_MODULE_7__.hasOwn.call(options, \"id\")) {\n                // See comment in modify method about why we return false when\n                // options.id exists but is falsy/undefined.\n                return false;\n            }\n            options = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n                id: \"ROOT_QUERY\"\n            });\n        }\n        try {\n            // It's unlikely that the eviction will end up invoking any other\n            // cache update operations while it's running, but {in,de}crementing\n            // this.txCount still seems like a good idea, for uniformity with\n            // the other update methods.\n            ++this.txCount;\n            // Pass this.data as a limit on the depth of the eviction, so evictions\n            // during optimistic updates (when this.data is temporarily set equal to\n            // this.optimisticData) do not escape their optimistic Layer.\n            return this.optimisticData.evict(options, this.data);\n        } finally{\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.reset = function(options) {\n        var _this = this;\n        this.init();\n        _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            // Similar to what happens in the unsubscribe function returned by\n            // cache.watch, applied to all current watches.\n            this.watches.forEach(function(watch) {\n                return _this.maybeBroadcastWatch.forget(watch);\n            });\n            this.watches.clear();\n            (0,_reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__.forgetCache)(this);\n        } else {\n            // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n            // this.broadcastWatches() triggers a broadcast to every current watcher\n            // (letting them know their data is now missing). This default behavior is\n            // convenient because it means the watches do not have to be manually\n            // reestablished after resetting the cache. To prevent this broadcast and\n            // cancel all watches, pass true for options.discardWatches.\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function(idToRemove) {\n        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.batch = function(options) {\n        var _this = this;\n        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;\n        var updateResult;\n        var perform = function(layer) {\n            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;\n            ++_this.txCount;\n            if (layer) {\n                _this.data = _this.optimisticData = layer;\n            }\n            try {\n                return updateResult = update(_this);\n            } finally{\n                --_this.txCount;\n                _this.data = data;\n                _this.optimisticData = optimisticData;\n            }\n        };\n        var alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            // If an options.onWatchUpdated callback is provided, we want to call it\n            // with only the Cache.WatchOptions objects affected by options.update,\n            // but there might be dirty watchers already waiting to be broadcast that\n            // have nothing to do with the update. To prevent including those watchers\n            // in the post-update broadcast, we perform this initial broadcast to\n            // collect the dirty watchers, so we can re-dirty them later, after the\n            // post-update broadcast, allowing them to receive their pending\n            // broadcasts the next time broadcastWatches is called, just as they would\n            // if we never called cache.batch.\n            this.broadcastWatches((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n                onWatchUpdated: function(watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                }\n            }));\n        }\n        if (typeof optimistic === \"string\") {\n            // Note that there can be multiple layers with the same optimistic ID.\n            // When removeOptimistic(id) is called for that id, all matching layers\n            // will be removed, and the remaining layers will be reapplied.\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        } else if (optimistic === false) {\n            // Ensure both this.data and this.optimisticData refer to the root\n            // (non-optimistic) layer of the cache during the update. Note that\n            // this.data could be a Layer if we are currently executing an optimistic\n            // update function, but otherwise will always be an EntityStore.Root\n            // instance.\n            perform(this.data);\n        } else {\n            // Otherwise, leave this.data and this.optimisticData unchanged and run\n            // the update with broadcast batching.\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n        // takes the else branch and calls this.broadcastWatches(options), which\n        // does nothing when this.txCount > 0.\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n                onWatchUpdated: function(watch, diff) {\n                    var result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        // Since onWatchUpdated did not return false, this diff is\n                        // about to be broadcast to watch.callback, so we don't need\n                        // to re-dirty it with the other alreadyDirty watches below.\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                }\n            }));\n            // Silently re-dirty any watches that were already dirty before the update\n            // was performed, and were not broadcast just now.\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach(function(watch) {\n                    return _this.maybeBroadcastWatch.dirty(watch);\n                });\n            }\n        } else {\n            // If alreadyDirty is empty or we don't have an onWatchUpdated\n            // function, we don't need to go to the trouble of wrapping\n            // options.onWatchUpdated.\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    };\n    InMemoryCache.prototype.performTransaction = function(update, optimisticId) {\n        return this.batch({\n            update: update,\n            optimistic: optimisticId || optimisticId !== null\n        });\n    };\n    InMemoryCache.prototype.transformDocument = function(document) {\n        return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n    };\n    InMemoryCache.prototype.broadcastWatches = function(options) {\n        var _this = this;\n        if (!this.txCount) {\n            this.watches.forEach(function(c) {\n                return _this.maybeBroadcastWatch(c, options);\n            });\n        }\n    };\n    InMemoryCache.prototype.addFragmentsToDocument = function(document) {\n        var fragments = this.config.fragments;\n        return fragments ? fragments.transform(document) : document;\n    };\n    InMemoryCache.prototype.addTypenameToDocument = function(document) {\n        if (this.addTypename) {\n            return this.addTypenameTransform.transformDocument(document);\n        }\n        return document;\n    };\n    // This method is wrapped by maybeBroadcastWatch, which is called by\n    // broadcastWatches, so that we compute and broadcast results only when\n    // the data that would be broadcast might have changed. It would be\n    // simpler to check for changes after recomputing a result but before\n    // broadcasting it, but this wrapping approach allows us to skip both\n    // the recomputation and the broadcast, in most cases.\n    InMemoryCache.prototype.broadcastWatch = function(c, options) {\n        var lastDiff = c.lastDiff;\n        // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n        // currently requires no additional properties, so we can use c (a\n        // WatchOptions object) as DiffOptions, without having to allocate a new\n        // object, and without having to enumerate the relevant properties (query,\n        // variables, etc.) explicitly. There will be some additional properties\n        // (lastDiff, callback, etc.), but cache.diff ignores them.\n        var diff = this.diff(c);\n        if (options) {\n            if (c.optimistic && typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                // Returning false from the onWatchUpdated callback will prevent\n                // calling c.callback(diff) for this watcher.\n                return;\n            }\n        }\n        if (!lastDiff || !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(lastDiff.result, diff.result)) {\n            c.callback(c.lastDiff = diff, lastDiff);\n        }\n    };\n    return InMemoryCache;\n}(_core_cache_js__WEBPACK_IMPORTED_MODULE_17__.ApolloCache);\n\nif (globalThis.__DEV__ !== false) {\n    InMemoryCache.prototype.getMemoryInternals = _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_18__.getInMemoryCacheMemoryInternals;\n} //# sourceMappingURL=inMemoryCache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9pbk1lbW9yeUNhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ2lCO0FBQzdELDBFQUEwRTtBQUMvQztBQUNLO0FBQ007QUFDUztBQUNhO0FBQzZFO0FBQ3hGO0FBQ0Q7QUFDc0I7QUFDQTtBQUM3QjtBQUNxQztBQUNrQjtBQUNoRyxJQUFJeUIsZ0JBQWdCLFdBQVcsR0FBSSxTQUFVQyxNQUFNO0lBQy9DekIsZ0RBQVNBLENBQUN3QixlQUFlQztJQUN6QixTQUFTRCxjQUFjRSxNQUFNO1FBQ3pCLElBQUlBLFdBQVcsS0FBSyxHQUFHO1lBQUVBLFNBQVMsQ0FBQztRQUFHO1FBQ3RDLElBQUlDLFFBQVFGLE9BQU9HLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSTtRQUNyQ0QsTUFBTUUsT0FBTyxHQUFHLElBQUlDO1FBQ3BCSCxNQUFNSSxvQkFBb0IsR0FBRyxJQUFJdkIsa0VBQWlCQSxDQUFDRixzRUFBcUJBO1FBQ3hFLDRFQUE0RTtRQUM1RSwyRUFBMkU7UUFDM0VxQixNQUFNSyxzQkFBc0IsR0FBRztRQUMvQkwsTUFBTVgsT0FBTyxHQUFHQSxxREFBT0E7UUFDdkJXLE1BQU1NLE9BQU8sR0FBRztRQUNoQk4sTUFBTUQsTUFBTSxHQUFHTCw0REFBZUEsQ0FBQ0s7UUFDL0JDLE1BQU1PLFdBQVcsR0FBRyxDQUFDLENBQUNQLE1BQU1ELE1BQU0sQ0FBQ1EsV0FBVztRQUM5Q1AsTUFBTVEsUUFBUSxHQUFHLElBQUloQixrREFBUUEsQ0FBQztZQUMxQmlCLE9BQU9UO1lBQ1BVLGtCQUFrQlYsTUFBTUQsTUFBTSxDQUFDVyxnQkFBZ0I7WUFDL0NDLGVBQWVYLE1BQU1ELE1BQU0sQ0FBQ1ksYUFBYTtZQUN6Q0MsY0FBY1osTUFBTUQsTUFBTSxDQUFDYSxZQUFZO1FBQzNDO1FBQ0FaLE1BQU1hLElBQUk7UUFDVixP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O1FBQ3hFLGtFQUFrRTtRQUNsRSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSwyREFBMkQ7UUFDM0QsSUFBSTlDLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUM3QjtRQUNyQixJQUFJQyxTQUFTO1lBQ1QsSUFBSUQsRUFBRU0sVUFBVSxJQUFJLE9BQU9MLFFBQVFLLFVBQVUsS0FBSyxVQUFVO2dCQUN4RHVCLEtBQUsrQyx5QkFBeUIsR0FBRztZQUNyQztZQUNBLElBQUkzRSxRQUFRNkQsY0FBYyxJQUN0QjdELFFBQVE2RCxjQUFjLENBQUM1RixJQUFJLENBQUMsSUFBSSxFQUFFOEIsR0FBRzZCLE1BQU04QyxjQUFjLE9BQU87Z0JBQ2hFLGdFQUFnRTtnQkFDaEUsNkNBQTZDO2dCQUM3QztZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNBLFlBQVksQ0FBQ2xJLG9EQUFLQSxDQUFDa0ksU0FBU3RELE1BQU0sRUFBRVEsS0FBS1IsTUFBTSxHQUFHO1lBQ25EckIsRUFBRVUsUUFBUSxDQUFFVixFQUFFMkUsUUFBUSxHQUFHOUMsTUFBTzhDO1FBQ3BDO0lBQ0o7SUFDQSxPQUFPN0c7QUFDWCxFQUFFcEIsd0RBQVdBO0FBQ1k7QUFDekIsSUFBSXNHLFdBQVdDLE9BQU8sS0FBSyxPQUFPO0lBQzlCbkYsY0FBY2lCLFNBQVMsQ0FBQzhGLGtCQUFrQixHQUFHaEgsc0dBQStCQTtBQUNoRixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkvaW5NZW1vcnlDYWNoZS5qcz8wNDM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuLy8gTWFrZSBidWlsdGlucyBsaWtlIE1hcCBhbmQgU2V0IHNhZmUgdG8gdXNlIHdpdGggbm9uLWV4dGVuc2libGUgb2JqZWN0cy5cbmltcG9ydCBcIi4vZml4UG9seWZpbGxzLmpzXCI7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSBcIm9wdGltaXNtXCI7XG5pbXBvcnQgeyBlcXVhbCB9IGZyb20gXCJAd3J5L2VxdWFsaXR5XCI7XG5pbXBvcnQgeyBBcG9sbG9DYWNoZSB9IGZyb20gXCIuLi9jb3JlL2NhY2hlLmpzXCI7XG5pbXBvcnQgeyBNaXNzaW5nRmllbGRFcnJvciB9IGZyb20gXCIuLi9jb3JlL3R5cGVzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgYWRkVHlwZW5hbWVUb0RvY3VtZW50LCBpc1JlZmVyZW5jZSwgRG9jdW1lbnRUcmFuc2Zvcm0sIGNhbm9uaWNhbFN0cmluZ2lmeSwgcHJpbnQsIGNhY2hlU2l6ZXMsIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU3RvcmVSZWFkZXIgfSBmcm9tIFwiLi9yZWFkRnJvbVN0b3JlLmpzXCI7XG5pbXBvcnQgeyBTdG9yZVdyaXRlciB9IGZyb20gXCIuL3dyaXRlVG9TdG9yZS5qc1wiO1xuaW1wb3J0IHsgRW50aXR5U3RvcmUsIHN1cHBvcnRzUmVzdWx0Q2FjaGluZyB9IGZyb20gXCIuL2VudGl0eVN0b3JlLmpzXCI7XG5pbXBvcnQgeyBtYWtlVmFyLCBmb3JnZXRDYWNoZSwgcmVjYWxsQ2FjaGUgfSBmcm9tIFwiLi9yZWFjdGl2ZVZhcnMuanNcIjtcbmltcG9ydCB7IFBvbGljaWVzIH0gZnJvbSBcIi4vcG9saWNpZXMuanNcIjtcbmltcG9ydCB7IGhhc093biwgbm9ybWFsaXplQ29uZmlnLCBzaG91bGRDYW5vbml6ZVJlc3VsdHMgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBnZXRJbk1lbW9yeUNhY2hlTWVtb3J5SW50ZXJuYWxzIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9jYWNoaW5nL2dldE1lbW9yeUludGVybmFscy5qc1wiO1xudmFyIEluTWVtb3J5Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluTWVtb3J5Q2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlDYWNoZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndhdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLmFkZFR5cGVuYW1lVHJhbnNmb3JtID0gbmV3IERvY3VtZW50VHJhbnNmb3JtKGFkZFR5cGVuYW1lVG9Eb2N1bWVudCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbHVlLCBzaW5jZSBJbk1lbW9yeUNhY2hlIHJlc3VsdCBvYmplY3RzIGFyZSBmcm96ZW5cbiAgICAgICAgLy8gaW4gZGV2ZWxvcG1lbnQgYW5kIGV4cGVjdGVkIHRvIHJlbWFpbiBsb2dpY2FsbHkgaW1tdXRhYmxlIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIF90aGlzLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYWtlVmFyID0gbWFrZVZhcjtcbiAgICAgICAgX3RoaXMudHhDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IG5vcm1hbGl6ZUNvbmZpZyhjb25maWcpO1xuICAgICAgICBfdGhpcy5hZGRUeXBlbmFtZSA9ICEhX3RoaXMuY29uZmlnLmFkZFR5cGVuYW1lO1xuICAgICAgICBfdGhpcy5wb2xpY2llcyA9IG5ldyBQb2xpY2llcyh7XG4gICAgICAgICAgICBjYWNoZTogX3RoaXMsXG4gICAgICAgICAgICBkYXRhSWRGcm9tT2JqZWN0OiBfdGhpcy5jb25maWcuZGF0YUlkRnJvbU9iamVjdCxcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXM6IF90aGlzLmNvbmZpZy5wb3NzaWJsZVR5cGVzLFxuICAgICAgICAgICAgdHlwZVBvbGljaWVzOiBfdGhpcy5jb25maWcudHlwZVBvbGljaWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgeyByZXN1bHRDYWNoaW5nOiBmYWxzZSB9IGluIHRoZSBJbk1lbW9yeUNhY2hlIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgICAgLy8gd2lsbCBjb21wbGV0ZWx5IGRpc2FibGUgZGVwZW5kZW5jeSB0cmFja2luZywgd2hpY2ggd2lsbCBpbXByb3ZlIG1lbW9yeVxuICAgICAgICAvLyB1c2FnZSBidXQgd29yc2VuIHRoZSBwZXJmb3JtYW5jZSBvZiByZXBlYXRlZCByZWFkcy5cbiAgICAgICAgdmFyIHJvb3RTdG9yZSA9ICh0aGlzLmRhdGEgPSBuZXcgRW50aXR5U3RvcmUuUm9vdCh7XG4gICAgICAgICAgICBwb2xpY2llczogdGhpcy5wb2xpY2llcyxcbiAgICAgICAgICAgIHJlc3VsdENhY2hpbmc6IHRoaXMuY29uZmlnLnJlc3VsdENhY2hpbmcsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gV2hlbiBubyBvcHRpbWlzdGljIHdyaXRlcyBhcmUgY3VycmVudGx5IGFjdGl2ZSwgY2FjaGUub3B0aW1pc3RpY0RhdGEgPT09XG4gICAgICAgIC8vIGNhY2hlLmRhdGEsIHNvIHRoZXJlIGFyZSBubyBhZGRpdGlvbmFsIGxheWVycyBvbiB0b3Agb2YgdGhlIGFjdHVhbCBkYXRhLlxuICAgICAgICAvLyBXaGVuIGFuIG9wdGltaXN0aWMgdXBkYXRlIGhhcHBlbnMsIHRoaXMub3B0aW1pc3RpY0RhdGEgd2lsbCBiZWNvbWUgYVxuICAgICAgICAvLyBsaW5rZWQgbGlzdCBvZiBFbnRpdHlTdG9yZSBMYXllciBvYmplY3RzIHRoYXQgdGVybWluYXRlcyB3aXRoIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCB0aGlzLmRhdGEgY2FjaGUgb2JqZWN0LlxuICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gcm9vdFN0b3JlLnN0dW1wO1xuICAgICAgICB0aGlzLnJlc2V0UmVzdWx0Q2FjaGUoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc2V0UmVzdWx0Q2FjaGUgPSBmdW5jdGlvbiAocmVzZXRSZXN1bHRJZGVudGl0aWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2aW91c1JlYWRlciA9IHRoaXMuc3RvcmVSZWFkZXI7XG4gICAgICAgIHZhciBmcmFnbWVudHMgPSB0aGlzLmNvbmZpZy5mcmFnbWVudHM7XG4gICAgICAgIC8vIFRoZSBTdG9yZVdyaXRlciBpcyBtb3N0bHkgc3RhdGVsZXNzIGFuZCBzbyBkb2Vzbid0IHJlYWxseSBuZWVkIHRvIGJlXG4gICAgICAgIC8vIHJlc2V0LCBidXQgaXQgZG9lcyBuZWVkIHRvIGhhdmUgaXRzIHdyaXRlci5zdG9yZVJlYWRlciByZWZlcmVuY2UgdXBkYXRlZCxcbiAgICAgICAgLy8gc28gaXQncyBzaW1wbGVyIHRvIHVwZGF0ZSB0aGlzLnN0b3JlV3JpdGVyIGFzIHdlbGwuXG4gICAgICAgIHRoaXMuc3RvcmVXcml0ZXIgPSBuZXcgU3RvcmVXcml0ZXIodGhpcywgKHRoaXMuc3RvcmVSZWFkZXIgPSBuZXcgU3RvcmVSZWFkZXIoe1xuICAgICAgICAgICAgY2FjaGU6IHRoaXMsXG4gICAgICAgICAgICBhZGRUeXBlbmFtZTogdGhpcy5hZGRUeXBlbmFtZSxcbiAgICAgICAgICAgIHJlc3VsdENhY2hlTWF4U2l6ZTogdGhpcy5jb25maWcucmVzdWx0Q2FjaGVNYXhTaXplLFxuICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiBzaG91bGRDYW5vbml6ZVJlc3VsdHModGhpcy5jb25maWcpLFxuICAgICAgICAgICAgY2Fub246IHJlc2V0UmVzdWx0SWRlbnRpdGllcyA/IHZvaWQgMCA6IChwcmV2aW91c1JlYWRlciAmJiBwcmV2aW91c1JlYWRlci5jYW5vbiksXG4gICAgICAgICAgICBmcmFnbWVudHM6IGZyYWdtZW50cyxcbiAgICAgICAgfSkpLCBmcmFnbWVudHMpO1xuICAgICAgICB0aGlzLm1heWJlQnJvYWRjYXN0V2F0Y2ggPSB3cmFwKGZ1bmN0aW9uIChjLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYnJvYWRjYXN0V2F0Y2goYywgb3B0aW9ucyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1heDogdGhpcy5jb25maWcucmVzdWx0Q2FjaGVNYXhTaXplIHx8XG4gICAgICAgICAgICAgICAgY2FjaGVTaXplc1tcImluTWVtb3J5Q2FjaGUubWF5YmVCcm9hZGNhc3RXYXRjaFwiXSB8fFxuICAgICAgICAgICAgICAgIDUwMDAgLyogZGVmYXVsdENhY2hlU2l6ZXNbXCJpbk1lbW9yeUNhY2hlLm1heWJlQnJvYWRjYXN0V2F0Y2hcIl0gKi8sXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgY2FjaGUga2V5ICh0aHVzIGVuYWJsaW5nIHJlc3VsdCBjYWNoaW5nKSBvbmx5IGlmIHdlJ3JlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IHVzaW5nIGEgZGF0YSBzdG9yZSB0aGF0IGNhbiB0cmFjayBjYWNoZSBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gYy5vcHRpbWlzdGljID8gX3RoaXMub3B0aW1pc3RpY0RhdGEgOiBfdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc3VsdENhY2hpbmcoc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpbWlzdGljID0gYy5vcHRpbWlzdGljLCBpZCA9IGMuaWQsIHZhcmlhYmxlcyA9IGMudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUubWFrZUNhY2hlS2V5KGMucXVlcnksIFxuICAgICAgICAgICAgICAgICAgICAvLyBEaWZmZXJlbnQgd2F0Y2hlcyBjYW4gaGF2ZSB0aGUgc2FtZSBxdWVyeSwgb3B0aW1pc3RpY1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGF0dXMsIHJvb3RJZCwgYW5kIHZhcmlhYmxlcywgYnV0IGlmIHRoZWlyIGNhbGxiYWNrcyBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50LCB0aGUgKGlkZW50aWNhbCkgcmVzdWx0IG5lZWRzIHRvIGJlIGRlbGl2ZXJlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBlYWNoIGRpc3RpbmN0IGNhbGxiYWNrLiBUaGUgZWFzaWVzdCB3YXkgdG8gYWNoaWV2ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRpb24gaXMgdG8gaW5jbHVkZSBjLmNhbGxiYWNrIGluIHRoZSBjYWNoZSBrZXkgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG1heWJlQnJvYWRjYXN0V2F0Y2ggY2FsbHMuIFNlZSBpc3N1ZSAjNTczMy5cbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsYmFjaywgY2Fub25pY2FsU3RyaW5naWZ5KHsgb3B0aW1pc3RpYzogb3B0aW1pc3RpYywgaWQ6IGlkLCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgdGhyb3duIGF3YXkgYWxsIHRoZSBjYWNoZWQgZnVuY3Rpb25zIHRoYXQgZGVwZW5kIG9uIHRoZVxuICAgICAgICAvLyBDYWNoZUdyb3VwIGRlcGVuZGVuY2llcyBtYWludGFpbmVkIGJ5IEVudGl0eVN0b3JlLCB3ZSBzaG91bGQgYWxzbyByZXNldFxuICAgICAgICAvLyBhbGwgQ2FjaGVHcm91cCBkZXBlbmRlbmN5IGluZm9ybWF0aW9uLlxuICAgICAgICBuZXcgU2V0KFt0aGlzLmRhdGEuZ3JvdXAsIHRoaXMub3B0aW1pc3RpY0RhdGEuZ3JvdXBdKS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwLnJlc2V0Q2FjaGluZygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgLy8gU2luY2UgY2FsbGluZyB0aGlzLmluaXQoKSBkaXNjYXJkcy9yZXBsYWNlcyB0aGUgZW50aXJlIFN0b3JlUmVhZGVyLCBhbG9uZ1xuICAgICAgICAvLyB3aXRoIHRoZSByZXN1bHQgY2FjaGVzIGl0IG1haW50YWlucywgdGhpcy5kYXRhLnJlcGxhY2UoZGF0YSkgd29uJ3QgaGF2ZVxuICAgICAgICAvLyB0byBib3RoZXIgZGVsZXRpbmcgdGhlIG9sZCBkYXRhLlxuICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgIHRoaXMuZGF0YS5yZXBsYWNlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAob3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gKG9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhKS5leHRyYWN0KCk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIFxuICAgICAgICAvLyBTaW5jZSByZWFkIHJldHVybnMgZGF0YSBvciBudWxsLCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIG1ldGFkYXRhXG4gICAgICAgIC8vIGFib3V0IHdoZXRoZXIvd2hlcmUgdGhlcmUgbWlnaHQgaGF2ZSBiZWVuIG1pc3NpbmcgZmllbGRzLCB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBjYW5ub3QgYmUgcmV0dXJuUGFydGlhbERhdGEgPSB0cnVlIChsaWtlIGl0IGlzXG4gICAgICAgIC8vIGZvciB0aGUgZGlmZiBtZXRob2QpLCBzaW5jZSBkZWZhdWx0aW5nIHRvIHRydWUgd291bGQgdmlvbGF0ZSB0aGVcbiAgICAgICAgLy8gaW50ZWdyaXR5IG9mIHRoZSBUIGluIHRoZSByZXR1cm4gdHlwZS4gSG93ZXZlciwgcGFydGlhbCBkYXRhIG1heVxuICAgICAgICAvLyBiZSB1c2VmdWwgaW4gc29tZSBjYXNlcywgc28gcmV0dXJuUGFydGlhbERhdGE6dHJ1ZSBtYXkgYmVcbiAgICAgICAgLy8gc3BlY2lmaWVkIGV4cGxpY2l0bHkuXG4gICAgICAgIF9hID0gb3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSwgXG4gICAgICAgIC8vIFNpbmNlIHJlYWQgcmV0dXJucyBkYXRhIG9yIG51bGwsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgLy8gYWJvdXQgd2hldGhlci93aGVyZSB0aGVyZSBtaWdodCBoYXZlIGJlZW4gbWlzc2luZyBmaWVsZHMsIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGNhbm5vdCBiZSByZXR1cm5QYXJ0aWFsRGF0YSA9IHRydWUgKGxpa2UgaXQgaXNcbiAgICAgICAgLy8gZm9yIHRoZSBkaWZmIG1ldGhvZCksIHNpbmNlIGRlZmF1bHRpbmcgdG8gdHJ1ZSB3b3VsZCB2aW9sYXRlIHRoZVxuICAgICAgICAvLyBpbnRlZ3JpdHkgb2YgdGhlIFQgaW4gdGhlIHJldHVybiB0eXBlLiBIb3dldmVyLCBwYXJ0aWFsIGRhdGEgbWF5XG4gICAgICAgIC8vIGJlIHVzZWZ1bCBpbiBzb21lIGNhc2VzLCBzbyByZXR1cm5QYXJ0aWFsRGF0YTp0cnVlIG1heSBiZVxuICAgICAgICAvLyBzcGVjaWZpZWQgZXhwbGljaXRseS5cbiAgICAgICAgcmV0dXJuUGFydGlhbERhdGEgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zdG9yZVJlYWRlci5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHN0b3JlOiBvcHRpb25zLm9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhLCBjb25maWc6IHRoaXMuY29uZmlnLCByZXR1cm5QYXJ0aWFsRGF0YTogcmV0dXJuUGFydGlhbERhdGEgfSkpLnJlc3VsdCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNaXNzaW5nRmllbGRFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgTWlzc2luZ0ZpZWxkRXJyb3IgYW5kIHJldHVybiBudWxsLCBzbyBjYWxsZXJzIGRvIG5vdCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8gd29ycnkgYWJvdXQgY2F0Y2hpbmcgXCJub3JtYWxcIiBleGNlcHRpb25zIHJlc3VsdGluZyBmcm9tIGluY29tcGxldGVcbiAgICAgICAgICAgICAgICAvLyBjYWNoZSBkYXRhLiBVbmV4cGVjdGVkIGVycm9ycyB3aWxsIGJlIHJlLXRocm93bi4gSWYgeW91IG5lZWQgbW9yZVxuICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHdoaWNoIGZpZWxkcyB3ZXJlIG1pc3NpbmcsIHVzZSBjYWNoZS5kaWZmIGluc3RlYWQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGV4YW1pbmUgZGlmZlJlc3VsdC5taXNzaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKyt0aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVdyaXRlci53cml0ZVRvU3RvcmUodGhpcy5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghLS10aGlzLnR4Q291bnQgJiYgb3B0aW9ucy5icm9hZGNhc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChvcHRpb25zLCBcImlkXCIpICYmICFvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICAvLyBUbyBteSBrbm93bGVkZ2UsIFR5cGVTY3JpcHQgZG9lcyBub3QgY3VycmVudGx5IHByb3ZpZGUgYSB3YXkgdG9cbiAgICAgICAgICAgIC8vIGVuZm9yY2UgdGhhdCBhbiBvcHRpb25hbCBwcm9wZXJ0eT86dHlwZSBtdXN0ICpub3QqIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gd2hlbiBwcmVzZW50LiBUaGF0IGFiaWxpdHkgd291bGQgYmUgdXNlZnVsIGhlcmUsIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgICAgICAgLy8gb3B0aW9ucy5pZCB0byBkZWZhdWx0IHRvIFJPT1RfUVVFUlkgb25seSB3aGVuIG5vIG9wdGlvbnMuaWQgd2FzXG4gICAgICAgICAgICAvLyBwcm92aWRlZC4gSWYgdGhlIGNhbGxlciBhdHRlbXB0cyB0byBwYXNzIG9wdGlvbnMuaWQgd2l0aCBhXG4gICAgICAgICAgICAvLyBmYWxzeS91bmRlZmluZWQgdmFsdWUgKHBlcmhhcHMgYmVjYXVzZSBjYWNoZS5pZGVudGlmeSBmYWlsZWQpLCB3ZVxuICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBhc3N1bWUgdGhlIGdvYWwgd2FzIHRvIG1vZGlmeSB0aGUgUk9PVF9RVUVSWSBvYmplY3QuXG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB0aHJvdywgYnV0IGl0IHNlZW1zIG5hdHVyYWwgdG8gcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlXG4gICAgICAgICAgICAvLyB0aGF0IG5vdGhpbmcgd2FzIG1vZGlmaWVkLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9yZSA9ICgob3B0aW9ucy5vcHRpbWlzdGljKSAvLyBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgKSA/XG4gICAgICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhXG4gICAgICAgICAgICA6IHRoaXMuZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICsrdGhpcy50eENvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLm1vZGlmeShvcHRpb25zLmlkIHx8IFwiUk9PVF9RVUVSWVwiLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIS0tdGhpcy50eENvdW50ICYmIG9wdGlvbnMuYnJvYWRjYXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVSZWFkZXIuZGlmZlF1ZXJ5QWdhaW5zdFN0b3JlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzdG9yZTogb3B0aW9ucy5vcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSwgcm9vdElkOiBvcHRpb25zLmlkIHx8IFwiUk9PVF9RVUVSWVwiLCBjb25maWc6IHRoaXMuY29uZmlnIH0pKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKHdhdGNoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy53YXRjaGVzLnNpemUpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugd2UgcHJldmlvdXNseSBjYWxsZWQgZm9yZ2V0Q2FjaGUodGhpcykgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhpcy53YXRjaGVzIGJlY2FtZSBlbXB0eSAoc2VlIGJlbG93KSwgcmVhdHRhY2ggdGhpcyBjYWNoZSB0byBhbnlcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHZhcmlhYmxlcyBvbiB3aGljaCBpdCBwcmV2aW91c2x5IGRlcGVuZGVkLiBJdCBtaWdodCBzZWVtXG4gICAgICAgICAgICAvLyBwYXJhZG94aWNhbCB0aGF0IHdlJ3JlIGFibGUgdG8gcmVjYWxsIHNvbWV0aGluZyB3ZSBzdXBwb3NlZGx5XG4gICAgICAgICAgICAvLyBmb3Jnb3QsIGJ1dCB0aGUgcG9pbnQgb2YgY2FsbGluZyBmb3JnZXRDYWNoZSh0aGlzKSBpcyB0byBzaWxlbmNlXG4gICAgICAgICAgICAvLyB1c2VsZXNzIGJyb2FkY2FzdHMgd2hpbGUgdGhpcy53YXRjaGVzIGlzIGVtcHR5LCBhbmQgdG8gYWxsb3cgdGhlXG4gICAgICAgICAgICAvLyBjYWNoZSB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC4gSWYsIGhvd2V2ZXIsIHdlIG1hbmFnZSB0byBjYWxsXG4gICAgICAgICAgICAvLyByZWNhbGxDYWNoZSh0aGlzKSBoZXJlLCB0aGlzIGNhY2hlIG9iamVjdCBtdXN0IG5vdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGdhcmJhZ2UgY29sbGVjdGVkIHlldCwgYW5kIHNob3VsZCByZXN1bWUgcmVjZWl2aW5nIHVwZGF0ZXMgZnJvbVxuICAgICAgICAgICAgLy8gcmVhY3RpdmUgdmFyaWFibGVzLCBub3cgdGhhdCBpdCBoYXMgYSB3YXRjaGVyIHRvIG5vdGlmeS5cbiAgICAgICAgICAgIHJlY2FsbENhY2hlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hlcy5hZGQod2F0Y2gpO1xuICAgICAgICBpZiAod2F0Y2guaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlQnJvYWRjYXN0V2F0Y2god2F0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmNlIHdlIHJlbW92ZSB0aGUgbGFzdCB3YXRjaCBmcm9tIHRoaXMud2F0Y2hlcywgY2FjaGUuYnJvYWRjYXN0V2F0Y2hlc1xuICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcsIHNvIHdlIHByZWVtcHRpdmVseSB0ZWxsIHRoZSByZWFjdGl2ZSB2YXJpYWJsZVxuICAgICAgICAgICAgLy8gc3lzdGVtIHRvIGV4Y2x1ZGUgdGhpcyBjYWNoZSBmcm9tIGZ1dHVyZSBicm9hZGNhc3RzLlxuICAgICAgICAgICAgaWYgKF90aGlzLndhdGNoZXMuZGVsZXRlKHdhdGNoKSAmJiAhX3RoaXMud2F0Y2hlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yZ2V0Q2FjaGUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgd2F0Y2ggZnJvbSB0aGUgTFJVIGNhY2hlIG1hbmFnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyBtYXliZUJyb2FkY2FzdFdhdGNoIE9wdGltaXN0aWNXcmFwcGVyRnVuY3Rpb24sIHRvIHByZXZlbnQgbWVtb3J5XG4gICAgICAgICAgICAvLyBsZWFrcyBpbnZvbHZpbmcgdGhlIGNsb3N1cmUgb2Ygd2F0Y2guY2FsbGJhY2suXG4gICAgICAgICAgICBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoLmZvcmdldCh3YXRjaCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5nYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2Fub25pY2FsU3RyaW5naWZ5LnJlc2V0KCk7XG4gICAgICAgIHByaW50LnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYWRkVHlwZW5hbWVUcmFuc2Zvcm0ucmVzZXRDYWNoZSgpO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbmZpZy5mcmFnbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldENhY2hlcygpO1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5vcHRpbWlzdGljRGF0YS5nYygpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAhdGhpcy50eENvdW50KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXNldFJlc3VsdENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFJlc3VsdENhY2hlKG9wdGlvbnMucmVzZXRSZXN1bHRJZGVudGl0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucmVzZXRSZXN1bHRJZGVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZVJlYWRlci5yZXNldENhbm9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9O1xuICAgIC8vIENhbGwgdGhpcyBtZXRob2QgdG8gZW5zdXJlIHRoZSBnaXZlbiByb290IElEIHJlbWFpbnMgaW4gdGhlIGNhY2hlIGFmdGVyXG4gICAgLy8gZ2FyYmFnZSBjb2xsZWN0aW9uLCBhbG9uZyB3aXRoIGl0cyB0cmFuc2l0aXZlIGNoaWxkIGVudGl0aWVzLiBOb3RlIHRoYXRcbiAgICAvLyB0aGUgY2FjaGUgYXV0b21hdGljYWxseSByZXRhaW5zIGFsbCBkaXJlY3RseSB3cml0dGVuIGVudGl0aWVzLiBCeSBkZWZhdWx0LFxuICAgIC8vIHRoZSByZXRhaW5tZW50IHBlcnNpc3RzIGFmdGVyIG9wdGltaXN0aWMgdXBkYXRlcyBhcmUgcmVtb3ZlZC4gUGFzcyB0cnVlXG4gICAgLy8gZm9yIHRoZSBvcHRpbWlzdGljIGFyZ3VtZW50IGlmIHlvdSB3b3VsZCBwcmVmZXIgZm9yIHRoZSByZXRhaW5tZW50IHRvIGJlXG4gICAgLy8gZGlzY2FyZGVkIHdoZW4gdGhlIHRvcC1tb3N0IG9wdGltaXN0aWMgbGF5ZXIgaXMgcmVtb3ZlZC4gUmV0dXJucyB0aGVcbiAgICAvLyByZXN1bHRpbmcgKG5vbi1uZWdhdGl2ZSkgcmV0YWlubWVudCBjb3VudC5cbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbiAocm9vdElkLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIHJldHVybiAob3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEpLnJldGFpbihyb290SWQpO1xuICAgIH07XG4gICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCB0byB1bmRvIHRoZSBlZmZlY3Qgb2YgdGhlIHJldGFpbiBtZXRob2QsIGFib3ZlLiBPbmNlIHRoZVxuICAgIC8vIHJldGFpbm1lbnQgY291bnQgZmFsbHMgdG8gemVybywgdGhlIGdpdmVuIElEIHdpbGwgbm8gbG9uZ2VyIGJlIHByZXNlcnZlZFxuICAgIC8vIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb24sIHRob3VnaCBpdCBtYXkgc3RpbGwgYmUgcHJlc2VydmVkIGJ5IG90aGVyIHNhZmVcbiAgICAvLyBlbnRpdGllcyB0aGF0IHJlZmVyIHRvIGl0LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgKG5vbi1uZWdhdGl2ZSkgcmV0YWlubWVudFxuICAgIC8vIGNvdW50LCBpbiBjYXNlIHRoYXQncyB1c2VmdWwuXG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChyb290SWQsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSkucmVsZWFzZShyb290SWQpO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB0aGUgY2Fub25pY2FsIElEIGZvciBhIGdpdmVuIFN0b3JlT2JqZWN0LCBvYmV5aW5nIHR5cGVQb2xpY2llc1xuICAgIC8vIGFuZCBrZXlGaWVsZHMgKGFuZCBkYXRhSWRGcm9tT2JqZWN0LCBpZiB5b3Ugc3RpbGwgdXNlIHRoYXQpLiBBdCBtaW5pbXVtLFxuICAgIC8vIHRoZSBvYmplY3QgbXVzdCBjb250YWluIGEgX190eXBlbmFtZSBhbmQgYW55IHByaW1hcnkga2V5IGZpZWxkcyByZXF1aXJlZFxuICAgIC8vIHRvIGlkZW50aWZ5IGVudGl0aWVzIG9mIHRoYXQgdHlwZS4gSWYgeW91IHBhc3MgYSBxdWVyeSByZXN1bHQgb2JqZWN0LCBiZVxuICAgIC8vIHN1cmUgdGhhdCBub25lIG9mIHRoZSBwcmltYXJ5IGtleSBmaWVsZHMgaGF2ZSBiZWVuIHJlbmFtZWQgYnkgYWxpYXNpbmcuXG4gICAgLy8gSWYgeW91IHBhc3MgYSBSZWZlcmVuY2Ugb2JqZWN0LCBpdHMgX19yZWYgSUQgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChpc1JlZmVyZW5jZShvYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5fX3JlZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljaWVzLmlkZW50aWZ5KG9iamVjdClbMF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob3B0aW9ucywgXCJpZFwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGluIG1vZGlmeSBtZXRob2QgYWJvdXQgd2h5IHdlIHJldHVybiBmYWxzZSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5pZCBleGlzdHMgYnV0IGlzIGZhbHN5L3VuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGlkOiBcIlJPT1RfUVVFUllcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGF0IHRoZSBldmljdGlvbiB3aWxsIGVuZCB1cCBpbnZva2luZyBhbnkgb3RoZXJcbiAgICAgICAgICAgIC8vIGNhY2hlIHVwZGF0ZSBvcGVyYXRpb25zIHdoaWxlIGl0J3MgcnVubmluZywgYnV0IHtpbixkZX1jcmVtZW50aW5nXG4gICAgICAgICAgICAvLyB0aGlzLnR4Q291bnQgc3RpbGwgc2VlbXMgbGlrZSBhIGdvb2QgaWRlYSwgZm9yIHVuaWZvcm1pdHkgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIG90aGVyIHVwZGF0ZSBtZXRob2RzLlxuICAgICAgICAgICAgKyt0aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICAvLyBQYXNzIHRoaXMuZGF0YSBhcyBhIGxpbWl0IG9uIHRoZSBkZXB0aCBvZiB0aGUgZXZpY3Rpb24sIHNvIGV2aWN0aW9uc1xuICAgICAgICAgICAgLy8gZHVyaW5nIG9wdGltaXN0aWMgdXBkYXRlcyAod2hlbiB0aGlzLmRhdGEgaXMgdGVtcG9yYXJpbHkgc2V0IGVxdWFsIHRvXG4gICAgICAgICAgICAvLyB0aGlzLm9wdGltaXN0aWNEYXRhKSBkbyBub3QgZXNjYXBlIHRoZWlyIG9wdGltaXN0aWMgTGF5ZXIuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpbWlzdGljRGF0YS5ldmljdChvcHRpb25zLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCEtLXRoaXMudHhDb3VudCAmJiBvcHRpb25zLmJyb2FkY2FzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgY2Fub25pY2FsU3RyaW5naWZ5LnJlc2V0KCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGlzY2FyZFdhdGNoZXMpIHtcbiAgICAgICAgICAgIC8vIFNpbWlsYXIgdG8gd2hhdCBoYXBwZW5zIGluIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbiByZXR1cm5lZCBieVxuICAgICAgICAgICAgLy8gY2FjaGUud2F0Y2gsIGFwcGxpZWQgdG8gYWxsIGN1cnJlbnQgd2F0Y2hlcy5cbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YXRjaCkgeyByZXR1cm4gX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaC5mb3JnZXQod2F0Y2gpOyB9KTtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5jbGVhcigpO1xuICAgICAgICAgICAgZm9yZ2V0Q2FjaGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoaXMuaW5pdCgpIGFib3ZlIHVuYmxvY2tzIGFsbCBtYXliZUJyb2FkY2FzdFdhdGNoIGNhY2hpbmcsIHNvXG4gICAgICAgICAgICAvLyB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKSB0cmlnZ2VycyBhIGJyb2FkY2FzdCB0byBldmVyeSBjdXJyZW50IHdhdGNoZXJcbiAgICAgICAgICAgIC8vIChsZXR0aW5nIHRoZW0ga25vdyB0aGVpciBkYXRhIGlzIG5vdyBtaXNzaW5nKS4gVGhpcyBkZWZhdWx0IGJlaGF2aW9yIGlzXG4gICAgICAgICAgICAvLyBjb252ZW5pZW50IGJlY2F1c2UgaXQgbWVhbnMgdGhlIHdhdGNoZXMgZG8gbm90IGhhdmUgdG8gYmUgbWFudWFsbHlcbiAgICAgICAgICAgIC8vIHJlZXN0YWJsaXNoZWQgYWZ0ZXIgcmVzZXR0aW5nIHRoZSBjYWNoZS4gVG8gcHJldmVudCB0aGlzIGJyb2FkY2FzdCBhbmRcbiAgICAgICAgICAgIC8vIGNhbmNlbCBhbGwgd2F0Y2hlcywgcGFzcyB0cnVlIGZvciBvcHRpb25zLmRpc2NhcmRXYXRjaGVzLlxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVtb3ZlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChpZFRvUmVtb3ZlKSB7XG4gICAgICAgIHZhciBuZXdPcHRpbWlzdGljRGF0YSA9IHRoaXMub3B0aW1pc3RpY0RhdGEucmVtb3ZlTGF5ZXIoaWRUb1JlbW92ZSk7XG4gICAgICAgIGlmIChuZXdPcHRpbWlzdGljRGF0YSAhPT0gdGhpcy5vcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpbWlzdGljRGF0YSA9IG5ld09wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZSA9IG9wdGlvbnMudXBkYXRlLCBfYSA9IG9wdGlvbnMub3B0aW1pc3RpYywgb3B0aW1pc3RpYyA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIHJlbW92ZU9wdGltaXN0aWMgPSBvcHRpb25zLnJlbW92ZU9wdGltaXN0aWMsIG9uV2F0Y2hVcGRhdGVkID0gb3B0aW9ucy5vbldhdGNoVXBkYXRlZDtcbiAgICAgICAgdmFyIHVwZGF0ZVJlc3VsdDtcbiAgICAgICAgdmFyIHBlcmZvcm0gPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBkYXRhID0gX2EuZGF0YSwgb3B0aW1pc3RpY0RhdGEgPSBfYS5vcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICsrX3RoaXMudHhDb3VudDtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEgPSBfdGhpcy5vcHRpbWlzdGljRGF0YSA9IGxheWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVwZGF0ZVJlc3VsdCA9IHVwZGF0ZShfdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLS1fdGhpcy50eENvdW50O1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGltaXN0aWNEYXRhID0gb3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhbHJlYWR5RGlydHkgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbldhdGNoVXBkYXRlZCAmJiAhdGhpcy50eENvdW50KSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvcHRpb25zLm9uV2F0Y2hVcGRhdGVkIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCB3ZSB3YW50IHRvIGNhbGwgaXRcbiAgICAgICAgICAgIC8vIHdpdGggb25seSB0aGUgQ2FjaGUuV2F0Y2hPcHRpb25zIG9iamVjdHMgYWZmZWN0ZWQgYnkgb3B0aW9ucy51cGRhdGUsXG4gICAgICAgICAgICAvLyBidXQgdGhlcmUgbWlnaHQgYmUgZGlydHkgd2F0Y2hlcnMgYWxyZWFkeSB3YWl0aW5nIHRvIGJlIGJyb2FkY2FzdCB0aGF0XG4gICAgICAgICAgICAvLyBoYXZlIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGUgdXBkYXRlLiBUbyBwcmV2ZW50IGluY2x1ZGluZyB0aG9zZSB3YXRjaGVyc1xuICAgICAgICAgICAgLy8gaW4gdGhlIHBvc3QtdXBkYXRlIGJyb2FkY2FzdCwgd2UgcGVyZm9ybSB0aGlzIGluaXRpYWwgYnJvYWRjYXN0IHRvXG4gICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBkaXJ0eSB3YXRjaGVycywgc28gd2UgY2FuIHJlLWRpcnR5IHRoZW0gbGF0ZXIsIGFmdGVyIHRoZVxuICAgICAgICAgICAgLy8gcG9zdC11cGRhdGUgYnJvYWRjYXN0LCBhbGxvd2luZyB0aGVtIHRvIHJlY2VpdmUgdGhlaXIgcGVuZGluZ1xuICAgICAgICAgICAgLy8gYnJvYWRjYXN0cyB0aGUgbmV4dCB0aW1lIGJyb2FkY2FzdFdhdGNoZXMgaXMgY2FsbGVkLCBqdXN0IGFzIHRoZXkgd291bGRcbiAgICAgICAgICAgIC8vIGlmIHdlIG5ldmVyIGNhbGxlZCBjYWNoZS5iYXRjaC5cbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5RGlydHkuYWRkKHdhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW1pc3RpYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBsYXllcnMgd2l0aCB0aGUgc2FtZSBvcHRpbWlzdGljIElELlxuICAgICAgICAgICAgLy8gV2hlbiByZW1vdmVPcHRpbWlzdGljKGlkKSBpcyBjYWxsZWQgZm9yIHRoYXQgaWQsIGFsbCBtYXRjaGluZyBsYXllcnNcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCwgYW5kIHRoZSByZW1haW5pbmcgbGF5ZXJzIHdpbGwgYmUgcmVhcHBsaWVkLlxuICAgICAgICAgICAgdGhpcy5vcHRpbWlzdGljRGF0YSA9IHRoaXMub3B0aW1pc3RpY0RhdGEuYWRkTGF5ZXIob3B0aW1pc3RpYywgcGVyZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW1pc3RpYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBib3RoIHRoaXMuZGF0YSBhbmQgdGhpcy5vcHRpbWlzdGljRGF0YSByZWZlciB0byB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gKG5vbi1vcHRpbWlzdGljKSBsYXllciBvZiB0aGUgY2FjaGUgZHVyaW5nIHRoZSB1cGRhdGUuIE5vdGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhpcy5kYXRhIGNvdWxkIGJlIGEgTGF5ZXIgaWYgd2UgYXJlIGN1cnJlbnRseSBleGVjdXRpbmcgYW4gb3B0aW1pc3RpY1xuICAgICAgICAgICAgLy8gdXBkYXRlIGZ1bmN0aW9uLCBidXQgb3RoZXJ3aXNlIHdpbGwgYWx3YXlzIGJlIGFuIEVudGl0eVN0b3JlLlJvb3RcbiAgICAgICAgICAgIC8vIGluc3RhbmNlLlxuICAgICAgICAgICAgcGVyZm9ybSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZWF2ZSB0aGlzLmRhdGEgYW5kIHRoaXMub3B0aW1pc3RpY0RhdGEgdW5jaGFuZ2VkIGFuZCBydW5cbiAgICAgICAgICAgIC8vIHRoZSB1cGRhdGUgd2l0aCBicm9hZGNhc3QgYmF0Y2hpbmcuXG4gICAgICAgICAgICBwZXJmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZW1vdmVPcHRpbWlzdGljID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gdGhpcy5vcHRpbWlzdGljRGF0YS5yZW1vdmVMYXllcihyZW1vdmVPcHRpbWlzdGljKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBpZiB0aGlzLnR4Q291bnQgPiAwLCB0aGVuIGFscmVhZHlEaXJ0eS5zaXplID09PSAwLCBzbyB0aGlzIGNvZGVcbiAgICAgICAgLy8gdGFrZXMgdGhlIGVsc2UgYnJhbmNoIGFuZCBjYWxscyB0aGlzLmJyb2FkY2FzdFdhdGNoZXMob3B0aW9ucyksIHdoaWNoXG4gICAgICAgIC8vIGRvZXMgbm90aGluZyB3aGVuIHRoaXMudHhDb3VudCA+IDAuXG4gICAgICAgIGlmIChvbldhdGNoVXBkYXRlZCAmJiBhbHJlYWR5RGlydHkuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBvbldhdGNoVXBkYXRlZDogZnVuY3Rpb24gKHdhdGNoLCBkaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvbldhdGNoVXBkYXRlZC5jYWxsKHRoaXMsIHdhdGNoLCBkaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIG9uV2F0Y2hVcGRhdGVkIGRpZCBub3QgcmV0dXJuIGZhbHNlLCB0aGlzIGRpZmYgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3V0IHRvIGJlIGJyb2FkY2FzdCB0byB3YXRjaC5jYWxsYmFjaywgc28gd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmUtZGlydHkgaXQgd2l0aCB0aGUgb3RoZXIgYWxyZWFkeURpcnR5IHdhdGNoZXMgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5RGlydHkuZGVsZXRlKHdhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgLy8gU2lsZW50bHkgcmUtZGlydHkgYW55IHdhdGNoZXMgdGhhdCB3ZXJlIGFscmVhZHkgZGlydHkgYmVmb3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgIC8vIHdhcyBwZXJmb3JtZWQsIGFuZCB3ZXJlIG5vdCBicm9hZGNhc3QganVzdCBub3cuXG4gICAgICAgICAgICBpZiAoYWxyZWFkeURpcnR5LnNpemUpIHtcbiAgICAgICAgICAgICAgICBhbHJlYWR5RGlydHkuZm9yRWFjaChmdW5jdGlvbiAod2F0Y2gpIHsgcmV0dXJuIF90aGlzLm1heWJlQnJvYWRjYXN0V2F0Y2guZGlydHkod2F0Y2gpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGFscmVhZHlEaXJ0eSBpcyBlbXB0eSBvciB3ZSBkb24ndCBoYXZlIGFuIG9uV2F0Y2hVcGRhdGVkXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBnbyB0byB0aGUgdHJvdWJsZSBvZiB3cmFwcGluZ1xuICAgICAgICAgICAgLy8gb3B0aW9ucy5vbldhdGNoVXBkYXRlZC5cbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlUmVzdWx0O1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucGVyZm9ybVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHVwZGF0ZSwgb3B0aW1pc3RpY0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoKHtcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogb3B0aW1pc3RpY0lkIHx8IG9wdGltaXN0aWNJZCAhPT0gbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRUeXBlbmFtZVRvRG9jdW1lbnQodGhpcy5hZGRGcmFnbWVudHNUb0RvY3VtZW50KGRvY3VtZW50KSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5icm9hZGNhc3RXYXRjaGVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnR4Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoKGMsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYWRkRnJhZ21lbnRzVG9Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICB2YXIgZnJhZ21lbnRzID0gdGhpcy5jb25maWcuZnJhZ21lbnRzO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzID8gZnJhZ21lbnRzLnRyYW5zZm9ybShkb2N1bWVudCkgOiBkb2N1bWVudDtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmFkZFR5cGVuYW1lVG9Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodGhpcy5hZGRUeXBlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVHlwZW5hbWVUcmFuc2Zvcm0udHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIHdyYXBwZWQgYnkgbWF5YmVCcm9hZGNhc3RXYXRjaCwgd2hpY2ggaXMgY2FsbGVkIGJ5XG4gICAgLy8gYnJvYWRjYXN0V2F0Y2hlcywgc28gdGhhdCB3ZSBjb21wdXRlIGFuZCBicm9hZGNhc3QgcmVzdWx0cyBvbmx5IHdoZW5cbiAgICAvLyB0aGUgZGF0YSB0aGF0IHdvdWxkIGJlIGJyb2FkY2FzdCBtaWdodCBoYXZlIGNoYW5nZWQuIEl0IHdvdWxkIGJlXG4gICAgLy8gc2ltcGxlciB0byBjaGVjayBmb3IgY2hhbmdlcyBhZnRlciByZWNvbXB1dGluZyBhIHJlc3VsdCBidXQgYmVmb3JlXG4gICAgLy8gYnJvYWRjYXN0aW5nIGl0LCBidXQgdGhpcyB3cmFwcGluZyBhcHByb2FjaCBhbGxvd3MgdXMgdG8gc2tpcCBib3RoXG4gICAgLy8gdGhlIHJlY29tcHV0YXRpb24gYW5kIHRoZSBicm9hZGNhc3QsIGluIG1vc3QgY2FzZXMuXG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYnJvYWRjYXN0V2F0Y2ggPSBmdW5jdGlvbiAoYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFzdERpZmYgPSBjLmxhc3REaWZmO1xuICAgICAgICAvLyBCb3RoIFdhdGNoT3B0aW9ucyBhbmQgRGlmZk9wdGlvbnMgZXh0ZW5kIFJlYWRPcHRpb25zLCBhbmQgRGlmZk9wdGlvbnNcbiAgICAgICAgLy8gY3VycmVudGx5IHJlcXVpcmVzIG5vIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc28gd2UgY2FuIHVzZSBjIChhXG4gICAgICAgIC8vIFdhdGNoT3B0aW9ucyBvYmplY3QpIGFzIERpZmZPcHRpb25zLCB3aXRob3V0IGhhdmluZyB0byBhbGxvY2F0ZSBhIG5ld1xuICAgICAgICAvLyBvYmplY3QsIGFuZCB3aXRob3V0IGhhdmluZyB0byBlbnVtZXJhdGUgdGhlIHJlbGV2YW50IHByb3BlcnRpZXMgKHF1ZXJ5LFxuICAgICAgICAvLyB2YXJpYWJsZXMsIGV0Yy4pIGV4cGxpY2l0bHkuIFRoZXJlIHdpbGwgYmUgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGxhc3REaWZmLCBjYWxsYmFjaywgZXRjLiksIGJ1dCBjYWNoZS5kaWZmIGlnbm9yZXMgdGhlbS5cbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYoYyk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoYy5vcHRpbWlzdGljICYmIHR5cGVvZiBvcHRpb25zLm9wdGltaXN0aWMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkaWZmLmZyb21PcHRpbWlzdGljVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25XYXRjaFVwZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uV2F0Y2hVcGRhdGVkLmNhbGwodGhpcywgYywgZGlmZiwgbGFzdERpZmYpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBvbldhdGNoVXBkYXRlZCBjYWxsYmFjayB3aWxsIHByZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIGMuY2FsbGJhY2soZGlmZikgZm9yIHRoaXMgd2F0Y2hlci5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0RGlmZiB8fCAhZXF1YWwobGFzdERpZmYucmVzdWx0LCBkaWZmLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIGMuY2FsbGJhY2soKGMubGFzdERpZmYgPSBkaWZmKSwgbGFzdERpZmYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5NZW1vcnlDYWNoZTtcbn0oQXBvbGxvQ2FjaGUpKTtcbmV4cG9ydCB7IEluTWVtb3J5Q2FjaGUgfTtcbmlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlKSB7XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZ2V0TWVtb3J5SW50ZXJuYWxzID0gZ2V0SW5NZW1vcnlDYWNoZU1lbW9yeUludGVybmFscztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluTWVtb3J5Q2FjaGUuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiX19leHRlbmRzIiwiaW52YXJpYW50Iiwid3JhcCIsImVxdWFsIiwiQXBvbGxvQ2FjaGUiLCJNaXNzaW5nRmllbGRFcnJvciIsImFkZFR5cGVuYW1lVG9Eb2N1bWVudCIsImlzUmVmZXJlbmNlIiwiRG9jdW1lbnRUcmFuc2Zvcm0iLCJjYW5vbmljYWxTdHJpbmdpZnkiLCJwcmludCIsImNhY2hlU2l6ZXMiLCJTdG9yZVJlYWRlciIsIlN0b3JlV3JpdGVyIiwiRW50aXR5U3RvcmUiLCJzdXBwb3J0c1Jlc3VsdENhY2hpbmciLCJtYWtlVmFyIiwiZm9yZ2V0Q2FjaGUiLCJyZWNhbGxDYWNoZSIsIlBvbGljaWVzIiwiaGFzT3duIiwibm9ybWFsaXplQ29uZmlnIiwic2hvdWxkQ2Fub25pemVSZXN1bHRzIiwiZ2V0SW5NZW1vcnlDYWNoZU1lbW9yeUludGVybmFscyIsIkluTWVtb3J5Q2FjaGUiLCJfc3VwZXIiLCJjb25maWciLCJfdGhpcyIsImNhbGwiLCJ3YXRjaGVzIiwiU2V0IiwiYWRkVHlwZW5hbWVUcmFuc2Zvcm0iLCJhc3N1bWVJbW11dGFibGVSZXN1bHRzIiwidHhDb3VudCIsImFkZFR5cGVuYW1lIiwicG9saWNpZXMiLCJjYWNoZSIsImRhdGFJZEZyb21PYmplY3QiLCJwb3NzaWJsZVR5cGVzIiwidHlwZVBvbGljaWVzIiwiaW5pdCIsInByb3RvdHlwZSIsInJvb3RTdG9yZSIsImRhdGEiLCJSb290IiwicmVzdWx0Q2FjaGluZyIsIm9wdGltaXN0aWNEYXRhIiwic3R1bXAiLCJyZXNldFJlc3VsdENhY2hlIiwicmVzZXRSZXN1bHRJZGVudGl0aWVzIiwicHJldmlvdXNSZWFkZXIiLCJzdG9yZVJlYWRlciIsImZyYWdtZW50cyIsInN0b3JlV3JpdGVyIiwicmVzdWx0Q2FjaGVNYXhTaXplIiwiY2Fub25pemVSZXN1bHRzIiwiY2Fub24iLCJtYXliZUJyb2FkY2FzdFdhdGNoIiwiYyIsIm9wdGlvbnMiLCJicm9hZGNhc3RXYXRjaCIsIm1heCIsIm1ha2VDYWNoZUtleSIsInN0b3JlIiwib3B0aW1pc3RpYyIsImlkIiwidmFyaWFibGVzIiwicXVlcnkiLCJjYWxsYmFjayIsImdyb3VwIiwiZm9yRWFjaCIsInJlc2V0Q2FjaGluZyIsInJlc3RvcmUiLCJyZXBsYWNlIiwiZXh0cmFjdCIsInJlYWQiLCJfYSIsInJldHVyblBhcnRpYWxEYXRhIiwiZGlmZlF1ZXJ5QWdhaW5zdFN0b3JlIiwicmVzdWx0IiwiZSIsIndyaXRlIiwid3JpdGVUb1N0b3JlIiwiYnJvYWRjYXN0IiwiYnJvYWRjYXN0V2F0Y2hlcyIsIm1vZGlmeSIsImZpZWxkcyIsImRpZmYiLCJyb290SWQiLCJ3YXRjaCIsInNpemUiLCJhZGQiLCJpbW1lZGlhdGUiLCJkZWxldGUiLCJmb3JnZXQiLCJnYyIsInJlc2V0IiwicmVzZXRDYWNoZSIsInJlc2V0Q2FjaGVzIiwiaWRzIiwicmVzZXRDYW5vbiIsInJldGFpbiIsInJlbGVhc2UiLCJpZGVudGlmeSIsIm9iamVjdCIsIl9fcmVmIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJ3YXJuIiwiZXZpY3QiLCJkaXNjYXJkV2F0Y2hlcyIsImNsZWFyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZW1vdmVPcHRpbWlzdGljIiwiaWRUb1JlbW92ZSIsIm5ld09wdGltaXN0aWNEYXRhIiwicmVtb3ZlTGF5ZXIiLCJiYXRjaCIsInVwZGF0ZSIsIm9uV2F0Y2hVcGRhdGVkIiwidXBkYXRlUmVzdWx0IiwicGVyZm9ybSIsImxheWVyIiwiYWxyZWFkeURpcnR5IiwiYWRkTGF5ZXIiLCJkaXJ0eSIsInBlcmZvcm1UcmFuc2FjdGlvbiIsIm9wdGltaXN0aWNJZCIsInRyYW5zZm9ybURvY3VtZW50IiwiZG9jdW1lbnQiLCJhZGRGcmFnbWVudHNUb0RvY3VtZW50IiwidHJhbnNmb3JtIiwibGFzdERpZmYiLCJmcm9tT3B0aW1pc3RpY1RyYW5zYWN0aW9uIiwiZ2V0TWVtb3J5SW50ZXJuYWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/inMemoryCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/key-extractor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/key-extractor.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   collectSpecifierPaths: function() { return /* binding */ collectSpecifierPaths; },\n/* harmony export */   extractKeyPath: function() { return /* binding */ extractKeyPath; },\n/* harmony export */   getSpecifierPaths: function() { return /* binding */ getSpecifierPaths; },\n/* harmony export */   keyArgsFnFromSpecifier: function() { return /* binding */ keyArgsFnFromSpecifier; },\n/* harmony export */   keyFieldsFnFromSpecifier: function() { return /* binding */ keyFieldsFnFromSpecifier; }\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n\n\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n    // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n    // just arrays of strings or nested KeySpecifier arrays, and the order of the\n    // array elements is important (and suitably preserved by JSON.stringify).\n    var cacheKey = JSON.stringify(spec);\n    return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {\n        var extract = function(from, key) {\n            return context.readField(key, from);\n        };\n        var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {\n            var extracted = extractKeyPath(context.storeObject, schemaKeyPath, // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract);\n            if (extracted === void 0 && object !== context.storeObject && _helpers_js__WEBPACK_IMPORTED_MODULE_1__.hasOwn.call(object, schemaKeyPath[0])) {\n                // If context.storeObject fails to provide a value for the requested\n                // path, fall back to the raw result object, if it has a top-level key\n                // matching the first key in the path (schemaKeyPath[0]). This allows\n                // key fields included in the written data to be saved in the cache\n                // even if they are not selected explicitly in context.selectionSet.\n                // Not being mentioned by context.selectionSet is convenient here,\n                // since it means these extra fields cannot be affected by field\n                // aliasing, which is why we can use extractKey instead of\n                // context.readField for this extraction.\n                extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n            }\n            (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(extracted !== void 0, 4, schemaKeyPath.join(\".\"), object);\n            return extracted;\n        });\n        return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n    });\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nfunction keyArgsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyArgsFn || (info.keyArgsFn = function(args, _a) {\n        var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;\n        var collected = collectSpecifierPaths(specifier, function(keyPath) {\n            var firstKey = keyPath[0];\n            var firstChar = firstKey.charAt(0);\n            if (firstChar === \"@\") {\n                if (field && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isNonEmptyArray)(field.directives)) {\n                    var directiveName_1 = firstKey.slice(1);\n                    // If the directive appears multiple times, only the first\n                    // occurrence's arguments will be used. TODO Allow repetition?\n                    // TODO Cache this work somehow, a la aliasMap?\n                    var d = field.directives.find(function(d) {\n                        return d.name.value === directiveName_1;\n                    });\n                    // Fortunately argumentsObjectFromField works for DirectiveNode!\n                    var directiveArgs = d && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.argumentsObjectFromField)(d, variables);\n                    // For directives without arguments (d defined, but directiveArgs ===\n                    // null), the presence or absence of the directive still counts as\n                    // part of the field key, so we return null in those cases. If no\n                    // directive with this name was found for this field (d undefined and\n                    // thus directiveArgs undefined), we return undefined, which causes\n                    // this value to be omitted from the key object returned by\n                    // collectSpecifierPaths.\n                    return directiveArgs && extractKeyPath(directiveArgs, // If keyPath.length === 1, this code calls extractKeyPath with an\n                    // empty path, which works because it uses directiveArgs as the\n                    // extracted value.\n                    keyPath.slice(1));\n                }\n                // If the key started with @ but there was no corresponding directive,\n                // we want to omit this value from the key object, not fall through to\n                // treating @whatever as a normal argument name.\n                return;\n            }\n            if (firstChar === \"$\") {\n                var variableName = firstKey.slice(1);\n                if (variables && _helpers_js__WEBPACK_IMPORTED_MODULE_1__.hasOwn.call(variables, variableName)) {\n                    var varKeyPath = keyPath.slice(0);\n                    varKeyPath[0] = variableName;\n                    return extractKeyPath(variables, varKeyPath);\n                }\n                // If the key started with $ but there was no corresponding variable, we\n                // want to omit this value from the key object, not fall through to\n                // treating $whatever as a normal argument name.\n                return;\n            }\n            if (args) {\n                return extractKeyPath(args, keyPath);\n            }\n        });\n        var suffix = JSON.stringify(collected);\n        // If no arguments were passed to this field, and it didn't have any other\n        // field key contributions from directives or variables, hide the empty\n        // :{} suffix from the field key. However, a field passed no arguments can\n        // still end up with a non-empty :{...} suffix if its key configuration\n        // refers to directives or variables.\n        if (args || suffix !== \"{}\") {\n            fieldName += \":\" + suffix;\n        }\n        return fieldName;\n    });\n}\nfunction collectSpecifierPaths(specifier, extractor) {\n    // For each path specified by specifier, invoke the extractor, and repeatedly\n    // merge the results together, with appropriate ancestor context.\n    var merger = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.DeepMerger();\n    return getSpecifierPaths(specifier).reduce(function(collected, path) {\n        var _a;\n        var toMerge = extractor(path);\n        if (toMerge !== void 0) {\n            // This path is not expected to contain array indexes, so the toMerge\n            // reconstruction will not contain arrays. TODO Fix this?\n            for(var i = path.length - 1; i >= 0; --i){\n                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n            }\n            collected = merger.merge(collected, toMerge);\n        }\n        return collected;\n    }, Object.create(null));\n}\nfunction getSpecifierPaths(spec) {\n    var info = lookupSpecifierInfo(spec);\n    if (!info.paths) {\n        var paths_1 = info.paths = [];\n        var currentPath_1 = [];\n        spec.forEach(function(s, i) {\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(s)) {\n                getSpecifierPaths(s).forEach(function(p) {\n                    return paths_1.push(currentPath_1.concat(p));\n                });\n                currentPath_1.length = 0;\n            } else {\n                currentPath_1.push(s);\n                if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(spec[i + 1])) {\n                    paths_1.push(currentPath_1.slice(0));\n                    currentPath_1.length = 0;\n                }\n            }\n        });\n    }\n    return info.paths;\n}\nfunction extractKey(object, key) {\n    return object[key];\n}\nfunction extractKeyPath(object, path, extract) {\n    // For each key in path, extract the corresponding child property from obj,\n    // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n    // possible). The final result of path.reduce is normalized so unexpected leaf\n    // objects have their keys safely sorted. That final result is difficult to\n    // type as anything other than any. You're welcome to try to improve the\n    // return type, but keep in mind extractKeyPath is not a public function\n    // (exported only for testing), so the effort may not be worthwhile unless the\n    // limited set of actual callers (see above) pass arguments that TypeScript\n    // can statically type. If we know only that path is some array of strings\n    // (and not, say, a specific tuple of statically known strings), any (or\n    // possibly unknown) is the honest answer.\n    extract = extract || extractKey;\n    return normalize(path.reduce(function reducer(obj, key) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(obj) ? obj.map(function(child) {\n            return reducer(child, key);\n        }) : obj && extract(obj, key);\n    }, object));\n}\nfunction normalize(value) {\n    // Usually the extracted value will be a scalar value, since most primary\n    // key fields are scalar, but just in case we get an object or an array, we\n    // need to do some normalization of the order of (nested) keys.\n    if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isNonNullObject)(value)) {\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n            return value.map(normalize);\n        }\n        return collectSpecifierPaths(Object.keys(value).sort(), function(path) {\n            return extractKeyPath(value, path);\n        });\n    }\n    return value;\n} //# sourceMappingURL=key-extractor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9rZXktZXh0cmFjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ3NEO0FBQ3BFO0FBQy9DLDRFQUE0RTtBQUM1RSxJQUFJTyxxQkFBcUJDLE9BQU9DLE1BQU0sQ0FBQztBQUN2QyxTQUFTQyxvQkFBb0JDLElBQUk7SUFDN0IsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSwwRUFBMEU7SUFDMUUsSUFBSUMsV0FBV0MsS0FBS0MsU0FBUyxDQUFDSDtJQUM5QixPQUFRSixrQkFBa0IsQ0FBQ0ssU0FBUyxJQUMvQkwsQ0FBQUEsa0JBQWtCLENBQUNLLFNBQVMsR0FBR0osT0FBT0MsTUFBTSxDQUFDLEtBQUk7QUFDMUQ7QUFDTyxTQUFTTSx5QkFBeUJDLFNBQVM7SUFDOUMsSUFBSUMsT0FBT1Asb0JBQW9CTTtJQUMvQixPQUFRQyxLQUFLQyxXQUFXLElBQUtELENBQUFBLEtBQUtDLFdBQVcsR0FBRyxTQUFVQyxNQUFNLEVBQUVDLE9BQU87UUFDakUsSUFBSUMsVUFBVSxTQUFVQyxJQUFJLEVBQUVDLEdBQUc7WUFDN0IsT0FBT0gsUUFBUUksU0FBUyxDQUFDRCxLQUFLRDtRQUNsQztRQUNBLElBQUlHLFlBQWFMLFFBQVFLLFNBQVMsR0FBR0Msc0JBQXNCVixXQUFXLFNBQVVXLGFBQWE7WUFDekYsSUFBSUMsWUFBWUMsZUFBZVQsUUFBUVUsV0FBVyxFQUFFSCxlQUNwRCxvRUFBb0U7WUFDcEUscUVBQXFFO1lBQ3JFLHlCQUF5QjtZQUN6Qk47WUFDQSxJQUFJTyxjQUFjLEtBQUssS0FDbkJULFdBQVdDLFFBQVFVLFdBQVcsSUFDOUJ6QiwrQ0FBTUEsQ0FBQzBCLElBQUksQ0FBQ1osUUFBUVEsYUFBYSxDQUFDLEVBQUUsR0FBRztnQkFDdkMsb0VBQW9FO2dCQUNwRSxzRUFBc0U7Z0JBQ3RFLHFFQUFxRTtnQkFDckUsbUVBQW1FO2dC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Li9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkva2V5LWV4dHJhY3Rvci5qcz9kNzI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkLCBEZWVwTWVyZ2VyLCBpc05vbkVtcHR5QXJyYXksIGlzTm9uTnVsbE9iamVjdCwgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoYXNPd24sIGlzQXJyYXkgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG4vLyBNYXBwaW5nIGZyb20gSlNPTi1lbmNvZGVkIEtleVNwZWNpZmllciBzdHJpbmdzIHRvIGFzc29jaWF0ZWQgaW5mb3JtYXRpb24uXG52YXIgc3BlY2lmaWVySW5mb0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGxvb2t1cFNwZWNpZmllckluZm8oc3BlYykge1xuICAgIC8vIEl0J3Mgc2FmZSB0byBlbmNvZGUgS2V5U3BlY2lmaWVyIGFycmF5cyB3aXRoIEpTT04uc3RyaW5naWZ5LCBzaW5jZSB0aGV5J3JlXG4gICAgLy8ganVzdCBhcnJheXMgb2Ygc3RyaW5ncyBvciBuZXN0ZWQgS2V5U3BlY2lmaWVyIGFycmF5cywgYW5kIHRoZSBvcmRlciBvZiB0aGVcbiAgICAvLyBhcnJheSBlbGVtZW50cyBpcyBpbXBvcnRhbnQgKGFuZCBzdWl0YWJseSBwcmVzZXJ2ZWQgYnkgSlNPTi5zdHJpbmdpZnkpLlxuICAgIHZhciBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KHNwZWMpO1xuICAgIHJldHVybiAoc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSB8fFxuICAgICAgICAoc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgdmFyIGluZm8gPSBsb29rdXBTcGVjaWZpZXJJbmZvKHNwZWNpZmllcik7XG4gICAgcmV0dXJuIChpbmZvLmtleUZpZWxkc0ZuIHx8IChpbmZvLmtleUZpZWxkc0ZuID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhY3QgPSBmdW5jdGlvbiAoZnJvbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucmVhZEZpZWxkKGtleSwgZnJvbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGtleU9iamVjdCA9IChjb250ZXh0LmtleU9iamVjdCA9IGNvbGxlY3RTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIsIGZ1bmN0aW9uIChzY2hlbWFLZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhY3RlZCA9IGV4dHJhY3RLZXlQYXRoKGNvbnRleHQuc3RvcmVPYmplY3QsIHNjaGVtYUtleVBhdGgsIFxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGNvbnRleHQucmVhZEZpZWxkIHRvIGV4dHJhY3QgcGF0aHMgZnJvbSBjb250ZXh0LnN0b3JlT2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSBleHRyYWN0aW9uIHRvIHNlZSB0aHJvdWdoIFJlZmVyZW5jZSBvYmplY3RzIGFuZCByZXNwZWN0XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIHJlYWQgZnVuY3Rpb25zLlxuICAgICAgICAgICAgICAgIGV4dHJhY3QpO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYWN0ZWQgPT09IHZvaWQgMCAmJlxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgIT09IGNvbnRleHQuc3RvcmVPYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaGFzT3duLmNhbGwob2JqZWN0LCBzY2hlbWFLZXlQYXRoWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb250ZXh0LnN0b3JlT2JqZWN0IGZhaWxzIHRvIHByb3ZpZGUgYSB2YWx1ZSBmb3IgdGhlIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoLCBmYWxsIGJhY2sgdG8gdGhlIHJhdyByZXN1bHQgb2JqZWN0LCBpZiBpdCBoYXMgYSB0b3AtbGV2ZWwga2V5XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoaW5nIHRoZSBmaXJzdCBrZXkgaW4gdGhlIHBhdGggKHNjaGVtYUtleVBhdGhbMF0pLiBUaGlzIGFsbG93c1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXkgZmllbGRzIGluY2x1ZGVkIGluIHRoZSB3cml0dGVuIGRhdGEgdG8gYmUgc2F2ZWQgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhleSBhcmUgbm90IHNlbGVjdGVkIGV4cGxpY2l0bHkgaW4gY29udGV4dC5zZWxlY3Rpb25TZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBiZWluZyBtZW50aW9uZWQgYnkgY29udGV4dC5zZWxlY3Rpb25TZXQgaXMgY29udmVuaWVudCBoZXJlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCBtZWFucyB0aGVzZSBleHRyYSBmaWVsZHMgY2Fubm90IGJlIGFmZmVjdGVkIGJ5IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsaWFzaW5nLCB3aGljaCBpcyB3aHkgd2UgY2FuIHVzZSBleHRyYWN0S2V5IGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dC5yZWFkRmllbGQgZm9yIHRoaXMgZXh0cmFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkID0gZXh0cmFjdEtleVBhdGgob2JqZWN0LCBzY2hlbWFLZXlQYXRoLCBleHRyYWN0S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52YXJpYW50KGV4dHJhY3RlZCAhPT0gdm9pZCAwLCA0LCBzY2hlbWFLZXlQYXRoLmpvaW4oXCIuXCIpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoY29udGV4dC50eXBlbmFtZSwgXCI6XCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShrZXlPYmplY3QpKTtcbiAgICAgICAgfSkpO1xufVxuLy8gVGhlIGtleUFyZ3MgZXh0cmFjdGlvbiBwcm9jZXNzIGlzIHJvdWdobHkgYW5hbG9nb3VzIHRvIGtleUZpZWxkcyBleHRyYWN0aW9uLFxuLy8gYnV0IHRoZXJlIGFyZSBubyBhbGlhc2VzIGludm9sdmVkLCBtaXNzaW5nIGZpZWxkcyBhcmUgdG9sZXJhdGVkIChieSBtZXJlbHlcbi8vIG9taXR0aW5nIHRoZW0gZnJvbSB0aGUga2V5KSwgYW5kIGRyYXdpbmcgZnJvbSBmaWVsZC5kaXJlY3RpdmVzIG9yIHZhcmlhYmxlc1xuLy8gaXMgYWxsb3dlZCAoaW4gYWRkaXRpb24gdG8gZHJhd2luZyBmcm9tIHRoZSBmaWVsZCdzIGFyZ3VtZW50cyBvYmplY3QpLlxuLy8gQ29uY3JldGVseSwgdGhlc2UgZGlmZmVyZW5jZXMgbWVhbiBwYXNzaW5nIGEgZGlmZmVyZW50IGtleSBwYXRoIGV4dHJhY3RvclxuLy8gZnVuY3Rpb24gdG8gY29sbGVjdFNwZWNpZmllclBhdGhzLCByZXVzaW5nIHRoZSBzaGFyZWQgZXh0cmFjdEtleVBhdGggaGVscGVyXG4vLyB3aGVyZXZlciBwb3NzaWJsZS5cbmV4cG9ydCBmdW5jdGlvbiBrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIHZhciBpbmZvID0gbG9va3VwU3BlY2lmaWVySW5mbyhzcGVjaWZpZXIpO1xuICAgIHJldHVybiAoaW5mby5rZXlBcmdzRm4gfHxcbiAgICAgICAgKGluZm8ua2V5QXJnc0ZuID0gZnVuY3Rpb24gKGFyZ3MsIF9hKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBmaWVsZE5hbWUgPSBfYS5maWVsZE5hbWU7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGVkID0gY29sbGVjdFNwZWNpZmllclBhdGhzKHNwZWNpZmllciwgZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RLZXkgPSBrZXlQYXRoWzBdO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdENoYXIgPSBmaXJzdEtleS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGlzTm9uRW1wdHlBcnJheShmaWVsZC5kaXJlY3RpdmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5hbWVfMSA9IGZpcnN0S2V5LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpcmVjdGl2ZSBhcHBlYXJzIG11bHRpcGxlIHRpbWVzLCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXJyZW5jZSdzIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQuIFRPRE8gQWxsb3cgcmVwZXRpdGlvbj9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQ2FjaGUgdGhpcyB3b3JrIHNvbWVob3csIGEgbGEgYWxpYXNNYXA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGZpZWxkLmRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnZhbHVlID09PSBkaXJlY3RpdmVOYW1lXzE7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ydHVuYXRlbHkgYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkIHdvcmtzIGZvciBEaXJlY3RpdmVOb2RlIVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUFyZ3MgPSBkICYmIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGRpcmVjdGl2ZXMgd2l0aG91dCBhcmd1bWVudHMgKGQgZGVmaW5lZCwgYnV0IGRpcmVjdGl2ZUFyZ3MgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsKSwgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgdGhlIGRpcmVjdGl2ZSBzdGlsbCBjb3VudHMgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIGZpZWxkIGtleSwgc28gd2UgcmV0dXJuIG51bGwgaW4gdGhvc2UgY2FzZXMuIElmIG5vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXJlY3RpdmUgd2l0aCB0aGlzIG5hbWUgd2FzIGZvdW5kIGZvciB0aGlzIGZpZWxkIChkIHVuZGVmaW5lZCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRodXMgZGlyZWN0aXZlQXJncyB1bmRlZmluZWQpLCB3ZSByZXR1cm4gdW5kZWZpbmVkLCB3aGljaCBjYXVzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgdG8gYmUgb21pdHRlZCBmcm9tIHRoZSBrZXkgb2JqZWN0IHJldHVybmVkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0U3BlY2lmaWVyUGF0aHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpcmVjdGl2ZUFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5UGF0aChkaXJlY3RpdmVBcmdzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXlQYXRoLmxlbmd0aCA9PT0gMSwgdGhpcyBjb2RlIGNhbGxzIGV4dHJhY3RLZXlQYXRoIHdpdGggYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBwYXRoLCB3aGljaCB3b3JrcyBiZWNhdXNlIGl0IHVzZXMgZGlyZWN0aXZlQXJncyBhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHRyYWN0ZWQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aC5zbGljZSgxKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgc3RhcnRlZCB3aXRoIEAgYnV0IHRoZXJlIHdhcyBubyBjb3JyZXNwb25kaW5nIGRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBvbWl0IHRoaXMgdmFsdWUgZnJvbSB0aGUga2V5IG9iamVjdCwgbm90IGZhbGwgdGhyb3VnaCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdGluZyBAd2hhdGV2ZXIgYXMgYSBub3JtYWwgYXJndW1lbnQgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSBcIiRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gZmlyc3RLZXkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZXMgJiYgaGFzT3duLmNhbGwodmFyaWFibGVzLCB2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyS2V5UGF0aCA9IGtleVBhdGguc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJLZXlQYXRoWzBdID0gdmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RLZXlQYXRoKHZhcmlhYmxlcywgdmFyS2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGtleSBzdGFydGVkIHdpdGggJCBidXQgdGhlcmUgd2FzIG5vIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUsIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gb21pdCB0aGlzIHZhbHVlIGZyb20gdGhlIGtleSBvYmplY3QsIG5vdCBmYWxsIHRocm91Z2ggdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXRpbmcgJHdoYXRldmVyIGFzIGEgbm9ybWFsIGFyZ3VtZW50IG5hbWUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RLZXlQYXRoKGFyZ3MsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IEpTT04uc3RyaW5naWZ5KGNvbGxlY3RlZCk7XG4gICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgd2VyZSBwYXNzZWQgdG8gdGhpcyBmaWVsZCwgYW5kIGl0IGRpZG4ndCBoYXZlIGFueSBvdGhlclxuICAgICAgICAgICAgLy8gZmllbGQga2V5IGNvbnRyaWJ1dGlvbnMgZnJvbSBkaXJlY3RpdmVzIG9yIHZhcmlhYmxlcywgaGlkZSB0aGUgZW1wdHlcbiAgICAgICAgICAgIC8vIDp7fSBzdWZmaXggZnJvbSB0aGUgZmllbGQga2V5LiBIb3dldmVyLCBhIGZpZWxkIHBhc3NlZCBubyBhcmd1bWVudHMgY2FuXG4gICAgICAgICAgICAvLyBzdGlsbCBlbmQgdXAgd2l0aCBhIG5vbi1lbXB0eSA6ey4uLn0gc3VmZml4IGlmIGl0cyBrZXkgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgLy8gcmVmZXJzIHRvIGRpcmVjdGl2ZXMgb3IgdmFyaWFibGVzLlxuICAgICAgICAgICAgaWYgKGFyZ3MgfHwgc3VmZml4ICE9PSBcInt9XCIpIHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgKz0gXCI6XCIgKyBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdFNwZWNpZmllclBhdGhzKHNwZWNpZmllciwgZXh0cmFjdG9yKSB7XG4gICAgLy8gRm9yIGVhY2ggcGF0aCBzcGVjaWZpZWQgYnkgc3BlY2lmaWVyLCBpbnZva2UgdGhlIGV4dHJhY3RvciwgYW5kIHJlcGVhdGVkbHlcbiAgICAvLyBtZXJnZSB0aGUgcmVzdWx0cyB0b2dldGhlciwgd2l0aCBhcHByb3ByaWF0ZSBhbmNlc3RvciBjb250ZXh0LlxuICAgIHZhciBtZXJnZXIgPSBuZXcgRGVlcE1lcmdlcigpO1xuICAgIHJldHVybiBnZXRTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIpLnJlZHVjZShmdW5jdGlvbiAoY29sbGVjdGVkLCBwYXRoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHRvTWVyZ2UgPSBleHRyYWN0b3IocGF0aCk7XG4gICAgICAgIGlmICh0b01lcmdlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0aCBpcyBub3QgZXhwZWN0ZWQgdG8gY29udGFpbiBhcnJheSBpbmRleGVzLCBzbyB0aGUgdG9NZXJnZVxuICAgICAgICAgICAgLy8gcmVjb25zdHJ1Y3Rpb24gd2lsbCBub3QgY29udGFpbiBhcnJheXMuIFRPRE8gRml4IHRoaXM/XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHRvTWVyZ2UgPSAoX2EgPSB7fSwgX2FbcGF0aFtpXV0gPSB0b01lcmdlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0ZWQgPSBtZXJnZXIubWVyZ2UoY29sbGVjdGVkLCB0b01lcmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNwZWNpZmllclBhdGhzKHNwZWMpIHtcbiAgICB2YXIgaW5mbyA9IGxvb2t1cFNwZWNpZmllckluZm8oc3BlYyk7XG4gICAgaWYgKCFpbmZvLnBhdGhzKSB7XG4gICAgICAgIHZhciBwYXRoc18xID0gKGluZm8ucGF0aHMgPSBbXSk7XG4gICAgICAgIHZhciBjdXJyZW50UGF0aF8xID0gW107XG4gICAgICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkocykpIHtcbiAgICAgICAgICAgICAgICBnZXRTcGVjaWZpZXJQYXRocyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5jb25jYXQocCkpOyB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHNwZWNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoXzEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5mby5wYXRocztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEtleVBhdGgob2JqZWN0LCBwYXRoLCBleHRyYWN0KSB7XG4gICAgLy8gRm9yIGVhY2gga2V5IGluIHBhdGgsIGV4dHJhY3QgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgcHJvcGVydHkgZnJvbSBvYmosXG4gICAgLy8gZmxhdHRlbmluZyBhcnJheXMgaWYgZW5jb3VudGVyZWQgKHVuY29tbW9uIGZvciBrZXlGaWVsZHMgYW5kIGtleUFyZ3MsIGJ1dFxuICAgIC8vIHBvc3NpYmxlKS4gVGhlIGZpbmFsIHJlc3VsdCBvZiBwYXRoLnJlZHVjZSBpcyBub3JtYWxpemVkIHNvIHVuZXhwZWN0ZWQgbGVhZlxuICAgIC8vIG9iamVjdHMgaGF2ZSB0aGVpciBrZXlzIHNhZmVseSBzb3J0ZWQuIFRoYXQgZmluYWwgcmVzdWx0IGlzIGRpZmZpY3VsdCB0b1xuICAgIC8vIHR5cGUgYXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhbnkuIFlvdSdyZSB3ZWxjb21lIHRvIHRyeSB0byBpbXByb3ZlIHRoZVxuICAgIC8vIHJldHVybiB0eXBlLCBidXQga2VlcCBpbiBtaW5kIGV4dHJhY3RLZXlQYXRoIGlzIG5vdCBhIHB1YmxpYyBmdW5jdGlvblxuICAgIC8vIChleHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nKSwgc28gdGhlIGVmZm9ydCBtYXkgbm90IGJlIHdvcnRod2hpbGUgdW5sZXNzIHRoZVxuICAgIC8vIGxpbWl0ZWQgc2V0IG9mIGFjdHVhbCBjYWxsZXJzIChzZWUgYWJvdmUpIHBhc3MgYXJndW1lbnRzIHRoYXQgVHlwZVNjcmlwdFxuICAgIC8vIGNhbiBzdGF0aWNhbGx5IHR5cGUuIElmIHdlIGtub3cgb25seSB0aGF0IHBhdGggaXMgc29tZSBhcnJheSBvZiBzdHJpbmdzXG4gICAgLy8gKGFuZCBub3QsIHNheSwgYSBzcGVjaWZpYyB0dXBsZSBvZiBzdGF0aWNhbGx5IGtub3duIHN0cmluZ3MpLCBhbnkgKG9yXG4gICAgLy8gcG9zc2libHkgdW5rbm93bikgaXMgdGhlIGhvbmVzdCBhbnN3ZXIuXG4gICAgZXh0cmFjdCA9IGV4dHJhY3QgfHwgZXh0cmFjdEtleTtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgucmVkdWNlKGZ1bmN0aW9uIHJlZHVjZXIob2JqLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/XG4gICAgICAgICAgICBvYmoubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gcmVkdWNlcihjaGlsZCwga2V5KTsgfSlcbiAgICAgICAgICAgIDogb2JqICYmIGV4dHJhY3Qob2JqLCBrZXkpO1xuICAgIH0sIG9iamVjdCkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlKSB7XG4gICAgLy8gVXN1YWxseSB0aGUgZXh0cmFjdGVkIHZhbHVlIHdpbGwgYmUgYSBzY2FsYXIgdmFsdWUsIHNpbmNlIG1vc3QgcHJpbWFyeVxuICAgIC8vIGtleSBmaWVsZHMgYXJlIHNjYWxhciwgYnV0IGp1c3QgaW4gY2FzZSB3ZSBnZXQgYW4gb2JqZWN0IG9yIGFuIGFycmF5LCB3ZVxuICAgIC8vIG5lZWQgdG8gZG8gc29tZSBub3JtYWxpemF0aW9uIG9mIHRoZSBvcmRlciBvZiAobmVzdGVkKSBrZXlzLlxuICAgIGlmIChpc05vbk51bGxPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChub3JtYWxpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0U3BlY2lmaWVyUGF0aHMoT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKSwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRyYWN0S2V5UGF0aCh2YWx1ZSwgcGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXktZXh0cmFjdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJpbnZhcmlhbnQiLCJhcmd1bWVudHNPYmplY3RGcm9tRmllbGQiLCJEZWVwTWVyZ2VyIiwiaXNOb25FbXB0eUFycmF5IiwiaXNOb25OdWxsT2JqZWN0IiwiaGFzT3duIiwiaXNBcnJheSIsInNwZWNpZmllckluZm9DYWNoZSIsIk9iamVjdCIsImNyZWF0ZSIsImxvb2t1cFNwZWNpZmllckluZm8iLCJzcGVjIiwiY2FjaGVLZXkiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5RmllbGRzRm5Gcm9tU3BlY2lmaWVyIiwic3BlY2lmaWVyIiwiaW5mbyIsImtleUZpZWxkc0ZuIiwib2JqZWN0IiwiY29udGV4dCIsImV4dHJhY3QiLCJmcm9tIiwia2V5IiwicmVhZEZpZWxkIiwia2V5T2JqZWN0IiwiY29sbGVjdFNwZWNpZmllclBhdGhzIiwic2NoZW1hS2V5UGF0aCIsImV4dHJhY3RlZCIsImV4dHJhY3RLZXlQYXRoIiwic3RvcmVPYmplY3QiLCJjYWxsIiwiZXh0cmFjdEtleSIsImpvaW4iLCJjb25jYXQiLCJ0eXBlbmFtZSIsImtleUFyZ3NGbkZyb21TcGVjaWZpZXIiLCJrZXlBcmdzRm4iLCJhcmdzIiwiX2EiLCJmaWVsZCIsInZhcmlhYmxlcyIsImZpZWxkTmFtZSIsImNvbGxlY3RlZCIsImtleVBhdGgiLCJmaXJzdEtleSIsImZpcnN0Q2hhciIsImNoYXJBdCIsImRpcmVjdGl2ZXMiLCJkaXJlY3RpdmVOYW1lXzEiLCJzbGljZSIsImQiLCJmaW5kIiwibmFtZSIsInZhbHVlIiwiZGlyZWN0aXZlQXJncyIsInZhcmlhYmxlTmFtZSIsInZhcktleVBhdGgiLCJzdWZmaXgiLCJleHRyYWN0b3IiLCJtZXJnZXIiLCJnZXRTcGVjaWZpZXJQYXRocyIsInJlZHVjZSIsInBhdGgiLCJ0b01lcmdlIiwiaSIsImxlbmd0aCIsIm1lcmdlIiwicGF0aHMiLCJwYXRoc18xIiwiY3VycmVudFBhdGhfMSIsImZvckVhY2giLCJzIiwicCIsInB1c2giLCJub3JtYWxpemUiLCJyZWR1Y2VyIiwib2JqIiwibWFwIiwiY2hpbGQiLCJrZXlzIiwic29ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/key-extractor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/object-canon.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/object-canon.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjectCanon: function() { return /* binding */ ObjectCanon; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n\n\n\n\nfunction shallowCopy(value) {\n    if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value)) {\n        return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(value) ? value.slice(0) : (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n            __proto__: Object.getPrototypeOf(value)\n        }, value);\n    }\n    return value;\n}\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nvar ObjectCanon = /** @class */ function() {\n    function ObjectCanon() {\n        // Set of all canonical objects this ObjectCanon has admitted, allowing\n        // canon.admit to return previously-canonicalized objects immediately.\n        this.known = new (_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.canUseWeakSet ? WeakSet : Set)();\n        // Efficient storage/lookup structure for canonical objects.\n        this.pool = new _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie(_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.canUseWeakMap);\n        // Make the ObjectCanon assume this value has already been\n        // canonicalized.\n        this.passes = new WeakMap();\n        // Arrays that contain the same elements in a different order can share\n        // the same SortedKeysInfo object, to save memory.\n        this.keysByJSON = new Map();\n        // This has to come last because it depends on keysByJSON.\n        this.empty = this.admit({});\n    }\n    ObjectCanon.prototype.isKnown = function(value) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value) && this.known.has(value);\n    };\n    ObjectCanon.prototype.pass = function(value) {\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value)) {\n            var copy = shallowCopy(value);\n            this.passes.set(copy, value);\n            return copy;\n        }\n        return value;\n    };\n    ObjectCanon.prototype.admit = function(value) {\n        var _this = this;\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value)) {\n            var original = this.passes.get(value);\n            if (original) return original;\n            var proto = Object.getPrototypeOf(value);\n            switch(proto){\n                case Array.prototype:\n                    {\n                        if (this.known.has(value)) return value;\n                        var array = value.map(this.admit, this);\n                        // Arrays are looked up in the Trie using their recursively\n                        // canonicalized elements, and the known version of the array is\n                        // preserved as node.array.\n                        var node = this.pool.lookupArray(array);\n                        if (!node.array) {\n                            this.known.add(node.array = array);\n                            // Since canonical arrays may be shared widely between\n                            // unrelated consumers, it's important to regard them as\n                            // immutable, even if they are not frozen in production.\n                            if (globalThis.__DEV__ !== false) {\n                                Object.freeze(array);\n                            }\n                        }\n                        return node.array;\n                    }\n                case null:\n                case Object.prototype:\n                    {\n                        if (this.known.has(value)) return value;\n                        var proto_1 = Object.getPrototypeOf(value);\n                        var array_1 = [\n                            proto_1\n                        ];\n                        var keys = this.sortedKeys(value);\n                        array_1.push(keys.json);\n                        var firstValueIndex_1 = array_1.length;\n                        keys.sorted.forEach(function(key) {\n                            array_1.push(_this.admit(value[key]));\n                        });\n                        // Objects are looked up in the Trie by their prototype (which\n                        // is *not* recursively canonicalized), followed by a JSON\n                        // representation of their (sorted) keys, followed by the\n                        // sequence of recursively canonicalized values corresponding to\n                        // those keys. To keep the final results unambiguous with other\n                        // sequences (such as arrays that just happen to contain [proto,\n                        // keys.json, value1, value2, ...]), the known version of the\n                        // object is stored as node.object.\n                        var node = this.pool.lookupArray(array_1);\n                        if (!node.object) {\n                            var obj_1 = node.object = Object.create(proto_1);\n                            this.known.add(obj_1);\n                            keys.sorted.forEach(function(key, i) {\n                                obj_1[key] = array_1[firstValueIndex_1 + i];\n                            });\n                            // Since canonical objects may be shared widely between\n                            // unrelated consumers, it's important to regard them as\n                            // immutable, even if they are not frozen in production.\n                            if (globalThis.__DEV__ !== false) {\n                                Object.freeze(obj_1);\n                            }\n                        }\n                        return node.object;\n                    }\n            }\n        }\n        return value;\n    };\n    // It's worthwhile to cache the sorting of arrays of strings, since the\n    // same initial unsorted arrays tend to be encountered many times.\n    // Fortunately, we can reuse the Trie machinery to look up the sorted\n    // arrays in linear time (which is faster than sorting large arrays).\n    ObjectCanon.prototype.sortedKeys = function(obj) {\n        var keys = Object.keys(obj);\n        var node = this.pool.lookupArray(keys);\n        if (!node.keys) {\n            keys.sort();\n            var json = JSON.stringify(keys);\n            if (!(node.keys = this.keysByJSON.get(json))) {\n                this.keysByJSON.set(json, node.keys = {\n                    sorted: keys,\n                    json: json\n                });\n            }\n        }\n        return node.keys;\n    };\n    return ObjectCanon;\n}();\n //# sourceMappingURL=object-canon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9vYmplY3QtY2Fub24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ0E7QUFDNEU7QUFDdEU7QUFDdkMsU0FBU08sWUFBWUMsS0FBSztJQUN0QixJQUFJSCxvRUFBZUEsQ0FBQ0csUUFBUTtRQUN4QixPQUFPRixvREFBT0EsQ0FBQ0UsU0FDWEEsTUFBTUMsS0FBSyxDQUFDLEtBQ1ZULCtDQUFRQSxDQUFDO1lBQUVVLFdBQVdDLE9BQU9DLGNBQWMsQ0FBQ0o7UUFBTyxHQUFHQTtJQUNoRTtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxzRUFBc0U7QUFDdEUscUVBQXFFO0FBQ3JFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHlFQUF5RTtBQUN6RSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSwwRUFBMEU7QUFDMUUsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSxxREFBcUQ7QUFDckQsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRix5RUFBeUU7QUFDekUseUVBQXlFO0FBQ3pFLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEUseURBQXlEO0FBQ3pELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLG9FQUFvRTtBQUNwRSxtRUFBbUU7QUFDbkUsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSwwRUFBMEU7QUFDMUUsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSxFQUFFO0FBQ0YsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEUsb0NBQW9DO0FBQ3BDLEVBQUU7QUFDRix5RUFBeUU7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O1lBQ1pBLEtBQUtjLElBQUk7WUFDVCxJQUFJWCxPQUFPWSxLQUFLQyxTQUFTLENBQUNoQjtZQUMxQixJQUFJLENBQUVSLENBQUFBLEtBQUtRLElBQUksR0FBRyxJQUFJLENBQUN6QixVQUFVLENBQUNZLEdBQUcsQ0FBQ2dCLEtBQUksR0FBSTtnQkFDMUMsSUFBSSxDQUFDNUIsVUFBVSxDQUFDUyxHQUFHLENBQUNtQixNQUFPWCxLQUFLUSxJQUFJLEdBQUc7b0JBQUVNLFFBQVFOO29CQUFNRyxNQUFNQTtnQkFBSztZQUN0RTtRQUNKO1FBQ0EsT0FBT1gsS0FBS1EsSUFBSTtJQUNwQjtJQUNBLE9BQU9oQztBQUNYO0FBQ3VCLENBQ3ZCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkvb2JqZWN0LWNhbm9uLmpzPzEyMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFRyaWUgfSBmcm9tIFwiQHdyeS90cmllXCI7XG5pbXBvcnQgeyBjYW5Vc2VXZWFrTWFwLCBjYW5Vc2VXZWFrU2V0LCBpc05vbk51bGxPYmplY3QgYXMgaXNPYmplY3RPckFycmF5LCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5mdW5jdGlvbiBzaGFsbG93Q29weSh2YWx1ZSkge1xuICAgIGlmIChpc09iamVjdE9yQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/XG4gICAgICAgICAgICB2YWx1ZS5zbGljZSgwKVxuICAgICAgICAgICAgOiBfX2Fzc2lnbih7IF9fcHJvdG9fXzogT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSB9LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFdoZW4gcHJvZ3JhbW1lcnMgdGFsayBhYm91dCB0aGUgXCJjYW5vbmljYWwgZm9ybVwiIG9mIGFuIG9iamVjdCwgdGhleVxuLy8gdXN1YWxseSBoYXZlIHRoZSBmb2xsb3dpbmcgbWVhbmluZyBpbiBtaW5kLCB3aGljaCBJJ3ZlIGNvcGllZCBmcm9tXG4vLyBodHRwczovL2VuLndpa3Rpb25hcnkub3JnL3dpa2kvY2Fub25pY2FsX2Zvcm06XG4vL1xuLy8gMS4gQSBzdGFuZGFyZCBvciBub3JtYWwgcHJlc2VudGF0aW9uIG9mIGEgbWF0aGVtYXRpY2FsIGVudGl0eSBbb3Jcbi8vICAgIG9iamVjdF0uIEEgY2Fub25pY2FsIGZvcm0gaXMgYW4gZWxlbWVudCBvZiBhIHNldCBvZiByZXByZXNlbnRhdGl2ZXNcbi8vICAgIG9mIGVxdWl2YWxlbmNlIGNsYXNzZXMgb2YgZm9ybXMgc3VjaCB0aGF0IHRoZXJlIGlzIGEgZnVuY3Rpb24gb3Jcbi8vICAgIHByb2NlZHVyZSB3aGljaCBwcm9qZWN0cyBldmVyeSBlbGVtZW50IG9mIGVhY2ggZXF1aXZhbGVuY2UgY2xhc3Ncbi8vICAgIG9udG8gdGhhdCBvbmUgZWxlbWVudCwgdGhlIGNhbm9uaWNhbCBmb3JtIG9mIHRoYXQgZXF1aXZhbGVuY2Vcbi8vICAgIGNsYXNzLiBUaGUgY2Fub25pY2FsIGZvcm0gaXMgZXhwZWN0ZWQgdG8gYmUgc2ltcGxlciB0aGFuIHRoZSByZXN0IG9mXG4vLyAgICB0aGUgZm9ybXMgaW4gc29tZSB3YXkuXG4vL1xuLy8gVGhhdCdzIGEgbG9uZy13aW5kZWQgd2F5IG9mIHNheWluZyBhbnkgdHdvIG9iamVjdHMgdGhhdCBoYXZlIHRoZSBzYW1lXG4vLyBjYW5vbmljYWwgZm9ybSBtYXkgYmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LCBldmVuIGlmIHRoZXkgYXJlICE9PSxcbi8vIHdoaWNoIHVzdWFsbHkgbWVhbnMgdGhlIG9iamVjdHMgYXJlIHN0cnVjdHVyYWxseSBlcXVpdmFsZW50IChkZWVwbHlcbi8vIGVxdWFsKSwgYnV0IGRvbid0IG5lY2Vzc2FyaWx5IHVzZSB0aGUgc2FtZSBtZW1vcnkuXG4vL1xuLy8gTGlrZSBhIGxpdGVyYXJ5IG9yIG11c2ljYWwgY2Fub24sIHRoaXMgT2JqZWN0Q2Fub24gY2xhc3MgcmVwcmVzZW50cyBhXG4vLyBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBjYW5vbmljYWwgaXRlbXMgKEphdmFTY3JpcHQgb2JqZWN0cyksIHdpdGggdGhlXG4vLyBpbXBvcnRhbnQgcHJvcGVydHkgdGhhdCBjYW5vbi5hZG1pdChhKSA9PT0gY2Fub24uYWRtaXQoYikgaWYgYSBhbmQgYlxuLy8gYXJlIGRlZXBseSBlcXVhbCB0byBlYWNoIG90aGVyLiBJbiB0ZXJtcyBvZiB0aGUgZGVmaW5pdGlvbiBhYm92ZSwgdGhlXG4vLyBjYW5vbi5hZG1pdCBtZXRob2QgaXMgdGhlIFwiZnVuY3Rpb24gb3IgcHJvY2VkdXJlIHdoaWNoIHByb2plY3RzIGV2ZXJ5XCJcbi8vIG9iamVjdCBcIm9udG8gdGhhdCBvbmUgZWxlbWVudCwgdGhlIGNhbm9uaWNhbCBmb3JtLlwiXG4vL1xuLy8gSW4gdGhlIHdvcnN0IGNhc2UsIHRoZSBjYW5vbmljYWxpemF0aW9uIHByb2Nlc3MgbWF5IGludm9sdmUgbG9va2luZyBhdFxuLy8gZXZlcnkgcHJvcGVydHkgaW4gdGhlIHByb3ZpZGVkIG9iamVjdCB0cmVlLCBzbyBpdCB0YWtlcyB0aGUgc2FtZSBvcmRlclxuLy8gb2YgdGltZSBhcyBkZWVwIGVxdWFsaXR5IGNoZWNraW5nLiBGb3J0dW5hdGVseSwgYWxyZWFkeS1jYW5vbmljYWxpemVkXG4vLyBvYmplY3RzIGFyZSByZXR1cm5lZCBpbW1lZGlhdGVseSBmcm9tIGNhbm9uLmFkbWl0LCBzbyB0aGUgcHJlc2VuY2Ugb2Zcbi8vIGNhbm9uaWNhbCBzdWJ0cmVlcyB0ZW5kcyB0byBzcGVlZCB1cCBjYW5vbmljYWxpemF0aW9uLlxuLy9cbi8vIFNpbmNlIGNvbnN1bWVycyBvZiBjYW5vbmljYWwgb2JqZWN0cyBjYW4gY2hlY2sgZm9yIGRlZXAgZXF1YWxpdHkgaW5cbi8vIGNvbnN0YW50IHRpbWUsIGNhbm9uaWNhbGl6aW5nIGNhY2hlIHJlc3VsdHMgY2FuIG1hc3NpdmVseSBpbXByb3ZlIHRoZVxuLy8gcGVyZm9ybWFuY2Ugb2YgYXBwbGljYXRpb24gY29kZSB0aGF0IHNraXBzIHJlLXJlbmRlcmluZyB1bmNoYW5nZWRcbi8vIHJlc3VsdHMsIHN1Y2ggYXMgXCJwdXJlXCIgVUkgY29tcG9uZW50cyBpbiBhIGZyYW1ld29yayBsaWtlIFJlYWN0LlxuLy9cbi8vIE9mIGNvdXJzZSwgc2luY2UgY2Fub25pY2FsIG9iamVjdHMgbWF5IGJlIHNoYXJlZCB3aWRlbHkgYmV0d2VlblxuLy8gdW5yZWxhdGVkIGNvbnN1bWVycywgaXQncyBpbXBvcnRhbnQgdG8gdGhpbmsgb2YgdGhlbSBhcyBpbW11dGFibGUsIGV2ZW5cbi8vIHRob3VnaCB0aGV5IGFyZSBub3QgYWN0dWFsbHkgZnJvemVuIHdpdGggT2JqZWN0LmZyZWV6ZSBpbiBwcm9kdWN0aW9uLFxuLy8gZHVlIHRvIHRoZSBleHRyYSBwZXJmb3JtYW5jZSBvdmVyaGVhZCB0aGF0IGNvbWVzIHdpdGggZnJvemVuIG9iamVjdHMuXG4vL1xuLy8gQ3VzdG9tIHNjYWxhciBvYmplY3RzIHdob3NlIGludGVybmFsIGNsYXNzIG5hbWUgaXMgbmVpdGhlciBBcnJheSBub3Jcbi8vIE9iamVjdCBjYW4gYmUgaW5jbHVkZWQgc2FmZWx5IGluIHRoZSBhZG1pdHRlZCB0cmVlLCBidXQgdGhleSB3aWxsIG5vdFxuLy8gYmUgcmVwbGFjZWQgd2l0aCBhIGNhbm9uaWNhbCB2ZXJzaW9uICh0byBwdXQgaXQgYW5vdGhlciB3YXksIHRoZXkgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIGNhbm9uaWNhbCBhbHJlYWR5KS5cbi8vXG4vLyBJZiB3ZSBpZ25vcmUgY3VzdG9tIG9iamVjdHMsIG5vIGRldGVjdGlvbiBvZiBjeWNsZXMgb3IgcmVwZWF0ZWQgb2JqZWN0XG4vLyByZWZlcmVuY2VzIGlzIGN1cnJlbnRseSByZXF1aXJlZCBieSB0aGUgU3RvcmVSZWFkZXIgY2xhc3MsIHNpbmNlXG4vLyBHcmFwaFFMIHJlc3VsdCBvYmplY3RzIGFyZSBKU09OLXNlcmlhbGl6YWJsZSB0cmVlcyAoYW5kIHRodXMgY29udGFpblxuLy8gbmVpdGhlciBjeWNsZXMgbm9yIHJlcGVhdGVkIHN1YnRyZWVzKSwgc28gd2UgY2FuIGF2b2lkIHRoZSBjb21wbGV4aXR5XG4vLyBvZiBrZWVwaW5nIHRyYWNrIG9mIG9iamVjdHMgd2UndmUgYWxyZWFkeSBzZWVuIGR1cmluZyB0aGUgcmVjdXJzaW9uIG9mXG4vLyB0aGUgYWRtaXQgbWV0aG9kLlxuLy9cbi8vIEluIHRoZSBmdXR1cmUsIHdlIG1heSBjb25zaWRlciBhZGRpbmcgYWRkaXRpb25hbCBjYXNlcyB0byB0aGUgc3dpdGNoXG4vLyBzdGF0ZW1lbnQgdG8gaGFuZGxlIG90aGVyIGNvbW1vbiBvYmplY3QgdHlwZXMsIHN1Y2ggYXMgXCJbb2JqZWN0IERhdGVdXCJcbi8vIG9iamVjdHMsIGFzIG5lZWRlZC5cbnZhciBPYmplY3RDYW5vbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RDYW5vbigpIHtcbiAgICAgICAgLy8gU2V0IG9mIGFsbCBjYW5vbmljYWwgb2JqZWN0cyB0aGlzIE9iamVjdENhbm9uIGhhcyBhZG1pdHRlZCwgYWxsb3dpbmdcbiAgICAgICAgLy8gY2Fub24uYWRtaXQgdG8gcmV0dXJuIHByZXZpb3VzbHktY2Fub25pY2FsaXplZCBvYmplY3RzIGltbWVkaWF0ZWx5LlxuICAgICAgICB0aGlzLmtub3duID0gbmV3IChjYW5Vc2VXZWFrU2V0ID8gV2Vha1NldCA6IFNldCkoKTtcbiAgICAgICAgLy8gRWZmaWNpZW50IHN0b3JhZ2UvbG9va3VwIHN0cnVjdHVyZSBmb3IgY2Fub25pY2FsIG9iamVjdHMuXG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBUcmllKGNhblVzZVdlYWtNYXApO1xuICAgICAgICAvLyBNYWtlIHRoZSBPYmplY3RDYW5vbiBhc3N1bWUgdGhpcyB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIGNhbm9uaWNhbGl6ZWQuXG4gICAgICAgIHRoaXMucGFzc2VzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgLy8gQXJyYXlzIHRoYXQgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cyBpbiBhIGRpZmZlcmVudCBvcmRlciBjYW4gc2hhcmVcbiAgICAgICAgLy8gdGhlIHNhbWUgU29ydGVkS2V5c0luZm8gb2JqZWN0LCB0byBzYXZlIG1lbW9yeS5cbiAgICAgICAgdGhpcy5rZXlzQnlKU09OID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUaGlzIGhhcyB0byBjb21lIGxhc3QgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIGtleXNCeUpTT04uXG4gICAgICAgIHRoaXMuZW1wdHkgPSB0aGlzLmFkbWl0KHt9KTtcbiAgICB9XG4gICAgT2JqZWN0Q2Fub24ucHJvdG90eXBlLmlzS25vd24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0T3JBcnJheSh2YWx1ZSkgJiYgdGhpcy5rbm93bi5oYXModmFsdWUpO1xuICAgIH07XG4gICAgT2JqZWN0Q2Fub24ucHJvdG90eXBlLnBhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0T3JBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuc2V0KGNvcHksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdENhbm9uLnByb3RvdHlwZS5hZG1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNPYmplY3RPckFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5wYXNzZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAgICAgc3dpdGNoIChwcm90bykge1xuICAgICAgICAgICAgICAgIGNhc2UgQXJyYXkucHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmtub3duLmhhcyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHZhbHVlLm1hcCh0aGlzLmFkbWl0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlzIGFyZSBsb29rZWQgdXAgaW4gdGhlIFRyaWUgdXNpbmcgdGhlaXIgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsaXplZCBlbGVtZW50cywgYW5kIHRoZSBrbm93biB2ZXJzaW9uIG9mIHRoZSBhcnJheSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQgYXMgbm9kZS5hcnJheS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBvb2wubG9va3VwQXJyYXkoYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua25vd24uYWRkKChub2RlLmFycmF5ID0gYXJyYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGNhbm9uaWNhbCBhcnJheXMgbWF5IGJlIHNoYXJlZCB3aWRlbHkgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5yZWxhdGVkIGNvbnN1bWVycywgaXQncyBpbXBvcnRhbnQgdG8gcmVnYXJkIHRoZW0gYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltbXV0YWJsZSwgZXZlbiBpZiB0aGV5IGFyZSBub3QgZnJvemVuIGluIHByb2R1Y3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgY2FzZSBPYmplY3QucHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmtub3duLmhhcyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm90b18xID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5XzEgPSBbcHJvdG9fMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5zb3J0ZWRLZXlzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlfMS5wdXNoKGtleXMuanNvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFZhbHVlSW5kZXhfMSA9IGFycmF5XzEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnNvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5XzEucHVzaChfdGhpcy5hZG1pdCh2YWx1ZVtrZXldKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3RzIGFyZSBsb29rZWQgdXAgaW4gdGhlIFRyaWUgYnkgdGhlaXIgcHJvdG90eXBlICh3aGljaFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyAqbm90KiByZWN1cnNpdmVseSBjYW5vbmljYWxpemVkKSwgZm9sbG93ZWQgYnkgYSBKU09OXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIG9mIHRoZWlyIChzb3J0ZWQpIGtleXMsIGZvbGxvd2VkIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBvZiByZWN1cnNpdmVseSBjYW5vbmljYWxpemVkIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRob3NlIGtleXMuIFRvIGtlZXAgdGhlIGZpbmFsIHJlc3VsdHMgdW5hbWJpZ3VvdXMgd2l0aCBvdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZXMgKHN1Y2ggYXMgYXJyYXlzIHRoYXQganVzdCBoYXBwZW4gdG8gY29udGFpbiBbcHJvdG8sXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMuanNvbiwgdmFsdWUxLCB2YWx1ZTIsIC4uLl0pLCB0aGUga25vd24gdmVyc2lvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGlzIHN0b3JlZCBhcyBub2RlLm9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBvb2wubG9va3VwQXJyYXkoYXJyYXlfMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpfMSA9IChub2RlLm9iamVjdCA9IE9iamVjdC5jcmVhdGUocHJvdG9fMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rbm93bi5hZGQob2JqXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zb3J0ZWQuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqXzFba2V5XSA9IGFycmF5XzFbZmlyc3RWYWx1ZUluZGV4XzEgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgY2Fub25pY2FsIG9iamVjdHMgbWF5IGJlIHNoYXJlZCB3aWRlbHkgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5yZWxhdGVkIGNvbnN1bWVycywgaXQncyBpbXBvcnRhbnQgdG8gcmVnYXJkIHRoZW0gYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltbXV0YWJsZSwgZXZlbiBpZiB0aGV5IGFyZSBub3QgZnJvemVuIGluIHByb2R1Y3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUob2JqXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLy8gSXQncyB3b3J0aHdoaWxlIHRvIGNhY2hlIHRoZSBzb3J0aW5nIG9mIGFycmF5cyBvZiBzdHJpbmdzLCBzaW5jZSB0aGVcbiAgICAvLyBzYW1lIGluaXRpYWwgdW5zb3J0ZWQgYXJyYXlzIHRlbmQgdG8gYmUgZW5jb3VudGVyZWQgbWFueSB0aW1lcy5cbiAgICAvLyBGb3J0dW5hdGVseSwgd2UgY2FuIHJldXNlIHRoZSBUcmllIG1hY2hpbmVyeSB0byBsb29rIHVwIHRoZSBzb3J0ZWRcbiAgICAvLyBhcnJheXMgaW4gbGluZWFyIHRpbWUgKHdoaWNoIGlzIGZhc3RlciB0aGFuIHNvcnRpbmcgbGFyZ2UgYXJyYXlzKS5cbiAgICBPYmplY3RDYW5vbi5wcm90b3R5cGUuc29ydGVkS2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucG9vbC5sb29rdXBBcnJheShrZXlzKTtcbiAgICAgICAgaWYgKCFub2RlLmtleXMpIHtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShrZXlzKTtcbiAgICAgICAgICAgIGlmICghKG5vZGUua2V5cyA9IHRoaXMua2V5c0J5SlNPTi5nZXQoanNvbikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzQnlKU09OLnNldChqc29uLCAobm9kZS5rZXlzID0geyBzb3J0ZWQ6IGtleXMsIGpzb246IGpzb24gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmtleXM7XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0Q2Fub247XG59KCkpO1xuZXhwb3J0IHsgT2JqZWN0Q2Fub24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1jYW5vbi5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJUcmllIiwiY2FuVXNlV2Vha01hcCIsImNhblVzZVdlYWtTZXQiLCJpc05vbk51bGxPYmplY3QiLCJpc09iamVjdE9yQXJyYXkiLCJpc0FycmF5Iiwic2hhbGxvd0NvcHkiLCJ2YWx1ZSIsInNsaWNlIiwiX19wcm90b19fIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJPYmplY3RDYW5vbiIsImtub3duIiwiV2Vha1NldCIsIlNldCIsInBvb2wiLCJwYXNzZXMiLCJXZWFrTWFwIiwia2V5c0J5SlNPTiIsIk1hcCIsImVtcHR5IiwiYWRtaXQiLCJwcm90b3R5cGUiLCJpc0tub3duIiwiaGFzIiwicGFzcyIsImNvcHkiLCJzZXQiLCJfdGhpcyIsIm9yaWdpbmFsIiwiZ2V0IiwicHJvdG8iLCJBcnJheSIsImFycmF5IiwibWFwIiwibm9kZSIsImxvb2t1cEFycmF5IiwiYWRkIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJmcmVlemUiLCJwcm90b18xIiwiYXJyYXlfMSIsImtleXMiLCJzb3J0ZWRLZXlzIiwicHVzaCIsImpzb24iLCJmaXJzdFZhbHVlSW5kZXhfMSIsImxlbmd0aCIsInNvcnRlZCIsImZvckVhY2giLCJrZXkiLCJvYmplY3QiLCJvYmpfMSIsImNyZWF0ZSIsImkiLCJvYmoiLCJzb3J0IiwiSlNPTiIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/object-canon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/policies.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/policies.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Policies: function() { return /* binding */ Policies; },\n/* harmony export */   normalizeReadFieldOptions: function() { return /* binding */ normalizeReadFieldOptions; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/stringifyForDisplay.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reactiveVars.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/reactiveVars.js\");\n/* harmony import */ var _key_extractor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./key-extractor.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/key-extractor.js\");\n\n\n\n\n\n\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args : spec.field ? (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.argumentsObjectFromField)(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function() {\n    return void 0;\n};\nvar simpleKeyArgsFn = function(_args, context) {\n    return context.fieldName;\n};\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function(existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function(_, incoming) {\n    return incoming;\n};\nvar Policies = /** @class */ function() {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        // Map from subtype names to sets of supertype names. Note that this\n        // representation inverts the structure of possibleTypes (whose keys are\n        // supertypes and whose values are arrays of subtypes) because it tends\n        // to be much more efficient to search upwards than downwards.\n        this.supertypeMap = new Map();\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\n        // RegExp objects and recorded here. Every key of this map can also be\n        // found in supertypeMap. In many cases this Map will be empty, which\n        // means no fuzzy subtype checking will happen in fragmentMatches.\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            dataIdFromObject: _helpers_js__WEBPACK_IMPORTED_MODULE_3__.defaultDataIdFromObject\n        }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function(object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\n                \"ROOT_QUERY\"\n            ];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        var storeObject = partialContext && partialContext.storeObject || object;\n        var context = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, partialContext), {\n            typename: typename,\n            storeObject: storeObject,\n            readField: partialContext && partialContext.readField || function() {\n                var options = normalizeReadFieldOptions(arguments, storeObject);\n                return policies.readField(options, {\n                    store: policies.cache[\"data\"],\n                    variables: options.variables\n                });\n            }\n        });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while(keyFn){\n            var specifierOrId = keyFn((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, object), storeObject), context);\n            if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(specifierOrId)) {\n                keyFn = (0,_key_extractor_js__WEBPACK_IMPORTED_MODULE_5__.keyFieldsFnFromSpecifier)(specifierOrId);\n            } else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [\n            id,\n            context.keyObject\n        ] : [\n            id\n        ];\n    };\n    Policies.prototype.addTypePolicies = function(typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function(typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(_a, [\n                \"queryType\",\n                \"mutationType\",\n                \"subscriptionType\"\n            ]);\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType) _this.setRootTypename(\"Query\", typename);\n            if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n            if (_helpers_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            } else {\n                _this.toBeAdded[typename] = [\n                    incoming\n                ];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function(typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn = // Pass false to disable normalization for this typename.\n        keyFields === false ? nullKeyFieldsFn : (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(keyFields) ? (0,_key_extractor_js__WEBPACK_IMPORTED_MODULE_5__.keyFieldsFnFromSpecifier)(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function(fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                } else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn = // Pass false to disable argument-based differentiation of\n                    // field identities.\n                    keyArgs === false ? simpleKeyArgsFn : (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(keyArgs) ? (0,_key_extractor_js__WEBPACK_IMPORTED_MODULE_5__.keyArgsFnFromSpecifier)(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function(which, typename) {\n        if (typename === void 0) {\n            typename = which;\n        }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(!old || old === which, 5, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old) delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function(possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function(supertype) {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function(subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(_helpers_js__WEBPACK_IMPORTED_MODULE_3__.TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function(typename) {\n        var _this = this;\n        if (!_helpers_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = this.typePolicies[typename] = Object.create(null);\n            policy_1.fields = Object.create(null);\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            var supertypes_1 = this.supertypeMap.get(typename);\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes_1 = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach(function(regExp, fuzzy) {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach(function(supertype) {\n                                return supertypes_1.add(supertype);\n                            });\n                        }\n                    }\n                });\n            }\n            if (supertypes_1 && supertypes_1.size) {\n                supertypes_1.forEach(function(supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(_a, [\n                        \"fields\"\n                    ]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach(function(policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function(subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, supertypeSet = new Set());\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function(fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition) return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename) return false;\n        var supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype) return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [\n                typenameSupertypeSet\n            ];\n            var maybeEnqueue_1 = function(subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for(var i = 0; i < workQueue_1.length; ++i){\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(6, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all\n                // non-fuzzy subtypes (after the final iteration of the loop).\n                i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result\n                // after we verify the supertype, but this check is often less\n                // expensive than that search, and we will have to do the\n                // comparison anyway whenever we find a potential match.\n                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.selectionSetMatchesResult)(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function(typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function(fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while(keyFn){\n                var specifierOrString = keyFn(args, context);\n                if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(specifierOrString)) {\n                    keyFn = (0,_key_extractor_js__WEBPACK_IMPORTED_MODULE_5__.keyArgsFnFromSpecifier)(specifierOrString);\n                } else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field ? (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.storeKeyNameFromField)(fieldSpec.field, fieldSpec.variables) : (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.getStoreKeyName)(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.fieldNameFromStoreName)(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function(options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference) return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField) return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename) options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.fieldNameFromStoreName)(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return _reactiveVars_js__WEBPACK_IMPORTED_MODULE_6__.cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions\n            ]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function(typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function(existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename: typename,\n            fieldName: field.name.value,\n            field: field,\n            variables: context.variables\n        }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}();\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.fieldNameFromStoreName)(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function() {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store)\n    };\n}\nfunction normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference\n        };\n    } else {\n        options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, fieldNameOrOptions);\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!_helpers_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\n        globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(7, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.stringifyForDisplay)(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(existing) || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(incoming)) {\n            throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(8);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.isNonNullObject)(existing) && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.isNonNullObject)(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(existing) && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.storeValueIsStoreObject)(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.storeValueIsStoreObject)(existing) && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.storeValueIsStoreObject)(existing) && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.storeValueIsStoreObject)(incoming)) {\n                return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n} //# sourceMappingURL=policies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9wb2xpY2llcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5QztBQUN1QztBQUNnRjtBQUNZO0FBQzlIO0FBQ3lDO0FBQ3ZGLFNBQVNvQix1QkFBdUJDLElBQUk7SUFDaEMsT0FBUUEsS0FBS0MsSUFBSSxLQUFLLEtBQUssSUFBSUQsS0FBS0MsSUFBSSxHQUNsQ0QsS0FBS0UsS0FBSyxHQUFHbEIsNkVBQXdCQSxDQUFDZ0IsS0FBS0UsS0FBSyxFQUFFRixLQUFLRyxTQUFTLElBQzVEO0FBQ2Q7QUFDQSxJQUFJQyxrQkFBa0I7SUFBYyxPQUFPLEtBQUs7QUFBRztBQUNuRCxJQUFJQyxrQkFBa0IsU0FBVUMsS0FBSyxFQUFFQyxPQUFPO0lBQUksT0FBT0EsUUFBUUMsU0FBUztBQUFFO0FBQzVFLG9FQUFvRTtBQUNwRSxpQ0FBaUM7QUFDakMsSUFBSUMsY0FBYyxTQUFVQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsRUFBRTtJQUM5QyxJQUFJQyxlQUFlRCxHQUFHQyxZQUFZO0lBQ2xDLE9BQU9BLGFBQWFILFVBQVVDO0FBQ2xDO0FBQ0EsSUFBSUcsZUFBZSxTQUFVQyxDQUFDLEVBQUVKLFFBQVE7SUFBSSxPQUFPQTtBQUFVO0FBQzdELElBQUlLLFdBQVcsV0FBVyxHQUFJO0lBQzFCLFNBQVNBLFNBQVNDLE1BQU07UUFDcEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxZQUFZLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQztRQUNsQyxJQUFJLENBQUNDLFNBQVMsR0FBR0YsT0FBT0MsTUFBTSxDQUFDO1FBQy9CLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsdUVBQXVFO1FBQ3ZFLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNFLFlBQVksR0FBRyxJQUFJQztRQUN4QixxRUFBcUU7UUFDckUsc0VBQXNFO1FBQ3RFLHFFQUFxRTtR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QkFBOEI7Z0JBQzlCb0MsTUFBTW9CLEtBQUssQ0FBQ3pELFNBQVN3SCxLQUFLLEVBQUV2SDtnQkFDNUIsT0FBT0Q7WUFDWDtZQUNBLElBQUluQixvRUFBdUJBLENBQUNtQixhQUFhekIsZ0VBQVdBLENBQUMwQixXQUFXO2dCQUM1RCxpRUFBaUU7Z0JBQ2pFLHVFQUF1RTtnQkFDdkUsZ0VBQWdFO2dCQUNoRSxnQ0FBZ0M7Z0JBQ2hDb0MsTUFBTW9CLEtBQUssQ0FBQ3pELFVBQVVDLFNBQVN1SCxLQUFLO2dCQUNwQyxPQUFPdkg7WUFDWDtZQUNBLElBQUlwQixvRUFBdUJBLENBQUNtQixhQUN4Qm5CLG9FQUF1QkEsQ0FBQ29CLFdBQVc7Z0JBQ25DLE9BQU9oQywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHK0IsV0FBV0M7WUFDNUM7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkvcG9saWNpZXMuanM/NGVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQsIG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9nbG9iYWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzdG9yZUtleU5hbWVGcm9tRmllbGQsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZCwgaXNSZWZlcmVuY2UsIGdldFN0b3JlS2V5TmFtZSwgaXNOb25OdWxsT2JqZWN0LCBzdHJpbmdpZnlGb3JEaXNwbGF5LCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGhhc093biwgZmllbGROYW1lRnJvbVN0b3JlTmFtZSwgc3RvcmVWYWx1ZUlzU3RvcmVPYmplY3QsIHNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQsIFR5cGVPckZpZWxkTmFtZVJlZ0V4cCwgZGVmYXVsdERhdGFJZEZyb21PYmplY3QsIGlzQXJyYXksIH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgY2FjaGVTbG90IH0gZnJvbSBcIi4vcmVhY3RpdmVWYXJzLmpzXCI7XG5pbXBvcnQgeyBrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyLCBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIsIH0gZnJvbSBcIi4va2V5LWV4dHJhY3Rvci5qc1wiO1xuZnVuY3Rpb24gYXJnc0Zyb21GaWVsZFNwZWNpZmllcihzcGVjKSB7XG4gICAgcmV0dXJuIChzcGVjLmFyZ3MgIT09IHZvaWQgMCA/IHNwZWMuYXJnc1xuICAgICAgICA6IHNwZWMuZmllbGQgPyBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQoc3BlYy5maWVsZCwgc3BlYy52YXJpYWJsZXMpXG4gICAgICAgICAgICA6IG51bGwpO1xufVxudmFyIG51bGxLZXlGaWVsZHNGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgMDsgfTtcbnZhciBzaW1wbGVLZXlBcmdzRm4gPSBmdW5jdGlvbiAoX2FyZ3MsIGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQuZmllbGROYW1lOyB9O1xuLy8gVGhlc2UgbWVyZ2UgZnVuY3Rpb25zIGNhbiBiZSBzZWxlY3RlZCBieSBzcGVjaWZ5aW5nIG1lcmdlOnRydWUgb3Jcbi8vIG1lcmdlOmZhbHNlIGluIGEgZmllbGQgcG9saWN5LlxudmFyIG1lcmdlVHJ1ZUZuID0gZnVuY3Rpb24gKGV4aXN0aW5nLCBpbmNvbWluZywgX2EpIHtcbiAgICB2YXIgbWVyZ2VPYmplY3RzID0gX2EubWVyZ2VPYmplY3RzO1xuICAgIHJldHVybiBtZXJnZU9iamVjdHMoZXhpc3RpbmcsIGluY29taW5nKTtcbn07XG52YXIgbWVyZ2VGYWxzZUZuID0gZnVuY3Rpb24gKF8sIGluY29taW5nKSB7IHJldHVybiBpbmNvbWluZzsgfTtcbnZhciBQb2xpY2llcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2xpY2llcyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZVBvbGljaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50b0JlQWRkZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBNYXAgZnJvbSBzdWJ0eXBlIG5hbWVzIHRvIHNldHMgb2Ygc3VwZXJ0eXBlIG5hbWVzLiBOb3RlIHRoYXQgdGhpc1xuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBpbnZlcnRzIHRoZSBzdHJ1Y3R1cmUgb2YgcG9zc2libGVUeXBlcyAod2hvc2Uga2V5cyBhcmVcbiAgICAgICAgLy8gc3VwZXJ0eXBlcyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBhcnJheXMgb2Ygc3VidHlwZXMpIGJlY2F1c2UgaXQgdGVuZHNcbiAgICAgICAgLy8gdG8gYmUgbXVjaCBtb3JlIGVmZmljaWVudCB0byBzZWFyY2ggdXB3YXJkcyB0aGFuIGRvd253YXJkcy5cbiAgICAgICAgdGhpcy5zdXBlcnR5cGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEFueSBmdXp6eSBzdWJ0eXBlcyBzcGVjaWZpZWQgYnkgcG9zc2libGVUeXBlcyB3aWxsIGJlIGNvbnZlcnRlZCB0b1xuICAgICAgICAvLyBSZWdFeHAgb2JqZWN0cyBhbmQgcmVjb3JkZWQgaGVyZS4gRXZlcnkga2V5IG9mIHRoaXMgbWFwIGNhbiBhbHNvIGJlXG4gICAgICAgIC8vIGZvdW5kIGluIHN1cGVydHlwZU1hcC4gSW4gbWFueSBjYXNlcyB0aGlzIE1hcCB3aWxsIGJlIGVtcHR5LCB3aGljaFxuICAgICAgICAvLyBtZWFucyBubyBmdXp6eSBzdWJ0eXBlIGNoZWNraW5nIHdpbGwgaGFwcGVuIGluIGZyYWdtZW50TWF0Y2hlcy5cbiAgICAgICAgdGhpcy5mdXp6eVN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJvb3RJZHNCeVR5cGVuYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yb290VHlwZW5hbWVzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudXNpbmdQb3NzaWJsZVR5cGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uZmlnID0gX19hc3NpZ24oeyBkYXRhSWRGcm9tT2JqZWN0OiBkZWZhdWx0RGF0YUlkRnJvbU9iamVjdCB9LCBjb25maWcpO1xuICAgICAgICB0aGlzLmNhY2hlID0gdGhpcy5jb25maWcuY2FjaGU7XG4gICAgICAgIHRoaXMuc2V0Um9vdFR5cGVuYW1lKFwiUXVlcnlcIik7XG4gICAgICAgIHRoaXMuc2V0Um9vdFR5cGVuYW1lKFwiTXV0YXRpb25cIik7XG4gICAgICAgIHRoaXMuc2V0Um9vdFR5cGVuYW1lKFwiU3Vic2NyaXB0aW9uXCIpO1xuICAgICAgICBpZiAoY29uZmlnLnBvc3NpYmxlVHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zc2libGVUeXBlcyhjb25maWcucG9zc2libGVUeXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50eXBlUG9saWNpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHlwZVBvbGljaWVzKGNvbmZpZy50eXBlUG9saWNpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvbGljaWVzLnByb3RvdHlwZS5pZGVudGlmeSA9IGZ1bmN0aW9uIChvYmplY3QsIHBhcnRpYWxDb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHBvbGljaWVzID0gdGhpcztcbiAgICAgICAgdmFyIHR5cGVuYW1lID0gKHBhcnRpYWxDb250ZXh0ICYmXG4gICAgICAgICAgICAocGFydGlhbENvbnRleHQudHlwZW5hbWUgfHwgKChfYSA9IHBhcnRpYWxDb250ZXh0LnN0b3JlT2JqZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX190eXBlbmFtZSkpKSB8fFxuICAgICAgICAgICAgb2JqZWN0Ll9fdHlwZW5hbWU7XG4gICAgICAgIC8vIEl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB3cml0ZSByb290IFF1ZXJ5IGZpZWxkcyB3aXRoIHdyaXRlRnJhZ21lbnQsXG4gICAgICAgIC8vIHVzaW5nIHsgX190eXBlbmFtZTogXCJRdWVyeVwiLCAuLi4gfSBhcyB0aGUgZGF0YSwgYnV0IGl0IGRvZXMgbm90IG1ha2VcbiAgICAgICAgLy8gc2Vuc2UgdG8gYWxsb3cgdGhlIHNhbWUgaWRlbnRpZmljYXRpb24gYmVoYXZpb3IgZm9yIHRoZSBNdXRhdGlvbiBhbmRcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHR5cGVzLCBzaW5jZSBhcHBsaWNhdGlvbiBjb2RlIHNob3VsZCBuZXZlciBiZSB3cml0aW5nXG4gICAgICAgIC8vIGRpcmVjdGx5IHRvIChvciByZWFkaW5nIGRpcmVjdGx5IGZyb20pIHRob3NlIHJvb3Qgb2JqZWN0cy5cbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkLlJPT1RfUVVFUlkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXCJST09UX1FVRVJZXCJdO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgY29udGV4dC5zdG9yZU9iamVjdCB0byBvYmplY3QgaWYgbm90IG90aGVyd2lzZSBwcm92aWRlZC5cbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gKHBhcnRpYWxDb250ZXh0ICYmIHBhcnRpYWxDb250ZXh0LnN0b3JlT2JqZWN0KSB8fCBvYmplY3Q7XG4gICAgICAgIHZhciBjb250ZXh0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcnRpYWxDb250ZXh0KSwgeyB0eXBlbmFtZTogdHlwZW5hbWUsIHN0b3JlT2JqZWN0OiBzdG9yZU9iamVjdCwgcmVhZEZpZWxkOiAocGFydGlhbENvbnRleHQgJiYgcGFydGlhbENvbnRleHQucmVhZEZpZWxkKSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKGFyZ3VtZW50cywgc3RvcmVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9saWNpZXMucmVhZEZpZWxkKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBwb2xpY2llcy5jYWNoZVtcImRhdGFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0eXBlbmFtZSAmJiB0aGlzLmdldFR5cGVQb2xpY3kodHlwZW5hbWUpO1xuICAgICAgICB2YXIga2V5Rm4gPSAocG9saWN5ICYmIHBvbGljeS5rZXlGbikgfHwgdGhpcy5jb25maWcuZGF0YUlkRnJvbU9iamVjdDtcbiAgICAgICAgd2hpbGUgKGtleUZuKSB7XG4gICAgICAgICAgICB2YXIgc3BlY2lmaWVyT3JJZCA9IGtleUZuKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvYmplY3QpLCBzdG9yZU9iamVjdCksIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3BlY2lmaWVyT3JJZCkpIHtcbiAgICAgICAgICAgICAgICBrZXlGbiA9IGtleUZpZWxkc0ZuRnJvbVNwZWNpZmllcihzcGVjaWZpZXJPcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkID0gc3BlY2lmaWVyT3JJZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZCA9IGlkID8gU3RyaW5nKGlkKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQua2V5T2JqZWN0ID8gW2lkLCBjb250ZXh0LmtleU9iamVjdF0gOiBbaWRdO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmFkZFR5cGVQb2xpY2llcyA9IGZ1bmN0aW9uICh0eXBlUG9saWNpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModHlwZVBvbGljaWVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlbmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdHlwZVBvbGljaWVzW3R5cGVuYW1lXSwgcXVlcnlUeXBlID0gX2EucXVlcnlUeXBlLCBtdXRhdGlvblR5cGUgPSBfYS5tdXRhdGlvblR5cGUsIHN1YnNjcmlwdGlvblR5cGUgPSBfYS5zdWJzY3JpcHRpb25UeXBlLCBpbmNvbWluZyA9IF9fcmVzdChfYSwgW1wicXVlcnlUeXBlXCIsIFwibXV0YXRpb25UeXBlXCIsIFwic3Vic2NyaXB0aW9uVHlwZVwiXSk7XG4gICAgICAgICAgICAvLyBUaG91Z2gge3F1ZXJ5LG11dGF0aW9uLHN1YnNjcmlwdGlvbn1UeXBlIGNvbmZpZ3VyYXRpb25zIGFyZSByYXJlLFxuICAgICAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gY2FsbCBzZXRSb290VHlwZW5hbWUgYXMgZWFybHkgYXMgcG9zc2libGUsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGVzZSBjb25maWd1cmF0aW9ucyBzaG91bGQgYXBwbHkgY29uc2lzdGVudGx5IGZvciB0aGVcbiAgICAgICAgICAgIC8vIGVudGlyZSBsaWZldGltZSBvZiB0aGUgY2FjaGUuIEFsc28sIHNpbmNlIG9ubHkgb25lIF9fdHlwZW5hbWUgY2FuXG4gICAgICAgICAgICAvLyBxdWFsaWZ5IGFzIG9uZSBvZiB0aGVzZSByb290IHR5cGVzLCB0aGVzZSB0aHJlZSBwcm9wZXJ0aWVzIGNhbm5vdFxuICAgICAgICAgICAgLy8gYmUgaW5oZXJpdGVkLCB1bmxpa2UgdGhlIHJlc3Qgb2YgdGhlIGluY29taW5nIHByb3BlcnRpZXMuIFRoYXRcbiAgICAgICAgICAgIC8vIHJlc3RyaWN0aW9uIGlzIGNvbnZlbmllbnQsIGJlY2F1c2UgdGhlIHB1cnBvc2Ugb2YgdGhpcy50b0JlQWRkZWRcbiAgICAgICAgICAgIC8vIGlzIHRvIGRlbGF5IHRoZSBwcm9jZXNzaW5nIG9mIHR5cGUvZmllbGQgcG9saWNpZXMgdW50aWwgdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZXkncmUgdXNlZCwgYWxsb3dpbmcgcG9saWNpZXMgdG8gYmUgYWRkZWQgaW4gYW55IG9yZGVyIGFzXG4gICAgICAgICAgICAvLyBsb25nIGFzIGFsbCByZWxldmFudCBwb2xpY2llcyAoaW5jbHVkaW5nIHBvbGljaWVzIGZvciBzdXBlcnR5cGVzKVxuICAgICAgICAgICAgLy8gaGF2ZSBiZWVuIGFkZGVkIGJ5IHRoZSB0aW1lIGEgZ2l2ZW4gcG9saWN5IGlzIHVzZWQgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgLy8gdGltZS4gSW4gb3RoZXIgd29yZHMsIHNpbmNlIGluaGVyaXRhbmNlIGRvZXNuJ3QgbWF0dGVyIGZvciB0aGVzZVxuICAgICAgICAgICAgLy8gcHJvcGVydGllcywgdGhlcmUncyBhbHNvIG5vIG5lZWQgdG8gZGVsYXkgdGhlaXIgcHJvY2Vzc2luZyB1c2luZ1xuICAgICAgICAgICAgLy8gdGhlIHRoaXMudG9CZUFkZGVkIHF1ZXVlLlxuICAgICAgICAgICAgaWYgKHF1ZXJ5VHlwZSlcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRSb290VHlwZW5hbWUoXCJRdWVyeVwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIk11dGF0aW9uXCIsIHR5cGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIlN1YnNjcmlwdGlvblwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoX3RoaXMudG9CZUFkZGVkLCB0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b0JlQWRkZWRbdHlwZW5hbWVdLnB1c2goaW5jb21pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudG9CZUFkZGVkW3R5cGVuYW1lXSA9IFtpbmNvbWluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnVwZGF0ZVR5cGVQb2xpY3kgPSBmdW5jdGlvbiAodHlwZW5hbWUsIGluY29taW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0VHlwZVBvbGljeSh0eXBlbmFtZSk7XG4gICAgICAgIHZhciBrZXlGaWVsZHMgPSBpbmNvbWluZy5rZXlGaWVsZHMsIGZpZWxkcyA9IGluY29taW5nLmZpZWxkcztcbiAgICAgICAgZnVuY3Rpb24gc2V0TWVyZ2UoZXhpc3RpbmcsIG1lcmdlKSB7XG4gICAgICAgICAgICBleGlzdGluZy5tZXJnZSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG1lcmdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXJnZVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIG1lcmdlOnRydWUgYXMgYSBzaG9ydGhhbmQgZm9yIGEgbWVyZ2UgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCByZXR1cm5zIG9wdGlvbnMubWVyZ2VPYmplY3RzKGV4aXN0aW5nLCBpbmNvbWluZykuXG4gICAgICAgICAgICAgICAgICAgIDogbWVyZ2UgPT09IHRydWUgPyBtZXJnZVRydWVGblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBtZXJnZTpmYWxzZSB0byBtYWtlIGluY29taW5nIGFsd2F5cyByZXBsYWNlIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IGFueSB3YXJuaW5ncyBhYm91dCBkYXRhIGNsb2JiZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1lcmdlID09PSBmYWxzZSA/IG1lcmdlRmFsc2VGblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXhpc3RpbmcubWVyZ2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZSBwb2xpY2llcyBjYW4gZGVmaW5lIG1lcmdlIGZ1bmN0aW9ucywgYXMgYW4gYWx0ZXJuYXRpdmUgdG9cbiAgICAgICAgLy8gdXNpbmcgZmllbGQgcG9saWNpZXMgdG8gbWVyZ2UgY2hpbGQgb2JqZWN0cy5cbiAgICAgICAgc2V0TWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLm1lcmdlKTtcbiAgICAgICAgZXhpc3Rpbmcua2V5Rm4gPVxuICAgICAgICAgICAgLy8gUGFzcyBmYWxzZSB0byBkaXNhYmxlIG5vcm1hbGl6YXRpb24gZm9yIHRoaXMgdHlwZW5hbWUuXG4gICAgICAgICAgICBrZXlGaWVsZHMgPT09IGZhbHNlID8gbnVsbEtleUZpZWxkc0ZuXG4gICAgICAgICAgICAgICAgLy8gUGFzcyBhbiBhcnJheSBvZiBzdHJpbmdzIHRvIHVzZSB0aG9zZSBmaWVsZHMgdG8gY29tcHV0ZSBhXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlIElEIGZvciBvYmplY3RzIG9mIHRoaXMgdHlwZW5hbWUuXG4gICAgICAgICAgICAgICAgOiBpc0FycmF5KGtleUZpZWxkcykgPyBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoa2V5RmllbGRzKVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGEgZnVuY3Rpb24gdG8gdGFrZSBmdWxsIGNvbnRyb2wgb3ZlciBpZGVudGlmaWNhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Yga2V5RmllbGRzID09PSBcImZ1bmN0aW9uXCIgPyBrZXlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlYXZlIGV4aXN0aW5nLmtleUZuIHVuY2hhbmdlZCBpZiBhYm92ZSBjYXNlcyBmYWlsLlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBleGlzdGluZy5rZXlGbjtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBfdGhpcy5nZXRGaWVsZFBvbGljeSh0eXBlbmFtZSwgZmllbGROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jb21pbmcgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluY29taW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucmVhZCA9IGluY29taW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFyZ3MgPSBpbmNvbWluZy5rZXlBcmdzLCByZWFkID0gaW5jb21pbmcucmVhZCwgbWVyZ2UgPSBpbmNvbWluZy5tZXJnZTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBmYWxzZSB0byBkaXNhYmxlIGFyZ3VtZW50LWJhc2VkIGRpZmZlcmVudGlhdGlvbiBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaWRlbnRpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUFyZ3MgPT09IGZhbHNlID8gc2ltcGxlS2V5QXJnc0ZuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBhbiBhcnJheSBvZiBzdHJpbmdzIHRvIHVzZSBuYW1lZCBhcmd1bWVudHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGEgY29tcG9zaXRlIGlkZW50aXR5IGZvciB0aGUgZmllbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc0FycmF5KGtleUFyZ3MpID8ga2V5QXJnc0ZuRnJvbVNwZWNpZmllcihrZXlBcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGEgZnVuY3Rpb24gdG8gdGFrZSBmdWxsIGNvbnRyb2wgb3ZlciBmaWVsZCBpZGVudGl0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Yga2V5QXJncyA9PT0gXCJmdW5jdGlvblwiID8ga2V5QXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmUgZXhpc3Rpbmcua2V5Rm4gdW5jaGFuZ2VkIGlmIGFib3ZlIGNhc2VzIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4aXN0aW5nLmtleUZuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucmVhZCA9IHJlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0TWVyZ2UoZXhpc3RpbmcsIG1lcmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nLnJlYWQgJiYgZXhpc3RpbmcubWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBib3RoIGEgcmVhZCBhbmQgYSBtZXJnZSBmdW5jdGlvbiwgYXNzdW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleUFyZ3M6ZmFsc2UsIGJlY2F1c2UgcmVhZCBhbmQgbWVyZ2UgdG9nZXRoZXIgY2FuIHRha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2liaWxpdHkgZm9yIGludGVycHJldGluZyBhcmd1bWVudHMgaW4gYW5kIG91dC4gVGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGFzc3VtcHRpb24gY2FuIGFsd2F5cyBiZSBvdmVycmlkZGVuIGJ5IHNwZWNpZnlpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5QXJncyBleHBsaWNpdGx5IGluIHRoZSBGaWVsZFBvbGljeS5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm4gPSBleGlzdGluZy5rZXlGbiB8fCBzaW1wbGVLZXlBcmdzRm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5zZXRSb290VHlwZW5hbWUgPSBmdW5jdGlvbiAod2hpY2gsIHR5cGVuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlbmFtZSA9PT0gdm9pZCAwKSB7IHR5cGVuYW1lID0gd2hpY2g7IH1cbiAgICAgICAgdmFyIHJvb3RJZCA9IFwiUk9PVF9cIiArIHdoaWNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkW3Jvb3RJZF07XG4gICAgICAgIGlmICh0eXBlbmFtZSAhPT0gb2xkKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQoIW9sZCB8fCBvbGQgPT09IHdoaWNoLCA1LCB3aGljaCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZGVsZXRlIGFueSBvbGQgX190eXBlbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByb290SWQgZnJvbVxuICAgICAgICAgICAgLy8gcm9vdElkc0J5VHlwZW5hbWUuXG4gICAgICAgICAgICBpZiAob2xkKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJvb3RJZHNCeVR5cGVuYW1lW29sZF07XG4gICAgICAgICAgICAvLyBOb3cgbWFrZSB0aGlzIHRoZSBvbmx5IF9fdHlwZW5hbWUgdGhhdCBtYXBzIHRvIHRoaXMgcm9vdElkLlxuICAgICAgICAgICAgdGhpcy5yb290SWRzQnlUeXBlbmFtZVt0eXBlbmFtZV0gPSByb290SWQ7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIF9fdHlwZW5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcm9vdElkLlxuICAgICAgICAgICAgdGhpcy5yb290VHlwZW5hbWVzQnlJZFtyb290SWRdID0gdHlwZW5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5hZGRQb3NzaWJsZVR5cGVzID0gZnVuY3Rpb24gKHBvc3NpYmxlVHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51c2luZ1Bvc3NpYmxlVHlwZXMgPSB0cnVlO1xuICAgICAgICBPYmplY3Qua2V5cyhwb3NzaWJsZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdXBlcnR5cGUpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgdHlwZXMgaGF2ZSBhbiBlbnRyeSBpbiB0aGlzLnN1cGVydHlwZU1hcCwgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhlaXIgc3VwZXJ0eXBlIHNldCBpcyBlbXB0eSwgc28gd2UgY2FuIHJldHVybiBmYWxzZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gZnJvbSBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMgZm9yIHVua25vd24gc3VwZXJ0eXBlcy5cbiAgICAgICAgICAgIF90aGlzLmdldFN1cGVydHlwZVNldChzdXBlcnR5cGUsIHRydWUpO1xuICAgICAgICAgICAgcG9zc2libGVUeXBlc1tzdXBlcnR5cGVdLmZvckVhY2goZnVuY3Rpb24gKHN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRTdXBlcnR5cGVTZXQoc3VidHlwZSwgdHJ1ZSkuYWRkKHN1cGVydHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gc3VidHlwZS5tYXRjaChUeXBlT3JGaWVsZE5hbWVSZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMF0gIT09IHN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBEb24ndCBpbnRlcnByZXQganVzdCBhbnkgaW52YWxpZCB0eXBlbmFtZSBhcyBhIFJlZ0V4cC5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZnV6enlTdWJ0eXBlcy5zZXQoc3VidHlwZSwgbmV3IFJlZ0V4cChzdWJ0eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmdldFR5cGVQb2xpY3kgPSBmdW5jdGlvbiAodHlwZW5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0aGlzLnR5cGVQb2xpY2llcywgdHlwZW5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcG9saWN5XzEgPSAodGhpcy50eXBlUG9saWNpZXNbdHlwZW5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICBwb2xpY3lfMS5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgVHlwZVBvbGljeSBmb3IgdHlwZW5hbWUgaXMgZmlyc3QgYWNjZXNzZWQsIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggYW4gZW1wdHkgcG9saWN5IG9iamVjdCwgaW5oZXJpdCBhbnkgcHJvcGVydGllcyBvclxuICAgICAgICAgICAgLy8gZmllbGRzIGZyb20gdGhlIHR5cGUgcG9saWNpZXMgb2YgdGhlIHN1cGVydHlwZXMgb2YgdHlwZW5hbWUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQW55IHByb3BlcnRpZXMgb3IgZmllbGRzIGRlZmluZWQgZXhwbGljaXRseSB3aXRoaW4gdGhlIFR5cGVQb2xpY3lcbiAgICAgICAgICAgIC8vIGZvciB0eXBlbmFtZSB3aWxsIHRha2UgcHJlY2VkZW5jZSwgYW5kIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gc3VwZXJ0eXBlcywgdGhlIHByb3BlcnRpZXMgb2YgcG9saWNpZXMgd2hvc2UgdHlwZXMgd2VyZSBhZGRlZFxuICAgICAgICAgICAgLy8gbGF0ZXIgdmlhIGFkZFBvc3NpYmxlVHlwZXMgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aG9zZSBvZlxuICAgICAgICAgICAgLy8gZWFybGllciBzdXBlcnR5cGVzLiBUT0RPIFBlcmhhcHMgd2Ugc2hvdWxkIHdhcm4gYWJvdXQgdGhlc2VcbiAgICAgICAgICAgIC8vIGNvbmZsaWN0cyBpbiBkZXZlbG9wbWVudCwgYW5kIHJlY29tbWVuZCBkZWZpbmluZyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgaW4gdGhlIHN1YnR5cGUgcG9saWN5P1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZpZWxkIHBvbGljeSBpbmhlcml0YW5jZSBpcyBhdG9taWMvc2hhbGxvdzogeW91IGNhbid0IGluaGVyaXQgYVxuICAgICAgICAgICAgLy8gZmllbGQgcG9saWN5IGFuZCB0aGVuIG92ZXJyaWRlIGp1c3QgaXRzIHJlYWQgZnVuY3Rpb24sIHNpbmNlIHJlYWRcbiAgICAgICAgICAgIC8vIGFuZCBtZXJnZSBmdW5jdGlvbnMgb2Z0ZW4gbmVlZCB0byBjb29wZXJhdGUsIHNvIGNoYW5naW5nIG9ubHkgb25lXG4gICAgICAgICAgICAvLyBvZiB0aGVtIHdvdWxkIGJlIGEgcmVjaXBlIGZvciBpbmNvbnNpc3RlbmN5LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE9uY2UgdGhlIFR5cGVQb2xpY3kgZm9yIHR5cGVuYW1lIGhhcyBiZWVuIGFjY2Vzc2VkLCBpdHMgcHJvcGVydGllcyBjYW5cbiAgICAgICAgICAgIC8vIHN0aWxsIGJlIHVwZGF0ZWQgZGlyZWN0bHkgdXNpbmcgYWRkVHlwZVBvbGljaWVzLCBidXQgZnV0dXJlIGNoYW5nZXMgdG9cbiAgICAgICAgICAgIC8vIGluaGVyaXRlZCBzdXBlcnR5cGUgcG9saWNpZXMgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluIHRoaXMgc3VidHlwZVxuICAgICAgICAgICAgLy8gcG9saWN5LCBiZWNhdXNlIHRoaXMgY29kZSBydW5zIGF0IG1vc3Qgb25jZSBwZXIgdHlwZW5hbWUuXG4gICAgICAgICAgICB2YXIgc3VwZXJ0eXBlc18xID0gdGhpcy5zdXBlcnR5cGVNYXAuZ2V0KHR5cGVuYW1lKTtcbiAgICAgICAgICAgIGlmICghc3VwZXJ0eXBlc18xICYmIHRoaXMuZnV6enlTdWJ0eXBlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gVG8gbWFrZSB0aGUgaW5oZXJpdGFuY2UgbG9naWMgd29yayBmb3IgdW5rbm93biB0eXBlbmFtZSBzdHJpbmdzIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBtYXkgaGF2ZSBmdXp6eSBzdXBlcnR5cGVzLCB3ZSBnaXZlIHRoaXMgdHlwZW5hbWUgYW4gZW1wdHkgc3VwZXJ0eXBlXG4gICAgICAgICAgICAgICAgLy8gc2V0IGFuZCB0aGVuIHBvcHVsYXRlIGl0IHdpdGggYW55IGZ1enp5IHN1cGVydHlwZXMgdGhhdCBtYXRjaC5cbiAgICAgICAgICAgICAgICBzdXBlcnR5cGVzXzEgPSB0aGlzLmdldFN1cGVydHlwZVNldCh0eXBlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciB0eXBlbmFtZXMgdGhhdCBhcmUgZGlyZWN0bHkgbWF0Y2hlZCBieSBhIGZ1enp5XG4gICAgICAgICAgICAgICAgLy8gc3VwZXJ0eXBlLiBXaGF0IGlmIHRoZXJlIGlzIGFuIGludGVybWVkaWF0ZSBjaGFpbiBvZiBzdXBlcnR5cGVzP1xuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHBvc3NpYmxlLCB0aGF0IHNpdHVhdGlvbiBjYW4gb25seSBiZSBzb2x2ZWQgZWZmZWN0aXZlbHkgYnlcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZ5aW5nIHRoZSBpbnRlcm1lZGlhdGUgcmVsYXRpb25zaGlwcyB2aWEgcG9zc2libGVUeXBlcywgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAvLyBhbmQgaW4gYSBub24tZnV6enkgd2F5LlxuICAgICAgICAgICAgICAgIHRoaXMuZnV6enlTdWJ0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdFeHAsIGZ1enp5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdFeHAudGVzdCh0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmdXp6eSBwYXJhbWV0ZXIgaXMganVzdCB0aGUgb3JpZ2luYWwgc3RyaW5nIHZlcnNpb24gb2YgcmVnRXhwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobm90IGEgdmFsaWQgX190eXBlbmFtZSBzdHJpbmcpLCBidXQgd2UgY2FuIGxvb2sgdXAgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHN1cGVydHlwZShzKSBpbiB0aGlzLnN1cGVydHlwZU1hcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdXp6eVN1cGVydHlwZXMgPSBfdGhpcy5zdXBlcnR5cGVNYXAuZ2V0KGZ1enp5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdXp6eVN1cGVydHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdXp6eVN1cGVydHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VwZXJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlcnR5cGVzXzEuYWRkKHN1cGVydHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBlcnR5cGVzXzEgJiYgc3VwZXJ0eXBlc18xLnNpemUpIHtcbiAgICAgICAgICAgICAgICBzdXBlcnR5cGVzXzEuZm9yRWFjaChmdW5jdGlvbiAoc3VwZXJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmdldFR5cGVQb2xpY3koc3VwZXJ0eXBlKSwgZmllbGRzID0gX2EuZmllbGRzLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmaWVsZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBvbGljeV8xLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwb2xpY3lfMS5maWVsZHMsIGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluYm94ID0gdGhpcy50b0JlQWRkZWRbdHlwZW5hbWVdO1xuICAgICAgICBpZiAoaW5ib3ggJiYgaW5ib3gubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgcGVuZGluZyBwb2xpY2llcyBpbnRvIHRoaXMudHlwZVBvbGljaWVzLCBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgICAgICAgLy8gd2VyZSBvcmlnaW5hbGx5IHBhc3NlZCB0byBhZGRUeXBlUG9saWN5LlxuICAgICAgICAgICAgaW5ib3guc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHBvbGljeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVR5cGVQb2xpY3kodHlwZW5hbWUsIHBvbGljeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlUG9saWNpZXNbdHlwZW5hbWVdO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmdldEZpZWxkUG9saWN5ID0gZnVuY3Rpb24gKHR5cGVuYW1lLCBmaWVsZE5hbWUsIGNyZWF0ZUlmTWlzc2luZykge1xuICAgICAgICBpZiAodHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZFBvbGljaWVzID0gdGhpcy5nZXRUeXBlUG9saWN5KHR5cGVuYW1lKS5maWVsZHM7XG4gICAgICAgICAgICByZXR1cm4gKGZpZWxkUG9saWNpZXNbZmllbGROYW1lXSB8fFxuICAgICAgICAgICAgICAgIChjcmVhdGVJZk1pc3NpbmcgJiYgKGZpZWxkUG9saWNpZXNbZmllbGROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRTdXBlcnR5cGVTZXQgPSBmdW5jdGlvbiAoc3VidHlwZSwgY3JlYXRlSWZNaXNzaW5nKSB7XG4gICAgICAgIHZhciBzdXBlcnR5cGVTZXQgPSB0aGlzLnN1cGVydHlwZU1hcC5nZXQoc3VidHlwZSk7XG4gICAgICAgIGlmICghc3VwZXJ0eXBlU2V0ICYmIGNyZWF0ZUlmTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5zdXBlcnR5cGVNYXAuc2V0KHN1YnR5cGUsIChzdXBlcnR5cGVTZXQgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXJ0eXBlU2V0O1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmZyYWdtZW50TWF0Y2hlcyA9IGZ1bmN0aW9uIChmcmFnbWVudCwgdHlwZW5hbWUsIHJlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZnJhZ21lbnQudHlwZUNvbmRpdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgZnJhZ21lbnQgaGFzIGEgdHlwZSBjb25kaXRpb24gYnV0IHRoZSBvYmplY3Qgd2UncmUgbWF0Y2hpbmdcbiAgICAgICAgLy8gYWdhaW5zdCBkb2VzIG5vdCBoYXZlIGEgX190eXBlbmFtZSwgdGhlIGZyYWdtZW50IGNhbm5vdCBtYXRjaC5cbiAgICAgICAgaWYgKCF0eXBlbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHN1cGVydHlwZSA9IGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgLy8gQ29tbW9uIGNhc2U6IGZyYWdtZW50IHR5cGUgY29uZGl0aW9uIGFuZCBfX3R5cGVuYW1lIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSBzdXBlcnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNpbmdQb3NzaWJsZVR5cGVzICYmIHRoaXMuc3VwZXJ0eXBlTWFwLmhhcyhzdXBlcnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWVTdXBlcnR5cGVTZXQgPSB0aGlzLmdldFN1cGVydHlwZVNldCh0eXBlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgd29ya1F1ZXVlXzEgPSBbdHlwZW5hbWVTdXBlcnR5cGVTZXRdO1xuICAgICAgICAgICAgdmFyIG1heWJlRW5xdWV1ZV8xID0gZnVuY3Rpb24gKHN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJ0eXBlU2V0ID0gX3RoaXMuZ2V0U3VwZXJ0eXBlU2V0KHN1YnR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VwZXJ0eXBlU2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHN1cGVydHlwZVNldC5zaXplICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtRdWV1ZV8xLmluZGV4T2Yoc3VwZXJ0eXBlU2V0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1F1ZXVlXzEucHVzaChzdXBlcnR5cGVTZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGZ1enp5IHN1YnR5cGVzIG9ubHkgaWYgd2UgZW5jb3VudGVyZWQgZnV6enlcbiAgICAgICAgICAgIC8vIHN1YnR5cGUgc3RyaW5ncyBpbiBhZGRQb3NzaWJsZVR5cGVzLCBhbmQgb25seSB3aGlsZSB3cml0aW5nIHRvXG4gICAgICAgICAgICAvLyB0aGUgY2FjaGUsIHNpbmNlIHRoYXQncyB3aGVuIHNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQgZ2l2ZXMgYVxuICAgICAgICAgICAgLy8gc3Ryb25nIHNpZ25hbCBvZiBmcmFnbWVudCBtYXRjaGluZy4gVGhlIFN0b3JlUmVhZGVyIGNsYXNzIGNhbGxzXG4gICAgICAgICAgICAvLyBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMgd2l0aG91dCBwYXNzaW5nIGEgcmVzdWx0IG9iamVjdCwgc29cbiAgICAgICAgICAgIC8vIG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyBpcyBhbHdheXMgZmFsc2Ugd2hpbGUgcmVhZGluZy5cbiAgICAgICAgICAgIHZhciBuZWVkVG9DaGVja0Z1enp5U3VidHlwZXMgPSAhIShyZXN1bHQgJiYgdGhpcy5mdXp6eVN1YnR5cGVzLnNpemUpO1xuICAgICAgICAgICAgdmFyIGNoZWNraW5nRnV6enlTdWJ0eXBlcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8ga2VlcCBldmFsdWF0aW5nIHdvcmtRdWV1ZS5sZW5ndGggZWFjaCB0aW1lIHRocm91Z2hcbiAgICAgICAgICAgIC8vIHRoZSBsb29wLCBiZWNhdXNlIHRoZSBxdWV1ZSBjYW4gZ3JvdyB3aGlsZSB3ZSdyZSBpdGVyYXRpbmcgb3ZlciBpdC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ya1F1ZXVlXzEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJ0eXBlU2V0ID0gd29ya1F1ZXVlXzFbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN1cGVydHlwZVNldC5oYXMoc3VwZXJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVuYW1lU3VwZXJ0eXBlU2V0LmhhcyhzdXBlcnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tpbmdGdXp6eVN1YnR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2Fybig2LCB0eXBlbmFtZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCBwb3NpdGl2ZSByZXN1bHRzIGZvciBmYXN0ZXIgZnV0dXJlIGxvb2t1cC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHdlIGNhbm5vdCBzYWZlbHkgY2FjaGUgbmVnYXRpdmUgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgbmV3IHBvc3NpYmxlVHlwZXMgZGF0YSBjb3VsZCBhbHdheXMgYmUgYWRkZWQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb2xpY2llcyBjbGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lU3VwZXJ0eXBlU2V0LmFkZChzdXBlcnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdXBlcnR5cGVTZXQuZm9yRWFjaChtYXliZUVucXVldWVfMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBjaGVja2luZyBmdXp6eSBzdWJ0eXBlcyBvbmx5IGFmdGVyIGV4aGF1c3RpbmcgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbi1mdXp6eSBzdWJ0eXBlcyAoYWZ0ZXIgdGhlIGZpbmFsIGl0ZXJhdGlvbiBvZiB0aGUgbG9vcCkuXG4gICAgICAgICAgICAgICAgICAgIGkgPT09IHdvcmtRdWV1ZV8xLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgd2FpdCB0byBjb21wYXJlIGZyYWdtZW50LnNlbGVjdGlvblNldCB0byByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgd2UgdmVyaWZ5IHRoZSBzdXBlcnR5cGUsIGJ1dCB0aGlzIGNoZWNrIGlzIG9mdGVuIGxlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIHRoYW4gdGhhdCBzZWFyY2gsIGFuZCB3ZSB3aWxsIGhhdmUgdG8gZG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gYW55d2F5IHdoZW5ldmVyIHdlIGZpbmQgYSBwb3RlbnRpYWwgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQoZnJhZ21lbnQuc2VsZWN0aW9uU2V0LCByZXN1bHQsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWx3YXlzIG5lZWQgdG8gY2hlY2sgZnV6enkgc3VidHlwZXMgKGlmIG5vIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAvLyB3YXMgcHJvdmlkZWQsIG9yICF0aGlzLmZ1enp5U3VidHlwZXMuc2l6ZSksIGJ1dCwgd2hlbiB3ZSBkbyxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNoZWNrIHRoZW0gb25jZS5cbiAgICAgICAgICAgICAgICAgICAgbmVlZFRvQ2hlY2tGdXp6eVN1YnR5cGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNraW5nRnV6enlTdWJ0eXBlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgYW55IGZ1enp5IHN1YnR5cGVzIHRoYXQgbWF0Y2ggdHlwZW5hbWUsIGV4dGVuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd29ya1F1ZXVlIHRvIHNlYXJjaCB0aHJvdWdoIHRoZSBzdXBlcnR5cGVzIG9mIHRob3NlIGZ1enp5XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnR5cGVzLiBPdGhlcndpc2UgdGhlIGZvci1sb29wIHdpbGwgdGVybWluYXRlIGFuZCB3ZSdsbFxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2UgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnV6enlTdWJ0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdFeHAsIGZ1enp5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0eXBlbmFtZS5tYXRjaChyZWdFeHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdID09PSB0eXBlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlRW5xdWV1ZV8xKGZ1enp5U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5oYXNLZXlBcmdzID0gZnVuY3Rpb24gKHR5cGVuYW1lLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdmFyIHBvbGljeSA9IHRoaXMuZ2V0RmllbGRQb2xpY3kodHlwZW5hbWUsIGZpZWxkTmFtZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gISEocG9saWN5ICYmIHBvbGljeS5rZXlGbik7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuZ2V0U3RvcmVGaWVsZE5hbWUgPSBmdW5jdGlvbiAoZmllbGRTcGVjKSB7XG4gICAgICAgIHZhciB0eXBlbmFtZSA9IGZpZWxkU3BlYy50eXBlbmFtZSwgZmllbGROYW1lID0gZmllbGRTcGVjLmZpZWxkTmFtZTtcbiAgICAgICAgdmFyIHBvbGljeSA9IHRoaXMuZ2V0RmllbGRQb2xpY3kodHlwZW5hbWUsIGZpZWxkTmFtZSwgZmFsc2UpO1xuICAgICAgICB2YXIgc3RvcmVGaWVsZE5hbWU7XG4gICAgICAgIHZhciBrZXlGbiA9IHBvbGljeSAmJiBwb2xpY3kua2V5Rm47XG4gICAgICAgIGlmIChrZXlGbiAmJiB0eXBlbmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZFNwZWMuZmllbGQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGZpZWxkU3BlYy52YXJpYWJsZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmdzRnJvbUZpZWxkU3BlY2lmaWVyKGZpZWxkU3BlYyk7XG4gICAgICAgICAgICB3aGlsZSAoa2V5Rm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlY2lmaWVyT3JTdHJpbmcgPSBrZXlGbihhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzcGVjaWZpZXJPclN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5Rm4gPSBrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyKHNwZWNpZmllck9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXN0b20ga2V5Rm4gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBmYWxsIGJhY2sgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGROYW1lIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlRmllbGROYW1lID0gc3BlY2lmaWVyT3JTdHJpbmcgfHwgZmllbGROYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3JlRmllbGROYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN0b3JlRmllbGROYW1lID1cbiAgICAgICAgICAgICAgICBmaWVsZFNwZWMuZmllbGQgP1xuICAgICAgICAgICAgICAgICAgICBzdG9yZUtleU5hbWVGcm9tRmllbGQoZmllbGRTcGVjLmZpZWxkLCBmaWVsZFNwZWMudmFyaWFibGVzKVxuICAgICAgICAgICAgICAgICAgICA6IGdldFN0b3JlS2V5TmFtZShmaWVsZE5hbWUsIGFyZ3NGcm9tRmllbGRTcGVjaWZpZXIoZmllbGRTcGVjKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuaW5nIGZhbHNlIGZyb20gYSBrZXlBcmdzIGZ1bmN0aW9uIGlzIGxpa2UgY29uZmlndXJpbmdcbiAgICAgICAgLy8ga2V5QXJnczogZmFsc2UsIGJ1dCBtb3JlIGR5bmFtaWMuXG4gICAgICAgIGlmIChzdG9yZUZpZWxkTmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBmaWVsZCBuYW1lcyBzdGFydCB3aXRoIHRoZSBhY3R1YWwgZmllbGQubmFtZS52YWx1ZVxuICAgICAgICAvLyBvZiB0aGUgZmllbGQsIHNvIHdlIGNhbiBhbHdheXMgZmlndXJlIG91dCB3aGljaCBwcm9wZXJ0aWVzIG9mIGFcbiAgICAgICAgLy8gU3RvcmVPYmplY3QgY29ycmVzcG9uZCB0byB3aGljaCBvcmlnaW5hbCBmaWVsZCBuYW1lcy5cbiAgICAgICAgcmV0dXJuIGZpZWxkTmFtZSA9PT0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSkgPyBzdG9yZUZpZWxkTmFtZVxuICAgICAgICAgICAgOiBmaWVsZE5hbWUgKyBcIjpcIiArIHN0b3JlRmllbGROYW1lO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnJlYWRGaWVsZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvYmplY3RPclJlZmVyZW5jZSA9IG9wdGlvbnMuZnJvbTtcbiAgICAgICAgaWYgKCFvYmplY3RPclJlZmVyZW5jZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWVPckZpZWxkID0gb3B0aW9ucy5maWVsZCB8fCBvcHRpb25zLmZpZWxkTmFtZTtcbiAgICAgICAgaWYgKCFuYW1lT3JGaWVsZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZW5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lID0gY29udGV4dC5zdG9yZS5nZXRGaWVsZFZhbHVlKG9iamVjdE9yUmVmZXJlbmNlLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICBpZiAodHlwZW5hbWUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlbmFtZSA9IHR5cGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9yZUZpZWxkTmFtZSA9IHRoaXMuZ2V0U3RvcmVGaWVsZE5hbWUob3B0aW9ucyk7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gY29udGV4dC5zdG9yZS5nZXRGaWVsZFZhbHVlKG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KG9wdGlvbnMudHlwZW5hbWUsIGZpZWxkTmFtZSwgZmFsc2UpO1xuICAgICAgICB2YXIgcmVhZCA9IHBvbGljeSAmJiBwb2xpY3kucmVhZDtcbiAgICAgICAgaWYgKHJlYWQpIHtcbiAgICAgICAgICAgIHZhciByZWFkT3B0aW9ucyA9IG1ha2VGaWVsZEZ1bmN0aW9uT3B0aW9ucyh0aGlzLCBvYmplY3RPclJlZmVyZW5jZSwgb3B0aW9ucywgY29udGV4dCwgY29udGV4dC5zdG9yZS5nZXRTdG9yYWdlKGlzUmVmZXJlbmNlKG9iamVjdE9yUmVmZXJlbmNlKSA/XG4gICAgICAgICAgICAgICAgb2JqZWN0T3JSZWZlcmVuY2UuX19yZWZcbiAgICAgICAgICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgLy8gQ2FsbCByZWFkKGV4aXN0aW5nLCByZWFkT3B0aW9ucykgd2l0aCBjYWNoZVNsb3QgaG9sZGluZyB0aGlzLmNhY2hlLlxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlU2xvdC53aXRoVmFsdWUodGhpcy5jYWNoZSwgcmVhZCwgW1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLFxuICAgICAgICAgICAgICAgIHJlYWRPcHRpb25zLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmdldFJlYWRGdW5jdGlvbiA9IGZ1bmN0aW9uICh0eXBlbmFtZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHBvbGljeSAmJiBwb2xpY3kucmVhZDtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRNZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKHBhcmVudFR5cGVuYW1lLCBmaWVsZE5hbWUsIGNoaWxkVHlwZW5hbWUpIHtcbiAgICAgICAgdmFyIHBvbGljeSA9IHRoaXMuZ2V0RmllbGRQb2xpY3kocGFyZW50VHlwZW5hbWUsIGZpZWxkTmFtZSwgZmFsc2UpO1xuICAgICAgICB2YXIgbWVyZ2UgPSBwb2xpY3kgJiYgcG9saWN5Lm1lcmdlO1xuICAgICAgICBpZiAoIW1lcmdlICYmIGNoaWxkVHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHBvbGljeSA9IHRoaXMuZ2V0VHlwZVBvbGljeShjaGlsZFR5cGVuYW1lKTtcbiAgICAgICAgICAgIG1lcmdlID0gcG9saWN5ICYmIHBvbGljeS5tZXJnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2U7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUucnVuTWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcsIF9hLCBjb250ZXh0LCBzdG9yYWdlKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB0eXBlbmFtZSA9IF9hLnR5cGVuYW1lLCBtZXJnZSA9IF9hLm1lcmdlO1xuICAgICAgICBpZiAobWVyZ2UgPT09IG1lcmdlVHJ1ZUZuKSB7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGdvaW5nIHRvIHRoZSB0cm91YmxlIG9mIGNyZWF0aW5nIGEgZnVsbFxuICAgICAgICAgICAgLy8gRmllbGRGdW5jdGlvbk9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsaW5nIG1lcmdlVHJ1ZUZuLCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHNpbXBseSBjYWxsIG1lcmdlT2JqZWN0cywgYXMgbWVyZ2VUcnVlRm4gd291bGQuXG4gICAgICAgICAgICByZXR1cm4gbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKGNvbnRleHQuc3RvcmUpKGV4aXN0aW5nLCBpbmNvbWluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lcmdlID09PSBtZXJnZUZhbHNlRm4pIHtcbiAgICAgICAgICAgIC8vIExpa2V3aXNlIGZvciBtZXJnZUZhbHNlRm4sIHdob3NlIGltcGxlbWVudGF0aW9uIGlzIGV2ZW4gc2ltcGxlci5cbiAgICAgICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjYWNoZS53cml0ZVF1ZXJ5IG9yIGNhY2hlLndyaXRlRnJhZ21lbnQgd2FzIGNhbGxlZCB3aXRoXG4gICAgICAgIC8vIG9wdGlvbnMub3ZlcndyaXRlIHNldCB0byB0cnVlLCB3ZSBzdGlsbCBjYWxsIG1lcmdlIGZ1bmN0aW9ucywgYnV0XG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBkYXRhIGlzIGFsd2F5cyB1bmRlZmluZWQsIHNvIHRoZSBtZXJnZSBmdW5jdGlvbiB3aWxsXG4gICAgICAgIC8vIG5vdCBhdHRlbXB0IHRvIGNvbWJpbmUgdGhlIGluY29taW5nIGRhdGEgd2l0aCB0aGUgZXhpc3RpbmcgZGF0YS5cbiAgICAgICAgaWYgKGNvbnRleHQub3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBleGlzdGluZyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLCBtYWtlRmllbGRGdW5jdGlvbk9wdGlvbnModGhpcywgXG4gICAgICAgIC8vIFVubGlrZSBvcHRpb25zLnJlYWRGaWVsZCBmb3IgcmVhZCBmdW5jdGlvbnMsIHdlIGRvIG5vdCBmYWxsXG4gICAgICAgIC8vIGJhY2sgdG8gdGhlIGN1cnJlbnQgb2JqZWN0IGlmIG5vIGZvcmVpZ25PYmpPclJlZiBpcyBwcm92aWRlZCxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCdzIG5vdCBjbGVhciB3aGF0IHRoZSBjdXJyZW50IG9iamVjdCBzaG91bGQgYmUgZm9yXG4gICAgICAgIC8vIG1lcmdlIGZ1bmN0aW9uczogdGhlIChwb3NzaWJseSB1bmRlZmluZWQpIGV4aXN0aW5nIG9iamVjdCwgb3JcbiAgICAgICAgLy8gdGhlIGluY29taW5nIG9iamVjdD8gSWYgeW91IHRoaW5rIHlvdXIgbWVyZ2UgZnVuY3Rpb24gbmVlZHNcbiAgICAgICAgLy8gdG8gcmVhZCBzaWJsaW5nIGZpZWxkcyBpbiBvcmRlciB0byBwcm9kdWNlIGEgbmV3IHZhbHVlIGZvclxuICAgICAgICAvLyB0aGUgY3VycmVudCBmaWVsZCwgeW91IG1pZ2h0IHdhbnQgdG8gcmV0aGluayB5b3VyIHN0cmF0ZWd5LFxuICAgICAgICAvLyBiZWNhdXNlIHRoYXQncyBhIHJlY2lwZSBmb3IgbWFraW5nIG1lcmdlIGJlaGF2aW9yIHNlbnNpdGl2ZVxuICAgICAgICAvLyB0byB0aGUgb3JkZXIgaW4gd2hpY2ggZmllbGRzIGFyZSB3cml0dGVuIGludG8gdGhlIGNhY2hlLlxuICAgICAgICAvLyBIb3dldmVyLCByZWFkRmllbGQobmFtZSwgcmVmKSBpcyB1c2VmdWwgZm9yIG1lcmdlIGZ1bmN0aW9uc1xuICAgICAgICAvLyB0aGF0IG5lZWQgdG8gZGVkdXBsaWNhdGUgY2hpbGQgb2JqZWN0cyBhbmQgcmVmZXJlbmNlcy5cbiAgICAgICAgdm9pZCAwLCB7XG4gICAgICAgICAgICB0eXBlbmFtZTogdHlwZW5hbWUsXG4gICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkLm5hbWUudmFsdWUsXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IGNvbnRleHQudmFyaWFibGVzLFxuICAgICAgICB9LCBjb250ZXh0LCBzdG9yYWdlIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBQb2xpY2llcztcbn0oKSk7XG5leHBvcnQgeyBQb2xpY2llcyB9O1xuZnVuY3Rpb24gbWFrZUZpZWxkRnVuY3Rpb25PcHRpb25zKHBvbGljaWVzLCBvYmplY3RPclJlZmVyZW5jZSwgZmllbGRTcGVjLCBjb250ZXh0LCBzdG9yYWdlKSB7XG4gICAgdmFyIHN0b3JlRmllbGROYW1lID0gcG9saWNpZXMuZ2V0U3RvcmVGaWVsZE5hbWUoZmllbGRTcGVjKTtcbiAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgdmFyIHZhcmlhYmxlcyA9IGZpZWxkU3BlYy52YXJpYWJsZXMgfHwgY29udGV4dC52YXJpYWJsZXM7XG4gICAgdmFyIF9hID0gY29udGV4dC5zdG9yZSwgdG9SZWZlcmVuY2UgPSBfYS50b1JlZmVyZW5jZSwgY2FuUmVhZCA9IF9hLmNhblJlYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJnczogYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpLFxuICAgICAgICBmaWVsZDogZmllbGRTcGVjLmZpZWxkIHx8IG51bGwsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICBzdG9yZUZpZWxkTmFtZTogc3RvcmVGaWVsZE5hbWUsXG4gICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICBpc1JlZmVyZW5jZTogaXNSZWZlcmVuY2UsXG4gICAgICAgIHRvUmVmZXJlbmNlOiB0b1JlZmVyZW5jZSxcbiAgICAgICAgc3RvcmFnZTogc3RvcmFnZSxcbiAgICAgICAgY2FjaGU6IHBvbGljaWVzLmNhY2hlLFxuICAgICAgICBjYW5SZWFkOiBjYW5SZWFkLFxuICAgICAgICByZWFkRmllbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQobm9ybWFsaXplUmVhZEZpZWxkT3B0aW9ucyhhcmd1bWVudHMsIG9iamVjdE9yUmVmZXJlbmNlLCB2YXJpYWJsZXMpLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2VPYmplY3RzOiBtYWtlTWVyZ2VPYmplY3RzRnVuY3Rpb24oY29udGV4dC5zdG9yZSksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKHJlYWRGaWVsZEFyZ3MsIG9iamVjdE9yUmVmZXJlbmNlLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZmllbGROYW1lT3JPcHRpb25zID0gcmVhZEZpZWxkQXJnc1swXSwgZnJvbSA9IHJlYWRGaWVsZEFyZ3NbMV0sIGFyZ2MgPSByZWFkRmllbGRBcmdzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZpZWxkTmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWVPck9wdGlvbnMsXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIG9iamVjdE9yUmVmZXJlbmNlIG9ubHkgd2hlbiBubyBzZWNvbmQgYXJndW1lbnQgd2FzXG4gICAgICAgICAgICAvLyBwYXNzZWQgZm9yIHRoZSBmcm9tIHBhcmFtZXRlciwgbm90IHdoZW4gdW5kZWZpbmVkIGlzIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIC8vIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAgICAgICAgZnJvbTogYXJnYyA+IDEgPyBmcm9tIDogb2JqZWN0T3JSZWZlcmVuY2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oe30sIGZpZWxkTmFtZU9yT3B0aW9ucyk7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gb2JqZWN0T3JSZWZlcmVuY2Ugb25seSB3aGVuIGZpZWxkTmFtZU9yT3B0aW9ucy5mcm9tIGlzXG4gICAgICAgIC8vIGFjdHVhbGx5IG9taXR0ZWQsIHJhdGhlciB0aGFuIGp1c3QgdW5kZWZpbmVkLlxuICAgICAgICBpZiAoIWhhc093bi5jYWxsKG9wdGlvbnMsIFwiZnJvbVwiKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5mcm9tID0gb2JqZWN0T3JSZWZlcmVuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgb3B0aW9ucy5mcm9tID09PSB2b2lkIDApIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2Fybig3LCBzdHJpbmdpZnlGb3JEaXNwbGF5KEFycmF5LmZyb20ocmVhZEZpZWxkQXJncykpKTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCA9PT0gb3B0aW9ucy52YXJpYWJsZXMpIHtcbiAgICAgICAgb3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKHN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZXhpc3RpbmcpIHx8IGlzQXJyYXkoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXdJbnZhcmlhbnRFcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSBkeW5hbWljIGNoZWNrcyBhcmUgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIHBhcmFtZXRlcnMgb2YgYVxuICAgICAgICAvLyBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gY2FuIGVhc2lseSBoYXZlIHRoZSBhbnkgdHlwZSwgc28gdGhlIHR5cGVcbiAgICAgICAgLy8gc3lzdGVtIGNhbm5vdCBhbHdheXMgZW5mb3JjZSB0aGUgU3RvcmVPYmplY3QgfCBSZWZlcmVuY2UgcGFyYW1ldGVyXG4gICAgICAgIC8vIHR5cGVzIG9mIG9wdGlvbnMubWVyZ2VPYmplY3RzLlxuICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KGV4aXN0aW5nKSAmJiBpc05vbk51bGxPYmplY3QoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB2YXIgZVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGV4aXN0aW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgaVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGluY29taW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgdHlwZXNEaWZmZXIgPSBlVHlwZSAmJiBpVHlwZSAmJiBlVHlwZSAhPT0gaVR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZXNEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UoZXhpc3RpbmcpICYmIHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGluY29taW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbm9ybWFsaXplZCBFbnRpdHlTdG9yZSBmb3IgdGhlIGVudGl0eSBpZGVudGlmaWVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcuX19yZWYsIHByZWZlcnJpbmcvb3ZlcndyaXRpbmcgYW55IGZpZWxkcyBjb250cmlidXRlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXdlciBpbmNvbWluZyBTdG9yZU9iamVjdC5cbiAgICAgICAgICAgICAgICBzdG9yZS5tZXJnZShleGlzdGluZy5fX3JlZiwgaW5jb21pbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChleGlzdGluZykgJiYgaXNSZWZlcmVuY2UoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBub3JtYWxpemVkIEVudGl0eVN0b3JlIGZvciB0aGUgZW50aXR5IGlkZW50aWZpZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZy5fX3JlZiwgdGFraW5nIGZpZWxkcyBmcm9tIHRoZSBvbGRlciBleGlzdGluZyBvYmplY3Qgb25seSBpZlxuICAgICAgICAgICAgICAgIC8vIHRob3NlIGZpZWxkcyBhcmUgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgbmV3ZXIgU3RvcmVPYmplY3RcbiAgICAgICAgICAgICAgICAvLyBpZGVudGlmaWVkIGJ5IGluY29taW5nLl9fcmVmLlxuICAgICAgICAgICAgICAgIHN0b3JlLm1lcmdlKGV4aXN0aW5nLCBpbmNvbWluZy5fX3JlZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGV4aXN0aW5nKSAmJlxuICAgICAgICAgICAgICAgIHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGluY29taW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhpc3RpbmcpLCBpbmNvbWluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2xpY2llcy5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX3Jlc3QiLCJpbnZhcmlhbnQiLCJuZXdJbnZhcmlhbnRFcnJvciIsInN0b3JlS2V5TmFtZUZyb21GaWVsZCIsImFyZ3VtZW50c09iamVjdEZyb21GaWVsZCIsImlzUmVmZXJlbmNlIiwiZ2V0U3RvcmVLZXlOYW1lIiwiaXNOb25OdWxsT2JqZWN0Iiwic3RyaW5naWZ5Rm9yRGlzcGxheSIsImhhc093biIsImZpZWxkTmFtZUZyb21TdG9yZU5hbWUiLCJzdG9yZVZhbHVlSXNTdG9yZU9iamVjdCIsInNlbGVjdGlvblNldE1hdGNoZXNSZXN1bHQiLCJUeXBlT3JGaWVsZE5hbWVSZWdFeHAiLCJkZWZhdWx0RGF0YUlkRnJvbU9iamVjdCIsImlzQXJyYXkiLCJjYWNoZVNsb3QiLCJrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyIiwia2V5RmllbGRzRm5Gcm9tU3BlY2lmaWVyIiwiYXJnc0Zyb21GaWVsZFNwZWNpZmllciIsInNwZWMiLCJhcmdzIiwiZmllbGQiLCJ2YXJpYWJsZXMiLCJudWxsS2V5RmllbGRzRm4iLCJzaW1wbGVLZXlBcmdzRm4iLCJfYXJncyIsImNvbnRleHQiLCJmaWVsZE5hbWUiLCJtZXJnZVRydWVGbiIsImV4aXN0aW5nIiwiaW5jb21pbmciLCJfYSIsIm1lcmdlT2JqZWN0cyIsIm1lcmdlRmFsc2VGbiIsIl8iLCJQb2xpY2llcyIsImNvbmZpZyIsInR5cGVQb2xpY2llcyIsIk9iamVjdCIsImNyZWF0ZSIsInRvQmVBZGRlZCIsInN1cGVydHlwZU1hcCIsIk1hcCIsImZ1enp5U3VidHlwZXMiLCJyb290SWRzQnlUeXBlbmFtZSIsInJvb3RUeXBlbmFtZXNCeUlkIiwidXNpbmdQb3NzaWJsZVR5cGVzIiwiZGF0YUlkRnJvbU9iamVjdCIsImNhY2hlIiwic2V0Um9vdFR5cGVuYW1lIiwicG9zc2libGVUeXBlcyIsImFkZFBvc3NpYmxlVHlwZXMiLCJhZGRUeXBlUG9saWNpZXMiLCJwcm90b3R5cGUiLCJpZGVudGlmeSIsIm9iamVjdCIsInBhcnRpYWxDb250ZXh0IiwicG9saWNpZXMiLCJ0eXBlbmFtZSIsInN0b3JlT2JqZWN0IiwiX190eXBlbmFtZSIsIlJPT1RfUVVFUlkiLCJyZWFkRmllbGQiLCJvcHRpb25zIiwibm9ybWFsaXplUmVhZEZpZWxkT3B0aW9ucyIsImFyZ3VtZW50cyIsInN0b3JlIiwiaWQiLCJwb2xpY3kiLCJnZXRUeXBlUG9saWN5Iiwia2V5Rm4iLCJzcGVjaWZpZXJPcklkIiwiU3RyaW5nIiwia2V5T2JqZWN0IiwiX3RoaXMiLCJrZXlzIiwiZm9yRWFjaCIsInF1ZXJ5VHlwZSIsIm11dGF0aW9uVHlwZSIsInN1YnNjcmlwdGlvblR5cGUiLCJjYWxsIiwicHVzaCIsInVwZGF0ZVR5cGVQb2xpY3kiLCJrZXlGaWVsZHMiLCJmaWVsZHMiLCJzZXRNZXJnZSIsIm1lcmdlIiwiZ2V0RmllbGRQb2xpY3kiLCJyZWFkIiwia2V5QXJncyIsIndoaWNoIiwicm9vdElkIiwidG9VcHBlckNhc2UiLCJvbGQiLCJzdXBlcnR5cGUiLCJnZXRTdXBlcnR5cGVTZXQiLCJzdWJ0eXBlIiwiYWRkIiwibWF0Y2giLCJzZXQiLCJSZWdFeHAiLCJwb2xpY3lfMSIsInN1cGVydHlwZXNfMSIsImdldCIsInNpemUiLCJyZWdFeHAiLCJmdXp6eSIsInRlc3QiLCJmdXp6eVN1cGVydHlwZXMiLCJyZXN0IiwiYXNzaWduIiwiaW5ib3giLCJsZW5ndGgiLCJzcGxpY2UiLCJjcmVhdGVJZk1pc3NpbmciLCJmaWVsZFBvbGljaWVzIiwic3VwZXJ0eXBlU2V0IiwiU2V0IiwiZnJhZ21lbnRNYXRjaGVzIiwiZnJhZ21lbnQiLCJyZXN1bHQiLCJ0eXBlQ29uZGl0aW9uIiwibmFtZSIsInZhbHVlIiwiaGFzIiwidHlwZW5hbWVTdXBlcnR5cGVTZXQiLCJ3b3JrUXVldWVfMSIsIm1heWJlRW5xdWV1ZV8xIiwiaW5kZXhPZiIsIm5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyIsImNoZWNraW5nRnV6enlTdWJ0eXBlcyIsImkiLCJnbG9iYWxUaGlzIiwiX19ERVZfXyIsIndhcm4iLCJzZWxlY3Rpb25TZXQiLCJmdXp6eVN0cmluZyIsImhhc0tleUFyZ3MiLCJnZXRTdG9yZUZpZWxkTmFtZSIsImZpZWxkU3BlYyIsInN0b3JlRmllbGROYW1lIiwic3BlY2lmaWVyT3JTdHJpbmciLCJvYmplY3RPclJlZmVyZW5jZSIsImZyb20iLCJuYW1lT3JGaWVsZCIsImdldEZpZWxkVmFsdWUiLCJyZWFkT3B0aW9ucyIsIm1ha2VGaWVsZEZ1bmN0aW9uT3B0aW9ucyIsImdldFN0b3JhZ2UiLCJfX3JlZiIsIndpdGhWYWx1ZSIsImdldFJlYWRGdW5jdGlvbiIsImdldE1lcmdlRnVuY3Rpb24iLCJwYXJlbnRUeXBlbmFtZSIsImNoaWxkVHlwZW5hbWUiLCJydW5NZXJnZUZ1bmN0aW9uIiwic3RvcmFnZSIsIm1ha2VNZXJnZU9iamVjdHNGdW5jdGlvbiIsIm92ZXJ3cml0ZSIsInRvUmVmZXJlbmNlIiwiY2FuUmVhZCIsInJlYWRGaWVsZEFyZ3MiLCJmaWVsZE5hbWVPck9wdGlvbnMiLCJhcmdjIiwiQXJyYXkiLCJlVHlwZSIsImlUeXBlIiwidHlwZXNEaWZmZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/policies.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/reactiveVars.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/reactiveVars.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheSlot: function() { return /* binding */ cacheSlot; },\n/* harmony export */   forgetCache: function() { return /* binding */ forgetCache; },\n/* harmony export */   makeVar: function() { return /* binding */ makeVar; },\n/* harmony export */   recallCache: function() { return /* binding */ recallCache; }\n/* harmony export */ });\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nvar cacheSlot = new optimism__WEBPACK_IMPORTED_MODULE_0__.Slot();\nvar cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n    var info = cacheInfoMap.get(cache);\n    if (!info) {\n        cacheInfoMap.set(cache, info = {\n            vars: new Set(),\n            dep: (0,optimism__WEBPACK_IMPORTED_MODULE_0__.dep)()\n        });\n    }\n    return info;\n}\nfunction forgetCache(cache) {\n    getCacheInfo(cache).vars.forEach(function(rv) {\n        return rv.forgetCache(cache);\n    });\n}\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nfunction recallCache(cache) {\n    getCacheInfo(cache).vars.forEach(function(rv) {\n        return rv.attachCache(cache);\n    });\n}\nfunction makeVar(value) {\n    var caches = new Set();\n    var listeners = new Set();\n    var rv = function(newValue) {\n        if (arguments.length > 0) {\n            if (value !== newValue) {\n                value = newValue;\n                caches.forEach(function(cache) {\n                    // Invalidate any fields with custom read functions that\n                    // consumed this variable, so query results involving those\n                    // fields will be recomputed the next time we read them.\n                    getCacheInfo(cache).dep.dirty(rv);\n                    // Broadcast changes to any caches that have previously read\n                    // from this variable.\n                    broadcast(cache);\n                });\n                // Finally, notify any listeners added via rv.onNextChange.\n                var oldListeners = Array.from(listeners);\n                listeners.clear();\n                oldListeners.forEach(function(listener) {\n                    return listener(value);\n                });\n            }\n        } else {\n            // When reading from the variable, obtain the current cache from\n            // context via cacheSlot. This isn't entirely foolproof, but it's\n            // the same system that powers varDep.\n            var cache = cacheSlot.getValue();\n            if (cache) {\n                attach(cache);\n                getCacheInfo(cache).dep(rv);\n            }\n        }\n        return value;\n    };\n    rv.onNextChange = function(listener) {\n        listeners.add(listener);\n        return function() {\n            listeners.delete(listener);\n        };\n    };\n    var attach = rv.attachCache = function(cache) {\n        caches.add(cache);\n        getCacheInfo(cache).vars.add(rv);\n        return rv;\n    };\n    rv.forgetCache = function(cache) {\n        return caches.delete(cache);\n    };\n    return rv;\n}\nfunction broadcast(cache) {\n    if (cache.broadcastWatches) {\n        cache.broadcastWatches();\n    }\n} //# sourceMappingURL=reactiveVars.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9yZWFjdGl2ZVZhcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDckMseUVBQXlFO0FBQ3pFLGdDQUFnQztBQUN6QixJQUFJRSxZQUFZLElBQUlELDBDQUFJQSxHQUFHO0FBQ2xDLElBQUlFLGVBQWUsSUFBSUM7QUFDdkIsU0FBU0MsYUFBYUMsS0FBSztJQUN2QixJQUFJQyxPQUFPSixhQUFhSyxHQUFHLENBQUNGO0lBQzVCLElBQUksQ0FBQ0MsTUFBTTtRQUNQSixhQUFhTSxHQUFHLENBQUNILE9BQVFDLE9BQU87WUFDNUJHLE1BQU0sSUFBSUM7WUFDVlgsS0FBS0EsNkNBQUdBO1FBQ1o7SUFDSjtJQUNBLE9BQU9PO0FBQ1g7QUFDTyxTQUFTSyxZQUFZTixLQUFLO0lBQzdCRCxhQUFhQyxPQUFPSSxJQUFJLENBQUNHLE9BQU8sQ0FBQyxTQUFVQyxFQUFFO1FBQUksT0FBT0EsR0FBR0YsV0FBVyxDQUFDTjtJQUFRO0FBQ25GO0FBQ0EseUVBQXlFO0FBQ3pFLGtFQUFrRTtBQUNsRSwwRUFBMEU7QUFDMUUsc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSx3RUFBd0U7QUFDeEUsbUVBQW1FO0FBQ25FLHdEQUF3RDtBQUNqRCxTQUFTUyxZQUFZVCxLQUFLO0lBQzdCRCxhQUFhQyxPQUFPSSxJQUFJLENBQUNHLE9BQU8sQ0FBQyxTQUFVQyxFQUFFO1FBQUksT0FBT0EsR0FBR0UsV0FBVyxDQUFDVjtJQUFRO0FBQ25GO0FBQ08sU0FBU1csUUFBUUMsS0FBSztJQUN6QixJQUFJQyxTQUFTLElBQUlSO0lBQ2pCLElBQUlTLFlBQVksSUFBSVQ7SUFDcEIsSUFBSUcsS0FBSyxTQUFVTyxRQUFRO1FBQ3ZCLElBQUlDLFVBQVVDLE1BQU0sR0FBRyxHQUFHO1lBQ3RCLElBQUlMLFVBQVVHLFVBQVU7Z0JBQ3BCSCxRQUFRRztnQkFDUkYsT0FBT04sT0FBTyxDQUFDLFNBQVVQLEtBQUs7b0JBQzFCLHdEQUF3RDtvQkFDeEQsMkRBQTJEO29CQUMzRCx3REFBd0Q7b0JBQ3hERCxhQUFhQyxPQUFPTixHQUFHLENBQUN3QixLQUFLLENBQUNWO29CQUM5Qiw0REFBNEQ7b0JBQzVELHNCQUFzQjtvQkFDdEJXLFVBQVVuQjtnQkFDZDtnQkFDQSwyREFBMkQ7Z0JBQzNELElBQUlvQixlQUFlQyxNQUFNQyxJQUFJLENBQUNSO2dCQUM5QkEsVUFBVVMsS0FBSztnQkFDZkgsYUFBYWIsT0FBTyxDQUFDLFNBQVVpQixRQUFRO29CQUFJLE9BQU9BLFNBQVNaO2dCQUFRO1lBQ3ZFO1FBQ0osT0FDSztZQUNELGdFQUFnRTtZQUNoRSxpRUFBaUU7WUFDakUsc0NBQXNDO1lBQ3RDLElBQUlaLFFBQVFKLFVBQVU2QixRQUFRO1lBQzlCLElBQUl6QixPQUFPO2dCQUNQMEIsT0FBTzFCO2dCQUNQRCxhQUFhQyxPQUFPTixHQUFHLENBQUNjO1lBQzVCO1FBQ0o7UUFDQSxPQUFPSTtJQUNYO0lBQ0FKLEdBQUdtQixZQUFZLEdBQUcsU0FBVUgsUUFBUTtRQUNoQ1YsVUFBVWMsR0FBRyxDQUFDSjtRQUNkLE9BQU87WUFDSFYsVUFBVWUsTUFBTSxDQUFDTDtRQUNyQjtJQUNKO0lBQ0EsSUFBSUUsU0FBVWxCLEdBQUdFLFdBQVcsR0FBRyxTQUFVVixLQUFLO1FBQzFDYSxPQUFPZSxHQUFHLENBQUM1QjtRQUNYRCxhQUFhQyxPQUFPSSxJQUFJLENBQUN3QixHQUFHLENBQUNwQjtRQUM3QixPQUFPQTtJQUNYO0lBQ0FBLEdBQUdGLFdBQVcsR0FBRyxTQUFVTixLQUFLO1FBQUksT0FBT2EsT0FBT2dCLE1BQU0sQ0FBQzdCO0lBQVE7SUFDakUsT0FBT1E7QUFDWDtBQUNBLFNBQVNXLFVBQVVuQixLQUFLO0lBQ3BCLElBQUlBLE1BQU04QixnQkFBZ0IsRUFBRTtRQUN4QjlCLE1BQU04QixnQkFBZ0I7SUFDMUI7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkvcmVhY3RpdmVWYXJzLmpzP2Q3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVwLCBTbG90IH0gZnJvbSBcIm9wdGltaXNtXCI7XG4vLyBDb250ZXh0dWFsIFNsb3QgdGhhdCBhY3F1aXJlcyBpdHMgdmFsdWUgd2hlbiBjdXN0b20gcmVhZCBmdW5jdGlvbnMgYXJlXG4vLyBjYWxsZWQgaW4gUG9saWNpZXMjcmVhZEZpZWxkLlxuZXhwb3J0IHZhciBjYWNoZVNsb3QgPSBuZXcgU2xvdCgpO1xudmFyIGNhY2hlSW5mb01hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZUluZm8oY2FjaGUpIHtcbiAgICB2YXIgaW5mbyA9IGNhY2hlSW5mb01hcC5nZXQoY2FjaGUpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgICBjYWNoZUluZm9NYXAuc2V0KGNhY2hlLCAoaW5mbyA9IHtcbiAgICAgICAgICAgIHZhcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGRlcDogZGVwKCksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yZ2V0Q2FjaGUoY2FjaGUpIHtcbiAgICBnZXRDYWNoZUluZm8oY2FjaGUpLnZhcnMuZm9yRWFjaChmdW5jdGlvbiAocnYpIHsgcmV0dXJuIHJ2LmZvcmdldENhY2hlKGNhY2hlKTsgfSk7XG59XG4vLyBDYWxsaW5nIGZvcmdldENhY2hlKGNhY2hlKSBzZXJ2ZXMgdG8gc2lsZW5jZSBicm9hZGNhc3RzIGFuZCBhbGxvd3MgdGhlXG4vLyBjYWNoZSB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC4gSG93ZXZlciwgdGhlIHZhcnNCeUNhY2hlIFdlYWtNYXBcbi8vIHByZXNlcnZlcyB0aGUgc2V0IG9mIHJlYWN0aXZlIHZhcmlhYmxlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoaXMgY2FjaGUsIHdoaWNoIG1ha2VzIGl0IHBvc3NpYmxlIHRvIFwicmVjYWxsXCIgdGhlIGNhY2hlIGF0IGFcbi8vIGxhdGVyIHRpbWUsIGJ5IHJlYXR0YWNoaW5nIGl0IHRvIHRob3NlIHZhcmlhYmxlcy4gSWYgdGhlIGNhY2hlIGhhcyBiZWVuXG4vLyBnYXJiYWdlIGNvbGxlY3RlZCBpbiB0aGUgbWVhbnRpbWUsIGJlY2F1c2UgaXQgaXMgbm8gbG9uZ2VyIHJlYWNoYWJsZSxcbi8vIHlvdSB3b24ndCBiZSBhYmxlIHRvIGNhbGwgcmVjYWxsQ2FjaGUoY2FjaGUpLCBhbmQgdGhlIGNhY2hlIHdpbGxcbi8vIGF1dG9tYXRpY2FsbHkgZGlzYXBwZWFyIGZyb20gdGhlIHZhcnNCeUNhY2hlIFdlYWtNYXAuXG5leHBvcnQgZnVuY3Rpb24gcmVjYWxsQ2FjaGUoY2FjaGUpIHtcbiAgICBnZXRDYWNoZUluZm8oY2FjaGUpLnZhcnMuZm9yRWFjaChmdW5jdGlvbiAocnYpIHsgcmV0dXJuIHJ2LmF0dGFjaENhY2hlKGNhY2hlKTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVZhcih2YWx1ZSkge1xuICAgIHZhciBjYWNoZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBjYWNoZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbnkgZmllbGRzIHdpdGggY3VzdG9tIHJlYWQgZnVuY3Rpb25zIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3VtZWQgdGhpcyB2YXJpYWJsZSwgc28gcXVlcnkgcmVzdWx0cyBpbnZvbHZpbmcgdGhvc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIHdpbGwgYmUgcmVjb21wdXRlZCB0aGUgbmV4dCB0aW1lIHdlIHJlYWQgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVJbmZvKGNhY2hlKS5kZXAuZGlydHkocnYpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCcm9hZGNhc3QgY2hhbmdlcyB0byBhbnkgY2FjaGVzIHRoYXQgaGF2ZSBwcmV2aW91c2x5IHJlYWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGlzIHZhcmlhYmxlLlxuICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3QoY2FjaGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIG5vdGlmeSBhbnkgbGlzdGVuZXJzIGFkZGVkIHZpYSBydi5vbk5leHRDaGFuZ2UuXG4gICAgICAgICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IEFycmF5LmZyb20obGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBvbGRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIHJlYWRpbmcgZnJvbSB0aGUgdmFyaWFibGUsIG9idGFpbiB0aGUgY3VycmVudCBjYWNoZSBmcm9tXG4gICAgICAgICAgICAvLyBjb250ZXh0IHZpYSBjYWNoZVNsb3QuIFRoaXMgaXNuJ3QgZW50aXJlbHkgZm9vbHByb29mLCBidXQgaXQnc1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgc3lzdGVtIHRoYXQgcG93ZXJzIHZhckRlcC5cbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlU2xvdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoKGNhY2hlKTtcbiAgICAgICAgICAgICAgICBnZXRDYWNoZUluZm8oY2FjaGUpLmRlcChydik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcnYub25OZXh0Q2hhbmdlID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoID0gKHJ2LmF0dGFjaENhY2hlID0gZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlcy5hZGQoY2FjaGUpO1xuICAgICAgICBnZXRDYWNoZUluZm8oY2FjaGUpLnZhcnMuYWRkKHJ2KTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0pO1xuICAgIHJ2LmZvcmdldENhY2hlID0gZnVuY3Rpb24gKGNhY2hlKSB7IHJldHVybiBjYWNoZXMuZGVsZXRlKGNhY2hlKTsgfTtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBicm9hZGNhc3QoY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUuYnJvYWRjYXN0V2F0Y2hlcykge1xuICAgICAgICBjYWNoZS5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RpdmVWYXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZXAiLCJTbG90IiwiY2FjaGVTbG90IiwiY2FjaGVJbmZvTWFwIiwiV2Vha01hcCIsImdldENhY2hlSW5mbyIsImNhY2hlIiwiaW5mbyIsImdldCIsInNldCIsInZhcnMiLCJTZXQiLCJmb3JnZXRDYWNoZSIsImZvckVhY2giLCJydiIsInJlY2FsbENhY2hlIiwiYXR0YWNoQ2FjaGUiLCJtYWtlVmFyIiwidmFsdWUiLCJjYWNoZXMiLCJsaXN0ZW5lcnMiLCJuZXdWYWx1ZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImRpcnR5IiwiYnJvYWRjYXN0Iiwib2xkTGlzdGVuZXJzIiwiQXJyYXkiLCJmcm9tIiwiY2xlYXIiLCJsaXN0ZW5lciIsImdldFZhbHVlIiwiYXR0YWNoIiwib25OZXh0Q2hhbmdlIiwiYWRkIiwiZGVsZXRlIiwiYnJvYWRjYXN0V2F0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/reactiveVars.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/readFromStore.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/readFromStore.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StoreReader: function() { return /* binding */ StoreReader; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _entityStore_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entityStore.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/entityStore.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _core_types_common_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/types/common.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/core/types/common.js\");\n/* harmony import */ var _object_canon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object-canon.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/object-canon.js\");\n\n\n\n\n\n\n\n\n\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        // We split out this property so we can pass different values\n        // independently without modifying options.context itself.\n        options.context.canonizeResults\n    ];\n}\nvar StoreReader = /** @class */ function() {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.canUseWeakMap ? WeakMap : Map)();\n        this.config = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.compact)(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.shouldCanonizeResults)(config)\n        });\n        this.canon = config.canon || new _object_canon_js__WEBPACK_IMPORTED_MODULE_5__.ObjectCanon();\n        // memoized functions in this class will be \"garbage-collected\"\n        // by recreating the whole `StoreReader` in\n        // `InMemoryCache.resetResultsCache`\n        // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n        this.executeSelectionSet = (0,optimism__WEBPACK_IMPORTED_MODULE_1__.wrap)(function(options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            // Negate this boolean option so we can find out if we've already read\n            // this result using the other boolean value.\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, other), {\n                        // If we previously read this result without canonizing it, we can\n                        // reuse that result simply by canonizing it now.\n                        result: _this.canon.admit(other.result)\n                    });\n                }\n                // If we previously read this result with canonization enabled, we can\n                // return that canonized result as-is.\n                return other;\n            }\n            (0,_entityStore_js__WEBPACK_IMPORTED_MODULE_7__.maybeDependOnExistenceOfEntity)(options.context.store, options.enclosingRef.__ref);\n            // Finally, if we didn't find any useful previous results, run the real\n            // execSelectionSetImpl method with the given options.\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize || _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */ ,\n            keyArgs: execSelectionSetKeyArgs,\n            // Note that the parameters of makeCacheKey are determined by the\n            // array returned by keyArgs.\n            makeCacheKey: function(selectionSet, parent, context, canonizeResults) {\n                if ((0,_entityStore_js__WEBPACK_IMPORTED_MODULE_7__.supportsResultCaching)(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            }\n        });\n        this.executeSubSelectedArray = (0,optimism__WEBPACK_IMPORTED_MODULE_1__.wrap)(function(options) {\n            (0,_entityStore_js__WEBPACK_IMPORTED_MODULE_7__.maybeDependOnExistenceOfEntity)(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize || _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */ ,\n            makeCacheKey: function(_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if ((0,_entityStore_js__WEBPACK_IMPORTED_MODULE_7__.supportsResultCaching)(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            }\n        });\n    }\n    StoreReader.prototype.resetCanon = function() {\n        this.canon = new _object_canon_js__WEBPACK_IMPORTED_MODULE_5__.ObjectCanon();\n    };\n    /**\n     * Given a store and a query, return as much of the result as possible and\n     * identify if any data was missing from the store.\n     */ StoreReader.prototype.diffQueryAgainstStore = function(_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \"ROOT_QUERY\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.getDefaultValues)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.getQueryDefinition)(query))), variables);\n        var rootRef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.makeReference)(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.getMainDefinition)(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({\n                store: store,\n                query: query,\n                policies: policies,\n                variables: variables,\n                varString: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.canonicalStringify)(variables),\n                canonizeResults: canonizeResults\n            }, (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.extractFragmentContext)(query, this.config.fragments))\n        });\n        var missing;\n        if (execResult.missing) {\n            // For backwards compatibility we still report an array of\n            // MissingFieldError objects, even though there will only ever be at most\n            // one of them, now that all missing field error messages are grouped\n            // together in the execResult.missing tree.\n            missing = [\n                new _core_types_common_js__WEBPACK_IMPORTED_MODULE_12__.MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)\n            ];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing\n        };\n    };\n    StoreReader.prototype.isFresh = function(result, parent, selectionSet, context) {\n        if ((0,_entityStore_js__WEBPACK_IMPORTED_MODULE_7__.supportsResultCaching)(context.store) && this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, // If result is canonical, then it could only have been previously\n            // cached by the canonizing version of executeSelectionSet, so we can\n            // avoid checking both possibilities here.\n            this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // Uncached version of executeSelectionSet.\n    StoreReader.prototype.execSelectionSetImpl = function(_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.DeepMerger();\n        if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n            // Ensure we always include a default value for the __typename\n            // field, if we have one, and this.config.addTypename is true. Note\n            // that this field can be overridden by other merged objects.\n            objectsToMerge.push({\n                __typename: typename\n            });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function(selection) {\n            var _a, _b;\n            // Omit fields with directives @skip(if: <truthy value>) or\n            // @include(if: <falsy value>).\n            if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_14__.shouldInclude)(selection, variables)) return;\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isField)(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference\n                }, context);\n                var resultName = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.resultKeyNameFromField)(selection);\n                if (fieldValue === void 0) {\n                    if (!_utilities_index_js__WEBPACK_IMPORTED_MODULE_15__.addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n                    }\n                } else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_16__.isArray)(fieldValue)) {\n                    if (fieldValue.length > 0) {\n                        fieldValue = handleMissing(_this.executeSubSelectedArray({\n                            field: selection,\n                            array: fieldValue,\n                            enclosingRef: enclosingRef,\n                            context: context\n                        }), resultName);\n                    }\n                } else if (!selection.selectionSet) {\n                    // If the field does not have a selection set, then we handle it\n                    // as a scalar value. To keep this.canon from canonicalizing\n                    // this value, we use this.canon.pass to wrap fieldValue in a\n                    // Pass object that this.canon.admit will later unwrap as-is.\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                } else if (fieldValue != null) {\n                    // In this case, because we know the field has a selection set,\n                    // it must be trying to query a GraphQLObjectType, which is why\n                    // fieldValue must be != null.\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(fieldValue) ? fieldValue : enclosingRef,\n                        context: context\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            } else {\n                var fragment = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_17__.getFragmentFromSelection)(selection, context.lookupFragment);\n                if (!fragment && selection.kind === graphql__WEBPACK_IMPORTED_MODULE_18__.Kind.FRAGMENT_SPREAD) {\n                    throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(9, selection.name.value);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.mergeDeepArray)(objectsToMerge);\n        var finalResult = {\n            result: result,\n            missing: missing\n        };\n        var frozen = context.canonizeResults ? this.canon.admit(finalResult) : (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_19__.maybeDeepFreeze)(finalResult);\n        // Store this result with its selection set so that we can quickly\n        // recognize it again in the StoreReader#isFresh method.\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    // Uncached version of executeSubSelectedArray.\n    StoreReader.prototype.execSubSelectedArrayImpl = function(_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function(item, i) {\n            // null value in array\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse\n            if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_16__.isArray)(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context\n                }), i);\n            }\n            // This is an object, run the selection set on it\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(item) ? item : enclosingRef,\n                    context: context\n                }), i);\n            }\n            if (globalThis.__DEV__ !== false) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing\n        };\n    };\n    return StoreReader;\n}();\n\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function(_, value) {\n            if (typeof value === \"string\") throw value;\n            return value;\n        });\n    } catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([\n            fieldValue\n        ]);\n        workSet_1.forEach(function(value) {\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_20__.isNonNullObject)(value)) {\n                (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.isReference)(value), 10, (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getTypenameFromStoreObject)(store, value), field.name.value);\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n} //# sourceMappingURL=readFromStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9yZWFkRnJvbVN0b3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDK0M7QUFDakQ7QUFDQztBQUN1VDtBQUM3UDtBQUN5QjtBQUN2RDtBQUNaO0FBQ2hELFNBQVMrQix3QkFBd0JDLE9BQU87SUFDcEMsT0FBTztRQUNIQSxRQUFRQyxZQUFZO1FBQ3BCRCxRQUFRRSxpQkFBaUI7UUFDekJGLFFBQVFHLE9BQU87UUFDZiw2REFBNkQ7UUFDN0QsMERBQTBEO1FBQzFESCxRQUFRRyxPQUFPLENBQUNDLGVBQWU7S0FDbEM7QUFDTDtBQUNBLElBQUlDLGNBQWMsV0FBVyxHQUFJO0lBQzdCLFNBQVNBLFlBQVlDLE1BQU07UUFDdkIsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUtyQixDQUFBQSw4REFBYUEsR0FBR3NCLFVBQVVDLEdBQUU7UUFDckQsSUFBSSxDQUFDSixNQUFNLEdBQUdsQiw0REFBT0EsQ0FBQ2tCLFFBQVE7WUFDMUJLLGFBQWFMLE9BQU9LLFdBQVcsS0FBSztZQUNwQ1AsaUJBQWlCUixrRUFBcUJBLENBQUNVO1FBQzNDO1FBQ0EsSUFBSSxDQUFDTSxLQUFLLEdBQUdOLE9BQU9NLEtBQUssSUFBSSxJQUFJZCx5REFBV0E7UUFDNUMsK0RBQStEO1FBQy9ELDJDQUEyQztRQUMzQyxvQ0FBb0M7UUFDcEMsb0VBQW9FO1FBQ3BFLElBQUksQ0FBQ2UsbUJBQW1CLEdBQUd6Qyw4Q0FBSUEsQ0FBQyxTQUFVNEIsT0FBTztZQUM3QyxJQUFJYztZQUNKLElBQUlWLGtCQUFrQkosUUFBUUcsT0FBTyxDQUFDQyxlQUFlO1lBQ3JELElBQUlXLFdBQVdoQix3QkFBd0JDO1lBQ3ZDLHNFQUFzRTtZQUN0RSw2Q0FBNkM7WUFDN0NlLFFBQVEsQ0FBQyxFQUFFLEdBQUcsQ0FBQ1g7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RyxJQUFJLENBQUNRLEtBQUssQ0FBQ1EsS0FBSyxDQUFDYyxTQUFTQTtZQUM1RGdCLFNBQVNBO1FBQ2I7SUFDSjtJQUNBLE9BQU83QztBQUNYO0FBQ3VCO0FBQ3ZCLFNBQVM4QyxhQUFhc0QsSUFBSTtJQUN0QixJQUFJO1FBQ0F0QixLQUFLQyxTQUFTLENBQUNxQixNQUFNLFNBQVVDLENBQUMsRUFBRTFCLEtBQUs7WUFDbkMsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE1BQU1BO1lBQ1YsT0FBT0E7UUFDWDtJQUNKLEVBQ0EsT0FBTzdELFFBQVE7UUFDWCxPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTcUYsNkJBQTZCbkYsS0FBSyxFQUFFWSxLQUFLLEVBQUUyQyxVQUFVO0lBQzFELElBQUksQ0FBQzNDLE1BQU1oQyxZQUFZLEVBQUU7UUFDckIsSUFBSTBHLFlBQVksSUFBSW5DLElBQUk7WUFBQ0k7U0FBVztRQUNwQytCLFVBQVVqQyxPQUFPLENBQUMsU0FBVU0sS0FBSztZQUM3QixJQUFJOUYscUVBQWVBLENBQUM4RixRQUFRO2dCQUN4Qi9HLHNFQUFTQSxDQUNMLENBQUNNLGdFQUFXQSxDQUFDeUcsUUFDYixJQUNBckYsdUVBQTBCQSxDQUFDMEIsT0FBTzJELFFBQ2xDL0MsTUFBTThDLElBQUksQ0FBQ0MsS0FBSztnQkFFcEI0QixPQUFPQyxNQUFNLENBQUM3QixPQUFPTixPQUFPLENBQUNpQyxVQUFVZixHQUFHLEVBQUVlO1lBQ2hEO1FBQ0o7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS9yZWFkRnJvbVN0b3JlLmpzPzMyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEtpbmQgfSBmcm9tIFwiZ3JhcGhxbFwiO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gXCJvcHRpbWlzbVwiO1xuaW1wb3J0IHsgaXNGaWVsZCwgcmVzdWx0S2V5TmFtZUZyb21GaWVsZCwgaXNSZWZlcmVuY2UsIG1ha2VSZWZlcmVuY2UsIHNob3VsZEluY2x1ZGUsIGFkZFR5cGVuYW1lVG9Eb2N1bWVudCwgZ2V0RGVmYXVsdFZhbHVlcywgZ2V0TWFpbkRlZmluaXRpb24sIGdldFF1ZXJ5RGVmaW5pdGlvbiwgZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uLCBtYXliZURlZXBGcmVlemUsIG1lcmdlRGVlcEFycmF5LCBEZWVwTWVyZ2VyLCBpc05vbk51bGxPYmplY3QsIGNhblVzZVdlYWtNYXAsIGNvbXBhY3QsIGNhbm9uaWNhbFN0cmluZ2lmeSwgY2FjaGVTaXplcywgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBtYXliZURlcGVuZE9uRXhpc3RlbmNlT2ZFbnRpdHksIHN1cHBvcnRzUmVzdWx0Q2FjaGluZywgfSBmcm9tIFwiLi9lbnRpdHlTdG9yZS5qc1wiO1xuaW1wb3J0IHsgaXNBcnJheSwgZXh0cmFjdEZyYWdtZW50Q29udGV4dCwgZ2V0VHlwZW5hbWVGcm9tU3RvcmVPYmplY3QsIHNob3VsZENhbm9uaXplUmVzdWx0cywgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBNaXNzaW5nRmllbGRFcnJvciB9IGZyb20gXCIuLi9jb3JlL3R5cGVzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgT2JqZWN0Q2Fub24gfSBmcm9tIFwiLi9vYmplY3QtY2Fub24uanNcIjtcbmZ1bmN0aW9uIGV4ZWNTZWxlY3Rpb25TZXRLZXlBcmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvblNldCxcbiAgICAgICAgb3B0aW9ucy5vYmplY3RPclJlZmVyZW5jZSxcbiAgICAgICAgb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAvLyBXZSBzcGxpdCBvdXQgdGhpcyBwcm9wZXJ0eSBzbyB3ZSBjYW4gcGFzcyBkaWZmZXJlbnQgdmFsdWVzXG4gICAgICAgIC8vIGluZGVwZW5kZW50bHkgd2l0aG91dCBtb2RpZnlpbmcgb3B0aW9ucy5jb250ZXh0IGl0c2VsZi5cbiAgICAgICAgb3B0aW9ucy5jb250ZXh0LmNhbm9uaXplUmVzdWx0cyxcbiAgICBdO1xufVxudmFyIFN0b3JlUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlUmVhZGVyKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmtub3duUmVzdWx0cyA9IG5ldyAoY2FuVXNlV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29tcGFjdChjb25maWcsIHtcbiAgICAgICAgICAgIGFkZFR5cGVuYW1lOiBjb25maWcuYWRkVHlwZW5hbWUgIT09IGZhbHNlLFxuICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiBzaG91bGRDYW5vbml6ZVJlc3VsdHMoY29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2Fub24gPSBjb25maWcuY2Fub24gfHwgbmV3IE9iamVjdENhbm9uKCk7XG4gICAgICAgIC8vIG1lbW9pemVkIGZ1bmN0aW9ucyBpbiB0aGlzIGNsYXNzIHdpbGwgYmUgXCJnYXJiYWdlLWNvbGxlY3RlZFwiXG4gICAgICAgIC8vIGJ5IHJlY3JlYXRpbmcgdGhlIHdob2xlIGBTdG9yZVJlYWRlcmAgaW5cbiAgICAgICAgLy8gYEluTWVtb3J5Q2FjaGUucmVzZXRSZXN1bHRzQ2FjaGVgXG4gICAgICAgIC8vICh0cmlnZ2VyZWQgZnJvbSBgSW5NZW1vcnlDYWNoZS5nY2Agd2l0aCBgcmVzZXRSZXN1bHRDYWNoZTogdHJ1ZWApXG4gICAgICAgIHRoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCA9IHdyYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBjYW5vbml6ZVJlc3VsdHMgPSBvcHRpb25zLmNvbnRleHQuY2Fub25pemVSZXN1bHRzO1xuICAgICAgICAgICAgdmFyIHBlZWtBcmdzID0gZXhlY1NlbGVjdGlvblNldEtleUFyZ3Mob3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBOZWdhdGUgdGhpcyBib29sZWFuIG9wdGlvbiBzbyB3ZSBjYW4gZmluZCBvdXQgaWYgd2UndmUgYWxyZWFkeSByZWFkXG4gICAgICAgICAgICAvLyB0aGlzIHJlc3VsdCB1c2luZyB0aGUgb3RoZXIgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICAgIHBlZWtBcmdzWzNdID0gIWNhbm9uaXplUmVzdWx0cztcbiAgICAgICAgICAgIHZhciBvdGhlciA9IChfYSA9IF90aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQpLnBlZWsuYXBwbHkoX2EsIHBlZWtBcmdzKTtcbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbml6ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvdGhlciksIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IHJlYWQgdGhpcyByZXN1bHQgd2l0aG91dCBjYW5vbml6aW5nIGl0LCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldXNlIHRoYXQgcmVzdWx0IHNpbXBseSBieSBjYW5vbml6aW5nIGl0IG5vdy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogX3RoaXMuY2Fub24uYWRtaXQob3RoZXIucmVzdWx0KSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSByZWFkIHRoaXMgcmVzdWx0IHdpdGggY2Fub25pemF0aW9uIGVuYWJsZWQsIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGF0IGNhbm9uaXplZCByZXN1bHQgYXMtaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF5YmVEZXBlbmRPbkV4aXN0ZW5jZU9mRW50aXR5KG9wdGlvbnMuY29udGV4dC5zdG9yZSwgb3B0aW9ucy5lbmNsb3NpbmdSZWYuX19yZWYpO1xuICAgICAgICAgICAgLy8gRmluYWxseSwgaWYgd2UgZGlkbid0IGZpbmQgYW55IHVzZWZ1bCBwcmV2aW91cyByZXN1bHRzLCBydW4gdGhlIHJlYWxcbiAgICAgICAgICAgIC8vIGV4ZWNTZWxlY3Rpb25TZXRJbXBsIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4ZWNTZWxlY3Rpb25TZXRJbXBsKG9wdGlvbnMpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXg6IHRoaXMuY29uZmlnLnJlc3VsdENhY2hlTWF4U2l6ZSB8fFxuICAgICAgICAgICAgICAgIGNhY2hlU2l6ZXNbXCJpbk1lbW9yeUNhY2hlLmV4ZWN1dGVTZWxlY3Rpb25TZXRcIl0gfHxcbiAgICAgICAgICAgICAgICA1MDAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImluTWVtb3J5Q2FjaGUuZXhlY3V0ZVNlbGVjdGlvblNldFwiXSAqLyxcbiAgICAgICAgICAgIGtleUFyZ3M6IGV4ZWNTZWxlY3Rpb25TZXRLZXlBcmdzLFxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBwYXJhbWV0ZXJzIG9mIG1ha2VDYWNoZUtleSBhcmUgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgICAgICAgIC8vIGFycmF5IHJldHVybmVkIGJ5IGtleUFyZ3MuXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHBhcmVudCwgY29udGV4dCwgY2Fub25pemVSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzUmVzdWx0Q2FjaGluZyhjb250ZXh0LnN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zdG9yZS5tYWtlQ2FjaGVLZXkoc2VsZWN0aW9uU2V0LCBpc1JlZmVyZW5jZShwYXJlbnQpID8gcGFyZW50Ll9fcmVmIDogcGFyZW50LCBjb250ZXh0LnZhclN0cmluZywgY2Fub25pemVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSA9IHdyYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eShvcHRpb25zLmNvbnRleHQuc3RvcmUsIG9wdGlvbnMuZW5jbG9zaW5nUmVmLl9fcmVmKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5leGVjU3ViU2VsZWN0ZWRBcnJheUltcGwob3B0aW9ucyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1heDogdGhpcy5jb25maWcucmVzdWx0Q2FjaGVNYXhTaXplIHx8XG4gICAgICAgICAgICAgICAgY2FjaGVTaXplc1tcImluTWVtb3J5Q2FjaGUuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXlcIl0gfHxcbiAgICAgICAgICAgICAgICAxMDAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImluTWVtb3J5Q2FjaGUuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXlcIl0gKi8sXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCBhcnJheSA9IF9hLmFycmF5LCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0b3JlLm1ha2VDYWNoZUtleShmaWVsZCwgYXJyYXksIGNvbnRleHQudmFyU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLnJlc2V0Q2Fub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2Fub24gPSBuZXcgT2JqZWN0Q2Fub24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RvcmUgYW5kIGEgcXVlcnksIHJldHVybiBhcyBtdWNoIG9mIHRoZSByZXN1bHQgYXMgcG9zc2libGUgYW5kXG4gICAgICogaWRlbnRpZnkgaWYgYW55IGRhdGEgd2FzIG1pc3NpbmcgZnJvbSB0aGUgc3RvcmUuXG4gICAgICovXG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmRpZmZRdWVyeUFnYWluc3RTdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RvcmUgPSBfYS5zdG9yZSwgcXVlcnkgPSBfYS5xdWVyeSwgX2IgPSBfYS5yb290SWQsIHJvb3RJZCA9IF9iID09PSB2b2lkIDAgPyBcIlJPT1RfUVVFUllcIiA6IF9iLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIF9jID0gX2EucmV0dXJuUGFydGlhbERhdGEsIHJldHVyblBhcnRpYWxEYXRhID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBfYS5jYW5vbml6ZVJlc3VsdHMsIGNhbm9uaXplUmVzdWx0cyA9IF9kID09PSB2b2lkIDAgPyB0aGlzLmNvbmZpZy5jYW5vbml6ZVJlc3VsdHMgOiBfZDtcbiAgICAgICAgdmFyIHBvbGljaWVzID0gdGhpcy5jb25maWcuY2FjaGUucG9saWNpZXM7XG4gICAgICAgIHZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXREZWZhdWx0VmFsdWVzKGdldFF1ZXJ5RGVmaW5pdGlvbihxdWVyeSkpKSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIHJvb3RSZWYgPSBtYWtlUmVmZXJlbmNlKHJvb3RJZCk7XG4gICAgICAgIHZhciBleGVjUmVzdWx0ID0gdGhpcy5leGVjdXRlU2VsZWN0aW9uU2V0KHtcbiAgICAgICAgICAgIHNlbGVjdGlvblNldDogZ2V0TWFpbkRlZmluaXRpb24ocXVlcnkpLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG9iamVjdE9yUmVmZXJlbmNlOiByb290UmVmLFxuICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiByb290UmVmLFxuICAgICAgICAgICAgY29udGV4dDogX19hc3NpZ24oeyBzdG9yZTogc3RvcmUsIHF1ZXJ5OiBxdWVyeSwgcG9saWNpZXM6IHBvbGljaWVzLCB2YXJpYWJsZXM6IHZhcmlhYmxlcywgdmFyU3RyaW5nOiBjYW5vbmljYWxTdHJpbmdpZnkodmFyaWFibGVzKSwgY2Fub25pemVSZXN1bHRzOiBjYW5vbml6ZVJlc3VsdHMgfSwgZXh0cmFjdEZyYWdtZW50Q29udGV4dChxdWVyeSwgdGhpcy5jb25maWcuZnJhZ21lbnRzKSksXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWlzc2luZztcbiAgICAgICAgaWYgKGV4ZWNSZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHN0aWxsIHJlcG9ydCBhbiBhcnJheSBvZlxuICAgICAgICAgICAgLy8gTWlzc2luZ0ZpZWxkRXJyb3Igb2JqZWN0cywgZXZlbiB0aG91Z2ggdGhlcmUgd2lsbCBvbmx5IGV2ZXIgYmUgYXQgbW9zdFxuICAgICAgICAgICAgLy8gb25lIG9mIHRoZW0sIG5vdyB0aGF0IGFsbCBtaXNzaW5nIGZpZWxkIGVycm9yIG1lc3NhZ2VzIGFyZSBncm91cGVkXG4gICAgICAgICAgICAvLyB0b2dldGhlciBpbiB0aGUgZXhlY1Jlc3VsdC5taXNzaW5nIHRyZWUuXG4gICAgICAgICAgICBtaXNzaW5nID0gW1xuICAgICAgICAgICAgICAgIG5ldyBNaXNzaW5nRmllbGRFcnJvcihmaXJzdE1pc3NpbmcoZXhlY1Jlc3VsdC5taXNzaW5nKSwgZXhlY1Jlc3VsdC5taXNzaW5nLCBxdWVyeSwgdmFyaWFibGVzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoIXJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbWlzc2luZ1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBleGVjUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAhbWlzc2luZyxcbiAgICAgICAgICAgIG1pc3Npbmc6IG1pc3NpbmcsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUuaXNGcmVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIHBhcmVudCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc3VsdENhY2hpbmcoY29udGV4dC5zdG9yZSkgJiZcbiAgICAgICAgICAgIHRoaXMua25vd25SZXN1bHRzLmdldChyZXN1bHQpID09PSBzZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIHZhciBsYXRlc3QgPSB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQucGVlayhzZWxlY3Rpb25TZXQsIHBhcmVudCwgY29udGV4dCwgXG4gICAgICAgICAgICAvLyBJZiByZXN1bHQgaXMgY2Fub25pY2FsLCB0aGVuIGl0IGNvdWxkIG9ubHkgaGF2ZSBiZWVuIHByZXZpb3VzbHlcbiAgICAgICAgICAgIC8vIGNhY2hlZCBieSB0aGUgY2Fub25pemluZyB2ZXJzaW9uIG9mIGV4ZWN1dGVTZWxlY3Rpb25TZXQsIHNvIHdlIGNhblxuICAgICAgICAgICAgLy8gYXZvaWQgY2hlY2tpbmcgYm90aCBwb3NzaWJpbGl0aWVzIGhlcmUuXG4gICAgICAgICAgICB0aGlzLmNhbm9uLmlzS25vd24ocmVzdWx0KSk7XG4gICAgICAgICAgICBpZiAobGF0ZXN0ICYmIHJlc3VsdCA9PT0gbGF0ZXN0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFVuY2FjaGVkIHZlcnNpb24gb2YgZXhlY3V0ZVNlbGVjdGlvblNldC5cbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUuZXhlY1NlbGVjdGlvblNldEltcGwgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgb2JqZWN0T3JSZWZlcmVuY2UgPSBfYS5vYmplY3RPclJlZmVyZW5jZSwgZW5jbG9zaW5nUmVmID0gX2EuZW5jbG9zaW5nUmVmLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgaWYgKGlzUmVmZXJlbmNlKG9iamVjdE9yUmVmZXJlbmNlKSAmJlxuICAgICAgICAgICAgIWNvbnRleHQucG9saWNpZXMucm9vdFR5cGVuYW1lc0J5SWRbb2JqZWN0T3JSZWZlcmVuY2UuX19yZWZdICYmXG4gICAgICAgICAgICAhY29udGV4dC5zdG9yZS5oYXMob2JqZWN0T3JSZWZlcmVuY2UuX19yZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5jYW5vbi5lbXB0eSxcbiAgICAgICAgICAgICAgICBtaXNzaW5nOiBcIkRhbmdsaW5nIHJlZmVyZW5jZSB0byBtaXNzaW5nIFwiLmNvbmNhdChvYmplY3RPclJlZmVyZW5jZS5fX3JlZiwgXCIgb2JqZWN0XCIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFyaWFibGVzID0gY29udGV4dC52YXJpYWJsZXMsIHBvbGljaWVzID0gY29udGV4dC5wb2xpY2llcywgc3RvcmUgPSBjb250ZXh0LnN0b3JlO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKG9iamVjdE9yUmVmZXJlbmNlLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgIHZhciBvYmplY3RzVG9NZXJnZSA9IFtdO1xuICAgICAgICB2YXIgbWlzc2luZztcbiAgICAgICAgdmFyIG1pc3NpbmdNZXJnZXIgPSBuZXcgRGVlcE1lcmdlcigpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkVHlwZW5hbWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIXBvbGljaWVzLnJvb3RJZHNCeVR5cGVuYW1lW3R5cGVuYW1lXSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBpbmNsdWRlIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIF9fdHlwZW5hbWVcbiAgICAgICAgICAgIC8vIGZpZWxkLCBpZiB3ZSBoYXZlIG9uZSwgYW5kIHRoaXMuY29uZmlnLmFkZFR5cGVuYW1lIGlzIHRydWUuIE5vdGVcbiAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBmaWVsZCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBvdGhlciBtZXJnZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iamVjdHNUb01lcmdlLnB1c2goeyBfX3R5cGVuYW1lOiB0eXBlbmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNaXNzaW5nKHJlc3VsdCwgcmVzdWx0TmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmdNZXJnZXIubWVyZ2UobWlzc2luZywgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgIF9hW3Jlc3VsdE5hbWVdID0gcmVzdWx0Lm1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd29ya1NldCA9IG5ldyBTZXQoc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMpO1xuICAgICAgICB3b3JrU2V0LmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIE9taXQgZmllbGRzIHdpdGggZGlyZWN0aXZlcyBAc2tpcChpZjogPHRydXRoeSB2YWx1ZT4pIG9yXG4gICAgICAgICAgICAvLyBAaW5jbHVkZShpZjogPGZhbHN5IHZhbHVlPikuXG4gICAgICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCB2YXJpYWJsZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRWYWx1ZSA9IHBvbGljaWVzLnJlYWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogc2VsZWN0aW9uLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogY29udGV4dC52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IG9iamVjdE9yUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHROYW1lID0gcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRUeXBlbmFtZVRvRG9jdW1lbnQuYWRkZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmdNZXJnZXIubWVyZ2UobWlzc2luZywgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbcmVzdWx0TmFtZV0gPSBcIkNhbid0IGZpbmQgZmllbGQgJ1wiLmNvbmNhdChzZWxlY3Rpb24ubmFtZS52YWx1ZSwgXCInIG9uIFwiKS5jb25jYXQoaXNSZWZlcmVuY2Uob2JqZWN0T3JSZWZlcmVuY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0T3JSZWZlcmVuY2UuX19yZWYgKyBcIiBvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwib2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0T3JSZWZlcmVuY2UsIG51bGwsIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiBlbmNsb3NpbmdSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCByZXN1bHROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2VsZWN0aW9uLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHNlbGVjdGlvbiBzZXQsIHRoZW4gd2UgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgc2NhbGFyIHZhbHVlLiBUbyBrZWVwIHRoaXMuY2Fub24gZnJvbSBjYW5vbmljYWxpemluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlLCB3ZSB1c2UgdGhpcy5jYW5vbi5wYXNzIHRvIHdyYXAgZmllbGRWYWx1ZSBpbiBhXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3Mgb2JqZWN0IHRoYXQgdGhpcy5jYW5vbi5hZG1pdCB3aWxsIGxhdGVyIHVud3JhcCBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2Fub25pemVSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gX3RoaXMuY2Fub24ucGFzcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBiZWNhdXNlIHdlIGtub3cgdGhlIGZpZWxkIGhhcyBhIHNlbGVjdGlvbiBzZXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IG11c3QgYmUgdHJ5aW5nIHRvIHF1ZXJ5IGEgR3JhcGhRTE9iamVjdFR5cGUsIHdoaWNoIGlzIHdoeVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZFZhbHVlIG11c3QgYmUgIT0gbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RPclJlZmVyZW5jZTogZmllbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY2xvc2luZ1JlZjogaXNSZWZlcmVuY2UoZmllbGRWYWx1ZSkgPyBmaWVsZFZhbHVlIDogZW5jbG9zaW5nUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSksIHJlc3VsdE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHNUb01lcmdlLnB1c2goKF9iID0ge30sIF9iW3Jlc3VsdE5hbWVdID0gZmllbGRWYWx1ZSwgX2IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBjb250ZXh0Lmxvb2t1cEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZyYWdtZW50ICYmIHNlbGVjdGlvbi5raW5kID09PSBLaW5kLkZSQUdNRU5UX1NQUkVBRCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXdJbnZhcmlhbnRFcnJvcig5LCBzZWxlY3Rpb24ubmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAmJiBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMoZnJhZ21lbnQsIHR5cGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5mb3JFYWNoKHdvcmtTZXQuYWRkLCB3b3JrU2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWVyZ2VEZWVwQXJyYXkob2JqZWN0c1RvTWVyZ2UpO1xuICAgICAgICB2YXIgZmluYWxSZXN1bHQgPSB7IHJlc3VsdDogcmVzdWx0LCBtaXNzaW5nOiBtaXNzaW5nIH07XG4gICAgICAgIHZhciBmcm96ZW4gPSBjb250ZXh0LmNhbm9uaXplUmVzdWx0cyA/XG4gICAgICAgICAgICB0aGlzLmNhbm9uLmFkbWl0KGZpbmFsUmVzdWx0KVxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcy5jYW5vbiBpcyBub3JtYWxseSByZXNwb25zaWJsZSBmb3IgZnJlZXppbmcgcmVzdWx0cyAob25seSBpblxuICAgICAgICAgICAgLy8gZGV2ZWxvcG1lbnQpLCBmcmVlemUgdGhlbSBtYW51YWxseSBpZiBjYW5vbml6YXRpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAgICA6IG1heWJlRGVlcEZyZWV6ZShmaW5hbFJlc3VsdCk7XG4gICAgICAgIC8vIFN0b3JlIHRoaXMgcmVzdWx0IHdpdGggaXRzIHNlbGVjdGlvbiBzZXQgc28gdGhhdCB3ZSBjYW4gcXVpY2tseVxuICAgICAgICAvLyByZWNvZ25pemUgaXQgYWdhaW4gaW4gdGhlIFN0b3JlUmVhZGVyI2lzRnJlc2ggbWV0aG9kLlxuICAgICAgICBpZiAoZnJvemVuLnJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5rbm93blJlc3VsdHMuc2V0KGZyb3plbi5yZXN1bHQsIHNlbGVjdGlvblNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb3plbjtcbiAgICB9O1xuICAgIC8vIFVuY2FjaGVkIHZlcnNpb24gb2YgZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkuXG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWNTdWJTZWxlY3RlZEFycmF5SW1wbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgYXJyYXkgPSBfYS5hcnJheSwgZW5jbG9zaW5nUmVmID0gX2EuZW5jbG9zaW5nUmVmLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG1pc3Npbmc7XG4gICAgICAgIHZhciBtaXNzaW5nTWVyZ2VyID0gbmV3IERlZXBNZXJnZXIoKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTWlzc2luZyhjaGlsZFJlc3VsdCwgaSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGNoaWxkUmVzdWx0Lm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nID0gbWlzc2luZ01lcmdlci5tZXJnZShtaXNzaW5nLCAoX2EgPSB7fSwgX2FbaV0gPSBjaGlsZFJlc3VsdC5taXNzaW5nLCBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5LmZpbHRlcihjb250ZXh0LnN0b3JlLmNhblJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5ID0gYXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAvLyBudWxsIHZhbHVlIGluIGFycmF5XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBhcnJheSwgcmVjdXJzZVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTWlzc2luZyhfdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGVuY2xvc2luZ1JlZjogZW5jbG9zaW5nUmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0LCBydW4gdGhlIHNlbGVjdGlvbiBzZXQgb24gaXRcbiAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTWlzc2luZyhfdGhpcy5leGVjdXRlU2VsZWN0aW9uU2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE9yUmVmZXJlbmNlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBlbmNsb3NpbmdSZWY6IGlzUmVmZXJlbmNlKGl0ZW0pID8gaXRlbSA6IGVuY2xvc2luZ1JlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFNlbGVjdGlvblNldEZvcklkVmFsdWUoY29udGV4dC5zdG9yZSwgZmllbGQsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBjb250ZXh0LmNhbm9uaXplUmVzdWx0cyA/IHRoaXMuY2Fub24uYWRtaXQoYXJyYXkpIDogYXJyYXksXG4gICAgICAgICAgICBtaXNzaW5nOiBtaXNzaW5nLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlUmVhZGVyO1xufSgpKTtcbmV4cG9ydCB7IFN0b3JlUmVhZGVyIH07XG5mdW5jdGlvbiBmaXJzdE1pc3NpbmcodHJlZSkge1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRyZWUsIGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTZWxlY3Rpb25TZXRGb3JJZFZhbHVlKHN0b3JlLCBmaWVsZCwgZmllbGRWYWx1ZSkge1xuICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgIHZhciB3b3JrU2V0XzEgPSBuZXcgU2V0KFtmaWVsZFZhbHVlXSk7XG4gICAgICAgIHdvcmtTZXRfMS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICAgICAgICAgICFpc1JlZmVyZW5jZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICBnZXRUeXBlbmFtZUZyb21TdG9yZU9iamVjdChzdG9yZSwgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5uYW1lLnZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHZhbHVlKS5mb3JFYWNoKHdvcmtTZXRfMS5hZGQsIHdvcmtTZXRfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWRGcm9tU3RvcmUuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiaW52YXJpYW50IiwibmV3SW52YXJpYW50RXJyb3IiLCJLaW5kIiwid3JhcCIsImlzRmllbGQiLCJyZXN1bHRLZXlOYW1lRnJvbUZpZWxkIiwiaXNSZWZlcmVuY2UiLCJtYWtlUmVmZXJlbmNlIiwic2hvdWxkSW5jbHVkZSIsImFkZFR5cGVuYW1lVG9Eb2N1bWVudCIsImdldERlZmF1bHRWYWx1ZXMiLCJnZXRNYWluRGVmaW5pdGlvbiIsImdldFF1ZXJ5RGVmaW5pdGlvbiIsImdldEZyYWdtZW50RnJvbVNlbGVjdGlvbiIsIm1heWJlRGVlcEZyZWV6ZSIsIm1lcmdlRGVlcEFycmF5IiwiRGVlcE1lcmdlciIsImlzTm9uTnVsbE9iamVjdCIsImNhblVzZVdlYWtNYXAiLCJjb21wYWN0IiwiY2Fub25pY2FsU3RyaW5naWZ5IiwiY2FjaGVTaXplcyIsIm1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eSIsInN1cHBvcnRzUmVzdWx0Q2FjaGluZyIsImlzQXJyYXkiLCJleHRyYWN0RnJhZ21lbnRDb250ZXh0IiwiZ2V0VHlwZW5hbWVGcm9tU3RvcmVPYmplY3QiLCJzaG91bGRDYW5vbml6ZVJlc3VsdHMiLCJNaXNzaW5nRmllbGRFcnJvciIsIk9iamVjdENhbm9uIiwiZXhlY1NlbGVjdGlvblNldEtleUFyZ3MiLCJvcHRpb25zIiwic2VsZWN0aW9uU2V0Iiwib2JqZWN0T3JSZWZlcmVuY2UiLCJjb250ZXh0IiwiY2Fub25pemVSZXN1bHRzIiwiU3RvcmVSZWFkZXIiLCJjb25maWciLCJfdGhpcyIsImtub3duUmVzdWx0cyIsIldlYWtNYXAiLCJNYXAiLCJhZGRUeXBlbmFtZSIsImNhbm9uIiwiZXhlY3V0ZVNlbGVjdGlvblNldCIsIl9hIiwicGVla0FyZ3MiLCJvdGhlciIsInBlZWsiLCJhcHBseSIsInJlc3VsdCIsImFkbWl0Iiwic3RvcmUiLCJlbmNsb3NpbmdSZWYiLCJfX3JlZiIsImV4ZWNTZWxlY3Rpb25TZXRJbXBsIiwibWF4IiwicmVzdWx0Q2FjaGVNYXhTaXplIiwia2V5QXJncyIsIm1ha2VDYWNoZUtleSIsInBhcmVudCIsInZhclN0cmluZyIsImV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5IiwiZXhlY1N1YlNlbGVjdGVkQXJyYXlJbXBsIiwiZmllbGQiLCJhcnJheSIsInByb3RvdHlwZSIsInJlc2V0Q2Fub24iLCJkaWZmUXVlcnlBZ2FpbnN0U3RvcmUiLCJxdWVyeSIsIl9iIiwicm9vdElkIiwidmFyaWFibGVzIiwiX2MiLCJyZXR1cm5QYXJ0aWFsRGF0YSIsIl9kIiwicG9saWNpZXMiLCJjYWNoZSIsInJvb3RSZWYiLCJleGVjUmVzdWx0IiwiZnJhZ21lbnRzIiwibWlzc2luZyIsImZpcnN0TWlzc2luZyIsImNvbXBsZXRlIiwiaXNGcmVzaCIsImdldCIsImxhdGVzdCIsImlzS25vd24iLCJyb290VHlwZW5hbWVzQnlJZCIsImhhcyIsImVtcHR5IiwiY29uY2F0IiwidHlwZW5hbWUiLCJnZXRGaWVsZFZhbHVlIiwib2JqZWN0c1RvTWVyZ2UiLCJtaXNzaW5nTWVyZ2VyIiwicm9vdElkc0J5VHlwZW5hbWUiLCJwdXNoIiwiX190eXBlbmFtZSIsImhhbmRsZU1pc3NpbmciLCJyZXN1bHROYW1lIiwibWVyZ2UiLCJ3b3JrU2V0IiwiU2V0Iiwic2VsZWN0aW9ucyIsImZvckVhY2giLCJzZWxlY3Rpb24iLCJmaWVsZFZhbHVlIiwicmVhZEZpZWxkIiwiZmllbGROYW1lIiwibmFtZSIsInZhbHVlIiwiZnJvbSIsImFkZGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImxlbmd0aCIsInBhc3MiLCJmcmFnbWVudCIsImxvb2t1cEZyYWdtZW50Iiwia2luZCIsIkZSQUdNRU5UX1NQUkVBRCIsImZyYWdtZW50TWF0Y2hlcyIsImFkZCIsImZpbmFsUmVzdWx0IiwiZnJvemVuIiwic2V0IiwiY2hpbGRSZXN1bHQiLCJpIiwiZmlsdGVyIiwiY2FuUmVhZCIsIm1hcCIsIml0ZW0iLCJnbG9iYWxUaGlzIiwiX19ERVZfXyIsImFzc2VydFNlbGVjdGlvblNldEZvcklkVmFsdWUiLCJ0cmVlIiwiXyIsIndvcmtTZXRfMSIsIk9iamVjdCIsInZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/readFromStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/writeToStore.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/writeToStore.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StoreWriter: function() { return /* binding */ StoreWriter; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/helpers.js\");\n/* harmony import */ var _policies_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./policies.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/policies.js\");\n\n\n\n\n\n\n\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, context), {\n            clientOnly: clientOnly,\n            deferred: deferred\n        }));\n    }\n    return flavored;\n}\nvar StoreWriter = /** @class */ function() {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function(store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.getOperationDefinition)(query);\n        var merger = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.makeProcessedFieldsMerger)();\n        variables = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.getDefaultValues)(operationDefinition)), variables);\n        var context = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n            store: store,\n            written: Object.create(null),\n            merge: function(existing, incoming) {\n                return merger.merge(existing, incoming);\n            },\n            variables: variables,\n            varString: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.canonicalStringify)(variables)\n        }, (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.extractFragmentContext)(query, this.fragments)), {\n            overwrite: !!overwrite,\n            incomingById: new Map(),\n            clientOnly: false,\n            deferred: false,\n            flavors: new Map()\n        });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: {\n                map: new Map()\n            },\n            context: context\n        });\n        if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(ref)) {\n            throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(11, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(function(_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.makeReference)(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function(field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function(storeFieldName) {\n                    return fieldsWithSelectionSets_1[(0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.fieldNameFromStoreName)(storeFieldName)] === true;\n                };\n                var hasMergeFunction_1 = function(storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function(storeFieldName) {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function(_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, // This object allows processSelectionSet to report useful information\n        // to its callers without explicitly returning that information.\n        mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        var incoming = Object.create(null);\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        var typename = dataId && policies.rootTypenamesById[dataId] || (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.getTypenameFromResult)(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        var readField = function() {\n            var options = (0,_policies_js__WEBPACK_IMPORTED_MODULE_8__.normalizeReadFieldOptions)(arguments, incoming, context.variables);\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), {\n                        from: info.storeObject\n                    }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach(function(context, field) {\n            var _a;\n            var resultFieldKey = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.resultKeyNameFromField)(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                var childTypename = void 0;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet && ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(incomingValue) || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.storeValueIsStoreObject)(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field: field,\n                        typename: typename,\n                        merge: merge\n                    };\n                } else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n            } else if (globalThis.__DEV__ !== false && !context.clientOnly && !context.deferred && !_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or\n            // provide a default value, so its absence from the written data should\n            // not be cause for alarm.\n            !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(12, (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.resultKeyNameFromField)(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField\n            }), id = _b[0], keyObject = _b[1];\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        } catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId) throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.makeReference)(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0) return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function(field) {\n                    return previous_1.fieldNodeSet.add(field);\n                });\n            } else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function(value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return globalThis.__DEV__ !== false ? (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(value) : value;\n        }\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(value)) {\n            return value.map(function(item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree\n        });\n    };\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    StoreWriter.prototype.flattenFields = function(selectionSet, result, context, typename) {\n        if (typename === void 0) {\n            typename = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.getTypenameFromResult)(result, selectionSet, context.fragmentMap);\n        }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new _wry_trie__WEBPACK_IMPORTED_MODULE_2__.Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited) return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function(selection) {\n                if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_12__.shouldInclude)(selection, context.variables)) return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (// Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isNonEmptyArray)(selection.directives)) {\n                    selection.directives.forEach(function(dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\") clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.argumentsObjectFromField)(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                        // TODO In the future, we may want to record args.label using\n                        // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isField)(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                } else {\n                    var fragment = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.getFragmentFromSelection)(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === graphql__WEBPACK_IMPORTED_MODULE_14__.Kind.FRAGMENT_SPREAD) {\n                        throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(13, selection.name.value);\n                    }\n                    if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(incoming)) {\n            var e_1 = // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(incoming) && // Likewise, existing must be either a Reference or a StoreObject\n            // in order for its fields to be safe to merge with the fields of\n            // the incoming object.\n            ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(existing) || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.storeValueIsStoreObject)(existing)) ? existing : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            var i_1 = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [\n                    (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(e_1) ? e_1.__ref : e_1\n                ];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            var changedFields_1;\n            var getValue_1 = function(from, name) {\n                return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n            };\n            mergeTree.map.forEach(function(childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal) return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map();\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(i_1) ? i_1.slice(0) : (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, i_1);\n                changedFields_1.forEach(function(value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}();\n\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || {\n            map: new Map()\n        });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n    if (!left || mergeTreeIsEmpty(left)) return right;\n    var info = left.info && right.info ? (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n    var merged = {\n        info: info,\n        map: map\n    };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function(leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function(key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function(objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing) return;\n    var incoming = getChild(incomingObj);\n    if (!incoming) return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.isReference)(existing)) return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(existing, incoming)) return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every(function(key) {\n        return store.getFieldValue(incoming, key) !== void 0;\n    })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.fieldNameFromStoreName)(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName)) return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(existing) && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_11__.isArray)(incoming)) {\n        [\n            existing,\n            incoming\n        ].forEach(function(child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(14, fieldName, parentType, childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", typeDotName, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, existing), (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, incoming));\n} //# sourceMappingURL=writeToStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9pbm1lbW9yeS93cml0ZVRvU3RvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUMrQztBQUMxQztBQUNMO0FBQ0Y7QUFDb1I7QUFDdks7QUFDbEY7QUFDMUQsNEVBQTRFO0FBQzVFLDhFQUE4RTtBQUM5RSxnRkFBZ0Y7QUFDaEYsK0VBQStFO0FBQy9FLCtEQUErRDtBQUMvRCxTQUFTMEIsaUJBQWlCQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsUUFBUTtJQUNuRCxJQUFJQyxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0gsWUFBWUcsTUFBTSxDQUFDRjtJQUN2QyxJQUFJRyxXQUFXTCxRQUFRTSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0o7SUFDbkMsSUFBSSxDQUFDRSxVQUFVO1FBQ1hMLFFBQVFNLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDTCxLQUFNRSxXQUN0QkwsUUFBUUMsVUFBVSxLQUFLQSxjQUFjRCxRQUFRRSxRQUFRLEtBQUtBLFdBQ3RERixVQUNFM0IsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBRzJCLFVBQVU7WUFBRUMsWUFBWUE7WUFBWUMsVUFBVUE7UUFBUztJQUMzRjtJQUNBLE9BQU9HO0FBQ1g7QUFDQSxJQUFJSSxjQUFjLFdBQVcsR0FBSTtJQUM3QixTQUFTQSxZQUFZQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsU0FBUztRQUN6QyxJQUFJLENBQUNGLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDckI7SUFDQUgsWUFBWUksU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxFQUFFO1FBQ3BELElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJQyxRQUFRRixHQUFHRSxLQUFLLEVBQUVDLFNBQVNILEdBQUdHLE1BQU0sRUFBRUMs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RUFBdUU7SUFDdkUsNERBQTREO0lBQzVELElBQUksQ0FBQ2pLLHFEQUFPQSxDQUFDb0MsYUFBYSxDQUFDcEMscURBQU9BLENBQUNxQyxXQUFXO1FBQzFDO1lBQUNEO1lBQVVDO1NBQVMsQ0FBQ1MsT0FBTyxDQUFDLFNBQVUrRyxLQUFLO1lBQ3hDLElBQUl2RixXQUFXaEQsTUFBTThHLGFBQWEsQ0FBQ3lCLE9BQU87WUFDMUMsSUFBSSxPQUFPdkYsYUFBYSxZQUFZLENBQUMyRixlQUFlQyxRQUFRLENBQUM1RixXQUFXO2dCQUNwRTJGLGVBQWUzRCxJQUFJLENBQUNoQztZQUN4QjtRQUNKO0lBQ0o7SUFDQWpCLFdBQVdDLE9BQU8sS0FBSyxTQUFTekUsa0VBQVNBLENBQUNzTCxJQUFJLENBQUMsSUFBSS9FLFdBQVcyRSxZQUFZRSxlQUFlRyxNQUFNLEdBQzNGLHVDQUNJSCxlQUFlSSxJQUFJLENBQUMsV0FDcEIsZ0RBQ0YsSUFBSUwsYUFBYXBMLCtDQUFRQSxDQUFDLENBQUMsR0FBR3dELFdBQVd4RCwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUd5RDtBQUNoRSxFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvaW5tZW1vcnkvd3JpdGVUb1N0b3JlLmpzP2M5MTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVxdWFsIH0gZnJvbSBcIkB3cnkvZXF1YWxpdHlcIjtcbmltcG9ydCB7IFRyaWUgfSBmcm9tIFwiQHdyeS90cmllXCI7XG5pbXBvcnQgeyBLaW5kIH0gZnJvbSBcImdyYXBocWxcIjtcbmltcG9ydCB7IGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbiwgZ2V0RGVmYXVsdFZhbHVlcywgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgZ2V0VHlwZW5hbWVGcm9tUmVzdWx0LCBtYWtlUmVmZXJlbmNlLCBpc0ZpZWxkLCByZXN1bHRLZXlOYW1lRnJvbUZpZWxkLCBpc1JlZmVyZW5jZSwgc2hvdWxkSW5jbHVkZSwgY2xvbmVEZWVwLCBhZGRUeXBlbmFtZVRvRG9jdW1lbnQsIGlzTm9uRW1wdHlBcnJheSwgYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkLCBjYW5vbmljYWxTdHJpbmdpZnksIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBcnJheSwgbWFrZVByb2Nlc3NlZEZpZWxkc01lcmdlciwgZmllbGROYW1lRnJvbVN0b3JlTmFtZSwgc3RvcmVWYWx1ZUlzU3RvcmVPYmplY3QsIGV4dHJhY3RGcmFnbWVudENvbnRleHQsIH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplUmVhZEZpZWxkT3B0aW9ucyB9IGZyb20gXCIuL3BvbGljaWVzLmpzXCI7XG4vLyBTaW5jZSB0aGVyZSBhcmUgb25seSBmb3VyIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBjb250ZXh0LmNsaWVudE9ubHkgYW5kXG4vLyBjb250ZXh0LmRlZmVycmVkIHZhbHVlcywgd2Ugc2hvdWxkIG5lZWQgYXQgbW9zdCBmb3VyIFwiZmxhdm9yc1wiIG9mIGFueSBnaXZlblxuLy8gV3JpdGVDb250ZXh0LiBUbyBhdm9pZCBjcmVhdGluZyBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIHNhbWUgY29udGV4dCwgd2UgY2FjaGVcbi8vIHRoZSBjb250ZXh0cyBpbiB0aGUgY29udGV4dC5mbGF2b3JzIE1hcCAoc2hhcmVkIGJ5IGFsbCBmbGF2b3JzKSBhY2NvcmRpbmcgdG9cbi8vIHRoZWlyIGNsaWVudE9ubHkgYW5kIGRlZmVycmVkIHZhbHVlcyAoYWx3YXlzIGluIHRoYXQgb3JkZXIpLlxuZnVuY3Rpb24gZ2V0Q29udGV4dEZsYXZvcihjb250ZXh0LCBjbGllbnRPbmx5LCBkZWZlcnJlZCkge1xuICAgIHZhciBrZXkgPSBcIlwiLmNvbmNhdChjbGllbnRPbmx5KS5jb25jYXQoZGVmZXJyZWQpO1xuICAgIHZhciBmbGF2b3JlZCA9IGNvbnRleHQuZmxhdm9ycy5nZXQoa2V5KTtcbiAgICBpZiAoIWZsYXZvcmVkKSB7XG4gICAgICAgIGNvbnRleHQuZmxhdm9ycy5zZXQoa2V5LCAoZmxhdm9yZWQgPVxuICAgICAgICAgICAgY29udGV4dC5jbGllbnRPbmx5ID09PSBjbGllbnRPbmx5ICYmIGNvbnRleHQuZGVmZXJyZWQgPT09IGRlZmVycmVkID9cbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgY2xpZW50T25seTogY2xpZW50T25seSwgZGVmZXJyZWQ6IGRlZmVycmVkIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBmbGF2b3JlZDtcbn1cbnZhciBTdG9yZVdyaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZVdyaXRlcihjYWNoZSwgcmVhZGVyLCBmcmFnbWVudHMpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgfVxuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS53cml0ZVRvU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUsIF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCByZXN1bHQgPSBfYS5yZXN1bHQsIGRhdGFJZCA9IF9hLmRhdGFJZCwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBvdmVyd3JpdGUgPSBfYS5vdmVyd3JpdGU7XG4gICAgICAgIHZhciBvcGVyYXRpb25EZWZpbml0aW9uID0gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHZhciBtZXJnZXIgPSBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCk7XG4gICAgICAgIHZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXREZWZhdWx0VmFsdWVzKG9wZXJhdGlvbkRlZmluaXRpb24pKSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHN0b3JlOiBzdG9yZSwgd3JpdHRlbjogT2JqZWN0LmNyZWF0ZShudWxsKSwgbWVyZ2U6IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VyLm1lcmdlKGV4aXN0aW5nLCBpbmNvbWluZyk7XG4gICAgICAgICAgICB9LCB2YXJpYWJsZXM6IHZhcmlhYmxlcywgdmFyU3RyaW5nOiBjYW5vbmljYWxTdHJpbmdpZnkodmFyaWFibGVzKSB9LCBleHRyYWN0RnJhZ21lbnRDb250ZXh0KHF1ZXJ5LCB0aGlzLmZyYWdtZW50cykpLCB7IG92ZXJ3cml0ZTogISFvdmVyd3JpdGUsIGluY29taW5nQnlJZDogbmV3IE1hcCgpLCBjbGllbnRPbmx5OiBmYWxzZSwgZGVmZXJyZWQ6IGZhbHNlLCBmbGF2b3JzOiBuZXcgTWFwKCkgfSk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnByb2Nlc3NTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBvcGVyYXRpb25EZWZpbml0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG1lcmdlVHJlZTogeyBtYXA6IG5ldyBNYXAoKSB9LFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNSZWZlcmVuY2UocmVmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoMTEsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU28gZmFyLCB0aGUgc3RvcmUgaGFzIG5vdCBiZWVuIG1vZGlmaWVkLCBzbyBub3cgaXQncyB0aW1lIHRvIHByb2Nlc3NcbiAgICAgICAgLy8gY29udGV4dC5pbmNvbWluZ0J5SWQgYW5kIG1lcmdlIHRob3NlIGluY29taW5nIGZpZWxkcyBpbnRvIGNvbnRleHQuc3RvcmUuXG4gICAgICAgIGNvbnRleHQuaW5jb21pbmdCeUlkLmZvckVhY2goZnVuY3Rpb24gKF9hLCBkYXRhSWQpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU9iamVjdCA9IF9hLnN0b3JlT2JqZWN0LCBtZXJnZVRyZWUgPSBfYS5tZXJnZVRyZWUsIGZpZWxkTm9kZVNldCA9IF9hLmZpZWxkTm9kZVNldDtcbiAgICAgICAgICAgIHZhciBlbnRpdHlSZWYgPSBtYWtlUmVmZXJlbmNlKGRhdGFJZCk7XG4gICAgICAgICAgICBpZiAobWVyZ2VUcmVlICYmIG1lcmdlVHJlZS5tYXAuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcHBsaWVkID0gX3RoaXMuYXBwbHlNZXJnZXMobWVyZ2VUcmVlLCBlbnRpdHlSZWYsIHN0b3JlT2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UoYXBwbGllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIFJlZmVyZW5jZXMgcmV0dXJuZWQgYnkgYXBwbHlNZXJnZXMgaGF2ZSBhbHJlYWR5IGJlZW4gbWVyZ2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIHN0b3JlLiBTZWUgbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uIGluIHBvbGljaWVzLnRzIGZvciBhblxuICAgICAgICAgICAgICAgICAgICAvLyBleGFtcGxlIG9mIGhvdyB0aGlzIGNhbiBoYXBwZW4uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhcHBseU1lcmdlcyByZXR1cm5lZCBhIFN0b3JlT2JqZWN0LCB3aG9zZSBmaWVsZHMgd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgaW50byB0aGUgc3RvcmUgKHNlZSBzdG9yZS5tZXJnZSBzdGF0ZW1lbnQgYmVsb3cpLlxuICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0ID0gYXBwbGllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmICFjb250ZXh0Lm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHNXaXRoU2VsZWN0aW9uU2V0c18xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmaWVsZE5vZGVTZXQuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzV2l0aFNlbGVjdGlvblNldHNfMVtmaWVsZC5uYW1lLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzU2VsZWN0aW9uU2V0XzEgPSBmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkc1dpdGhTZWxlY3Rpb25TZXRzXzFbZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSldID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBoYXNNZXJnZUZ1bmN0aW9uXzEgPSBmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IG1lcmdlVHJlZSAmJiBtZXJnZVRyZWUubWFwLmdldChzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGNoaWxkVHJlZSAmJiBjaGlsZFRyZWUuaW5mbyAmJiBjaGlsZFRyZWUuaW5mby5tZXJnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBtZXJnZSBmdW5jdGlvbiB3YXMgZGVmaW5lZCBmb3IgdGhpcyBmaWVsZCwgdHJ1c3QgdGhhdCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkaWQgdGhlIHJpZ2h0IHRoaW5nIGFib3V0IChub3QpIGNsb2JiZXJpbmcgZGF0YS4gSWYgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBubyBzZWxlY3Rpb24gc2V0LCBpdCdzIGEgc2NhbGFyIGZpZWxkLCBzbyBpdCBkb2Vzbid0IG5lZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBtZXJnZSBmdW5jdGlvbiAoZXZlbiBpZiBpdCdzIGFuIG9iamVjdCwgbGlrZSBKU09OIGRhdGEpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2VsZWN0aW9uU2V0XzEoc3RvcmVGaWVsZE5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaGFzTWVyZ2VGdW5jdGlvbl8xKHN0b3JlRmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybkFib3V0RGF0YUxvc3MoZW50aXR5UmVmLCBzdG9yZU9iamVjdCwgc3RvcmVGaWVsZE5hbWUsIGNvbnRleHQuc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5tZXJnZShkYXRhSWQsIHN0b3JlT2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFueSBJRHMgd3JpdHRlbiBleHBsaWNpdGx5IHRvIHRoZSBjYWNoZSB3aWxsIGJlIHJldGFpbmVkIGFzXG4gICAgICAgIC8vIHJlYWNoYWJsZSByb290IElEcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIHB1cnBvc2VzLiBBbHRob3VnaCB0aGlzXG4gICAgICAgIC8vIGxvZ2ljIGluY2x1ZGVzIHJvb3QgSURzIGxpa2UgUk9PVF9RVUVSWSBhbmQgUk9PVF9NVVRBVElPTiwgdGhlaXJcbiAgICAgICAgLy8gcmV0YWlubWVudCBjb3VudHMgYXJlIGVmZmVjdGl2ZWx5IGlnbm9yZWQgYmVjYXVzZSBjYWNoZS5nYygpIGFsd2F5c1xuICAgICAgICAvLyBpbmNsdWRlcyB0aGVtIGluIGl0cyByb290IElEIHNldC5cbiAgICAgICAgc3RvcmUucmV0YWluKHJlZi5fX3JlZik7XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcbiAgICBTdG9yZVdyaXRlci5wcm90b3R5cGUucHJvY2Vzc1NlbGVjdGlvblNldCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YUlkID0gX2EuZGF0YUlkLCByZXN1bHQgPSBfYS5yZXN1bHQsIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgY29udGV4dCA9IF9hLmNvbnRleHQsIFxuICAgICAgICAvLyBUaGlzIG9iamVjdCBhbGxvd3MgcHJvY2Vzc1NlbGVjdGlvblNldCB0byByZXBvcnQgdXNlZnVsIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIHRvIGl0cyBjYWxsZXJzIHdpdGhvdXQgZXhwbGljaXRseSByZXR1cm5pbmcgdGhhdCBpbmZvcm1hdGlvbi5cbiAgICAgICAgbWVyZ2VUcmVlID0gX2EubWVyZ2VUcmVlO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNhY2hlLnBvbGljaWVzO1xuICAgICAgICAvLyBUaGlzIHZhcmlhYmxlIHdpbGwgYmUgcmVwZWF0ZWRseSB1cGRhdGVkIHVzaW5nIGNvbnRleHQubWVyZ2UgdG9cbiAgICAgICAgLy8gYWNjdW11bGF0ZSBhbGwgZmllbGRzIHRoYXQgbmVlZCB0byBiZSB3cml0dGVuIGludG8gdGhlIHN0b3JlLlxuICAgICAgICB2YXIgaW5jb21pbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBJZiB0eXBlbmFtZSB3YXMgbm90IHBhc3NlZCBpbiwgaW5mZXIgaXQuIE5vdGUgdGhhdCB0eXBlbmFtZSBpc1xuICAgICAgICAvLyBhbHdheXMgcGFzc2VkIGluIGZvciB0cmlja3ktdG8taW5mZXIgY2FzZXMgc3VjaCBhcyBcIlF1ZXJ5XCIgZm9yXG4gICAgICAgIC8vIFJPT1RfUVVFUlkuXG4gICAgICAgIHZhciB0eXBlbmFtZSA9IChkYXRhSWQgJiYgcG9saWNpZXMucm9vdFR5cGVuYW1lc0J5SWRbZGF0YUlkXSkgfHxcbiAgICAgICAgICAgIGdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIHNlbGVjdGlvblNldCwgY29udGV4dC5mcmFnbWVudE1hcCkgfHxcbiAgICAgICAgICAgIChkYXRhSWQgJiYgY29udGV4dC5zdG9yZS5nZXQoZGF0YUlkLCBcIl9fdHlwZW5hbWVcIikpO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGVuYW1lKSB7XG4gICAgICAgICAgICBpbmNvbWluZy5fX3R5cGVuYW1lID0gdHlwZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyByZWFkRmllbGQgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYXMgY29udGV4dC5yZWFkRmllbGQgaW4gdGhlXG4gICAgICAgIC8vIEtleUZpZWxkc0NvbnRleHQgb2JqZWN0IGNyZWF0ZWQgd2l0aGluIHBvbGljaWVzLmlkZW50aWZ5IChjYWxsZWQgYmVsb3cpLlxuICAgICAgICAvLyBJbiBhZGRpdGlvbiB0byByZWFkaW5nIGZyb20gdGhlIGV4aXN0aW5nIGNvbnRleHQuc3RvcmUgKHRoYW5rcyB0byB0aGVcbiAgICAgICAgLy8gcG9saWNpZXMucmVhZEZpZWxkKG9wdGlvbnMsIGNvbnRleHQpIGxpbmUgYXQgdGhlIHZlcnkgYm90dG9tKSwgdGhpc1xuICAgICAgICAvLyB2ZXJzaW9uIG9mIHJlYWRGaWVsZCBjYW4gcmVhZCBmcm9tIFJlZmVyZW5jZSBvYmplY3RzIHRoYXQgYXJlIGN1cnJlbnRseVxuICAgICAgICAvLyBwZW5kaW5nIGluIGNvbnRleHQuaW5jb21pbmdCeUlkLCB3aGljaCBpcyBpbXBvcnRhbnQgd2hlbmV2ZXIga2V5RmllbGRzXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgZXh0cmFjdGVkIGZyb20gYSBjaGlsZCBvYmplY3QgdGhhdCBwcm9jZXNzU2VsZWN0aW9uU2V0IGhhc1xuICAgICAgICAvLyB0dXJuZWQgaW50byBhIFJlZmVyZW5jZS5cbiAgICAgICAgdmFyIHJlYWRGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplUmVhZEZpZWxkT3B0aW9ucyhhcmd1bWVudHMsIGluY29taW5nLCBjb250ZXh0LnZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2Uob3B0aW9ucy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY29udGV4dC5pbmNvbWluZ0J5SWQuZ2V0KG9wdGlvbnMuZnJvbS5fX3JlZik7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gcG9saWNpZXMucmVhZEZpZWxkKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tOiBpbmZvLnN0b3JlT2JqZWN0IH0pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaWVsZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZmxhdHRlbkZpZWxkcyhzZWxlY3Rpb25TZXQsIHJlc3VsdCwgXG4gICAgICAgIC8vIFRoaXMgV3JpdGVDb250ZXh0IHdpbGwgYmUgdGhlIGRlZmF1bHQgY29udGV4dCB2YWx1ZSBmb3IgZmllbGRzIHJldHVybmVkXG4gICAgICAgIC8vIGJ5IHRoZSBmbGF0dGVuRmllbGRzIG1ldGhvZCwgYnV0IHNvbWUgZmllbGRzIG1heSBiZSBhc3NpZ25lZCBhIG1vZGlmaWVkXG4gICAgICAgIC8vIGNvbnRleHQsIGRlcGVuZGluZyBvbiB0aGUgcHJlc2VuY2Ugb2YgQGNsaWVudCBhbmQgb3RoZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgY29udGV4dCwgdHlwZW5hbWUpLmZvckVhY2goZnVuY3Rpb24gKGNvbnRleHQsIGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcmVzdWx0RmllbGRLZXkgPSByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdFtyZXN1bHRGaWVsZEtleV07XG4gICAgICAgICAgICBmaWVsZE5vZGVTZXQuYWRkKGZpZWxkKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lID0gcG9saWNpZXMuZ2V0U3RvcmVGaWVsZE5hbWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlbmFtZTogdHlwZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbnRleHQudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSBnZXRDaGlsZE1lcmdlVHJlZShtZXJnZVRyZWUsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jb21pbmdWYWx1ZSA9IF90aGlzLnByb2Nlc3NGaWVsZFZhbHVlKHZhbHVlLCBmaWVsZCwgXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgY29udGV4dC5jbGllbnRPbmx5IGFuZCBjb250ZXh0LmRlZmVycmVkIHRvIHRoZWlyIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYmVmb3JlIHByb2Nlc3NpbmcgbmVzdGVkIHNlbGVjdGlvbiBzZXRzLlxuICAgICAgICAgICAgICAgIGZpZWxkLnNlbGVjdGlvblNldCA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHQsIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICAgICAgLy8gVG8gZGV0ZXJtaW5lIGlmIHRoaXMgZmllbGQgaG9sZHMgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIG1lcmdlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbiBpdHMgdHlwZSBwb2xpY3kgKHNlZSBQUiAjNzA3MCksIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBvYmplY3QncyBfX3R5cGVuYW1lLlxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFR5cGVuYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWVsZCdzIHZhbHVlIGNhbiBiZSBhbiBvYmplY3QgdGhhdCBoYXMgYSBfX3R5cGVuYW1lIG9ubHkgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmllbGQgaGFzIGEgc2VsZWN0aW9uIHNldC4gT3RoZXJ3aXNlIGluY29taW5nVmFsdWUgaXMgc2NhbGFyLlxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzUmVmZXJlbmNlKGluY29taW5nVmFsdWUpIHx8IHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGluY29taW5nVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFR5cGVuYW1lID0gcmVhZEZpZWxkKFwiX190eXBlbmFtZVwiLCBpbmNvbWluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlID0gcG9saWNpZXMuZ2V0TWVyZ2VGdW5jdGlvbih0eXBlbmFtZSwgZmllbGQubmFtZS52YWx1ZSwgY2hpbGRUeXBlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJlZS5pbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBDaGVjayBjb21wYXRpYmlsaXR5IGFnYWluc3QgYW55IGV4aXN0aW5nIGNoaWxkVHJlZS5maWVsZD9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lOiB0eXBlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtzdG9yZUZpZWxkTmFtZV0gPSBpbmNvbWluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFjb250ZXh0LmNsaWVudE9ubHkgJiZcbiAgICAgICAgICAgICAgICAhY29udGV4dC5kZWZlcnJlZCAmJlxuICAgICAgICAgICAgICAgICFhZGRUeXBlbmFtZVRvRG9jdW1lbnQuYWRkZWQoZmllbGQpICYmXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpZWxkIGhhcyBhIHJlYWQgZnVuY3Rpb24sIGl0IG1heSBiZSBhIHN5bnRoZXRpYyBmaWVsZCBvclxuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlLCBzbyBpdHMgYWJzZW5jZSBmcm9tIHRoZSB3cml0dGVuIGRhdGEgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gbm90IGJlIGNhdXNlIGZvciBhbGFybS5cbiAgICAgICAgICAgICAgICAhcG9saWNpZXMuZ2V0UmVhZEZ1bmN0aW9uKHR5cGVuYW1lLCBmaWVsZC5uYW1lLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmVycm9yKDEyLCByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElkZW50aWZ5IHRoZSByZXN1bHQgb2JqZWN0LCBldmVuIGlmIGRhdGFJZCB3YXMgYWxyZWFkeSBwcm92aWRlZCxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIG5lZWQga2V5T2JqZWN0IGJlbG93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9iID0gcG9saWNpZXMuaWRlbnRpZnkocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBjb250ZXh0LmZyYWdtZW50TWFwLFxuICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0OiBpbmNvbWluZyxcbiAgICAgICAgICAgICAgICByZWFkRmllbGQ6IHJlYWRGaWVsZCxcbiAgICAgICAgICAgIH0pLCBpZCA9IF9iWzBdLCBrZXlPYmplY3QgPSBfYlsxXTtcbiAgICAgICAgICAgIC8vIElmIGRhdGFJZCB3YXMgbm90IHByb3ZpZGVkLCBmYWxsIGJhY2sgdG8gdGhlIGlkIGp1c3QgZ2VuZXJhdGVkIGJ5XG4gICAgICAgICAgICAvLyBwb2xpY2llcy5pZGVudGlmeS5cbiAgICAgICAgICAgIGRhdGFJZCA9IGRhdGFJZCB8fCBpZDtcbiAgICAgICAgICAgIC8vIFdyaXRlIGFueSBrZXkgZmllbGRzIHRoYXQgd2VyZSB1c2VkIGR1cmluZyBpZGVudGlmaWNhdGlvbiwgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhleSB3ZXJlIG5vdCBtZW50aW9uZWQgaW4gdGhlIG9yaWdpbmFsIHF1ZXJ5LlxuICAgICAgICAgICAgaWYgKGtleU9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIGFyZ3VtZW50cz9cbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIGtleU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIGRhdGFJZCB3YXMgcHJvdmlkZWQsIHRvbGVyYXRlIGZhaWx1cmUgb2YgcG9saWNpZXMuaWRlbnRpZnkuXG4gICAgICAgICAgICBpZiAoIWRhdGFJZClcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YUlkKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJlZiA9IG1ha2VSZWZlcmVuY2UoZGF0YUlkKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIHByb2Nlc3NpbmcgdGhlIHNhbWUgZW50aXR5IG9iamVjdCB1c2luZyB0aGUgc2FtZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHNldCBtb3JlIHRoYW4gb25jZS4gV2UgdXNlIGFuIGFycmF5IGluc3RlYWQgb2YgYSBTZXQgc2luY2UgbW9zdFxuICAgICAgICAgICAgLy8gZW50aXR5IElEcyB3aWxsIGJlIHdyaXR0ZW4gdXNpbmcgb25seSBvbmUgc2VsZWN0aW9uIHNldCwgc28gdGhlXG4gICAgICAgICAgICAvLyBzaXplIG9mIHRoaXMgYXJyYXkgaXMgbGlrZWx5IHRvIGJlIHZlcnkgc21hbGwsIG1lYW5pbmcgaW5kZXhPZiBpc1xuICAgICAgICAgICAgLy8gbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuIFNldC5wcm90b3R5cGUuaGFzLlxuICAgICAgICAgICAgdmFyIHNldHMgPSBjb250ZXh0LndyaXR0ZW5bZGF0YUlkXSB8fCAoY29udGV4dC53cml0dGVuW2RhdGFJZF0gPSBbXSk7XG4gICAgICAgICAgICBpZiAoc2V0cy5pbmRleE9mKHNlbGVjdGlvblNldCkgPj0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVJlZjtcbiAgICAgICAgICAgIHNldHMucHVzaChzZWxlY3Rpb25TZXQpO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gd3JpdGUgYSByZXN1bHQgb2JqZWN0IGludG8gdGhlIHN0b3JlLCBidXQgd2VcbiAgICAgICAgICAgIC8vIGhhcHBlbiB0byBrbm93IHRoYXQgdGhlIGV4YWN0IHNhbWUgKD09PSkgcmVzdWx0IG9iamVjdCB3b3VsZCBiZVxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgaWYgd2Ugd2VyZSB0byByZXJlYWQgdGhlIHJlc3VsdCB3aXRoIHRoZSBzYW1lIGlucHV0cyxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHNraXAgdGhlIHJlc3Qgb2YgdGhlIHByb2Nlc3NTZWxlY3Rpb25TZXQgd29yayBmb3JcbiAgICAgICAgICAgIC8vIHRoaXMgb2JqZWN0LCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuIGEgUmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZGVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuaXNGcmVzaChyZXN1bHQsIGRhdGFSZWYsIHNlbGVjdGlvblNldCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2aW91c18xID0gY29udGV4dC5pbmNvbWluZ0J5SWQuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfMSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzXzEuc3RvcmVPYmplY3QgPSBjb250ZXh0Lm1lcmdlKHByZXZpb3VzXzEuc3RvcmVPYmplY3QsIGluY29taW5nKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c18xLm1lcmdlVHJlZSA9IG1lcmdlTWVyZ2VUcmVlcyhwcmV2aW91c18xLm1lcmdlVHJlZSwgbWVyZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZE5vZGVTZXQuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHByZXZpb3VzXzEuZmllbGROb2RlU2V0LmFkZChmaWVsZCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pbmNvbWluZ0J5SWQuc2V0KGRhdGFJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU9iamVjdDogaW5jb21pbmcsXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gbWVyZ2VUcmVlIG9ubHkgaWYgaXQgaXMgbm90IGVtcHR5LCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IE1lcmdlVHJlZXMgbWF5IGJlIHJlY3ljbGVkIGJ5IG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyByZXVzZWQgZm9yIGVudGlyZWx5IGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgcmVzdWx0IHRyZWUuXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVHJlZTogbWVyZ2VUcmVlSXNFbXB0eShtZXJnZVRyZWUpID8gdm9pZCAwIDogbWVyZ2VUcmVlLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5vZGVTZXQ6IGZpZWxkTm9kZVNldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhUmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzRmllbGRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZmllbGQsIGNvbnRleHQsIG1lcmdlVHJlZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIG5lZWQgdG8gY2xvbmUgc2NhbGFyIHZhbHVlcyBzbyB0aGF0IHRoZXkgY2FuIGJlXG4gICAgICAgICAgICAvLyBzYWZlbHkgZnJvemVuIHdpdGggbWF5YmVEZWVwRnJlZXplIGluIHJlYWRGcm9tU3RvcmUudHMuIEluIHByb2R1Y3Rpb24sXG4gICAgICAgICAgICAvLyBpdCdzIGNoZWFwZXIgdG8gc3RvcmUgdGhlIHNjYWxhciB2YWx1ZXMgZGlyZWN0bHkgaW4gdGhlIGNhY2hlLlxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgPyBjbG9uZURlZXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMucHJvY2Vzc0ZpZWxkVmFsdWUoaXRlbSwgZmllbGQsIGNvbnRleHQsIGdldENoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSkpO1xuICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1NlbGVjdGlvblNldCh7XG4gICAgICAgICAgICByZXN1bHQ6IHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbWVyZ2VUcmVlOiBtZXJnZVRyZWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gSW1wbGVtZW50cyBodHRwczovL3NwZWMuZ3JhcGhxbC5vcmcvZHJhZnQvI3NlYy1GaWVsZC1Db2xsZWN0aW9uLCBidXQgd2l0aFxuICAgIC8vIHNvbWUgYWRkaXRpb25zIGZvciB0cmFja2luZyBAY2xpZW50IGFuZCBAZGVmZXIgZGlyZWN0aXZlcy5cbiAgICBTdG9yZVdyaXRlci5wcm90b3R5cGUuZmxhdHRlbkZpZWxkcyA9IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHJlc3VsdCwgY29udGV4dCwgdHlwZW5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB2b2lkIDApIHsgdHlwZW5hbWUgPSBnZXRUeXBlbmFtZUZyb21SZXN1bHQocmVzdWx0LCBzZWxlY3Rpb25TZXQsIGNvbnRleHQuZnJhZ21lbnRNYXApOyB9XG4gICAgICAgIHZhciBmaWVsZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHBvbGljaWVzID0gdGhpcy5jYWNoZS5wb2xpY2llcztcbiAgICAgICAgdmFyIGxpbWl0aW5nVHJpZSA9IG5ldyBUcmllKGZhbHNlKTsgLy8gTm8gbmVlZCBmb3IgV2Vha01hcCwgc2luY2UgbGltaXRpbmdUcmllIGRvZXMgbm90IGVzY2FwZS5cbiAgICAgICAgKGZ1bmN0aW9uIGZsYXR0ZW4oc2VsZWN0aW9uU2V0LCBpbmhlcml0ZWRDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZE5vZGUgPSBsaW1pdGluZ1RyaWUubG9va3VwKHNlbGVjdGlvblNldCwgXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHRha2UgaW5oZXJpdGVkQ2xpZW50T25seSBhbmQgaW5oZXJpdGVkRGVmZXJyZWQgaW50b1xuICAgICAgICAgICAgLy8gY29uc2lkZXJhdGlvbiBoZXJlIChpbiBhZGRpdGlvbiB0byBzZWxlY3Rpb25TZXQpLCBpdCdzIHBvc3NpYmxlIGZvclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgc2VsZWN0aW9uIHNldCB0byBiZSBmbGF0dGVuZWQgbW9yZSB0aGFuIG9uY2UsIGlmIGl0IGFwcGVhcnNcbiAgICAgICAgICAgIC8vIGluIHRoZSBxdWVyeSB3aXRoIGRpZmZlcmVudCBAY2xpZW50IGFuZC9vciBAZGlyZWN0aXZlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgICAgaW5oZXJpdGVkQ29udGV4dC5jbGllbnRPbmx5LCBpbmhlcml0ZWRDb250ZXh0LmRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkTm9kZS52aXNpdGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZpc2l0ZWROb2RlLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgY29udGV4dC52YXJpYWJsZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudE9ubHkgPSBpbmhlcml0ZWRDb250ZXh0LmNsaWVudE9ubHksIGRlZmVycmVkID0gaW5oZXJpdGVkQ29udGV4dC5kZWZlcnJlZDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIHByZXNlbmNlIG9mIEBjbGllbnQgb3IgQGRlZmVyIG9uIHRoaXMgZmllbGQgY2FuIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBjbGllbnRPbmx5IG9yIGRlZmVycmVkIHRvIGJlY29tZSB0cnVlLCB3ZSBjYW4gc2tpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBmb3JFYWNoIGxvb3AgaWYgYm90aCBjbGllbnRPbmx5IGFuZCBkZWZlcnJlZCBhcmUgYWxyZWFkeSB0cnVlLlxuICAgICAgICAgICAgICAgICEoY2xpZW50T25seSAmJiBkZWZlcnJlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNOb25FbXB0eUFycmF5KHNlbGVjdGlvbi5kaXJlY3RpdmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGlyLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJjbGllbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImRlZmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkaXIsIGNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgQGRlZmVyIGRpcmVjdGl2ZSB0YWtlcyBhbiBvcHRpb25hbCBhcmdzLmlmIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCwgc2ltaWxhciB0byBAaW5jbHVkZShpZjogYm9vbGVhbikuIE5vdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBkZWZlcihpZjogZmFsc2UpIGRvZXMgbm90IG1ha2UgY29udGV4dC5kZWZlcnJlZCBmYWxzZSwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBiZWhhdmVzIGFzIGlmIHRoZXJlIHdhcyBubyBAZGVmZXIgZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJncyB8fCBhcmdzLmlmICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gcmVjb3JkIGFyZ3MubGFiZWwgdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0LmRlZmVycmVkLCBpZiBhIGxhYmVsIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gZmllbGRNYXAuZ2V0KHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmaWVsZCBoYXMgYmVlbiB2aXNpdGVkIGFsb25nIGFub3RoZXIgcmVjdXJzaXZlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSwgdGhlIGZpbmFsIGNvbnRleHQgc2hvdWxkIGhhdmUgY2xpZW50T25seSBvciBkZWZlcnJlZCBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRydWUgb25seSBpZiAqYWxsKiBwYXRocyBoYXZlIHRoZSBkaXJlY3RpdmUgKGhlbmNlIHRoZSAmJikuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRPbmx5ID0gY2xpZW50T25seSAmJiBleGlzdGluZy5jbGllbnRPbmx5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBkZWZlcnJlZCAmJiBleGlzdGluZy5kZWZlcnJlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWVsZE1hcC5zZXQoc2VsZWN0aW9uLCBnZXRDb250ZXh0Rmxhdm9yKGNvbnRleHQsIGNsaWVudE9ubHksIGRlZmVycmVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBjb250ZXh0Lmxvb2t1cEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudCAmJiBzZWxlY3Rpb24ua2luZCA9PT0gS2luZC5GUkFHTUVOVF9TUFJFQUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ld0ludmFyaWFudEVycm9yKDEzLCBzZWxlY3Rpb24ubmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMoZnJhZ21lbnQsIHR5cGVuYW1lLCByZXN1bHQsIGNvbnRleHQudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbihmcmFnbWVudC5zZWxlY3Rpb25TZXQsIGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgY2xpZW50T25seSwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShzZWxlY3Rpb25TZXQsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZmllbGRNYXA7XG4gICAgfTtcbiAgICBTdG9yZVdyaXRlci5wcm90b3R5cGUuYXBwbHlNZXJnZXMgPSBmdW5jdGlvbiAobWVyZ2VUcmVlLCBleGlzdGluZywgaW5jb21pbmcsIGNvbnRleHQsIGdldFN0b3JhZ2VBcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG1lcmdlVHJlZS5tYXAuc2l6ZSAmJiAhaXNSZWZlcmVuY2UoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB2YXIgZV8xID0gXG4gICAgICAgICAgICAvLyBJdGVtcyBpbiB0aGUgc2FtZSBwb3NpdGlvbiBpbiBkaWZmZXJlbnQgYXJyYXlzIGFyZSBub3RcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyaWx5IHJlbGF0ZWQgdG8gZWFjaCBvdGhlciwgc28gd2hlbiBpbmNvbWluZyBpcyBhbiBhcnJheVxuICAgICAgICAgICAgLy8gd2UgcHJvY2VzcyBpdHMgZWxlbWVudHMgYXMgaWYgdGhlcmUgd2FzIG5vIGV4aXN0aW5nIGRhdGEuXG4gICAgICAgICAgICAoIWlzQXJyYXkoaW5jb21pbmcpICYmXG4gICAgICAgICAgICAgICAgLy8gTGlrZXdpc2UsIGV4aXN0aW5nIG11c3QgYmUgZWl0aGVyIGEgUmVmZXJlbmNlIG9yIGEgU3RvcmVPYmplY3RcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXRzIGZpZWxkcyB0byBiZSBzYWZlIHRvIG1lcmdlIHdpdGggdGhlIGZpZWxkcyBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbmNvbWluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgKGlzUmVmZXJlbmNlKGV4aXN0aW5nKSB8fCBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChleGlzdGluZykpKSA/XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFRoaXMgbmFycm93aW5nIGlzIGltcGxpZWQgYnkgbWVyZ2VUcmVlLm1hcC5zaXplID4gMCBhbmRcbiAgICAgICAgICAgIC8vICFpc1JlZmVyZW5jZShpbmNvbWluZyksIHRob3VnaCBUeXBlU2NyaXB0IHVuZGVyc3RhbmRhYmx5IGNhbm5vdFxuICAgICAgICAgICAgLy8gaG9wZSB0byBpbmZlciB0aGlzIHR5cGUuXG4gICAgICAgICAgICB2YXIgaV8xID0gaW5jb21pbmc7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucy5zdG9yYWdlIG9iamVjdHMgcHJvdmlkZWQgdG8gcmVhZCBhbmQgbWVyZ2UgZnVuY3Rpb25zXG4gICAgICAgICAgICAvLyBhcmUgZGVyaXZlZCBmcm9tIHRoZSBpZGVudGl0eSBvZiB0aGUgcGFyZW50IG9iamVjdCBwbHVzIGFcbiAgICAgICAgICAgIC8vIHNlcXVlbmNlIG9mIHN0b3JlRmllbGROYW1lIHN0cmluZ3MvbnVtYmVycyBpZGVudGlmeWluZyB0aGUgbmVzdGVkXG4gICAgICAgICAgICAvLyBmaWVsZCBuYW1lIHBhdGggb2YgZWFjaCBmaWVsZCB2YWx1ZSB0byBiZSBtZXJnZWQuXG4gICAgICAgICAgICBpZiAoZV8xICYmICFnZXRTdG9yYWdlQXJncykge1xuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2VBcmdzID0gW2lzUmVmZXJlbmNlKGVfMSkgPyBlXzEuX19yZWYgOiBlXzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGFwcGx5aW5nIG1lcmdlIGZ1bmN0aW9ucyB0byB0aGlzIHN1YnRyZWUgd2lsbFxuICAgICAgICAgICAgLy8gbm90IGNoYW5nZSB0aGUgaW5jb21pbmcgZGF0YSwgc28gdGhpcyB2YXJpYWJsZSB0cmFja3MgdGhlIGZpZWxkc1xuICAgICAgICAgICAgLy8gdGhhdCBkaWQgY2hhbmdlLCBzbyB3ZSBjYW4gY3JlYXRlIGEgbmV3IGluY29taW5nIG9iamVjdCB3aGVuIChhbmRcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbikgYXQgbGVhc3Qgb25lIGluY29taW5nIGZpZWxkIGhhcyBjaGFuZ2VkLiBXZSB1c2UgYSBNYXBcbiAgICAgICAgICAgIC8vIHRvIHByZXNlcnZlIHRoZSB0eXBlIG9mIG51bWVyaWMga2V5cy5cbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRmllbGRzXzE7XG4gICAgICAgICAgICB2YXIgZ2V0VmFsdWVfMSA9IGZ1bmN0aW9uIChmcm9tLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc0FycmF5KGZyb20pID9cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG5hbWUgPT09IFwibnVtYmVyXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVtuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgOiBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUoZnJvbSwgU3RyaW5nKG5hbWUpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVyZ2VUcmVlLm1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFRyZWUsIHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVWYWwgPSBnZXRWYWx1ZV8xKGVfMSwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBpVmFsID0gZ2V0VmFsdWVfMShpXzEsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIGluY29taW5nIGRhdGEsIGxlYXZlIGFueSBleGlzdGluZyBkYXRhIHVudG91Y2hlZC5cbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBpVmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGdldFN0b3JhZ2VBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFN0b3JhZ2VBcmdzLnB1c2goc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYVZhbCA9IF90aGlzLmFwcGx5TWVyZ2VzKGNoaWxkVHJlZSwgZVZhbCwgaVZhbCwgY29udGV4dCwgZ2V0U3RvcmFnZUFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChhVmFsICE9PSBpVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHNfMSA9IGNoYW5nZWRGaWVsZHNfMSB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHNfMS5zZXQoc3RvcmVGaWVsZE5hbWUsIGFWYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2V0U3RvcmFnZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50KGdldFN0b3JhZ2VBcmdzLnBvcCgpID09PSBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZEZpZWxkc18xKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZSBpIHNvIHdlIGNhbiBhZGQgY2hhbmdlZCBmaWVsZHMgdG8gaXQuXG4gICAgICAgICAgICAgICAgaW5jb21pbmcgPSAoaXNBcnJheShpXzEpID8gaV8xLnNsaWNlKDApIDogX19hc3NpZ24oe30sIGlfMSkpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHNfMS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZ1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZVRyZWUuaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucG9saWNpZXMucnVuTWVyZ2VGdW5jdGlvbihleGlzdGluZywgaW5jb21pbmcsIG1lcmdlVHJlZS5pbmZvLCBjb250ZXh0LCBnZXRTdG9yYWdlQXJncyAmJiAoX2EgPSBjb250ZXh0LnN0b3JlKS5nZXRTdG9yYWdlLmFwcGx5KF9hLCBnZXRTdG9yYWdlQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICB9O1xuICAgIHJldHVybiBTdG9yZVdyaXRlcjtcbn0oKSk7XG5leHBvcnQgeyBTdG9yZVdyaXRlciB9O1xudmFyIGVtcHR5TWVyZ2VUcmVlUG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0Q2hpbGRNZXJnZVRyZWUoX2EsIG5hbWUpIHtcbiAgICB2YXIgbWFwID0gX2EubWFwO1xuICAgIGlmICghbWFwLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUsIGVtcHR5TWVyZ2VUcmVlUG9vbC5wb3AoKSB8fCB7IG1hcDogbmV3IE1hcCgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLmdldChuYW1lKTtcbn1cbmZ1bmN0aW9uIG1lcmdlTWVyZ2VUcmVlcyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCB8fCAhcmlnaHQgfHwgbWVyZ2VUcmVlSXNFbXB0eShyaWdodCkpXG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIGlmICghbGVmdCB8fCBtZXJnZVRyZWVJc0VtcHR5KGxlZnQpKVxuICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgdmFyIGluZm8gPSBsZWZ0LmluZm8gJiYgcmlnaHQuaW5mbyA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsZWZ0LmluZm8pLCByaWdodC5pbmZvKSA6IGxlZnQuaW5mbyB8fCByaWdodC5pbmZvO1xuICAgIHZhciBuZWVkVG9NZXJnZU1hcHMgPSBsZWZ0Lm1hcC5zaXplICYmIHJpZ2h0Lm1hcC5zaXplO1xuICAgIHZhciBtYXAgPSBuZWVkVG9NZXJnZU1hcHMgPyBuZXcgTWFwKClcbiAgICAgICAgOiBsZWZ0Lm1hcC5zaXplID8gbGVmdC5tYXBcbiAgICAgICAgICAgIDogcmlnaHQubWFwO1xuICAgIHZhciBtZXJnZWQgPSB7IGluZm86IGluZm8sIG1hcDogbWFwIH07XG4gICAgaWYgKG5lZWRUb01lcmdlTWFwcykge1xuICAgICAgICB2YXIgcmVtYWluaW5nUmlnaHRLZXlzXzEgPSBuZXcgU2V0KHJpZ2h0Lm1hcC5rZXlzKCkpO1xuICAgICAgICBsZWZ0Lm1hcC5mb3JFYWNoKGZ1bmN0aW9uIChsZWZ0VHJlZSwga2V5KSB7XG4gICAgICAgICAgICBtZXJnZWQubWFwLnNldChrZXksIG1lcmdlTWVyZ2VUcmVlcyhsZWZ0VHJlZSwgcmlnaHQubWFwLmdldChrZXkpKSk7XG4gICAgICAgICAgICByZW1haW5pbmdSaWdodEtleXNfMS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbWFpbmluZ1JpZ2h0S2V5c18xLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgbWVyZ2VkLm1hcC5zZXQoa2V5LCBtZXJnZU1lcmdlVHJlZXMocmlnaHQubWFwLmdldChrZXkpLCBsZWZ0Lm1hcC5nZXQoa2V5KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlVHJlZUlzRW1wdHkodHJlZSkge1xuICAgIHJldHVybiAhdHJlZSB8fCAhKHRyZWUuaW5mbyB8fCB0cmVlLm1hcC5zaXplKTtcbn1cbmZ1bmN0aW9uIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKF9hLCBuYW1lKSB7XG4gICAgdmFyIG1hcCA9IF9hLm1hcDtcbiAgICB2YXIgY2hpbGRUcmVlID0gbWFwLmdldChuYW1lKTtcbiAgICBpZiAoY2hpbGRUcmVlICYmIG1lcmdlVHJlZUlzRW1wdHkoY2hpbGRUcmVlKSkge1xuICAgICAgICBlbXB0eU1lcmdlVHJlZVBvb2wucHVzaChjaGlsZFRyZWUpO1xuICAgICAgICBtYXAuZGVsZXRlKG5hbWUpO1xuICAgIH1cbn1cbnZhciB3YXJuaW5ncyA9IG5ldyBTZXQoKTtcbi8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVudXNlZCBpbiBwcm9kdWN0aW9uLCBhbmQgdGh1cyBzaG91bGQgYmVcbi8vIHBydW5lZCBieSBhbnkgd2VsbC1jb25maWd1cmVkIG1pbmlmaWVyLlxuZnVuY3Rpb24gd2FybkFib3V0RGF0YUxvc3MoZXhpc3RpbmdSZWYsIGluY29taW5nT2JqLCBzdG9yZUZpZWxkTmFtZSwgc3RvcmUpIHtcbiAgICB2YXIgZ2V0Q2hpbGQgPSBmdW5jdGlvbiAob2JqT3JSZWYpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShvYmpPclJlZiwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkO1xuICAgIH07XG4gICAgdmFyIGV4aXN0aW5nID0gZ2V0Q2hpbGQoZXhpc3RpbmdSZWYpO1xuICAgIGlmICghZXhpc3RpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgaW5jb21pbmcgPSBnZXRDaGlsZChpbmNvbWluZ09iaik7XG4gICAgaWYgKCFpbmNvbWluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEl0J3MgYWx3YXlzIHNhZmUgdG8gcmVwbGFjZSBhIHJlZmVyZW5jZSwgc2luY2UgaXQgcmVmZXJzIHRvIGRhdGFcbiAgICAvLyBzYWZlbHkgc3RvcmVkIGVsc2V3aGVyZS5cbiAgICBpZiAoaXNSZWZlcmVuY2UoZXhpc3RpbmcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gSWYgdGhlIHZhbHVlcyBhcmUgc3RydWN0dXJhbGx5IGVxdWl2YWxlbnQsIHdlIGRvIG5vdCBuZWVkIHRvIHdvcnJ5XG4gICAgLy8gYWJvdXQgaW5jb21pbmcgcmVwbGFjaW5nIGV4aXN0aW5nLlxuICAgIGlmIChlcXVhbChleGlzdGluZywgaW5jb21pbmcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gSWYgd2UncmUgcmVwbGFjaW5nIGV2ZXJ5IGtleSBvZiB0aGUgZXhpc3Rpbmcgb2JqZWN0LCB0aGVuIHRoZVxuICAgIC8vIGV4aXN0aW5nIGRhdGEgd291bGQgYmUgb3ZlcndyaXR0ZW4gZXZlbiBpZiB0aGUgb2JqZWN0cyB3ZXJlXG4gICAgLy8gbm9ybWFsaXplZCwgc28gd2FybmluZyB3b3VsZCBub3QgYmUgaGVscGZ1bCBoZXJlLlxuICAgIGlmIChPYmplY3Qua2V5cyhleGlzdGluZykuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc3RvcmUuZ2V0RmllbGRWYWx1ZShpbmNvbWluZywga2V5KSAhPT0gdm9pZCAwOyB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJlbnRUeXBlID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShleGlzdGluZ1JlZiwgXCJfX3R5cGVuYW1lXCIpIHx8XG4gICAgICAgIHN0b3JlLmdldEZpZWxkVmFsdWUoaW5jb21pbmdPYmosIFwiX190eXBlbmFtZVwiKTtcbiAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgdmFyIHR5cGVEb3ROYW1lID0gXCJcIi5jb25jYXQocGFyZW50VHlwZSwgXCIuXCIpLmNvbmNhdChmaWVsZE5hbWUpO1xuICAgIC8vIEF2b2lkIHdhcm5pbmcgbW9yZSB0aGFuIG9uY2UgZm9yIHRoZSBzYW1lIHR5cGUgYW5kIGZpZWxkIG5hbWUuXG4gICAgaWYgKHdhcm5pbmdzLmhhcyh0eXBlRG90TmFtZSkpXG4gICAgICAgIHJldHVybjtcbiAgICB3YXJuaW5ncy5hZGQodHlwZURvdE5hbWUpO1xuICAgIHZhciBjaGlsZFR5cGVuYW1lcyA9IFtdO1xuICAgIC8vIEFycmF5cyBkbyBub3QgaGF2ZSBfX3R5cGVuYW1lIGZpZWxkcywgYW5kIGFsd2F5cyBuZWVkIGEgY3VzdG9tIG1lcmdlXG4gICAgLy8gZnVuY3Rpb24sIGV2ZW4gaWYgdGhlaXIgZWxlbWVudHMgYXJlIG5vcm1hbGl6ZWQgZW50aXRpZXMuXG4gICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSAmJiAhaXNBcnJheShpbmNvbWluZykpIHtcbiAgICAgICAgW2V4aXN0aW5nLCBpbmNvbWluZ10uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IHN0b3JlLmdldEZpZWxkVmFsdWUoY2hpbGQsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgIWNoaWxkVHlwZW5hbWVzLmluY2x1ZGVzKHR5cGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZW5hbWVzLnB1c2godHlwZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2FybigxNCwgZmllbGROYW1lLCBwYXJlbnRUeXBlLCBjaGlsZFR5cGVuYW1lcy5sZW5ndGggP1xuICAgICAgICBcImVpdGhlciBlbnN1cmUgYWxsIG9iamVjdHMgb2YgdHlwZSBcIiArXG4gICAgICAgICAgICBjaGlsZFR5cGVuYW1lcy5qb2luKFwiIGFuZCBcIikgK1xuICAgICAgICAgICAgXCIgaGF2ZSBhbiBJRCBvciBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiwgb3IgXCJcbiAgICAgICAgOiBcIlwiLCB0eXBlRG90TmFtZSwgX19hc3NpZ24oe30sIGV4aXN0aW5nKSwgX19hc3NpZ24oe30sIGluY29taW5nKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cml0ZVRvU3RvcmUuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiaW52YXJpYW50IiwibmV3SW52YXJpYW50RXJyb3IiLCJlcXVhbCIsIlRyaWUiLCJLaW5kIiwiZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uIiwiZ2V0RGVmYXVsdFZhbHVlcyIsImdldE9wZXJhdGlvbkRlZmluaXRpb24iLCJnZXRUeXBlbmFtZUZyb21SZXN1bHQiLCJtYWtlUmVmZXJlbmNlIiwiaXNGaWVsZCIsInJlc3VsdEtleU5hbWVGcm9tRmllbGQiLCJpc1JlZmVyZW5jZSIsInNob3VsZEluY2x1ZGUiLCJjbG9uZURlZXAiLCJhZGRUeXBlbmFtZVRvRG9jdW1lbnQiLCJpc05vbkVtcHR5QXJyYXkiLCJhcmd1bWVudHNPYmplY3RGcm9tRmllbGQiLCJjYW5vbmljYWxTdHJpbmdpZnkiLCJpc0FycmF5IiwibWFrZVByb2Nlc3NlZEZpZWxkc01lcmdlciIsImZpZWxkTmFtZUZyb21TdG9yZU5hbWUiLCJzdG9yZVZhbHVlSXNTdG9yZU9iamVjdCIsImV4dHJhY3RGcmFnbWVudENvbnRleHQiLCJub3JtYWxpemVSZWFkRmllbGRPcHRpb25zIiwiZ2V0Q29udGV4dEZsYXZvciIsImNvbnRleHQiLCJjbGllbnRPbmx5IiwiZGVmZXJyZWQiLCJrZXkiLCJjb25jYXQiLCJmbGF2b3JlZCIsImZsYXZvcnMiLCJnZXQiLCJzZXQiLCJTdG9yZVdyaXRlciIsImNhY2hlIiwicmVhZGVyIiwiZnJhZ21lbnRzIiwicHJvdG90eXBlIiwid3JpdGVUb1N0b3JlIiwic3RvcmUiLCJfYSIsIl90aGlzIiwicXVlcnkiLCJyZXN1bHQiLCJkYXRhSWQiLCJ2YXJpYWJsZXMiLCJvdmVyd3JpdGUiLCJvcGVyYXRpb25EZWZpbml0aW9uIiwibWVyZ2VyIiwid3JpdHRlbiIsIk9iamVjdCIsImNyZWF0ZSIsIm1lcmdlIiwiZXhpc3RpbmciLCJpbmNvbWluZyIsInZhclN0cmluZyIsImluY29taW5nQnlJZCIsIk1hcCIsInJlZiIsInByb2Nlc3NTZWxlY3Rpb25TZXQiLCJzZWxlY3Rpb25TZXQiLCJtZXJnZVRyZWUiLCJtYXAiLCJmb3JFYWNoIiwic3RvcmVPYmplY3QiLCJmaWVsZE5vZGVTZXQiLCJlbnRpdHlSZWYiLCJzaXplIiwiYXBwbGllZCIsImFwcGx5TWVyZ2VzIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJmaWVsZHNXaXRoU2VsZWN0aW9uU2V0c18xIiwiZmllbGQiLCJuYW1lIiwidmFsdWUiLCJoYXNTZWxlY3Rpb25TZXRfMSIsInN0b3JlRmllbGROYW1lIiwiaGFzTWVyZ2VGdW5jdGlvbl8xIiwiY2hpbGRUcmVlIiwiQm9vbGVhbiIsImluZm8iLCJrZXlzIiwid2FybkFib3V0RGF0YUxvc3MiLCJyZXRhaW4iLCJfX3JlZiIsInBvbGljaWVzIiwidHlwZW5hbWUiLCJyb290VHlwZW5hbWVzQnlJZCIsImZyYWdtZW50TWFwIiwiX190eXBlbmFtZSIsInJlYWRGaWVsZCIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJmcm9tIiwicmVzdWx0XzEiLCJTZXQiLCJmbGF0dGVuRmllbGRzIiwicmVzdWx0RmllbGRLZXkiLCJhZGQiLCJnZXRTdG9yZUZpZWxkTmFtZSIsImZpZWxkTmFtZSIsImdldENoaWxkTWVyZ2VUcmVlIiwiaW5jb21pbmdWYWx1ZSIsInByb2Nlc3NGaWVsZFZhbHVlIiwiY2hpbGRUeXBlbmFtZSIsImdldE1lcmdlRnVuY3Rpb24iLCJtYXliZVJlY3ljbGVDaGlsZE1lcmdlVHJlZSIsImFkZGVkIiwiZ2V0UmVhZEZ1bmN0aW9uIiwiZXJyb3IiLCJfYiIsImlkZW50aWZ5IiwiaWQiLCJrZXlPYmplY3QiLCJlIiwiZGF0YVJlZiIsInNldHMiLCJpbmRleE9mIiwicHVzaCIsImlzRnJlc2giLCJwcmV2aW91c18xIiwibWVyZ2VNZXJnZVRyZWVzIiwibWVyZ2VUcmVlSXNFbXB0eSIsIml0ZW0iLCJpIiwiZmllbGRNYXAiLCJsaW1pdGluZ1RyaWUiLCJmbGF0dGVuIiwiaW5oZXJpdGVkQ29udGV4dCIsInZpc2l0ZWROb2RlIiwibG9va3VwIiwidmlzaXRlZCIsInNlbGVjdGlvbnMiLCJzZWxlY3Rpb24iLCJkaXJlY3RpdmVzIiwiZGlyIiwiYXJncyIsImlmIiwiZnJhZ21lbnQiLCJsb29rdXBGcmFnbWVudCIsImtpbmQiLCJGUkFHTUVOVF9TUFJFQUQiLCJmcmFnbWVudE1hdGNoZXMiLCJnZXRTdG9yYWdlQXJncyIsImVfMSIsImlfMSIsImNoYW5nZWRGaWVsZHNfMSIsImdldFZhbHVlXzEiLCJnZXRGaWVsZFZhbHVlIiwiU3RyaW5nIiwiZVZhbCIsImlWYWwiLCJhVmFsIiwicG9wIiwic2xpY2UiLCJydW5NZXJnZUZ1bmN0aW9uIiwiZ2V0U3RvcmFnZSIsImFwcGx5IiwiZW1wdHlNZXJnZVRyZWVQb29sIiwiaGFzIiwibGVmdCIsInJpZ2h0IiwibmVlZFRvTWVyZ2VNYXBzIiwibWVyZ2VkIiwicmVtYWluaW5nUmlnaHRLZXlzXzEiLCJsZWZ0VHJlZSIsImRlbGV0ZSIsInRyZWUiLCJ3YXJuaW5ncyIsImV4aXN0aW5nUmVmIiwiaW5jb21pbmdPYmoiLCJnZXRDaGlsZCIsIm9iak9yUmVmIiwiY2hpbGQiLCJldmVyeSIsInBhcmVudFR5cGUiLCJ0eXBlRG90TmFtZSIsImNoaWxkVHlwZW5hbWVzIiwiaW5jbHVkZXMiLCJ3YXJuIiwibGVuZ3RoIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/writeToStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/ApolloClient.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/ApolloClient.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloClient: function() { return /* binding */ ApolloClient; },\n/* harmony export */   mergeOptions: function() { return /* reexport safe */ _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../link/core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js\");\n/* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../link/core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/execute.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../version.js */ \"(app-pages-browser)/./node_modules/@apollo/client/version.js\");\n/* harmony import */ var _link_http_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../link/http/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/HttpLink.js\");\n/* harmony import */ var _QueryManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./QueryManager.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/QueryManager.js\");\n/* harmony import */ var _LocalState_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LocalState.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/LocalState.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeOptions.js\");\n/* harmony import */ var _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n\n\n\n\n\n\n\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\n\n\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */ var ApolloClient = /** @class */ function() {\n    /**\n     * Constructs an instance of `ApolloClient`.\n     *\n     * @example\n     * ```js\n     * import { ApolloClient, InMemoryCache } from '@apollo/client';\n     *\n     * const cache = new InMemoryCache();\n     *\n     * const client = new ApolloClient({\n     *   // Provide required constructor fields\n     *   cache: cache,\n     *   uri: 'http://localhost:4000/',\n     *\n     *   // Provide some optional constructor fields\n     *   name: 'react-web-client',\n     *   version: '1.3',\n     *   queryDeduplication: false,\n     *   defaultOptions: {\n     *     watchQuery: {\n     *       fetchPolicy: 'cache-and-network',\n     *     },\n     *   },\n     * });\n     * ```\n     */ function ApolloClient(options) {\n        var _this = this;\n        var _a;\n        this.resetStoreCallbacks = [];\n        this.clearStoreCallbacks = [];\n        if (!options.cache) {\n            throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(15);\n        }\n        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _b = options.ssrMode, ssrMode = _b === void 0 ? false : _b, _c = options.ssrForceFetchDelay, ssrForceFetchDelay = _c === void 0 ? 0 : _c, // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        connectToDevTools = options.connectToDevTools, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools;\n        var link = options.link;\n        if (!link) {\n            link = uri ? new _link_http_index_js__WEBPACK_IMPORTED_MODULE_2__.HttpLink({\n                uri: uri,\n                credentials: credentials,\n                headers: headers\n            }) : _link_core_index_js__WEBPACK_IMPORTED_MODULE_3__.ApolloLink.empty();\n        }\n        this.link = link;\n        this.cache = cache;\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.typeDefs = typeDefs;\n        this.devtoolsConfig = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, devtools), {\n            enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools\n        });\n        if (this.devtoolsConfig.enabled === undefined) {\n            this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;\n        }\n        if (ssrForceFetchDelay) {\n            setTimeout(function() {\n                return _this.disableNetworkFetches = false;\n            }, ssrForceFetchDelay);\n        }\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.watchFragment = this.watchFragment.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n        this.version = _version_js__WEBPACK_IMPORTED_MODULE_5__.version;\n        this.localState = new _LocalState_js__WEBPACK_IMPORTED_MODULE_6__.LocalState({\n            cache: cache,\n            client: this,\n            resolvers: resolvers,\n            fragmentMatcher: fragmentMatcher\n        });\n        this.queryManager = new _QueryManager_js__WEBPACK_IMPORTED_MODULE_7__.QueryManager({\n            cache: this.cache,\n            link: this.link,\n            defaultOptions: this.defaultOptions,\n            defaultContext: defaultContext,\n            documentTransform: documentTransform,\n            queryDeduplication: queryDeduplication,\n            ssrMode: ssrMode,\n            clientAwareness: {\n                name: clientAwarenessName,\n                version: clientAwarenessVersion\n            },\n            localState: this.localState,\n            assumeImmutableResults: assumeImmutableResults,\n            onBroadcast: this.devtoolsConfig.enabled ? function() {\n                if (_this.devToolsHookCb) {\n                    _this.devToolsHookCb({\n                        action: {},\n                        state: {\n                            queries: _this.queryManager.getQueryStore(),\n                            mutations: _this.queryManager.mutationStore || {}\n                        },\n                        dataWithOptimisticResults: _this.cache.extract(true)\n                    });\n                }\n            } : void 0\n        });\n        if (this.devtoolsConfig.enabled) this.connectToDevTools();\n    }\n    ApolloClient.prototype.connectToDevTools = function() {\n        if (false) {}\n        var windowWithDevTools = window;\n        var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n        windowWithDevTools.__APOLLO_CLIENT__ = this;\n        /**\n         * Suggest installing the devtools for developers who don't have them\n         */ if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n            hasSuggestedDevtools = true;\n            if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {\n                setTimeout(function() {\n                    if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n                        var nav = window.navigator;\n                        var ua = nav && nav.userAgent;\n                        var url = void 0;\n                        if (typeof ua === \"string\") {\n                            if (ua.indexOf(\"Chrome/\") > -1) {\n                                url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n                            } else if (ua.indexOf(\"Firefox/\") > -1) {\n                                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n                            }\n                        }\n                        if (url) {\n                            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n                        }\n                    }\n                }, 10000);\n            }\n        }\n    };\n    Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n        /**\n         * The `DocumentTransform` used to modify GraphQL documents before a request\n         * is made. If a custom `DocumentTransform` is not provided, this will be the\n         * default document transform.\n         */ get: function() {\n            return this.queryManager.documentTransform;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Call this method to terminate any active client processes, making it safe\n     * to dispose of this `ApolloClient` instance.\n     */ ApolloClient.prototype.stop = function() {\n        this.queryManager.stop();\n    };\n    /**\n     * This watches the cache store of the query according to the options specified and\n     * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n     * receive updated results through an observer when the cache store changes.\n     *\n     * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n     * it uses Apollo's store in order to reactively deliver updates to your query results.\n     *\n     * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n     * first and last name and this person has a particular object identifier, provided by\n     * dataIdFromObject. Later, a different query fetches that same person's\n     * first and last name and the first name has now changed. Then, any observers associated\n     * with the results of the first query will be updated with a new result object.\n     *\n     * Note that if the cache does not change, the subscriber will *not* be notified.\n     *\n     * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n     * a description of store reactivity.\n     */ ApolloClient.prototype.watchQuery = function(options) {\n        if (this.defaultOptions.watchQuery) {\n            options = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions)(this.defaultOptions.watchQuery, options);\n        }\n        // XXX Overwriting options is probably not the best way to do this long term...\n        if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n            options = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n                fetchPolicy: \"cache-first\"\n            });\n        }\n        return this.queryManager.watchQuery(options);\n    };\n    /**\n     * This resolves a single query according to the options specified and\n     * returns a `Promise` which is either resolved with the resulting data\n     * or rejected with an error.\n     *\n     * @param options - An object of type `QueryOptions` that allows us to\n     * describe how this query should be treated e.g. whether it should hit the\n     * server at all or just resolve from the cache, etc.\n     */ ApolloClient.prototype.query = function(options) {\n        if (this.defaultOptions.query) {\n            options = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions)(this.defaultOptions.query, options);\n        }\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(options.fetchPolicy !== \"cache-and-network\", 16);\n        if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n            options = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {\n                fetchPolicy: \"cache-first\"\n            });\n        }\n        return this.queryManager.query(options);\n    };\n    /**\n     * This resolves a single mutation according to the options specified and returns a\n     * Promise which is either resolved with the resulting data or rejected with an\n     * error. In some cases both `data` and `errors` might be undefined, for example\n     * when `errorPolicy` is set to `'ignore'`.\n     *\n     * It takes options as an object with the following keys and values:\n     */ ApolloClient.prototype.mutate = function(options) {\n        if (this.defaultOptions.mutate) {\n            options = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions)(this.defaultOptions.mutate, options);\n        }\n        return this.queryManager.mutate(options);\n    };\n    /**\n     * This subscribes to a graphql subscription according to the options specified and returns an\n     * `Observable` which either emits received data or an error.\n     */ ApolloClient.prototype.subscribe = function(options) {\n        return this.queryManager.startGraphQLSubscription(options);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL query without making a network request. This method will start at\n     * the root query. To start at a specific id returned by `dataIdFromObject`\n     * use `readFragment`.\n     *\n     * @param optimistic - Set to `true` to allow `readQuery` to return\n     * optimistic results. Is `false` by default.\n     */ ApolloClient.prototype.readQuery = function(options, optimistic) {\n        if (optimistic === void 0) {\n            optimistic = false;\n        }\n        return this.cache.readQuery(options, optimistic);\n    };\n    /**\n     * Watches the cache store of the fragment according to the options specified\n     * and returns an `Observable`. We can subscribe to this\n     * `Observable` and receive updated results through an\n     * observer when the cache store changes.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are reading. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     *\n     * @since 3.10.0\n     * @param options - An object of type `WatchFragmentOptions` that allows\n     * the cache to identify the fragment and optionally specify whether to react\n     * to optimistic updates.\n     */ ApolloClient.prototype.watchFragment = function(options) {\n        return this.cache.watchFragment(options);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL fragment without making a network request. This method will read a\n     * GraphQL fragment from any arbitrary id that is currently cached, unlike\n     * `readQuery` which will only read from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are reading. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     *\n     * @param optimistic - Set to `true` to allow `readFragment` to return\n     * optimistic results. Is `false` by default.\n     */ ApolloClient.prototype.readFragment = function(options, optimistic) {\n        if (optimistic === void 0) {\n            optimistic = false;\n        }\n        return this.cache.readFragment(options, optimistic);\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL query directly to\n     * the store. This method will start at the root query. To start at a\n     * specific id returned by `dataIdFromObject` then use `writeFragment`.\n     */ ApolloClient.prototype.writeQuery = function(options) {\n        var ref = this.cache.writeQuery(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL fragment directly to\n     * the store. This method will write to a GraphQL fragment from any arbitrary\n     * id that is currently cached, unlike `writeQuery` which will only write\n     * from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are writing. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     */ ApolloClient.prototype.writeFragment = function(options) {\n        var ref = this.cache.writeFragment(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    ApolloClient.prototype.__actionHookForDevTools = function(cb) {\n        this.devToolsHookCb = cb;\n    };\n    ApolloClient.prototype.__requestRaw = function(payload) {\n        return (0,_link_core_index_js__WEBPACK_IMPORTED_MODULE_8__.execute)(this.link, payload);\n    };\n    /**\n     * Resets your entire store by clearing out your cache and then re-executing\n     * all of your active queries. This makes it so that you may guarantee that\n     * there is no data left in your store from a time before you called this\n     * method.\n     *\n     * `resetStore()` is useful when your user just logged out. You’ve removed the\n     * user session, and you now want to make sure that any references to data you\n     * might have fetched while the user session was active is gone.\n     *\n     * It is important to remember that `resetStore()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */ ApolloClient.prototype.resetStore = function() {\n        var _this = this;\n        return Promise.resolve().then(function() {\n            return _this.queryManager.clearStore({\n                discardWatches: false\n            });\n        }).then(function() {\n            return Promise.all(_this.resetStoreCallbacks.map(function(fn) {\n                return fn();\n            }));\n        }).then(function() {\n            return _this.reFetchObservableQueries();\n        });\n    };\n    /**\n     * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n     * not refetch any active queries.\n     */ ApolloClient.prototype.clearStore = function() {\n        var _this = this;\n        return Promise.resolve().then(function() {\n            return _this.queryManager.clearStore({\n                discardWatches: true\n            });\n        }).then(function() {\n            return Promise.all(_this.clearStoreCallbacks.map(function(fn) {\n                return fn();\n            }));\n        });\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * reset. `onResetStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */ ApolloClient.prototype.onResetStore = function(cb) {\n        var _this = this;\n        this.resetStoreCallbacks.push(cb);\n        return function() {\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {\n                return c !== cb;\n            });\n        };\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * cleared. `onClearStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */ ApolloClient.prototype.onClearStore = function(cb) {\n        var _this = this;\n        this.clearStoreCallbacks.push(cb);\n        return function() {\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {\n                return c !== cb;\n            });\n        };\n    };\n    /**\n     * Refetches all of your active queries.\n     *\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     */ ApolloClient.prototype.reFetchObservableQueries = function(includeStandby) {\n        return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    /**\n     * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n     *\n     * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n     *\n     * It is important to remember that `refetchQueries()` *will* refetch specified active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */ ApolloClient.prototype.refetchQueries = function(options) {\n        var map = this.queryManager.refetchQueries(options);\n        var queries = [];\n        var results = [];\n        map.forEach(function(result, obsQuery) {\n            queries.push(obsQuery);\n            results.push(result);\n        });\n        var result = Promise.all(results);\n        // In case you need the raw results immediately, without awaiting\n        // Promise.all(results):\n        result.queries = queries;\n        result.results = results;\n        // If you decide to ignore the result Promise because you're using\n        // result.queries and result.results instead, you shouldn't have to worry\n        // about preventing uncaught rejections for the Promise.all result.\n        result.catch(function(error) {\n            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.debug(17, error);\n        });\n        return result;\n    };\n    /**\n     * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n     * query ID strings.\n     *\n     * An \"active\" query is one that has observers and a `fetchPolicy` other than\n     * \"standby\" or \"cache-only\".\n     *\n     * You can include all `ObservableQuery` objects (including the inactive ones)\n     * by passing \"all\" instead of \"active\", or you can include just a subset of\n     * active queries by passing an array of query names or DocumentNode objects.\n     */ ApolloClient.prototype.getObservableQueries = function(include) {\n        if (include === void 0) {\n            include = \"active\";\n        }\n        return this.queryManager.getObservableQueries(include);\n    };\n    /**\n     * Exposes the cache's complete state, in a serializable format for later restoration.\n     */ ApolloClient.prototype.extract = function(optimistic) {\n        return this.cache.extract(optimistic);\n    };\n    /**\n     * Replaces existing state in the cache (if any) with the values expressed by\n     * `serializedState`.\n     *\n     * Called when hydrating a cache (server side rendering, or offline storage),\n     * and also (potentially) during hot reloads.\n     */ ApolloClient.prototype.restore = function(serializedState) {\n        return this.cache.restore(serializedState);\n    };\n    /**\n     * Add additional local resolvers.\n     */ ApolloClient.prototype.addResolvers = function(resolvers) {\n        this.localState.addResolvers(resolvers);\n    };\n    /**\n     * Set (override existing) local resolvers.\n     */ ApolloClient.prototype.setResolvers = function(resolvers) {\n        this.localState.setResolvers(resolvers);\n    };\n    /**\n     * Get all registered local resolvers.\n     */ ApolloClient.prototype.getResolvers = function() {\n        return this.localState.getResolvers();\n    };\n    /**\n     * Set a custom local state fragment matcher.\n     */ ApolloClient.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {\n        this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    /**\n     * Define a new ApolloLink (or link chain) that Apollo Client will use.\n     */ ApolloClient.prototype.setLink = function(newLink) {\n        this.link = this.queryManager.link = newLink;\n    };\n    Object.defineProperty(ApolloClient.prototype, \"defaultContext\", {\n        get: function() {\n            return this.queryManager.defaultContext;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ApolloClient;\n}();\n\nif (globalThis.__DEV__ !== false) {\n    ApolloClient.prototype.getMemoryInternals = _utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_9__.getApolloClientMemoryInternals;\n} //# sourceMappingURL=ApolloClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL0Fwb2xsb0NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDNEM7QUFDakI7QUFDcEI7QUFDUztBQUNBO0FBQ0o7QUFDN0MsSUFBSVMsdUJBQXVCO0FBQzNCLHNFQUFzRTtBQUN0RSw4RUFBOEU7QUFDOUUsOEVBQThFO0FBQzlFLGdGQUFnRjtBQUMzQjtBQUN1QztBQUNwRTtBQUN4Qjs7Ozs7Q0FLQyxHQUNELElBQUlHLGVBQWUsV0FBVyxHQUFJO0lBQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBeUJDLEdBQ0QsU0FBU0EsYUFBYUMsT0FBTztRQUN6QixJQUFJQyxRQUFRLElBQUk7UUFDaEIsSUFBSUM7UUFDSixJQUFJLENBQUNDLG1CQUFtQixHQUFHLEVBQUU7UUFDN0IsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxFQUFFO1FBQzdCLElBQUksQ0FBQ0osUUFBUUssS0FBSyxFQUFFO1lBQ2hCLE1BQU1oQiw4RUFBaUJBLENBQUM7UUFDNUI7UUFDQSxJQUFJaUIsTUFBTU4sUUFBUU0sR0FBRyxFQUFFQyxjQUFjUCxRQUFRTyxXQUFXLEVBQUVDLFVBQVVSLFFBQVFRLE9BQU8sRUFBRUgsUUFBUUwsUUFBUUssS0FBSyxFQUFFSSxvQkFBb0JULFFBQVFTLGlCQUFpQixFQUFFQyxLQUFLVixRQUFRVyxPQUFPLEVBQUVBLFVBQVVELE9BQU8sS0FBSyxJQUFJLFFBQVFBLElBQUlFLEtBQUtaLFFBQVFhLGtCQUFrQixFQUFFQSxxQkFBcUJELE9BQU8sS0FBSyxJQUFJLElBQUlBLElBQ2pTLGtFQUFrRTtRQUNsRSxpRUFBaUU7UUFDakUsdURBQXVEO1FBQ3ZERSxvQkFBb0JkLFFBQVFjLGlCQUFpQixFQUFFQyxLQUFLZixRQUFRZ0Isa0JBQWtCLEVBQUVBLHFCQUFxQkQsT0FBTyxLQUFLLElBQUksT0FBT0EsSUFBSUUsaUJBQWlCakIsUUFB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R0FBRyxTQUFVM0csZUFBZTtRQUMzRSxJQUFJLENBQUN1QixVQUFVLENBQUNxRixrQkFBa0IsQ0FBQzVHO0lBQ3ZDO0lBQ0E7O0tBRUMsR0FDRHhCLGFBQWE2RCxTQUFTLENBQUN3RSxPQUFPLEdBQUcsU0FBVUMsT0FBTztRQUM5QyxJQUFJLENBQUN6RyxJQUFJLEdBQUcsSUFBSSxDQUFDb0IsWUFBWSxDQUFDcEIsSUFBSSxHQUFHeUc7SUFDekM7SUFDQXRHLE9BQU9tRCxjQUFjLENBQUNuRixhQUFhNkQsU0FBUyxFQUFFLGtCQUFrQjtRQUM1RHVCLEtBQUs7WUFDRCxPQUFPLElBQUksQ0FBQ25DLFlBQVksQ0FBQzlCLGNBQWM7UUFDM0M7UUFDQWtFLFlBQVk7UUFDWkMsY0FBYztJQUNsQjtJQUNBLE9BQU90RjtBQUNYO0FBQ3dCO0FBQ3hCLElBQUlxQyxXQUFXQyxPQUFPLEtBQUssT0FBTztJQUM5QnRDLGFBQWE2RCxTQUFTLENBQUMwRSxrQkFBa0IsR0FBR3hJLG9HQUE4QkE7QUFDOUUsRUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2NvcmUvQXBvbGxvQ2xpZW50LmpzP2I2MDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFwb2xsb0xpbmssIGV4ZWN1dGUgfSBmcm9tIFwiLi4vbGluay9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IEh0dHBMaW5rIH0gZnJvbSBcIi4uL2xpbmsvaHR0cC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUXVlcnlNYW5hZ2VyIH0gZnJvbSBcIi4vUXVlcnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBMb2NhbFN0YXRlIH0gZnJvbSBcIi4vTG9jYWxTdGF0ZS5qc1wiO1xudmFyIGhhc1N1Z2dlc3RlZERldnRvb2xzID0gZmFsc2U7XG4vLyBUaG91Z2ggbWVyZ2VPcHRpb25zIG5vdyByZXNpZGVzIGluIEBhcG9sbG8vY2xpZW50L3V0aWxpdGllcywgaXQgd2FzXG4vLyBwcmV2aW91c2x5IGRlY2xhcmVkIGFuZCBleHBvcnRlZCBmcm9tIHRoaXMgbW9kdWxlLCBhbmQgdGhlbiByZWV4cG9ydGVkIGZyb21cbi8vIEBhcG9sbG8vY2xpZW50L2NvcmUuIFNpbmNlIHdlIG5lZWQgdG8gcHJlc2VydmUgdGhhdCBBUEkgYW55d2F5LCB0aGUgZWFzaWVzdFxuLy8gc29sdXRpb24gaXMgdG8gcmVleHBvcnQgbWVyZ2VPcHRpb25zIHdoZXJlIGl0IHdhcyBwcmV2aW91c2x5IGRlY2xhcmVkIChoZXJlKS5cbmltcG9ydCB7IG1lcmdlT3B0aW9ucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFwb2xsb0NsaWVudE1lbW9yeUludGVybmFscyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY2FjaGluZy9nZXRNZW1vcnlJbnRlcm5hbHMuanNcIjtcbmV4cG9ydCB7IG1lcmdlT3B0aW9ucyB9O1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBwcmltYXJ5IEFwb2xsbyBDbGllbnQgY2xhc3MuIEl0IGlzIHVzZWQgdG8gc2VuZCBHcmFwaFFMIGRvY3VtZW50cyAoaS5lLiBxdWVyaWVzXG4gKiBhbmQgbXV0YXRpb25zKSB0byBhIEdyYXBoUUwgc3BlYy1jb21wbGlhbnQgc2VydmVyIG92ZXIgYW4gYEFwb2xsb0xpbmtgIGluc3RhbmNlLFxuICogcmVjZWl2ZSByZXN1bHRzIGZyb20gdGhlIHNlcnZlciBhbmQgY2FjaGUgdGhlIHJlc3VsdHMgaW4gYSBzdG9yZS4gSXQgYWxzbyBkZWxpdmVycyB1cGRhdGVzXG4gKiB0byBHcmFwaFFMIHF1ZXJpZXMgdGhyb3VnaCBgT2JzZXJ2YWJsZWAgaW5zdGFuY2VzLlxuICovXG52YXIgQXBvbGxvQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgYEFwb2xsb0NsaWVudGAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IHsgQXBvbGxvQ2xpZW50LCBJbk1lbW9yeUNhY2hlIH0gZnJvbSAnQGFwb2xsby9jbGllbnQnO1xuICAgICAqXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgSW5NZW1vcnlDYWNoZSgpO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudCh7XG4gICAgICogICAvLyBQcm92aWRlIHJlcXVpcmVkIGNvbnN0cnVjdG9yIGZpZWxkc1xuICAgICAqICAgY2FjaGU6IGNhY2hlLFxuICAgICAqICAgdXJpOiAnaHR0cDovL2xvY2FsaG9zdDo0MDAwLycsXG4gICAgICpcbiAgICAgKiAgIC8vIFByb3ZpZGUgc29tZSBvcHRpb25hbCBjb25zdHJ1Y3RvciBmaWVsZHNcbiAgICAgKiAgIG5hbWU6ICdyZWFjdC13ZWItY2xpZW50JyxcbiAgICAgKiAgIHZlcnNpb246ICcxLjMnLFxuICAgICAqICAgcXVlcnlEZWR1cGxpY2F0aW9uOiBmYWxzZSxcbiAgICAgKiAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICogICAgIHdhdGNoUXVlcnk6IHtcbiAgICAgKiAgICAgICBmZXRjaFBvbGljeTogJ2NhY2hlLWFuZC1uZXR3b3JrJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXBvbGxvQ2xpZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIGlmICghb3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoMTUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmkgPSBvcHRpb25zLnVyaSwgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzLCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzLCBjYWNoZSA9IG9wdGlvbnMuY2FjaGUsIGRvY3VtZW50VHJhbnNmb3JtID0gb3B0aW9ucy5kb2N1bWVudFRyYW5zZm9ybSwgX2IgPSBvcHRpb25zLnNzck1vZGUsIHNzck1vZGUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBvcHRpb25zLnNzckZvcmNlRmV0Y2hEZWxheSwgc3NyRm9yY2VGZXRjaERlbGF5ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgXG4gICAgICAgIC8vIEV4cG9zZSB0aGUgY2xpZW50IGluc3RhbmNlIGFzIHdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyBhbmQgY2FsbFxuICAgICAgICAvLyBvbkJyb2FkY2FzdCBpbiBxdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcyB0byBlbmFibGUgYnJvd3NlclxuICAgICAgICAvLyBkZXZ0b29scywgYnV0IGRpc2FibGUgdGhlbSBieSBkZWZhdWx0IGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGNvbm5lY3RUb0RldlRvb2xzID0gb3B0aW9ucy5jb25uZWN0VG9EZXZUb29scywgX2QgPSBvcHRpb25zLnF1ZXJ5RGVkdXBsaWNhdGlvbiwgcXVlcnlEZWR1cGxpY2F0aW9uID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zLmRlZmF1bHRPcHRpb25zLCBkZWZhdWx0Q29udGV4dCA9IG9wdGlvbnMuZGVmYXVsdENvbnRleHQsIF9lID0gb3B0aW9ucy5hc3N1bWVJbW11dGFibGVSZXN1bHRzLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2UgPT09IHZvaWQgMCA/IGNhY2hlLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgOiBfZSwgcmVzb2x2ZXJzID0gb3B0aW9ucy5yZXNvbHZlcnMsIHR5cGVEZWZzID0gb3B0aW9ucy50eXBlRGVmcywgZnJhZ21lbnRNYXRjaGVyID0gb3B0aW9ucy5mcmFnbWVudE1hdGNoZXIsIGNsaWVudEF3YXJlbmVzc05hbWUgPSBvcHRpb25zLm5hbWUsIGNsaWVudEF3YXJlbmVzc1ZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24sIGRldnRvb2xzID0gb3B0aW9ucy5kZXZ0b29scztcbiAgICAgICAgdmFyIGxpbmsgPSBvcHRpb25zLmxpbms7XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgbGluayA9XG4gICAgICAgICAgICAgICAgdXJpID8gbmV3IEh0dHBMaW5rKHsgdXJpOiB1cmksIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscywgaGVhZGVyczogaGVhZGVycyB9KSA6IEFwb2xsb0xpbmsuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMuZGlzYWJsZU5ldHdvcmtGZXRjaGVzID0gc3NyTW9kZSB8fCBzc3JGb3JjZUZldGNoRGVsYXkgPiAwO1xuICAgICAgICB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbiA9IHF1ZXJ5RGVkdXBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHlwZURlZnMgPSB0eXBlRGVmcztcbiAgICAgICAgdGhpcy5kZXZ0b29sc0NvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZXZ0b29scyksIHsgZW5hYmxlZDogKF9hID0gZGV2dG9vbHMgPT09IG51bGwgfHwgZGV2dG9vbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRldnRvb2xzLmVuYWJsZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbm5lY3RUb0RldlRvb2xzIH0pO1xuICAgICAgICBpZiAodGhpcy5kZXZ0b29sc0NvbmZpZy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV2dG9vbHNDb25maWcuZW5hYmxlZCA9IGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNzckZvcmNlRmV0Y2hEZWxheSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiAoX3RoaXMuZGlzYWJsZU5ldHdvcmtGZXRjaGVzID0gZmFsc2UpOyB9LCBzc3JGb3JjZUZldGNoRGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hRdWVyeSA9IHRoaXMud2F0Y2hRdWVyeS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm11dGF0ZSA9IHRoaXMubXV0YXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMud2F0Y2hGcmFnbWVudCA9IHRoaXMud2F0Y2hGcmFnbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmUgPSB0aGlzLnJlc2V0U3RvcmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSB0aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxTdGF0ZSh7XG4gICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMsXG4gICAgICAgICAgICByZXNvbHZlcnM6IHJlc29sdmVycyxcbiAgICAgICAgICAgIGZyYWdtZW50TWF0Y2hlcjogZnJhZ21lbnRNYXRjaGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIgPSBuZXcgUXVlcnlNYW5hZ2VyKHtcbiAgICAgICAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgICAgICAgICAgbGluazogdGhpcy5saW5rLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHRoaXMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgICAgICBkZWZhdWx0Q29udGV4dDogZGVmYXVsdENvbnRleHQsXG4gICAgICAgICAgICBkb2N1bWVudFRyYW5zZm9ybTogZG9jdW1lbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgICBxdWVyeURlZHVwbGljYXRpb246IHF1ZXJ5RGVkdXBsaWNhdGlvbixcbiAgICAgICAgICAgIHNzck1vZGU6IHNzck1vZGUsXG4gICAgICAgICAgICBjbGllbnRBd2FyZW5lc3M6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBjbGllbnRBd2FyZW5lc3NOYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGNsaWVudEF3YXJlbmVzc1ZlcnNpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxTdGF0ZTogdGhpcy5sb2NhbFN0YXRlLFxuICAgICAgICAgICAgYXNzdW1lSW1tdXRhYmxlUmVzdWx0czogYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyxcbiAgICAgICAgICAgIG9uQnJvYWRjYXN0OiB0aGlzLmRldnRvb2xzQ29uZmlnLmVuYWJsZWQgP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRldlRvb2xzSG9va0NiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXZUb29sc0hvb2tDYih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzOiBfdGhpcy5xdWVyeU1hbmFnZXIuZ2V0UXVlcnlTdG9yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbnM6IF90aGlzLnF1ZXJ5TWFuYWdlci5tdXRhdGlvblN0b3JlIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVdpdGhPcHRpbWlzdGljUmVzdWx0czogX3RoaXMuY2FjaGUuZXh0cmFjdCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGV2dG9vbHNDb25maWcuZW5hYmxlZClcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvRGV2VG9vbHMoKTtcbiAgICB9XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5jb25uZWN0VG9EZXZUb29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93V2l0aERldlRvb2xzID0gd2luZG93O1xuICAgICAgICB2YXIgZGV2dG9vbHNTeW1ib2wgPSBTeW1ib2wuZm9yKFwiYXBvbGxvLmRldnRvb2xzXCIpO1xuICAgICAgICAod2luZG93V2l0aERldlRvb2xzW2RldnRvb2xzU3ltYm9sXSA9XG4gICAgICAgICAgICB3aW5kb3dXaXRoRGV2VG9vbHNbZGV2dG9vbHNTeW1ib2xdIHx8IFtdKS5wdXNoKHRoaXMpO1xuICAgICAgICB3aW5kb3dXaXRoRGV2VG9vbHMuX19BUE9MTE9fQ0xJRU5UX18gPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VnZ2VzdCBpbnN0YWxsaW5nIHRoZSBkZXZ0b29scyBmb3IgZGV2ZWxvcGVycyB3aG8gZG9uJ3QgaGF2ZSB0aGVtXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWhhc1N1Z2dlc3RlZERldnRvb2xzICYmIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhhc1N1Z2dlc3RlZERldnRvb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZiAmJlxuICAgICAgICAgICAgICAgIC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuX19BUE9MTE9fREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWEgPSBuYXYgJiYgbmF2LnVzZXJBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVhLmluZGV4T2YoXCJDaHJvbWUvXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBvbGxvLWNsaWVudC1kZXZlbG9wZXItdC9qZGtrbmtrYmViYmFwaWxnb2VjY2NpZ2xrZmJtYm5mbVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1YS5pbmRleE9mKFwiRmlyZWZveC9cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL2FkZG9ucy5tb3ppbGxhLm9yZy9lbi1VUy9maXJlZm94L2FkZG9uL2Fwb2xsby1kZXZlbG9wZXItdG9vbHMvXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmxvZyhcIkRvd25sb2FkIHRoZSBBcG9sbG8gRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlcmllbmNlOiAlc1wiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBvbGxvQ2xpZW50LnByb3RvdHlwZSwgXCJkb2N1bWVudFRyYW5zZm9ybVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYERvY3VtZW50VHJhbnNmb3JtYCB1c2VkIHRvIG1vZGlmeSBHcmFwaFFMIGRvY3VtZW50cyBiZWZvcmUgYSByZXF1ZXN0XG4gICAgICAgICAqIGlzIG1hZGUuIElmIGEgY3VzdG9tIGBEb2N1bWVudFRyYW5zZm9ybWAgaXMgbm90IHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlXG4gICAgICAgICAqIGRlZmF1bHQgZG9jdW1lbnQgdHJhbnNmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIuZG9jdW1lbnRUcmFuc2Zvcm07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgYWN0aXZlIGNsaWVudCBwcm9jZXNzZXMsIG1ha2luZyBpdCBzYWZlXG4gICAgICogdG8gZGlzcG9zZSBvZiB0aGlzIGBBcG9sbG9DbGllbnRgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyB3YXRjaGVzIHRoZSBjYWNoZSBzdG9yZSBvZiB0aGUgcXVlcnkgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zIHNwZWNpZmllZCBhbmRcbiAgICAgKiByZXR1cm5zIGFuIGBPYnNlcnZhYmxlUXVlcnlgLiBXZSBjYW4gc3Vic2NyaWJlIHRvIHRoaXMgYE9ic2VydmFibGVRdWVyeWAgYW5kXG4gICAgICogcmVjZWl2ZSB1cGRhdGVkIHJlc3VsdHMgdGhyb3VnaCBhbiBvYnNlcnZlciB3aGVuIHRoZSBjYWNoZSBzdG9yZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdCBhbiBpbXBsZW1lbnRhdGlvbiBvZiBHcmFwaFFMIHN1YnNjcmlwdGlvbnMuIFJhdGhlcixcbiAgICAgKiBpdCB1c2VzIEFwb2xsbydzIHN0b3JlIGluIG9yZGVyIHRvIHJlYWN0aXZlbHkgZGVsaXZlciB1cGRhdGVzIHRvIHlvdXIgcXVlcnkgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBzdXBwb3NlIHlvdSBjYWxsIHdhdGNoUXVlcnkgb24gYSBHcmFwaFFMIHF1ZXJ5IHRoYXQgZmV0Y2hlcyBhIHBlcnNvbidzXG4gICAgICogZmlyc3QgYW5kIGxhc3QgbmFtZSBhbmQgdGhpcyBwZXJzb24gaGFzIGEgcGFydGljdWxhciBvYmplY3QgaWRlbnRpZmllciwgcHJvdmlkZWQgYnlcbiAgICAgKiBkYXRhSWRGcm9tT2JqZWN0LiBMYXRlciwgYSBkaWZmZXJlbnQgcXVlcnkgZmV0Y2hlcyB0aGF0IHNhbWUgcGVyc29uJ3NcbiAgICAgKiBmaXJzdCBhbmQgbGFzdCBuYW1lIGFuZCB0aGUgZmlyc3QgbmFtZSBoYXMgbm93IGNoYW5nZWQuIFRoZW4sIGFueSBvYnNlcnZlcnMgYXNzb2NpYXRlZFxuICAgICAqIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGZpcnN0IHF1ZXJ5IHdpbGwgYmUgdXBkYXRlZCB3aXRoIGEgbmV3IHJlc3VsdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgdGhlIGNhY2hlIGRvZXMgbm90IGNoYW5nZSwgdGhlIHN1YnNjcmliZXIgd2lsbCAqbm90KiBiZSBub3RpZmllZC5cbiAgICAgKlxuICAgICAqIFNlZSBbaGVyZV0oaHR0cHM6Ly9tZWRpdW0uY29tL2Fwb2xsby1zdGFjay90aGUtY29uY2VwdHMtb2YtZ3JhcGhxbC1iYzY4YmQ4MTliZTMjLjNtYjBjYmNtYykgZm9yXG4gICAgICogYSBkZXNjcmlwdGlvbiBvZiBzdG9yZSByZWFjdGl2aXR5LlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUud2F0Y2hRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFggT3ZlcndyaXRpbmcgb3B0aW9ucyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXMgbG9uZyB0ZXJtLi4uXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyAmJlxuICAgICAgICAgICAgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZldGNoUG9saWN5ID09PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiBcImNhY2hlLWZpcnN0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLndhdGNoUXVlcnkob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHJlc29sdmVzIGEgc2luZ2xlIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgb3B0aW9ucyBzcGVjaWZpZWQgYW5kXG4gICAgICogcmV0dXJucyBhIGBQcm9taXNlYCB3aGljaCBpcyBlaXRoZXIgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0aW5nIGRhdGFcbiAgICAgKiBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgb2YgdHlwZSBgUXVlcnlPcHRpb25zYCB0aGF0IGFsbG93cyB1cyB0b1xuICAgICAqIGRlc2NyaWJlIGhvdyB0aGlzIHF1ZXJ5IHNob3VsZCBiZSB0cmVhdGVkIGUuZy4gd2hldGhlciBpdCBzaG91bGQgaGl0IHRoZVxuICAgICAqIHNlcnZlciBhdCBhbGwgb3IganVzdCByZXNvbHZlIGZyb20gdGhlIGNhY2hlLCBldGMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGludmFyaWFudChvcHRpb25zLmZldGNoUG9saWN5ICE9PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIsIDE2KTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZU5ldHdvcmtGZXRjaGVzICYmIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6IFwiY2FjaGUtZmlyc3RcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIucXVlcnkob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHJlc29sdmVzIGEgc2luZ2xlIG11dGF0aW9uIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucyBzcGVjaWZpZWQgYW5kIHJldHVybnMgYVxuICAgICAqIFByb21pc2Ugd2hpY2ggaXMgZWl0aGVyIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdGluZyBkYXRhIG9yIHJlamVjdGVkIHdpdGggYW5cbiAgICAgKiBlcnJvci4gSW4gc29tZSBjYXNlcyBib3RoIGBkYXRhYCBhbmQgYGVycm9yc2AgbWlnaHQgYmUgdW5kZWZpbmVkLCBmb3IgZXhhbXBsZVxuICAgICAqIHdoZW4gYGVycm9yUG9saWN5YCBpcyBzZXQgdG8gYCdpZ25vcmUnYC5cbiAgICAgKlxuICAgICAqIEl0IHRha2VzIG9wdGlvbnMgYXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzIGFuZCB2YWx1ZXM6XG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5tdXRhdGUob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHN1YnNjcmliZXMgdG8gYSBncmFwaHFsIHN1YnNjcmlwdGlvbiBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMgc3BlY2lmaWVkIGFuZCByZXR1cm5zIGFuXG4gICAgICogYE9ic2VydmFibGVgIHdoaWNoIGVpdGhlciBlbWl0cyByZWNlaXZlZCBkYXRhIG9yIGFuIGVycm9yLlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIHJlYWQgc29tZSBkYXRhIGZyb20gdGhlIHN0b3JlIGluIHRoZSBzaGFwZSBvZiB0aGUgcHJvdmlkZWRcbiAgICAgKiBHcmFwaFFMIHF1ZXJ5IHdpdGhvdXQgbWFraW5nIGEgbmV0d29yayByZXF1ZXN0LiBUaGlzIG1ldGhvZCB3aWxsIHN0YXJ0IGF0XG4gICAgICogdGhlIHJvb3QgcXVlcnkuIFRvIHN0YXJ0IGF0IGEgc3BlY2lmaWMgaWQgcmV0dXJuZWQgYnkgYGRhdGFJZEZyb21PYmplY3RgXG4gICAgICogdXNlIGByZWFkRnJhZ21lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGltaXN0aWMgLSBTZXQgdG8gYHRydWVgIHRvIGFsbG93IGByZWFkUXVlcnlgIHRvIHJldHVyblxuICAgICAqIG9wdGltaXN0aWMgcmVzdWx0cy4gSXMgYGZhbHNlYCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVhZFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVhZFF1ZXJ5KG9wdGlvbnMsIG9wdGltaXN0aWMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2F0Y2hlcyB0aGUgY2FjaGUgc3RvcmUgb2YgdGhlIGZyYWdtZW50IGFjY29yZGluZyB0byB0aGUgb3B0aW9ucyBzcGVjaWZpZWRcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBgT2JzZXJ2YWJsZWAuIFdlIGNhbiBzdWJzY3JpYmUgdG8gdGhpc1xuICAgICAqIGBPYnNlcnZhYmxlYCBhbmQgcmVjZWl2ZSB1cGRhdGVkIHJlc3VsdHMgdGhyb3VnaCBhblxuICAgICAqIG9ic2VydmVyIHdoZW4gdGhlIGNhY2hlIHN0b3JlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBZb3UgbXVzdCBwYXNzIGluIGEgR3JhcGhRTCBkb2N1bWVudCB3aXRoIGEgc2luZ2xlIGZyYWdtZW50IG9yIGEgZG9jdW1lbnRcbiAgICAgKiB3aXRoIG11bHRpcGxlIGZyYWdtZW50cyB0aGF0IHJlcHJlc2VudCB3aGF0IHlvdSBhcmUgcmVhZGluZy4gSWYgeW91IHBhc3NcbiAgICAgKiBpbiBhIGRvY3VtZW50IHdpdGggbXVsdGlwbGUgZnJhZ21lbnRzIHRoZW4geW91IG11c3QgYWxzbyBzcGVjaWZ5IGFcbiAgICAgKiBgZnJhZ21lbnROYW1lYC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBvZiB0eXBlIGBXYXRjaEZyYWdtZW50T3B0aW9uc2AgdGhhdCBhbGxvd3NcbiAgICAgKiB0aGUgY2FjaGUgdG8gaWRlbnRpZnkgdGhlIGZyYWdtZW50IGFuZCBvcHRpb25hbGx5IHNwZWNpZnkgd2hldGhlciB0byByZWFjdFxuICAgICAqIHRvIG9wdGltaXN0aWMgdXBkYXRlcy5cbiAgICAgKi9cbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndhdGNoRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS53YXRjaEZyYWdtZW50KG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gcmVhZCBzb21lIGRhdGEgZnJvbSB0aGUgc3RvcmUgaW4gdGhlIHNoYXBlIG9mIHRoZSBwcm92aWRlZFxuICAgICAqIEdyYXBoUUwgZnJhZ21lbnQgd2l0aG91dCBtYWtpbmcgYSBuZXR3b3JrIHJlcXVlc3QuIFRoaXMgbWV0aG9kIHdpbGwgcmVhZCBhXG4gICAgICogR3JhcGhRTCBmcmFnbWVudCBmcm9tIGFueSBhcmJpdHJhcnkgaWQgdGhhdCBpcyBjdXJyZW50bHkgY2FjaGVkLCB1bmxpa2VcbiAgICAgKiBgcmVhZFF1ZXJ5YCB3aGljaCB3aWxsIG9ubHkgcmVhZCBmcm9tIHRoZSByb290IHF1ZXJ5LlxuICAgICAqXG4gICAgICogWW91IG11c3QgcGFzcyBpbiBhIEdyYXBoUUwgZG9jdW1lbnQgd2l0aCBhIHNpbmdsZSBmcmFnbWVudCBvciBhIGRvY3VtZW50XG4gICAgICogd2l0aCBtdWx0aXBsZSBmcmFnbWVudHMgdGhhdCByZXByZXNlbnQgd2hhdCB5b3UgYXJlIHJlYWRpbmcuIElmIHlvdSBwYXNzXG4gICAgICogaW4gYSBkb2N1bWVudCB3aXRoIG11bHRpcGxlIGZyYWdtZW50cyB0aGVuIHlvdSBtdXN0IGFsc28gc3BlY2lmeSBhXG4gICAgICogYGZyYWdtZW50TmFtZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW1pc3RpYyAtIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgYHJlYWRGcmFnbWVudGAgdG8gcmV0dXJuXG4gICAgICogb3B0aW1pc3RpYyByZXN1bHRzLiBJcyBgZmFsc2VgIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZWFkRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZWFkRnJhZ21lbnQob3B0aW9ucywgb3B0aW1pc3RpYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgc29tZSBkYXRhIGluIHRoZSBzaGFwZSBvZiB0aGUgcHJvdmlkZWQgR3JhcGhRTCBxdWVyeSBkaXJlY3RseSB0b1xuICAgICAqIHRoZSBzdG9yZS4gVGhpcyBtZXRob2Qgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBxdWVyeS4gVG8gc3RhcnQgYXQgYVxuICAgICAqIHNwZWNpZmljIGlkIHJldHVybmVkIGJ5IGBkYXRhSWRGcm9tT2JqZWN0YCB0aGVuIHVzZSBgd3JpdGVGcmFnbWVudGAuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS53cml0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuY2FjaGUud3JpdGVRdWVyeShvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvYWRjYXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgc29tZSBkYXRhIGluIHRoZSBzaGFwZSBvZiB0aGUgcHJvdmlkZWQgR3JhcGhRTCBmcmFnbWVudCBkaXJlY3RseSB0b1xuICAgICAqIHRoZSBzdG9yZS4gVGhpcyBtZXRob2Qgd2lsbCB3cml0ZSB0byBhIEdyYXBoUUwgZnJhZ21lbnQgZnJvbSBhbnkgYXJiaXRyYXJ5XG4gICAgICogaWQgdGhhdCBpcyBjdXJyZW50bHkgY2FjaGVkLCB1bmxpa2UgYHdyaXRlUXVlcnlgIHdoaWNoIHdpbGwgb25seSB3cml0ZVxuICAgICAqIGZyb20gdGhlIHJvb3QgcXVlcnkuXG4gICAgICpcbiAgICAgKiBZb3UgbXVzdCBwYXNzIGluIGEgR3JhcGhRTCBkb2N1bWVudCB3aXRoIGEgc2luZ2xlIGZyYWdtZW50IG9yIGEgZG9jdW1lbnRcbiAgICAgKiB3aXRoIG11bHRpcGxlIGZyYWdtZW50cyB0aGF0IHJlcHJlc2VudCB3aGF0IHlvdSBhcmUgd3JpdGluZy4gSWYgeW91IHBhc3NcbiAgICAgKiBpbiBhIGRvY3VtZW50IHdpdGggbXVsdGlwbGUgZnJhZ21lbnRzIHRoZW4geW91IG11c3QgYWxzbyBzcGVjaWZ5IGFcbiAgICAgKiBgZnJhZ21lbnROYW1lYC5cbiAgICAgKi9cbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5jYWNoZS53cml0ZUZyYWdtZW50KG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5icm9hZGNhc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuX19hY3Rpb25Ib29rRm9yRGV2VG9vbHMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5kZXZUb29sc0hvb2tDYiA9IGNiO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5fX3JlcXVlc3RSYXcgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZSh0aGlzLmxpbmssIHBheWxvYWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHlvdXIgZW50aXJlIHN0b3JlIGJ5IGNsZWFyaW5nIG91dCB5b3VyIGNhY2hlIGFuZCB0aGVuIHJlLWV4ZWN1dGluZ1xuICAgICAqIGFsbCBvZiB5b3VyIGFjdGl2ZSBxdWVyaWVzLiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgeW91IG1heSBndWFyYW50ZWUgdGhhdFxuICAgICAqIHRoZXJlIGlzIG5vIGRhdGEgbGVmdCBpbiB5b3VyIHN0b3JlIGZyb20gYSB0aW1lIGJlZm9yZSB5b3UgY2FsbGVkIHRoaXNcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBgcmVzZXRTdG9yZSgpYCBpcyB1c2VmdWwgd2hlbiB5b3VyIHVzZXIganVzdCBsb2dnZWQgb3V0LiBZb3XigJl2ZSByZW1vdmVkIHRoZVxuICAgICAqIHVzZXIgc2Vzc2lvbiwgYW5kIHlvdSBub3cgd2FudCB0byBtYWtlIHN1cmUgdGhhdCBhbnkgcmVmZXJlbmNlcyB0byBkYXRhIHlvdVxuICAgICAqIG1pZ2h0IGhhdmUgZmV0Y2hlZCB3aGlsZSB0aGUgdXNlciBzZXNzaW9uIHdhcyBhY3RpdmUgaXMgZ29uZS5cbiAgICAgKlxuICAgICAqIEl0IGlzIGltcG9ydGFudCB0byByZW1lbWJlciB0aGF0IGByZXNldFN0b3JlKClgICp3aWxsKiByZWZldGNoIGFueSBhY3RpdmVcbiAgICAgKiBxdWVyaWVzLiBUaGlzIG1lYW5zIHRoYXQgYW55IGNvbXBvbmVudHMgdGhhdCBtaWdodCBiZSBtb3VudGVkIHdpbGwgZXhlY3V0ZVxuICAgICAqIHRoZWlyIHF1ZXJpZXMgYWdhaW4gdXNpbmcgeW91ciBuZXR3b3JrIGludGVyZmFjZS4gSWYgeW91IGRvIG5vdCB3YW50IHRvXG4gICAgICogcmUtZXhlY3V0ZSBhbnkgcXVlcmllcyB0aGVuIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHN0b3Agd2F0Y2hpbmcgYW55XG4gICAgICogYWN0aXZlIHF1ZXJpZXMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZXNldFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5xdWVyeU1hbmFnZXIuY2xlYXJTdG9yZSh7XG4gICAgICAgICAgICAgICAgZGlzY2FyZFdhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcygpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZGF0YSBmcm9tIHRoZSBzdG9yZS4gVW5saWtlIGByZXNldFN0b3JlYCwgYGNsZWFyU3RvcmVgIHdpbGxcbiAgICAgKiBub3QgcmVmZXRjaCBhbnkgYWN0aXZlIHF1ZXJpZXMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5jbGVhclN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5xdWVyeU1hbmFnZXIuY2xlYXJTdG9yZSh7XG4gICAgICAgICAgICAgICAgZGlzY2FyZFdhdGNoZXM6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UuYWxsKF90aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBjYWxsYmFja3MgdG8gYmUgcmVnaXN0ZXJlZCB0aGF0IGFyZSBleGVjdXRlZCB3aGVuIHRoZSBzdG9yZSBpc1xuICAgICAqIHJlc2V0LiBgb25SZXNldFN0b3JlYCByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWRcbiAgICAgKiB0byByZW1vdmUgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5vblJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IF90aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSBjYjsgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY2FsbGJhY2tzIHRvIGJlIHJlZ2lzdGVyZWQgdGhhdCBhcmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RvcmUgaXNcbiAgICAgKiBjbGVhcmVkLiBgb25DbGVhclN0b3JlYCByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWRcbiAgICAgKiB0byByZW1vdmUgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5vbkNsZWFyU3RvcmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcyA9IF90aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSBjYjsgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWZldGNoZXMgYWxsIG9mIHlvdXIgYWN0aXZlIHF1ZXJpZXMuXG4gICAgICpcbiAgICAgKiBgcmVGZXRjaE9ic2VydmFibGVRdWVyaWVzKClgIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBicmluZyB0aGUgY2xpZW50IGJhY2sgdG8gcHJvcGVyIHN0YXRlIGluIGNhc2Ugb2YgYSBuZXR3b3JrIG91dGFnZVxuICAgICAqXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgYHJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcygpYCAqd2lsbCogcmVmZXRjaCBhbnkgYWN0aXZlXG4gICAgICogcXVlcmllcy4gVGhpcyBtZWFucyB0aGF0IGFueSBjb21wb25lbnRzIHRoYXQgbWlnaHQgYmUgbW91bnRlZCB3aWxsIGV4ZWN1dGVcbiAgICAgKiB0aGVpciBxdWVyaWVzIGFnYWluIHVzaW5nIHlvdXIgbmV0d29yayBpbnRlcmZhY2UuIElmIHlvdSBkbyBub3Qgd2FudCB0b1xuICAgICAqIHJlLWV4ZWN1dGUgYW55IHF1ZXJpZXMgdGhlbiB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byBzdG9wIHdhdGNoaW5nIGFueVxuICAgICAqIGFjdGl2ZSBxdWVyaWVzLlxuICAgICAqIFRha2VzIG9wdGlvbmFsIHBhcmFtZXRlciBgaW5jbHVkZVN0YW5kYnlgIHdoaWNoIHdpbGwgaW5jbHVkZSBxdWVyaWVzIGluIHN0YW5kYnktbW9kZSB3aGVuIHJlZmV0Y2hpbmcuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVN0YW5kYnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlU3RhbmRieSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWZldGNoZXMgc3BlY2lmaWVkIGFjdGl2ZSBxdWVyaWVzLiBTaW1pbGFyIHRvIFwicmVGZXRjaE9ic2VydmFibGVRdWVyaWVzKClcIiBidXQgd2l0aCBhIHNwZWNpZmljIGxpc3Qgb2YgcXVlcmllcy5cbiAgICAgKlxuICAgICAqIGByZWZldGNoUXVlcmllcygpYCBpcyB1c2VmdWwgZm9yIHVzZSBjYXNlcyB0byBpbXBlcmF0aXZlbHkgcmVmcmVzaCBhIHNlbGVjdGlvbiBvZiBxdWVyaWVzLlxuICAgICAqXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgYHJlZmV0Y2hRdWVyaWVzKClgICp3aWxsKiByZWZldGNoIHNwZWNpZmllZCBhY3RpdmVcbiAgICAgKiBxdWVyaWVzLiBUaGlzIG1lYW5zIHRoYXQgYW55IGNvbXBvbmVudHMgdGhhdCBtaWdodCBiZSBtb3VudGVkIHdpbGwgZXhlY3V0ZVxuICAgICAqIHRoZWlyIHF1ZXJpZXMgYWdhaW4gdXNpbmcgeW91ciBuZXR3b3JrIGludGVyZmFjZS4gSWYgeW91IGRvIG5vdCB3YW50IHRvXG4gICAgICogcmUtZXhlY3V0ZSBhbnkgcXVlcmllcyB0aGVuIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHN0b3Agd2F0Y2hpbmcgYW55XG4gICAgICogYWN0aXZlIHF1ZXJpZXMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZWZldGNoUXVlcmllcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLnF1ZXJ5TWFuYWdlci5yZWZldGNoUXVlcmllcyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCwgb2JzUXVlcnkpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMucHVzaChvYnNRdWVyeSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBQcm9taXNlLmFsbChyZXN1bHRzKTtcbiAgICAgICAgLy8gSW4gY2FzZSB5b3UgbmVlZCB0aGUgcmF3IHJlc3VsdHMgaW1tZWRpYXRlbHksIHdpdGhvdXQgYXdhaXRpbmdcbiAgICAgICAgLy8gUHJvbWlzZS5hbGwocmVzdWx0cyk6XG4gICAgICAgIHJlc3VsdC5xdWVyaWVzID0gcXVlcmllcztcbiAgICAgICAgcmVzdWx0LnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICAvLyBJZiB5b3UgZGVjaWRlIHRvIGlnbm9yZSB0aGUgcmVzdWx0IFByb21pc2UgYmVjYXVzZSB5b3UncmUgdXNpbmdcbiAgICAgICAgLy8gcmVzdWx0LnF1ZXJpZXMgYW5kIHJlc3VsdC5yZXN1bHRzIGluc3RlYWQsIHlvdSBzaG91bGRuJ3QgaGF2ZSB0byB3b3JyeVxuICAgICAgICAvLyBhYm91dCBwcmV2ZW50aW5nIHVuY2F1Z2h0IHJlamVjdGlvbnMgZm9yIHRoZSBQcm9taXNlLmFsbCByZXN1bHQuXG4gICAgICAgIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmRlYnVnKDE3LCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjdXJyZW50bHkgYWN0aXZlIGBPYnNlcnZhYmxlUXVlcnlgIG9iamVjdHMsIGluIGEgYE1hcGAga2V5ZWQgYnlcbiAgICAgKiBxdWVyeSBJRCBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQW4gXCJhY3RpdmVcIiBxdWVyeSBpcyBvbmUgdGhhdCBoYXMgb2JzZXJ2ZXJzIGFuZCBhIGBmZXRjaFBvbGljeWAgb3RoZXIgdGhhblxuICAgICAqIFwic3RhbmRieVwiIG9yIFwiY2FjaGUtb25seVwiLlxuICAgICAqXG4gICAgICogWW91IGNhbiBpbmNsdWRlIGFsbCBgT2JzZXJ2YWJsZVF1ZXJ5YCBvYmplY3RzIChpbmNsdWRpbmcgdGhlIGluYWN0aXZlIG9uZXMpXG4gICAgICogYnkgcGFzc2luZyBcImFsbFwiIGluc3RlYWQgb2YgXCJhY3RpdmVcIiwgb3IgeW91IGNhbiBpbmNsdWRlIGp1c3QgYSBzdWJzZXQgb2ZcbiAgICAgKiBhY3RpdmUgcXVlcmllcyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHF1ZXJ5IG5hbWVzIG9yIERvY3VtZW50Tm9kZSBvYmplY3RzLlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuZ2V0T2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZSkge1xuICAgICAgICBpZiAoaW5jbHVkZSA9PT0gdm9pZCAwKSB7IGluY2x1ZGUgPSBcImFjdGl2ZVwiOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgdGhlIGNhY2hlJ3MgY29tcGxldGUgc3RhdGUsIGluIGEgc2VyaWFsaXphYmxlIGZvcm1hdCBmb3IgbGF0ZXIgcmVzdG9yYXRpb24uXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZXh0cmFjdChvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGV4aXN0aW5nIHN0YXRlIGluIHRoZSBjYWNoZSAoaWYgYW55KSB3aXRoIHRoZSB2YWx1ZXMgZXhwcmVzc2VkIGJ5XG4gICAgICogYHNlcmlhbGl6ZWRTdGF0ZWAuXG4gICAgICpcbiAgICAgKiBDYWxsZWQgd2hlbiBoeWRyYXRpbmcgYSBjYWNoZSAoc2VydmVyIHNpZGUgcmVuZGVyaW5nLCBvciBvZmZsaW5lIHN0b3JhZ2UpLFxuICAgICAqIGFuZCBhbHNvIChwb3RlbnRpYWxseSkgZHVyaW5nIGhvdCByZWxvYWRzLlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVzdG9yZShzZXJpYWxpemVkU3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgbG9jYWwgcmVzb2x2ZXJzLlxuICAgICAqL1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuYWRkUmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUmVzb2x2ZXJzKHJlc29sdmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgKG92ZXJyaWRlIGV4aXN0aW5nKSBsb2NhbCByZXNvbHZlcnMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zZXRSZXNvbHZlcnMgPSBmdW5jdGlvbiAocmVzb2x2ZXJzKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5zZXRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVnaXN0ZXJlZCBsb2NhbCByZXNvbHZlcnMuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5nZXRSZXNvbHZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuZ2V0UmVzb2x2ZXJzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gbG9jYWwgc3RhdGUgZnJhZ21lbnQgbWF0Y2hlci5cbiAgICAgKi9cbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnNldExvY2FsU3RhdGVGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5zZXRGcmFnbWVudE1hdGNoZXIoZnJhZ21lbnRNYXRjaGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZSBhIG5ldyBBcG9sbG9MaW5rIChvciBsaW5rIGNoYWluKSB0aGF0IEFwb2xsbyBDbGllbnQgd2lsbCB1c2UuXG4gICAgICovXG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zZXRMaW5rID0gZnVuY3Rpb24gKG5ld0xpbmspIHtcbiAgICAgICAgdGhpcy5saW5rID0gdGhpcy5xdWVyeU1hbmFnZXIubGluayA9IG5ld0xpbms7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBvbGxvQ2xpZW50LnByb3RvdHlwZSwgXCJkZWZhdWx0Q29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLmRlZmF1bHRDb250ZXh0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEFwb2xsb0NsaWVudDtcbn0oKSk7XG5leHBvcnQgeyBBcG9sbG9DbGllbnQgfTtcbmlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlKSB7XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5nZXRNZW1vcnlJbnRlcm5hbHMgPSBnZXRBcG9sbG9DbGllbnRNZW1vcnlJbnRlcm5hbHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcG9sbG9DbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiaW52YXJpYW50IiwibmV3SW52YXJpYW50RXJyb3IiLCJBcG9sbG9MaW5rIiwiZXhlY3V0ZSIsInZlcnNpb24iLCJIdHRwTGluayIsIlF1ZXJ5TWFuYWdlciIsIkxvY2FsU3RhdGUiLCJoYXNTdWdnZXN0ZWREZXZ0b29scyIsIm1lcmdlT3B0aW9ucyIsImdldEFwb2xsb0NsaWVudE1lbW9yeUludGVybmFscyIsIkFwb2xsb0NsaWVudCIsIm9wdGlvbnMiLCJfdGhpcyIsIl9hIiwicmVzZXRTdG9yZUNhbGxiYWNrcyIsImNsZWFyU3RvcmVDYWxsYmFja3MiLCJjYWNoZSIsInVyaSIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImRvY3VtZW50VHJhbnNmb3JtIiwiX2IiLCJzc3JNb2RlIiwiX2MiLCJzc3JGb3JjZUZldGNoRGVsYXkiLCJjb25uZWN0VG9EZXZUb29scyIsIl9kIiwicXVlcnlEZWR1cGxpY2F0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJkZWZhdWx0Q29udGV4dCIsIl9lIiwiYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyIsInJlc29sdmVycyIsInR5cGVEZWZzIiwiZnJhZ21lbnRNYXRjaGVyIiwiY2xpZW50QXdhcmVuZXNzTmFtZSIsIm5hbWUiLCJjbGllbnRBd2FyZW5lc3NWZXJzaW9uIiwiZGV2dG9vbHMiLCJsaW5rIiwiZW1wdHkiLCJkaXNhYmxlTmV0d29ya0ZldGNoZXMiLCJPYmplY3QiLCJjcmVhdGUiLCJkZXZ0b29sc0NvbmZpZyIsImVuYWJsZWQiLCJ1bmRlZmluZWQiLCJnbG9iYWxUaGlzIiwiX19ERVZfXyIsInNldFRpbWVvdXQiLCJ3YXRjaFF1ZXJ5IiwiYmluZCIsInF1ZXJ5IiwibXV0YXRlIiwid2F0Y2hGcmFnbWVudCIsInJlc2V0U3RvcmUiLCJyZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMiLCJsb2NhbFN0YXRlIiwiY2xpZW50IiwicXVlcnlNYW5hZ2VyIiwiY2xpZW50QXdhcmVuZXNzIiwib25Ccm9hZGNhc3QiLCJkZXZUb29sc0hvb2tDYiIsImFjdGlvbiIsInN0YXRlIiwicXVlcmllcyIsImdldFF1ZXJ5U3RvcmUiLCJtdXRhdGlvbnMiLCJtdXRhdGlvblN0b3JlIiwiZGF0YVdpdGhPcHRpbWlzdGljUmVzdWx0cyIsImV4dHJhY3QiLCJwcm90b3R5cGUiLCJ3aW5kb3dXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJkZXZ0b29sc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsInB1c2giLCJfX0FQT0xMT19DTElFTlRfXyIsImRvY3VtZW50IiwidG9wIiwic2VsZiIsInRlc3QiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiX19BUE9MTE9fREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsIm5hdiIsIm5hdmlnYXRvciIsInVhIiwidXNlckFnZW50IiwidXJsIiwiaW5kZXhPZiIsImxvZyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInN0b3AiLCJmZXRjaFBvbGljeSIsInN1YnNjcmliZSIsInN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbiIsInJlYWRRdWVyeSIsIm9wdGltaXN0aWMiLCJyZWFkRnJhZ21lbnQiLCJ3cml0ZVF1ZXJ5IiwicmVmIiwiYnJvYWRjYXN0IiwiYnJvYWRjYXN0UXVlcmllcyIsIndyaXRlRnJhZ21lbnQiLCJfX2FjdGlvbkhvb2tGb3JEZXZUb29scyIsImNiIiwiX19yZXF1ZXN0UmF3IiwicGF5bG9hZCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNsZWFyU3RvcmUiLCJkaXNjYXJkV2F0Y2hlcyIsImFsbCIsIm1hcCIsImZuIiwib25SZXNldFN0b3JlIiwiZmlsdGVyIiwiYyIsIm9uQ2xlYXJTdG9yZSIsImluY2x1ZGVTdGFuZGJ5IiwicmVmZXRjaFF1ZXJpZXMiLCJyZXN1bHRzIiwiZm9yRWFjaCIsInJlc3VsdCIsIm9ic1F1ZXJ5IiwiY2F0Y2giLCJlcnJvciIsImRlYnVnIiwiZ2V0T2JzZXJ2YWJsZVF1ZXJpZXMiLCJpbmNsdWRlIiwicmVzdG9yZSIsInNlcmlhbGl6ZWRTdGF0ZSIsImFkZFJlc29sdmVycyIsInNldFJlc29sdmVycyIsImdldFJlc29sdmVycyIsInNldExvY2FsU3RhdGVGcmFnbWVudE1hdGNoZXIiLCJzZXRGcmFnbWVudE1hdGNoZXIiLCJzZXRMaW5rIiwibmV3TGluayIsImdldE1lbW9yeUludGVybmFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/ApolloClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/LocalState.js":
/*!********************************************************!*\
  !*** ./node_modules/@apollo/client/core/LocalState.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalState: function() { return /* binding */ LocalState; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/predicates.mjs\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _cache_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cache/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/cache/inmemory/reactiveVars.js\");\n\n\n\n\n\nvar LocalState = /** @class */ function() {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.selectionsToResolveCache = new WeakMap();\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function(resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function(resolverGroup) {\n                _this.resolvers = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(_this.resolvers, resolverGroup);\n            });\n        } else {\n            this.resolvers = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function(resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function() {\n        return this.resolvers || {};\n    };\n    // Run local client resolvers against the incoming query and remote data.\n    // Locally resolved field values are merged with the incoming remote data,\n    // and returned. Note that locally resolved fields will overwrite\n    // remote data using the same field name.\n    LocalState.prototype.runResolvers = function(_a) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function(_b) {\n            var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_d) {\n                if (document) {\n                    return [\n                        2 /*return*/ ,\n                        this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {\n                            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, remoteResult), {\n                                data: localResult.result\n                            });\n                        })\n                    ];\n                }\n                return [\n                    2 /*return*/ ,\n                    remoteResult\n                ];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function(fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function() {\n        return this.fragmentMatcher;\n    };\n    // Client queries contain everything in the incoming document (if a @client\n    // directive is found).\n    LocalState.prototype.clientQuery = function(document) {\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.hasDirectives)([\n            \"client\"\n        ], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n        }\n        return null;\n    };\n    // Server queries are stripped of all @client based selection sets.\n    LocalState.prototype.serverQuery = function(document) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.removeClientSetsFromDocument)(document);\n    };\n    LocalState.prototype.prepareContext = function(context) {\n        var cache = this.cache;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), {\n            cache: cache,\n            // Getting an entry's cache key is useful for local state resolvers.\n            getCacheKey: function(obj) {\n                return cache.identify(obj);\n            }\n        });\n    };\n    // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n    // @client @export fields locally, then pass the resolved values back to be\n    // used alongside the original operation variables.\n    LocalState.prototype.addExportedVariables = function(document_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function(document, variables, context) {\n            if (variables === void 0) {\n                variables = {};\n            }\n            if (context === void 0) {\n                context = {};\n            }\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_a) {\n                if (document) {\n                    return [\n                        2 /*return*/ ,\n                        this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {\n                            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, variables), data.exportedVariables);\n                        })\n                    ];\n                }\n                return [\n                    2 /*return*/ ,\n                    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, variables)\n                ];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function(document) {\n        var forceResolvers = false;\n        (0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(document, {\n            Directive: {\n                enter: function(node) {\n                    if (node.name.value === \"client\" && node.arguments) {\n                        forceResolvers = node.arguments.some(function(arg) {\n                            return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return graphql__WEBPACK_IMPORTED_MODULE_5__.BREAK;\n                        }\n                    }\n                }\n            }\n        });\n        return forceResolvers;\n    };\n    // Query the cache and return matching data.\n    LocalState.prototype.buildRootValueFromCache = function(document, variables) {\n        return this.cache.diff({\n            query: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.buildQueryFromSelectionSet)(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function(document_1, rootValue_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n            if (context === void 0) {\n                context = {};\n            }\n            if (variables === void 0) {\n                variables = {};\n            }\n            if (fragmentMatcher === void 0) {\n                fragmentMatcher = function() {\n                    return true;\n                };\n            }\n            if (onlyRunForcedResolvers === void 0) {\n                onlyRunForcedResolvers = false;\n            }\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_b) {\n                mainDefinition = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.getMainDefinition)(document);\n                fragments = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.getFragmentDefinitions)(document);\n                fragmentMap = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.createFragmentMap)(fragments);\n                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n                definitionOperation = mainDefinition.operation;\n                defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), {\n                        cache: cache,\n                        client: client\n                    }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    selectionsToResolve: selectionsToResolve,\n                    onlyRunForcedResolvers: onlyRunForcedResolvers\n                };\n                isClientFieldDescendant = false;\n                return [\n                    2 /*return*/ ,\n                    this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {\n                        return {\n                            result: result,\n                            exportedVariables: execContext.exportedVariables\n                        };\n                    })\n                ];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function() {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [\n                    rootValue\n                ];\n                execute = function(selection) {\n                    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function() {\n                        var fragment, typeCondition;\n                        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_a) {\n                            if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                                // Skip selections without @client directives\n                                // (still processing if one of the ancestors or one of the child fields has @client directive)\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                            if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.shouldInclude)(selection, variables)) {\n                                // Skip this entirely.\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.isField)(selection)) {\n                                return [\n                                    2 /*return*/ ,\n                                    this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {\n                                        var _a;\n                                        if (typeof fieldResult !== \"undefined\") {\n                                            resultsToMerge.push((_a = {}, _a[(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.resultKeyNameFromField)(selection)] = fieldResult, _a));\n                                        }\n                                    })\n                                ];\n                            }\n                            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.isInlineFragment)(selection)) {\n                                fragment = selection;\n                            } else {\n                                // This is a named fragment.\n                                fragment = fragmentMap[selection.name.value];\n                                (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragment, 18, selection.name.value);\n                            }\n                            if (fragment && fragment.typeCondition) {\n                                typeCondition = fragment.typeCondition.name.value;\n                                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                    return [\n                                        2 /*return*/ ,\n                                        this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {\n                                            resultsToMerge.push(fragmentResult);\n                                        })\n                                    ];\n                                }\n                            }\n                            return [\n                                2 /*return*/ \n                            ];\n                        });\n                    });\n                };\n                return [\n                    2 /*return*/ ,\n                    Promise.all(selectionSet.selections.map(execute)).then(function() {\n                        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeepArray)(resultsToMerge);\n                    })\n                ];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function() {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_a) {\n                if (!rootValue) {\n                    return [\n                        2 /*return*/ ,\n                        null\n                    ];\n                }\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.resultKeyNameFromField)(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                // Usually all local resolvers are run when passing through here, but\n                // if we've specifically identified that we only want to run forced\n                // resolvers (that is, resolvers for fields marked with\n                // `@client(always: true)`), then we'll skip running non-forced resolvers.\n                if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(// In case the resolve function accesses reactive variables,\n                            // set cacheSlot to the current cache instance.\n                            _cache_index_js__WEBPACK_IMPORTED_MODULE_9__.cacheSlot.withValue(this.cache, resolve, [\n                                rootValue,\n                                (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.argumentsObjectFromField)(field, variables),\n                                execContext.context,\n                                {\n                                    field: field,\n                                    fragmentMap: execContext.fragmentMap\n                                }\n                            ]));\n                        }\n                    }\n                }\n                return [\n                    2 /*return*/ ,\n                    resultPromise.then(function(result) {\n                        var _a, _b;\n                        if (result === void 0) {\n                            result = defaultResult;\n                        }\n                        // If an @export directive is associated with the current field, store\n                        // the `as` export variable name and current result for later use.\n                        if (field.directives) {\n                            field.directives.forEach(function(directive) {\n                                if (directive.name.value === \"export\" && directive.arguments) {\n                                    directive.arguments.forEach(function(arg) {\n                                        if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        // Handle all scalar types here.\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        // From here down, the field has a selection set, which means it's trying\n                        // to query a GraphQLObjectType.\n                        if (result == null) {\n                            // Basically any field in a GraphQL response can be null, or missing\n                            return result;\n                        }\n                        var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function(d) {\n                            return d.name.value === \"client\";\n                        })) !== null && _b !== void 0 ? _b : false;\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                        // Returned value is an object, and the query has a sub-selection. Recurse.\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                    })\n                ];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function(item) {\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse.\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n            }\n            // This is an object, run the selection set on it.\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n            }\n        }));\n    };\n    // Collect selection nodes on paths from document root down to all @client directives.\n    // This function takes into account transitive fragment spreads.\n    // Complexity equals to a single `visit` over the full document.\n    LocalState.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {\n        var isSingleASTNode = function(node) {\n            return !Array.isArray(node);\n        };\n        var selectionsToResolveCache = this.selectionsToResolveCache;\n        function collectByDefinition(definitionNode) {\n            if (!selectionsToResolveCache.has(definitionNode)) {\n                var matches_1 = new Set();\n                selectionsToResolveCache.set(definitionNode, matches_1);\n                (0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(definitionNode, {\n                    Directive: function(node, _, __, ___, ancestors) {\n                        if (node.name.value === \"client\") {\n                            ancestors.forEach(function(node) {\n                                if (isSingleASTNode(node) && (0,graphql__WEBPACK_IMPORTED_MODULE_10__.isSelectionNode)(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                        }\n                    },\n                    FragmentSpread: function(spread, _, __, ___, ancestors) {\n                        var fragment = fragmentMap[spread.name.value];\n                        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragment, 19, spread.name.value);\n                        var fragmentSelections = collectByDefinition(fragment);\n                        if (fragmentSelections.size > 0) {\n                            // Fragment for this spread contains @client directive (either directly or transitively)\n                            // Collect selection nodes on paths from the root down to fields with the @client directive\n                            ancestors.forEach(function(node) {\n                                if (isSingleASTNode(node) && (0,graphql__WEBPACK_IMPORTED_MODULE_10__.isSelectionNode)(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                            matches_1.add(spread);\n                            fragmentSelections.forEach(function(selection) {\n                                matches_1.add(selection);\n                            });\n                        }\n                    }\n                });\n            }\n            return selectionsToResolveCache.get(definitionNode);\n        }\n        return collectByDefinition(mainDefinition);\n    };\n    return LocalState;\n}();\n //# sourceMappingURL=LocalState.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL0xvY2FsU3RhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0M7QUFDRjtBQUM4TztBQUN4UDtBQUM5QyxJQUFJcUIsYUFBYSxXQUFXLEdBQUk7SUFDNUIsU0FBU0EsV0FBV0MsRUFBRTtRQUNsQixJQUFJQyxRQUFRRCxHQUFHQyxLQUFLLEVBQUVDLFNBQVNGLEdBQUdFLE1BQU0sRUFBRUMsWUFBWUgsR0FBR0csU0FBUyxFQUFFQyxrQkFBa0JKLEdBQUdJLGVBQWU7UUFDeEcsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRyxJQUFJQztRQUNwQyxJQUFJLENBQUNMLEtBQUssR0FBR0E7UUFDYixJQUFJQyxRQUFRO1lBQ1IsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2xCO1FBQ0EsSUFBSUMsV0FBVztZQUNYLElBQUksQ0FBQ0ksWUFBWSxDQUFDSjtRQUN0QjtRQUNBLElBQUlDLGlCQUFpQjtZQUNqQixJQUFJLENBQUNJLGtCQUFrQixDQUFDSjtRQUM1QjtJQUNKO0lBQ0FMLFdBQVdVLFNBQVMsQ0FBQ0YsWUFBWSxHQUFHLFNBQVVKLFNBQVM7UUFDbkQsSUFBSU8sUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ1AsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxJQUFJLENBQUM7UUFDcEMsSUFBSVEsTUFBTUMsT0FBTyxDQUFDVCxZQUFZO1lBQzFCQSxVQUFVVSxPQUFPLENBQUMsU0FBVUMsYUFBYTtnQkFDckNKLE1BQU1QLFNBQVMsR0FBR1YsOERBQVNBLENBQUNpQixNQUFNUCxTQUFTLEVBQUVXO1lBQ2pEO1FBQ0osT0FDSztZQUNELElBQUksQ0FBQ1gsU0FBUyxHQUFHViw4REFBU0EsQ0FBQyxJQUFJLENBQUNVLFNBQVMsRUFBRUE7UUFDL0M7SUFDSjtJQUNBSixXQUFXVSxTQUFTLENBQUNNLFlBQVksR0FBRyxTQUFVWixTQUFTO1FBQ25ELElB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S0FBS0MsSUFBSSxDQUFDQyxLQUFLLEtBQUssVUFBVTs0QkFDOUJpRSxVQUFVckcsT0FBTyxDQUFDLFNBQVVrQyxJQUFJO2dDQUM1QixJQUFJMEQsZ0JBQWdCMUQsU0FBUy9ELHlEQUFlQSxDQUFDK0QsT0FBTztvQ0FDaEQ2RCxVQUFVTyxHQUFHLENBQUNwRTtnQ0FDbEI7NEJBQ0o7d0JBQ0o7b0JBQ0o7b0JBQ0FxRSxnQkFBZ0IsU0FBVUMsTUFBTSxFQUFFTixDQUFDLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxTQUFTO3dCQUNuRCxJQUFJckMsV0FBV2hCLFdBQVcsQ0FBQ3dELE9BQU9yRSxJQUFJLENBQUNDLEtBQUssQ0FBQzt3QkFDN0NwRSxzRUFBU0EsQ0FBQ2dHLFVBQVUsSUFBSXdDLE9BQU9yRSxJQUFJLENBQUNDLEtBQUs7d0JBQ3pDLElBQUlxRSxxQkFBcUJaLG9CQUFvQjdCO3dCQUM3QyxJQUFJeUMsbUJBQW1CQyxJQUFJLEdBQUcsR0FBRzs0QkFDN0Isd0ZBQXdGOzRCQUN4RiwyRkFBMkY7NEJBQzNGTCxVQUFVckcsT0FBTyxDQUFDLFNBQVVrQyxJQUFJO2dDQUM1QixJQUFJMEQsZ0JBQWdCMUQsU0FBUy9ELHlEQUFlQSxDQUFDK0QsT0FBTztvQ0FDaEQ2RCxVQUFVTyxHQUFHLENBQUNwRTtnQ0FDbEI7NEJBQ0o7NEJBQ0E2RCxVQUFVTyxHQUFHLENBQUNFOzRCQUNkQyxtQkFBbUJ6RyxPQUFPLENBQUMsU0FBVStELFNBQVM7Z0NBQzFDZ0MsVUFBVU8sR0FBRyxDQUFDdkM7NEJBQ2xCO3dCQUNKO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxPQUFPdkUseUJBQXlCbUgsR0FBRyxDQUFDYjtRQUN4QztRQUNBLE9BQU9ELG9CQUFvQi9DO0lBQy9CO0lBQ0EsT0FBTzVEO0FBQ1g7QUFDc0IsQ0FDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL0xvY2FsU3RhdGUuanM/YTcyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9nbG9iYWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2aXNpdCwgQlJFQUssIGlzU2VsZWN0aW9uTm9kZSB9IGZyb20gXCJncmFwaHFsXCI7XG5pbXBvcnQgeyBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQsIGJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0LCBjcmVhdGVGcmFnbWVudE1hcCwgZ2V0RnJhZ21lbnREZWZpbml0aW9ucywgZ2V0TWFpbkRlZmluaXRpb24sIGhhc0RpcmVjdGl2ZXMsIGlzRmllbGQsIGlzSW5saW5lRnJhZ21lbnQsIG1lcmdlRGVlcCwgbWVyZ2VEZWVwQXJyYXksIHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQsIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIHNob3VsZEluY2x1ZGUsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY2FjaGVTbG90IH0gZnJvbSBcIi4uL2NhY2hlL2luZGV4LmpzXCI7XG52YXIgTG9jYWxTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbFN0YXRlKF9hKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IF9hLmNhY2hlLCBjbGllbnQgPSBfYS5jbGllbnQsIHJlc29sdmVycyA9IF9hLnJlc29sdmVycywgZnJhZ21lbnRNYXRjaGVyID0gX2EuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNUb1Jlc29sdmVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVycykge1xuICAgICAgICAgICAgdGhpcy5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmFkZFJlc29sdmVycyA9IGZ1bmN0aW9uIChyZXNvbHZlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSB0aGlzLnJlc29sdmVycyB8fCB7fTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZXJzKSkge1xuICAgICAgICAgICAgcmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlcnMgPSBtZXJnZURlZXAoX3RoaXMucmVzb2x2ZXJzLCByZXNvbHZlckdyb3VwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSBtZXJnZURlZXAodGhpcy5yZXNvbHZlcnMsIHJlc29sdmVycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnNldFJlc29sdmVycyA9IGZ1bmN0aW9uIChyZXNvbHZlcnMpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmdldFJlc29sdmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJzIHx8IHt9O1xuICAgIH07XG4gICAgLy8gUnVuIGxvY2FsIGNsaWVudCByZXNvbHZlcnMgYWdhaW5zdCB0aGUgaW5jb21pbmcgcXVlcnkgYW5kIHJlbW90ZSBkYXRhLlxuICAgIC8vIExvY2FsbHkgcmVzb2x2ZWQgZmllbGQgdmFsdWVzIGFyZSBtZXJnZWQgd2l0aCB0aGUgaW5jb21pbmcgcmVtb3RlIGRhdGEsXG4gICAgLy8gYW5kIHJldHVybmVkLiBOb3RlIHRoYXQgbG9jYWxseSByZXNvbHZlZCBmaWVsZHMgd2lsbCBvdmVyd3JpdGVcbiAgICAvLyByZW1vdGUgZGF0YSB1c2luZyB0aGUgc2FtZSBmaWVsZCBuYW1lLlxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnJ1blJlc29sdmVycyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCA9IF9iLmRvY3VtZW50LCByZW1vdGVSZXN1bHQgPSBfYi5yZW1vdGVSZXN1bHQsIGNvbnRleHQgPSBfYi5jb250ZXh0LCB2YXJpYWJsZXMgPSBfYi52YXJpYWJsZXMsIF9jID0gX2Iub25seVJ1bkZvcmNlZFJlc29sdmVycywgb25seVJ1bkZvcmNlZFJlc29sdmVycyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXNvbHZlRG9jdW1lbnQoZG9jdW1lbnQsIHJlbW90ZVJlc3VsdC5kYXRhLCBjb250ZXh0LCB2YXJpYWJsZXMsIHRoaXMuZnJhZ21lbnRNYXRjaGVyLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzKS50aGVuKGZ1bmN0aW9uIChsb2NhbFJlc3VsdCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZW1vdGVSZXN1bHQpLCB7IGRhdGE6IGxvY2FsUmVzdWx0LnJlc3VsdCB9KSk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlbW90ZVJlc3VsdF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXRGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRNYXRjaGVyID0gZnJhZ21lbnRNYXRjaGVyO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0RnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudE1hdGNoZXI7XG4gICAgfTtcbiAgICAvLyBDbGllbnQgcXVlcmllcyBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdGhlIGluY29taW5nIGRvY3VtZW50IChpZiBhIEBjbGllbnRcbiAgICAvLyBkaXJlY3RpdmUgaXMgZm91bmQpLlxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmNsaWVudFF1ZXJ5ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChoYXNEaXJlY3RpdmVzKFtcImNsaWVudFwiXSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBTZXJ2ZXIgcXVlcmllcyBhcmUgc3RyaXBwZWQgb2YgYWxsIEBjbGllbnQgYmFzZWQgc2VsZWN0aW9uIHNldHMuXG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2VydmVyUXVlcnkgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucHJlcGFyZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgXG4gICAgICAgICAgICAvLyBHZXR0aW5nIGFuIGVudHJ5J3MgY2FjaGUga2V5IGlzIHVzZWZ1bCBmb3IgbG9jYWwgc3RhdGUgcmVzb2x2ZXJzLlxuICAgICAgICAgICAgZ2V0Q2FjaGVLZXk6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuaWRlbnRpZnkob2JqKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfTtcbiAgICAvLyBUbyBzdXBwb3J0IGBAY2xpZW50IEBleHBvcnQoYXM6IFwic29tZVZhclwiKWAgc3ludGF4LCB3ZSdsbCBmaXJzdCByZXNvbHZlXG4gICAgLy8gQGNsaWVudCBAZXhwb3J0IGZpZWxkcyBsb2NhbGx5LCB0aGVuIHBhc3MgdGhlIHJlc29sdmVkIHZhbHVlcyBiYWNrIHRvIGJlXG4gICAgLy8gdXNlZCBhbG9uZ3NpZGUgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbiB2YXJpYWJsZXMuXG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnRfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoZG9jdW1lbnQsIHZhcmlhYmxlcywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlcyA9PT0gdm9pZCAwKSB7IHZhcmlhYmxlcyA9IHt9OyB9XG4gICAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXNvbHZlRG9jdW1lbnQoZG9jdW1lbnQsIHRoaXMuYnVpbGRSb290VmFsdWVGcm9tQ2FjaGUoZG9jdW1lbnQsIHZhcmlhYmxlcykgfHwge30sIHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCksIHZhcmlhYmxlcykudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YXJpYWJsZXMpLCBkYXRhLmV4cG9ydGVkVmFyaWFibGVzKSk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKHt9LCB2YXJpYWJsZXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnNob3VsZEZvcmNlUmVzb2x2ZXJzID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBmb3JjZVJlc29sdmVycyA9IGZhbHNlO1xuICAgICAgICB2aXNpdChkb2N1bWVudCwge1xuICAgICAgICAgICAgRGlyZWN0aXZlOiB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUudmFsdWUgPT09IFwiY2xpZW50XCIgJiYgbm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVzb2x2ZXJzID0gbm9kZS5hcmd1bWVudHMuc29tZShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5uYW1lLnZhbHVlID09PSBcImFsd2F5c1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy52YWx1ZS5raW5kID09PSBcIkJvb2xlYW5WYWx1ZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy52YWx1ZS52YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9yY2VSZXNvbHZlcnM7XG4gICAgfTtcbiAgICAvLyBRdWVyeSB0aGUgY2FjaGUgYW5kIHJldHVybiBtYXRjaGluZyBkYXRhLlxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQoZG9jdW1lbnQpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICB9KS5yZXN1bHQ7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnRfMSwgcm9vdFZhbHVlXzEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGRvY3VtZW50LCByb290VmFsdWUsIGNvbnRleHQsIHZhcmlhYmxlcywgZnJhZ21lbnRNYXRjaGVyLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbWFpbkRlZmluaXRpb24sIGZyYWdtZW50cywgZnJhZ21lbnRNYXAsIHNlbGVjdGlvbnNUb1Jlc29sdmUsIGRlZmluaXRpb25PcGVyYXRpb24sIGRlZmF1bHRPcGVyYXRpb25UeXBlLCBfYSwgY2FjaGUsIGNsaWVudCwgZXhlY0NvbnRleHQsIGlzQ2xpZW50RmllbGREZXNjZW5kYW50O1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKGZyYWdtZW50TWF0Y2hlciA9PT0gdm9pZCAwKSB7IGZyYWdtZW50TWF0Y2hlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07IH1cbiAgICAgICAgICAgIGlmIChvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID09PSB2b2lkIDApIHsgb25seVJ1bkZvcmNlZFJlc29sdmVycyA9IGZhbHNlOyB9XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgbWFpbkRlZmluaXRpb24gPSBnZXRNYWluRGVmaW5pdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRzID0gZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRNYXAgPSBjcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnNUb1Jlc29sdmUgPSB0aGlzLmNvbGxlY3RTZWxlY3Rpb25zVG9SZXNvbHZlKG1haW5EZWZpbml0aW9uLCBmcmFnbWVudE1hcCk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbk9wZXJhdGlvbiA9IG1haW5EZWZpbml0aW9uLm9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3BlcmF0aW9uVHlwZSA9IGRlZmluaXRpb25PcGVyYXRpb24gP1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uT3BlcmF0aW9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25PcGVyYXRpb24uc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgOiBcIlF1ZXJ5XCI7XG4gICAgICAgICAgICAgICAgX2EgPSB0aGlzLCBjYWNoZSA9IF9hLmNhY2hlLCBjbGllbnQgPSBfYS5jbGllbnQ7XG4gICAgICAgICAgICAgICAgZXhlY0NvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBmcmFnbWVudE1hcCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGU6IGRlZmF1bHRPcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnNUb1Jlc29sdmU6IHNlbGVjdGlvbnNUb1Jlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpc0NsaWVudEZpZWxkRGVzY2VuZGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQobWFpbkRlZmluaXRpb24uc2VsZWN0aW9uU2V0LCBpc0NsaWVudEZpZWxkRGVzY2VuZGFudCwgcm9vdFZhbHVlLCBleGVjQ29udGV4dCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczogZXhlY0NvbnRleHQuZXhwb3J0ZWRWYXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlU2VsZWN0aW9uU2V0ID0gZnVuY3Rpb24gKHNlbGVjdGlvblNldCwgaXNDbGllbnRGaWVsZERlc2NlbmRhbnQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50TWFwLCBjb250ZXh0LCB2YXJpYWJsZXMsIHJlc3VsdHNUb01lcmdlLCBleGVjdXRlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwLCBjb250ZXh0ID0gZXhlY0NvbnRleHQuY29udGV4dCwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlID0gW3Jvb3RWYWx1ZV07XG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50LCB0eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2xpZW50RmllbGREZXNjZW5kYW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWV4ZWNDb250ZXh0LnNlbGVjdGlvbnNUb1Jlc29sdmUuaGFzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNlbGVjdGlvbnMgd2l0aG91dCBAY2xpZW50IGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoc3RpbGwgcHJvY2Vzc2luZyBpZiBvbmUgb2YgdGhlIGFuY2VzdG9ycyBvciBvbmUgb2YgdGhlIGNoaWxkIGZpZWxkcyBoYXMgQGNsaWVudCBkaXJlY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgdGhpcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucmVzb2x2ZUZpZWxkKHNlbGVjdGlvbiwgaXNDbGllbnRGaWVsZERlc2NlbmRhbnQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZpZWxkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkUmVzdWx0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaCgoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXSA9IGZpZWxkUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmFtZWQgZnJhZ21lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudE1hcFtzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50KGZyYWdtZW50LCAxOCwgc2VsZWN0aW9uLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlQ29uZGl0aW9uID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbi5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIocm9vdFZhbHVlLCB0eXBlQ29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXNvbHZlU2VsZWN0aW9uU2V0KGZyYWdtZW50LnNlbGVjdGlvblNldCwgaXNDbGllbnRGaWVsZERlc2NlbmRhbnQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaChmcmFnbWVudFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5hbGwoc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMubWFwKGV4ZWN1dGUpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURlZXBBcnJheShyZXN1bHRzVG9NZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnJlc29sdmVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgaXNDbGllbnRGaWVsZERlc2NlbmRhbnQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhcmlhYmxlcywgZmllbGROYW1lLCBhbGlhc2VkRmllbGROYW1lLCBhbGlhc1VzZWQsIGRlZmF1bHRSZXN1bHQsIHJlc3VsdFByb21pc2UsIHJlc29sdmVyVHlwZSwgcmVzb2x2ZXJNYXAsIHJlc29sdmU7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghcm9vdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZEZpZWxkTmFtZSA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQoZmllbGQpO1xuICAgICAgICAgICAgICAgIGFsaWFzVXNlZCA9IGZpZWxkTmFtZSAhPT0gYWxpYXNlZEZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gcm9vdFZhbHVlW2FsaWFzZWRGaWVsZE5hbWVdIHx8IHJvb3RWYWx1ZVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZGVmYXVsdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgLy8gVXN1YWxseSBhbGwgbG9jYWwgcmVzb2x2ZXJzIGFyZSBydW4gd2hlbiBwYXNzaW5nIHRocm91Z2ggaGVyZSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UndmUgc3BlY2lmaWNhbGx5IGlkZW50aWZpZWQgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gcnVuIGZvcmNlZFxuICAgICAgICAgICAgICAgIC8vIHJlc29sdmVycyAodGhhdCBpcywgcmVzb2x2ZXJzIGZvciBmaWVsZHMgbWFya2VkIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBgQGNsaWVudChhbHdheXM6IHRydWUpYCksIHRoZW4gd2UnbGwgc2tpcCBydW5uaW5nIG5vbi1mb3JjZWQgcmVzb2x2ZXJzLlxuICAgICAgICAgICAgICAgIGlmICghZXhlY0NvbnRleHQub25seVJ1bkZvcmNlZFJlc29sdmVycyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEZvcmNlUmVzb2x2ZXJzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlclR5cGUgPSByb290VmFsdWUuX190eXBlbmFtZSB8fCBleGVjQ29udGV4dC5kZWZhdWx0T3BlcmF0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJNYXAgPSB0aGlzLnJlc29sdmVycyAmJiB0aGlzLnJlc29sdmVyc1tyZXNvbHZlclR5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXNvbHZlck1hcFthbGlhc1VzZWQgPyBmaWVsZE5hbWUgOiBhbGlhc2VkRmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSByZXNvbHZlIGZ1bmN0aW9uIGFjY2Vzc2VzIHJlYWN0aXZlIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FjaGVTbG90IHRvIHRoZSBjdXJyZW50IGNhY2hlIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlU2xvdC53aXRoVmFsdWUodGhpcy5jYWNoZSwgcmVzb2x2ZSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogZmllbGQsIGZyYWdtZW50TWFwOiBleGVjQ29udGV4dC5mcmFnbWVudE1hcCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gZGVmYXVsdFJlc3VsdDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gQGV4cG9ydCBkaXJlY3RpdmUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGZpZWxkLCBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGBhc2AgZXhwb3J0IHZhcmlhYmxlIG5hbWUgYW5kIGN1cnJlbnQgcmVzdWx0IGZvciBsYXRlciB1c2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gXCJleHBvcnRcIiAmJiBkaXJlY3RpdmUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcubmFtZS52YWx1ZSA9PT0gXCJhc1wiICYmIGFyZy52YWx1ZS5raW5kID09PSBcIlN0cmluZ1ZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQuZXhwb3J0ZWRWYXJpYWJsZXNbYXJnLnZhbHVlLnZhbHVlXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBzY2FsYXIgdHlwZXMgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gaGVyZSBkb3duLCB0aGUgZmllbGQgaGFzIGEgc2VsZWN0aW9uIHNldCwgd2hpY2ggbWVhbnMgaXQncyB0cnlpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHF1ZXJ5IGEgR3JhcGhRTE9iamVjdFR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNpY2FsbHkgYW55IGZpZWxkIGluIGEgR3JhcGhRTCByZXNwb25zZSBjYW4gYmUgbnVsbCwgb3IgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNDbGllbnRGaWVsZCA9IChfYiA9IChfYSA9IGZpZWxkLmRpcmVjdGl2ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUudmFsdWUgPT09IFwiY2xpZW50XCI7IH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkoZmllbGQsIGlzQ2xpZW50RmllbGREZXNjZW5kYW50IHx8IGlzQ2xpZW50RmllbGQsIHJlc3VsdCwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0LCBhbmQgdGhlIHF1ZXJ5IGhhcyBhIHN1Yi1zZWxlY3Rpb24uIFJlY3Vyc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQoZmllbGQuc2VsZWN0aW9uU2V0LCBpc0NsaWVudEZpZWxkRGVzY2VuZGFudCB8fCBpc0NsaWVudEZpZWxkLCByZXN1bHQsIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkgPSBmdW5jdGlvbiAoZmllbGQsIGlzQ2xpZW50RmllbGREZXNjZW5kYW50LCByZXN1bHQsIGV4ZWNDb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBhcnJheSwgcmVjdXJzZS5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTdWJTZWxlY3RlZEFycmF5KGZpZWxkLCBpc0NsaWVudEZpZWxkRGVzY2VuZGFudCwgaXRlbSwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBvYmplY3QsIHJ1biB0aGUgc2VsZWN0aW9uIHNldCBvbiBpdC5cbiAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmaWVsZC5zZWxlY3Rpb25TZXQsIGlzQ2xpZW50RmllbGREZXNjZW5kYW50LCBpdGVtLCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8vIENvbGxlY3Qgc2VsZWN0aW9uIG5vZGVzIG9uIHBhdGhzIGZyb20gZG9jdW1lbnQgcm9vdCBkb3duIHRvIGFsbCBAY2xpZW50IGRpcmVjdGl2ZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNpdGl2ZSBmcmFnbWVudCBzcHJlYWRzLlxuICAgIC8vIENvbXBsZXhpdHkgZXF1YWxzIHRvIGEgc2luZ2xlIGB2aXNpdGAgb3ZlciB0aGUgZnVsbCBkb2N1bWVudC5cbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5jb2xsZWN0U2VsZWN0aW9uc1RvUmVzb2x2ZSA9IGZ1bmN0aW9uIChtYWluRGVmaW5pdGlvbiwgZnJhZ21lbnRNYXApIHtcbiAgICAgICAgdmFyIGlzU2luZ2xlQVNUTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAhQXJyYXkuaXNBcnJheShub2RlKTsgfTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnNUb1Jlc29sdmVDYWNoZSA9IHRoaXMuc2VsZWN0aW9uc1RvUmVzb2x2ZUNhY2hlO1xuICAgICAgICBmdW5jdGlvbiBjb2xsZWN0QnlEZWZpbml0aW9uKGRlZmluaXRpb25Ob2RlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbnNUb1Jlc29sdmVDYWNoZS5oYXMoZGVmaW5pdGlvbk5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXNfMSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zVG9SZXNvbHZlQ2FjaGUuc2V0KGRlZmluaXRpb25Ob2RlLCBtYXRjaGVzXzEpO1xuICAgICAgICAgICAgICAgIHZpc2l0KGRlZmluaXRpb25Ob2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIERpcmVjdGl2ZTogZnVuY3Rpb24gKG5vZGUsIF8sIF9fLCBfX18sIGFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZS52YWx1ZSA9PT0gXCJjbGllbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NpbmdsZUFTVE5vZGUobm9kZSkgJiYgaXNTZWxlY3Rpb25Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzXzEuYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIEZyYWdtZW50U3ByZWFkOiBmdW5jdGlvbiAoc3ByZWFkLCBfLCBfXywgX19fLCBhbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGZyYWdtZW50TWFwW3NwcmVhZC5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudChmcmFnbWVudCwgMTksIHNwcmVhZC5uYW1lLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudFNlbGVjdGlvbnMgPSBjb2xsZWN0QnlEZWZpbml0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudFNlbGVjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGcmFnbWVudCBmb3IgdGhpcyBzcHJlYWQgY29udGFpbnMgQGNsaWVudCBkaXJlY3RpdmUgKGVpdGhlciBkaXJlY3RseSBvciB0cmFuc2l0aXZlbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBzZWxlY3Rpb24gbm9kZXMgb24gcGF0aHMgZnJvbSB0aGUgcm9vdCBkb3duIHRvIGZpZWxkcyB3aXRoIHRoZSBAY2xpZW50IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NpbmdsZUFTVE5vZGUobm9kZSkgJiYgaXNTZWxlY3Rpb25Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzXzEuYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc18xLmFkZChzcHJlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc18xLmFkZChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbnNUb1Jlc29sdmVDYWNoZS5nZXQoZGVmaW5pdGlvbk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0QnlEZWZpbml0aW9uKG1haW5EZWZpbml0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFN0YXRlO1xufSgpKTtcbmV4cG9ydCB7IExvY2FsU3RhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvY2FsU3RhdGUuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiX19hd2FpdGVyIiwiX19nZW5lcmF0b3IiLCJpbnZhcmlhbnQiLCJ2aXNpdCIsIkJSRUFLIiwiaXNTZWxlY3Rpb25Ob2RlIiwiYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkIiwiYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQiLCJjcmVhdGVGcmFnbWVudE1hcCIsImdldEZyYWdtZW50RGVmaW5pdGlvbnMiLCJnZXRNYWluRGVmaW5pdGlvbiIsImhhc0RpcmVjdGl2ZXMiLCJpc0ZpZWxkIiwiaXNJbmxpbmVGcmFnbWVudCIsIm1lcmdlRGVlcCIsIm1lcmdlRGVlcEFycmF5IiwicmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCIsInJlc3VsdEtleU5hbWVGcm9tRmllbGQiLCJzaG91bGRJbmNsdWRlIiwiY2FjaGVTbG90IiwiTG9jYWxTdGF0ZSIsIl9hIiwiY2FjaGUiLCJjbGllbnQiLCJyZXNvbHZlcnMiLCJmcmFnbWVudE1hdGNoZXIiLCJzZWxlY3Rpb25zVG9SZXNvbHZlQ2FjaGUiLCJXZWFrTWFwIiwiYWRkUmVzb2x2ZXJzIiwic2V0RnJhZ21lbnRNYXRjaGVyIiwicHJvdG90eXBlIiwiX3RoaXMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicmVzb2x2ZXJHcm91cCIsInNldFJlc29sdmVycyIsImdldFJlc29sdmVycyIsInJ1blJlc29sdmVycyIsImFyZ3VtZW50cyIsIl9iIiwiZG9jdW1lbnQiLCJyZW1vdGVSZXN1bHQiLCJjb250ZXh0IiwidmFyaWFibGVzIiwiX2MiLCJvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzIiwiX2QiLCJyZXNvbHZlRG9jdW1lbnQiLCJkYXRhIiwidGhlbiIsImxvY2FsUmVzdWx0IiwicmVzdWx0IiwiZ2V0RnJhZ21lbnRNYXRjaGVyIiwiY2xpZW50UXVlcnkiLCJzZXJ2ZXJRdWVyeSIsInByZXBhcmVDb250ZXh0IiwiZ2V0Q2FjaGVLZXkiLCJvYmoiLCJpZGVudGlmeSIsImFkZEV4cG9ydGVkVmFyaWFibGVzIiwiZG9jdW1lbnRfMSIsImJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlIiwiZXhwb3J0ZWRWYXJpYWJsZXMiLCJzaG91bGRGb3JjZVJlc29sdmVycyIsImZvcmNlUmVzb2x2ZXJzIiwiRGlyZWN0aXZlIiwiZW50ZXIiLCJub2RlIiwibmFtZSIsInZhbHVlIiwic29tZSIsImFyZyIsImtpbmQiLCJkaWZmIiwicXVlcnkiLCJyZXR1cm5QYXJ0aWFsRGF0YSIsIm9wdGltaXN0aWMiLCJyb290VmFsdWVfMSIsInJvb3RWYWx1ZSIsIm1haW5EZWZpbml0aW9uIiwiZnJhZ21lbnRzIiwiZnJhZ21lbnRNYXAiLCJzZWxlY3Rpb25zVG9SZXNvbHZlIiwiZGVmaW5pdGlvbk9wZXJhdGlvbiIsImRlZmF1bHRPcGVyYXRpb25UeXBlIiwiZXhlY0NvbnRleHQiLCJpc0NsaWVudEZpZWxkRGVzY2VuZGFudCIsImNvbGxlY3RTZWxlY3Rpb25zVG9SZXNvbHZlIiwib3BlcmF0aW9uIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInJlc29sdmVTZWxlY3Rpb25TZXQiLCJzZWxlY3Rpb25TZXQiLCJyZXN1bHRzVG9NZXJnZSIsImV4ZWN1dGUiLCJzZWxlY3Rpb24iLCJmcmFnbWVudCIsInR5cGVDb25kaXRpb24iLCJoYXMiLCJyZXNvbHZlRmllbGQiLCJmaWVsZFJlc3VsdCIsInB1c2giLCJmcmFnbWVudFJlc3VsdCIsIlByb21pc2UiLCJhbGwiLCJzZWxlY3Rpb25zIiwibWFwIiwiZmllbGQiLCJmaWVsZE5hbWUiLCJhbGlhc2VkRmllbGROYW1lIiwiYWxpYXNVc2VkIiwiZGVmYXVsdFJlc3VsdCIsInJlc3VsdFByb21pc2UiLCJyZXNvbHZlclR5cGUiLCJyZXNvbHZlck1hcCIsInJlc29sdmUiLCJfX3R5cGVuYW1lIiwid2l0aFZhbHVlIiwiZGlyZWN0aXZlcyIsImRpcmVjdGl2ZSIsImlzQ2xpZW50RmllbGQiLCJkIiwicmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkiLCJpdGVtIiwiaXNTaW5nbGVBU1ROb2RlIiwiY29sbGVjdEJ5RGVmaW5pdGlvbiIsImRlZmluaXRpb25Ob2RlIiwibWF0Y2hlc18xIiwiU2V0Iiwic2V0IiwiXyIsIl9fIiwiX19fIiwiYW5jZXN0b3JzIiwiYWRkIiwiRnJhZ21lbnRTcHJlYWQiLCJzcHJlYWQiLCJmcmFnbWVudFNlbGVjdGlvbnMiLCJzaXplIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/LocalState.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/core/ObservableQuery.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObservableQuery: function() { return /* binding */ ObservableQuery; },\n/* harmony export */   logMissingFieldErrors: function() { return /* binding */ logMissingFieldErrors; },\n/* harmony export */   reobserveCacheFirst: function() { return /* binding */ reobserveCacheFirst; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./networkStatus.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\");\n/* harmony import */ var _equalByQuery_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./equalByQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js\");\n\n\n\n\n\n\n\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = _super.call(this, function(observer) {\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            } catch (_a) {}\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            } else if (last && last.result) {\n                observer.next && observer.next(last.result);\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function() {});\n            }\n            return function() {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy : _f;\n        _this.options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {\n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy,\n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy\n        });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.getOperationDefinition)(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function() {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        /**\n         * An object containing the variables that were provided for the query.\n         */ get: function() {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function() {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            // TODO: this code doesn’t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function(result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function() {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    /** @internal */ ObservableQuery.prototype.resetDiff = function() {\n        this.queryInfo.resetDiff();\n    };\n    ObservableQuery.prototype.getCurrentResult = function(saveAsLastResult) {\n        if (saveAsLastResult === void 0) {\n            saveAsLastResult = true;\n        }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.ready;\n        var result = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, lastResult), {\n            loading: (0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.isNetworkRequestInFlight)(networkStatus),\n            networkStatus: networkStatus\n        });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (// These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot\n        // trust diff.result, since it was read from the cache without running\n        // local resolvers (and it's too late to run resolvers now, since we must\n        // return a result synchronously).\n        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n        // Fall through.\n        } else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        } else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete && result.networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.loading && (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.ready;\n                    result.loading = false;\n                }\n            } else {\n                result.partial = true;\n            }\n            if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function(newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !(0,_equalByQuery_js__WEBPACK_IMPORTED_MODULE_5__.equalByQuery)(this.query, this.last.result, newResult, this.variables) : !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.last.result, newResult);\n        return resultIsDifferent || variables && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.last.variables, variables);\n    };\n    ObservableQuery.prototype.getLast = function(key, variablesMustMatch) {\n        var last = this.last;\n        if (last && last[key] && (!variablesMustMatch || (0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function(variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function(variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function() {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function() {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */ ObservableQuery.prototype.refetch = function(variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"cache-and-network\") {\n            reobserveOptions.fetchPolicy = fetchPolicy;\n        } else if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        } else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.getQueryDefinition)(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function(v) {\n                return v.variable.name.value === \"variables\";\n            })) {\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(20, variables, ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef);\n            }\n        }\n        if (variables && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.refetch);\n    };\n    /**\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n     */ ObservableQuery.prototype.fetchMore = function(fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, fetchMoreOptions.query ? fetchMoreOptions : (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options), {\n            query: this.options.query\n        }), fetchMoreOptions), {\n            variables: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options.variables), fetchMoreOptions.variables)\n        })), {\n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\"\n        });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;\n        var isCached = this.options.fetchPolicy !== \"no-cache\";\n        if (!isCached) {\n            (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(updateQuery, 21);\n        }\n        return this.queryManager.fetchQuery(qid, combinedOptions, _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.fetchMore).then(function(fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            if (isCached) {\n                // Performing this cache update inside a cache.batch transaction ensures\n                // any affected cache.watch watchers are notified at most once about any\n                // updates. Most watchers will be using the QueryInfo class, which\n                // responds to notifications by calling reobserveCacheFirst to deliver\n                // fetchMore cache results back to this ObservableQuery.\n                _this.queryManager.cache.batch({\n                    update: function(cache) {\n                        var updateQuery = fetchMoreOptions.updateQuery;\n                        if (updateQuery) {\n                            cache.updateQuery({\n                                query: _this.query,\n                                variables: _this.variables,\n                                returnPartialData: true,\n                                optimistic: false\n                            }, function(previous) {\n                                return updateQuery(previous, {\n                                    fetchMoreResult: fetchMoreResult.data,\n                                    variables: combinedOptions.variables\n                                });\n                            });\n                        } else {\n                            // If we're using a field policy instead of updateQuery, the only\n                            // thing we need to do is write the new data to the cache using\n                            // combinedOptions.variables (instead of this.variables, which is\n                            // what this.updateQuery uses, because it works by abusing the\n                            // original field value, keyed by the original variables).\n                            cache.writeQuery({\n                                query: combinedOptions.query,\n                                variables: combinedOptions.variables,\n                                data: fetchMoreResult.data\n                            });\n                        }\n                    },\n                    onWatchUpdated: function(watch) {\n                        // Record the DocumentNode associated with any watched query whose\n                        // data were updated by the cache writes above.\n                        updatedQuerySet.add(watch.query);\n                    }\n                });\n            } else {\n                // There is a possibility `lastResult` may not be set when\n                // `fetchMore` is called which would cause this to crash. This should\n                // only happen if we haven't previously reported a result. We don't\n                // quite know what the right behavior should be here since this block\n                // of code runs after the fetch result has executed on the network.\n                // We plan to let it crash in the meantime.\n                //\n                // If we get bug reports due to the `data` property access on\n                // undefined, this should give us a real-world scenario that we can\n                // use to test against and determine the right behavior. If we do end\n                // up changing this behavior, this may require, for example, an\n                // adjustment to the types on `updateQuery` since that function\n                // expects that the first argument always contains previous result\n                // data, but not `undefined`.\n                var lastResult = _this.getLast(\"result\");\n                var data = updateQuery(lastResult.data, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables\n                });\n                _this.reportResult((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, lastResult), {\n                    data: data\n                }), _this.variables);\n            }\n            return fetchMoreResult;\n        }).finally(function() {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (isCached && !updatedQuerySet.has(_this.query)) {\n                reobserveCacheFirst(_this);\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */ ObservableQuery.prototype.subscribeToMore = function(options) {\n        var _this = this;\n        var subscription = this.queryManager.startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context\n        }).subscribe({\n            next: function(subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function(previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables\n                        });\n                    });\n                }\n            },\n            error: function(err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(22, err);\n            }\n        });\n        this.subscriptions.add(subscription);\n        return function() {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function(newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function(newOptions) {\n        var mergedOptions = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.compact)(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */ ObservableQuery.prototype.setVariables = function(variables) {\n        if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables\n        }, _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.setVariables);\n    };\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */ ObservableQuery.prototype.updateQuery = function(mapFn) {\n        var queryManager = this.queryManager;\n        var result = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false\n        }).result;\n        var newResult = mapFn(result, {\n            variables: this.variables\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */ ObservableQuery.prototype.startPolling = function(pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */ ObservableQuery.prototype.stopPolling = function() {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function(reason, // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n            // Do nothing, leaving options.fetchPolicy unchanged.\n            } else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy\n                });\n            } else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            } else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function(options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        this.queryManager.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function() {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval || !this.hasObservers()) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(pollInterval, 23);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function() {\n            var _a, _b;\n            if (_this.pollingInfo) {\n                if (!(0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.isNetworkRequestInFlight)(_this.queryInfo.networkStatus) && !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n                    }, _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.poll).then(poll, poll);\n                } else {\n                    poll();\n                }\n            }\n        };\n        var poll = function() {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function(newResult, variables) {\n        if (variables === void 0) {\n            variables = this.variables;\n        }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return this.last = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            result: this.queryManager.assumeImmutableResults ? newResult : (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.cloneDeep)(newResult),\n            variables: variables\n        }, error ? {\n            error: error\n        } : null);\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,\n        // if it did, it would definitely use a disposable Concast.\n        newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force\n        // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n        newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.compact)(this.options, newOptions || {});\n        var options = useDisposableConcast ? // Disposable Concast fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions && newOptions.variables && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently \"standby\".\n            options.fetchPolicy !== \"standby\" && // If we're changing the fetchPolicy anyway, don't try to change it here\n            // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n            (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,\n            // so in that case `applyNextFetchPolicy` must be called.\n            typeof options.nextFetchPolicy === \"function\")) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function() {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function(result) {\n                if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportResult(result, variables);\n                }\n            },\n            error: function(error) {\n                if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(_this.variables, variables)) {\n                    // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n                    // However, calling `concast.cancel` can inject another type of error, so we have to\n                    // wrap it again here.\n                    if (!(0,_errors_index_js__WEBPACK_IMPORTED_MODULE_8__.isApolloError)(error)) {\n                        error = new _errors_index_js__WEBPACK_IMPORTED_MODULE_8__.ApolloError({\n                            networkError: error\n                        });\n                    }\n                    finishWaitingForOwnResult();\n                    _this.reportError(error, variables);\n                }\n            }\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function(newOptions, newNetworkStatus) {\n        return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function() {\n        this.reportResult(// Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function(result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.iterateObserversSafely)(this.observers, \"next\", result);\n        }\n    };\n    ObservableQuery.prototype.reportError = function(error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.getLastResult()), {\n            error: error,\n            errors: error.graphQLErrors,\n            networkStatus: _networkStatus_js__WEBPACK_IMPORTED_MODULE_4__.NetworkStatus.error,\n            loading: false\n        });\n        this.updateLastResult(errorResult, variables);\n        (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_9__.iterateObserversSafely)(this.observers, \"error\", this.last.error = error);\n    };\n    ObservableQuery.prototype.hasObservers = function() {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function() {\n        if (this.isTornDown) return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function(sub) {\n            return sub.unsubscribe();\n        });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function(document) {\n        return this.queryManager.transform(document);\n    };\n    return ObservableQuery;\n}(_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.Observable);\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\n(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.fixObservableSubclass)(ObservableQuery);\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nfunction reobserveCacheFirst(obsQuery) {\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n        return obsQuery.reobserve({\n            fetchPolicy: \"cache-first\",\n            // Use a temporary nextFetchPolicy function that replaces itself with the\n            // previous nextFetchPolicy value and returns the original fetchPolicy.\n            nextFetchPolicy: function(currentFetchPolicy, context) {\n                // Replace this nextFetchPolicy function in the options object with the\n                // original this.options.nextFetchPolicy value.\n                this.nextFetchPolicy = nextFetchPolicy;\n                // If the original nextFetchPolicy value was a function, give it a\n                // chance to decide what happens here.\n                if (typeof this.nextFetchPolicy === \"function\") {\n                    return this.nextFetchPolicy(currentFetchPolicy, context);\n                }\n                // Otherwise go back to the original this.options.fetchPolicy.\n                return fetchPolicy;\n            }\n        });\n    }\n    return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(24, error.message, error.stack);\n}\nfunction logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.debug(25, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */ ) {\n    return fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\" || fetchPolicy === \"standby\";\n} //# sourceMappingURL=ObservableQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL09ic2VydmFibGVRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDYztBQUNwQjtBQUN1QztBQUNzRjtBQUNuRztBQUNmO0FBQ2pELElBQUlnQixTQUFTQyxPQUFPRCxNQUFNLEVBQUVFLGlCQUFpQkQsT0FBT0MsY0FBYztBQUNsRSxJQUFJQyxrQkFBa0IsV0FBVyxHQUFJLFNBQVVDLE1BQU07SUFDakRuQixnREFBU0EsQ0FBQ2tCLGlCQUFpQkM7SUFDM0IsU0FBU0QsZ0JBQWdCRSxFQUFFO1FBQ3ZCLElBQUlDLGVBQWVELEdBQUdDLFlBQVksRUFBRUMsWUFBWUYsR0FBR0UsU0FBUyxFQUFFQyxVQUFVSCxHQUFHRyxPQUFPO1FBQ2xGLElBQUlDLFFBQVFMLE9BQU9NLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBVUMsUUFBUTtZQUM1QywwRUFBMEU7WUFDMUUsOENBQThDO1lBQzlDLElBQUk7Z0JBQ0EsSUFBSUMsY0FBY0QsU0FBU0UsYUFBYSxDQUFDQyxTQUFTO2dCQUNsRCxJQUFJRixlQUFlLENBQUNBLFlBQVlHLEtBQUssRUFBRTtvQkFDbkNILFlBQVlHLEtBQUssR0FBR0M7Z0JBQ3hCO1lBQ0osRUFDQSxPQUFPWCxJQUFJLENBQUU7WUFDYixJQUFJWSxRQUFRLENBQUNSLE1BQU1TLFNBQVMsQ0FBQ0MsSUFBSTtZQUNqQ1YsTUFBTVMsU0FBUyxDQUFDRSxHQUFHLENBQUNUO1lBQ3BCLHVDQUF1QztZQUN2QyxJQUFJVSxPQUFPWixNQUFNWSxJQUFJO1lBQ3JCLElBQUlBLFFBQVFBLEtBQUtOLEtBQUssRUFBRTtnQkFDcEJKLFNBQVNJLEtBQUssSUFBSUosU0FBU0ksS0FBSyxDQUFDTSxLQUFLTixLQUFLO1lBQy9DLE9BQ0ssSUFBSU0sUUFBUUEsS0FBS0MsTUFBTSxFQUFFO2dCQUMxQlgsU0FBU1ksSUFBSSxJQUFJWixTQUFTWSxJ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RSx1RUFBdUU7WUFDdkUySCxpQkFBaUIsU0FBVTZDLGtCQUFrQixFQUFFN0QsT0FBTztnQkFDbEQsdUVBQXVFO2dCQUN2RSwrQ0FBK0M7Z0JBQy9DLElBQUksQ0FBQ2dCLGVBQWUsR0FBR0E7Z0JBQ3ZCLGtFQUFrRTtnQkFDbEUsc0NBQXNDO2dCQUN0QyxJQUFJLE9BQU8sSUFBSSxDQUFDQSxlQUFlLEtBQUssWUFBWTtvQkFDNUMsT0FBTyxJQUFJLENBQUNBLGVBQWUsQ0FBQzZDLG9CQUFvQjdEO2dCQUNwRDtnQkFDQSw4REFBOEQ7Z0JBQzlELE9BQU8zRztZQUNYO1FBQ0o7SUFDSjtJQUNBLE9BQU91SyxTQUFTL0ssU0FBUztBQUM3QjtBQUNBLFNBQVNSLHlDQUF5Q0QsS0FBSztJQUNuRG9FLFdBQVdDLE9BQU8sS0FBSyxTQUFTbEcsa0VBQVNBLENBQUM2QixLQUFLLENBQUMsSUFBSUEsTUFBTTBMLE9BQU8sRUFBRTFMLE1BQU0yTCxLQUFLO0FBQ2xGO0FBQ08sU0FBU3BILHNCQUFzQkMsT0FBTztJQUN6QyxJQUFJSixXQUFXQyxPQUFPLEtBQUssU0FBU0csU0FBUztRQUN6Q0osV0FBV0MsT0FBTyxLQUFLLFNBQVNsRyxrRUFBU0EsQ0FBQ3lOLEtBQUssQ0FBQyxJQUFJcEg7SUFDeEQ7QUFDSjtBQUNBLFNBQVN4RCxpQkFBaUJDLFlBQVksMENBQTBDLEdBQTNDO0lBQ2pDLE9BQVFBLGdCQUFnQixrQkFDcEJBLGdCQUFnQixjQUNoQkEsZ0JBQWdCO0FBQ3hCLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL09ic2VydmFibGVRdWVyeS5qcz83ZjZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZXF1YWwgfSBmcm9tIFwiQHdyeS9lcXVhbGl0eVwiO1xuaW1wb3J0IHsgTmV0d29ya1N0YXR1cywgaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0IH0gZnJvbSBcIi4vbmV0d29ya1N0YXR1cy5qc1wiO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBjb21wYWN0LCBnZXRPcGVyYXRpb25EZWZpbml0aW9uLCBPYnNlcnZhYmxlLCBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5LCBmaXhPYnNlcnZhYmxlU3ViY2xhc3MsIGdldFF1ZXJ5RGVmaW5pdGlvbiwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBcG9sbG9FcnJvciwgaXNBcG9sbG9FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVxdWFsQnlRdWVyeSB9IGZyb20gXCIuL2VxdWFsQnlRdWVyeS5qc1wiO1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xudmFyIE9ic2VydmFibGVRdWVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2YWJsZVF1ZXJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVRdWVyeShfYSkge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gX2EucXVlcnlNYW5hZ2VyLCBxdWVyeUluZm8gPSBfYS5xdWVyeUluZm8sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIFplbiBPYnNlcnZhYmxlIGhhcyBpdHMgb3duIGVycm9yIGZ1bmN0aW9uLCBzbyBpbiBvcmRlciB0byBsb2cgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHByb3ZpZGUgYSBjdXN0b20gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJPYnNlcnZlciA9IG9ic2VydmVyLl9zdWJzY3JpcHRpb24uX29ic2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChzdWJPYnNlcnZlciAmJiAhc3ViT2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViT2JzZXJ2ZXIuZXJyb3IgPSBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSAhX3RoaXMub2JzZXJ2ZXJzLnNpemU7XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgICAgICAgIC8vIERlbGl2ZXIgbW9zdCByZWNlbnQgZXJyb3Igb3IgcmVzdWx0LlxuICAgICAgICAgICAgdmFyIGxhc3QgPSBfdGhpcy5sYXN0O1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGxhc3QuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdCAmJiBsYXN0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChsYXN0LnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWF0ZSBvYnNlcnZhdGlvbiBvZiB0aGlzIHF1ZXJ5IGlmIGl0IGhhc24ndCBiZWVuIHJlcG9ydGVkIHRvXG4gICAgICAgICAgICAvLyB0aGUgUXVlcnlNYW5hZ2VyIHlldC5cbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIC8vIEJsaW5kbHkgY2F0Y2hpbmcgaGVyZSBwcmV2ZW50cyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpcyBzYWZlIGJlY2F1c2UgdGhlIE9ic2VydmFibGVRdWVyeSBoYW5kbGVzIHRoaXMgZXJyb3Igd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoaXMub2JzZXJ2ZXIuZXJyb3IsIHNvIHdlJ3JlIG5vdCBqdXN0IHN3YWxsb3dpbmcgdGhlIGVycm9yIGJ5XG4gICAgICAgICAgICAgICAgLy8gaWdub3JpbmcgaXQgaGVyZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5yZW9ic2VydmUoKS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcikgJiYgIV90aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRlYXJEb3duUXVlcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIHJlbGF0ZWQgY2xhc3Nlc1xuICAgICAgICBfdGhpcy5xdWVyeUluZm8gPSBxdWVyeUluZm87XG4gICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlciA9IHF1ZXJ5TWFuYWdlcjtcbiAgICAgICAgLy8gYWN0aXZlIHN0YXRlXG4gICAgICAgIF90aGlzLndhaXRGb3JPd25SZXN1bHQgPSBza2lwQ2FjaGVEYXRhRm9yKG9wdGlvbnMuZmV0Y2hQb2xpY3kpO1xuICAgICAgICBfdGhpcy5pc1Rvcm5Eb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN1YnNjcmliZVRvTW9yZSA9IF90aGlzLnN1YnNjcmliZVRvTW9yZS5iaW5kKF90aGlzKTtcbiAgICAgICAgdmFyIF9iID0gcXVlcnlNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIF9jID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9kID0gX2MuZmV0Y2hQb2xpY3ksIGRlZmF1bHRGZXRjaFBvbGljeSA9IF9kID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfZDtcbiAgICAgICAgdmFyIF9lID0gb3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoUG9saWN5IDogX2UsIFxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3Qgc3RvcmUgXCJzdGFuZGJ5XCIgYXMgdGhlIGluaXRpYWxGZXRjaFBvbGljeS5cbiAgICAgICAgX2YgPSBvcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSwgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBzdG9yZSBcInN0YW5kYnlcIiBhcyB0aGUgaW5pdGlhbEZldGNoUG9saWN5LlxuICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3kgPSBfZiA9PT0gdm9pZCAwID8gZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiID8gZGVmYXVsdEZldGNoUG9saWN5IDogKGZldGNoUG9saWN5KSA6IF9mO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IFxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGluaXRpYWwgb3B0aW9ucy5mZXRjaFBvbGljeSBzbyB3ZSBjYW4gcmV2ZXJ0IGJhY2sgdG8gdGhpc1xuICAgICAgICAgICAgLy8gcG9saWN5IHdoZW4gdmFyaWFibGVzIGNoYW5nZS4gVGhpcyBpbmZvcm1hdGlvbiBjYW4gYWxzbyBiZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIChvciBvdmVycmlkZGVuKSBieSBwcm92aWRpbmcgb3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgZXhwbGljaXRseS5cbiAgICAgICAgICAgIGluaXRpYWxGZXRjaFBvbGljeTogaW5pdGlhbEZldGNoUG9saWN5LCBcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3kgYWx3YXlzIGhhcyBhIHN0cmluZyB2YWx1ZSwgaW5cbiAgICAgICAgICAgIC8vIGNhc2Ugb3B0aW9ucy5mZXRjaFBvbGljeSB3YXMgbm90IHByb3ZpZGVkLlxuICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5IH0pO1xuICAgICAgICBfdGhpcy5xdWVyeUlkID0gcXVlcnlJbmZvLnF1ZXJ5SWQgfHwgcXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpO1xuICAgICAgICB2YXIgb3BEZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKF90aGlzLnF1ZXJ5KTtcbiAgICAgICAgX3RoaXMucXVlcnlOYW1lID0gb3BEZWYgJiYgb3BEZWYubmFtZSAmJiBvcERlZi5uYW1lLnZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICAgICAgLy8gVGhlIGBxdWVyeWAgY29tcHV0ZWQgcHJvcGVydHkgd2lsbCBhbHdheXMgcmVmbGVjdCB0aGUgZG9jdW1lbnQgdHJhbnNmb3JtZWRcbiAgICAgICAgLy8gYnkgdGhlIGxhc3QgcnVuIHF1ZXJ5LiBgdGhpcy5vcHRpb25zLnF1ZXJ5YCB3aWxsIGFsd2F5cyByZWZsZWN0IHRoZSByYXdcbiAgICAgICAgLy8gdW50cmFuc2Zvcm1lZCBxdWVyeSB0byBlbnN1cmUgZG9jdW1lbnQgdHJhbnNmb3JtcyB3aXRoIHJ1bnRpbWUgY29uZGl0aW9uYWxzXG4gICAgICAgIC8vIGFyZSBydW4gb24gdGhlIG9yaWdpbmFsIGRvY3VtZW50LlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RRdWVyeSB8fCB0aGlzLm9wdGlvbnMucXVlcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZSwgXCJ2YXJpYWJsZXNcIiwge1xuICAgICAgICAvLyBDb21wdXRlZCBzaG9ydGhhbmQgZm9yIHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHByZXNlcnZlZCBmb3JcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzIHRoYXQgd2VyZSBwcm92aWRlZCBmb3IgdGhlIHF1ZXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhcmlhYmxlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBjb2RlIGRvZXNu4oCZdCBhY3R1YWxseSBtYWtlIHNlbnNlIGluc29mYXIgYXMgdGhlIG9ic2VydmVyXG4gICAgICAgICAgICAvLyB3aWxsIG5ldmVyIGV4aXN0IGluIHRoaXMub2JzZXJ2ZXJzIGR1ZSBob3cgemVuLW9ic2VydmFibGUgd3JhcHMgb2JzZXJ2YWJsZXMuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy96ZW4tb2JzZXJ2YWJsZS9ibG9iL21hc3Rlci9zcmMvT2JzZXJ2YWJsZS5qcyNMMTY5XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIHF1ZXJ5IHdpdGhpbiB0aGUgUXVlcnlNYW5hZ2VyIGlmIHdlIGNhbiBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGluIG9yZGVyIHRvIHByZXZlbnQgb2JzZXJ2ZXJzIHBpbGluZyB1cCB3aXRoaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIFF1ZXJ5TWFuYWdlci4gTm90aWNlIHRoYXQgd2Ugb25seSBmdWxseSB1bnN1YnNjcmliZVxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBzdWJzY3JpcHRpb24gaW4gYSBzZXRUaW1lb3V0KC4uLiwgMCkgIGNhbGwuIFRoaXMgY2FsbCBjYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgYmUgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBhdCBhIG11Y2ggbGF0ZXIgdGltZS4gSWYgcXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgZmlyZWQgaW4gdGhlIG1lYW50aW1lLCBvYnNlcnZlcnMgdGhhdCBzaG91bGQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUXVlcnlNYW5hZ2VyIHdpbGwgY29udGludWUgdG8gZmlyZSwgY2F1c2luZyBhbiB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtYW5jZSBoaXQuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIucmVtb3ZlUXVlcnkoX3RoaXMucXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc2V0RGlmZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWVyeUluZm8ucmVzZXREaWZmKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldEN1cnJlbnRSZXN1bHQgPSBmdW5jdGlvbiAoc2F2ZUFzTGFzdFJlc3VsdCkge1xuICAgICAgICBpZiAoc2F2ZUFzTGFzdFJlc3VsdCA9PT0gdm9pZCAwKSB7IHNhdmVBc0xhc3RSZXN1bHQgPSB0cnVlOyB9XG4gICAgICAgIC8vIFVzZSB0aGUgbGFzdCByZXN1bHQgYXMgbG9uZyBhcyB0aGUgdmFyaWFibGVzIG1hdGNoIHRoaXMudmFyaWFibGVzLlxuICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IHRoaXMuZ2V0TGFzdFJlc3VsdCh0cnVlKTtcbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSB0aGlzLnF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8XG4gICAgICAgICAgICAobGFzdFJlc3VsdCAmJiBsYXN0UmVzdWx0Lm5ldHdvcmtTdGF0dXMpIHx8XG4gICAgICAgICAgICBOZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICB2YXIgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxhc3RSZXN1bHQpLCB7IGxvYWRpbmc6IGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChuZXR3b3JrU3RhdHVzKSwgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyB9KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9hID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfYTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBUaGVzZSBmZXRjaCBwb2xpY2llcyBzaG91bGQgbmV2ZXIgZGVsaXZlciBkYXRhIGZyb20gdGhlIGNhY2hlLCB1bmxlc3NcbiAgICAgICAgLy8gcmVkZWxpdmVyaW5nIGEgcHJldmlvdXNseSBkZWxpdmVyZWQgcmVzdWx0LlxuICAgICAgICBza2lwQ2FjaGVEYXRhRm9yKGZldGNoUG9saWN5KSB8fFxuICAgICAgICAgICAgLy8gSWYgdGhpcy5vcHRpb25zLnF1ZXJ5IGhhcyBAY2xpZW50KGFsd2F5czogdHJ1ZSkgZmllbGRzLCB3ZSBjYW5ub3RcbiAgICAgICAgICAgIC8vIHRydXN0IGRpZmYucmVzdWx0LCBzaW5jZSBpdCB3YXMgcmVhZCBmcm9tIHRoZSBjYWNoZSB3aXRob3V0IHJ1bm5pbmdcbiAgICAgICAgICAgIC8vIGxvY2FsIHJlc29sdmVycyAoYW5kIGl0J3MgdG9vIGxhdGUgdG8gcnVuIHJlc29sdmVycyBub3csIHNpbmNlIHdlIG11c3RcbiAgICAgICAgICAgIC8vIHJldHVybiBhIHJlc3VsdCBzeW5jaHJvbm91c2x5KS5cbiAgICAgICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLmdldERvY3VtZW50SW5mbyh0aGlzLnF1ZXJ5KS5oYXNGb3JjZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndhaXRGb3JPd25SZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd291bGQgdXN1YWxseSBiZSBhIHBhcnQgb2YgYFF1ZXJ5SW5mby5nZXREaWZmKClgLlxuICAgICAgICAgICAgLy8gd2hpY2ggd2Ugc2tpcCBpbiB0aGUgd2FpdEZvck93blJlc3VsdCBjYXNlIHNpbmNlIHdlIGFyZSBub3RcbiAgICAgICAgICAgIC8vIGludGVyZXN0ZWQgaW4gdGhlIGRpZmYuXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5SW5mb1tcInVwZGF0ZVdhdGNoXCJdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMucXVlcnlJbmZvLmdldERpZmYoKTtcbiAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlIHx8IHRoaXMub3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGlmZi5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXF1YWwocmVzdWx0LmRhdGEsIHt9KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFyIHRvIHNldHRpbmcgcmVzdWx0LnBhcnRpYWwgdG8gZmFsc2UsIGJ1dCB0YWtpbmcgYWR2YW50YWdlIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZhbHNpbmVzcyBvZiBtaXNzaW5nIGZpZWxkcy5cbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnBhcnRpYWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZmYgaXMgY29tcGxldGUsIGFuZCB3ZSdyZSB1c2luZyBhIEZldGNoUG9saWN5IHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0ZXJtaW5hdGVzIGFmdGVyIGEgY29tcGxldGUgY2FjaGUgcmVhZCwgd2UgY2FuIGFzc3VtZSB0aGUgbmV4dCByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyB3ZSByZWNlaXZlIHdpbGwgaGF2ZSBOZXR3b3JrU3RhdHVzLnJlYWR5IGFuZCAhbG9hZGluZy5cbiAgICAgICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSAmJlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIChmZXRjaFBvbGljeSA9PT0gXCJjYWNoZS1maXJzdFwiIHx8IGZldGNoUG9saWN5ID09PSBcImNhY2hlLW9ubHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgIWRpZmYuY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5vcHRpb25zLnBhcnRpYWxSZWZldGNoICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5kYXRhICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ01pc3NpbmdGaWVsZEVycm9ycyhkaWZmLm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzYXZlQXNMYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gQ29tcGFyZXMgbmV3UmVzdWx0IHRvIHRoZSBzbmFwc2hvdCB3ZSB0b29rIG9mIHRoaXMubGFzdFJlc3VsdCB3aGVuIGl0IHdhc1xuICAgIC8vIGZpcnN0IHJlY2VpdmVkLlxuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdCA9IGZ1bmN0aW9uIChuZXdSZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdElzRGlmZmVyZW50ID0gdGhpcy5xdWVyeU1hbmFnZXIuZ2V0RG9jdW1lbnRJbmZvKHRoaXMucXVlcnkpLmhhc05vbnJlYWN0aXZlRGlyZWN0aXZlID9cbiAgICAgICAgICAgICFlcXVhbEJ5UXVlcnkodGhpcy5xdWVyeSwgdGhpcy5sYXN0LnJlc3VsdCwgbmV3UmVzdWx0LCB0aGlzLnZhcmlhYmxlcylcbiAgICAgICAgICAgIDogIWVxdWFsKHRoaXMubGFzdC5yZXN1bHQsIG5ld1Jlc3VsdCk7XG4gICAgICAgIHJldHVybiAocmVzdWx0SXNEaWZmZXJlbnQgfHwgKHZhcmlhYmxlcyAmJiAhZXF1YWwodGhpcy5sYXN0LnZhcmlhYmxlcywgdmFyaWFibGVzKSkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0ID0gZnVuY3Rpb24gKGtleSwgdmFyaWFibGVzTXVzdE1hdGNoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5sYXN0O1xuICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgbGFzdFtrZXldICYmXG4gICAgICAgICAgICAoIXZhcmlhYmxlc011c3RNYXRjaCB8fCBlcXVhbChsYXN0LnZhcmlhYmxlcywgdGhpcy52YXJpYWJsZXMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKHZhcmlhYmxlc011c3RNYXRjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXN0KFwicmVzdWx0XCIsIHZhcmlhYmxlc011c3RNYXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldExhc3RFcnJvciA9IGZ1bmN0aW9uICh2YXJpYWJsZXNNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdChcImVycm9yXCIsIHZhcmlhYmxlc011c3RNYXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc2V0TGFzdFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxhc3Q7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldFF1ZXJ5U3RvcmVFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLnJlc2V0RXJyb3JzKHRoaXMucXVlcnlJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHZhcmlhYmxlcyBvZiB0aGlzIG9ic2VydmFibGUgcXVlcnksIGFuZCBmZXRjaCB0aGUgbmV3IHJlc3VsdHMuXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHByZWZlcnJlZCBvdmVyIGBzZXRWYXJpYWJsZXNgIGluIG1vc3QgdXNlIGNhc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhcmlhYmxlcyAtIFRoZSBuZXcgc2V0IG9mIHZhcmlhYmxlcy4gSWYgdGhlcmUgYXJlIG1pc3NpbmcgdmFyaWFibGVzLFxuICAgICAqIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgdGhvc2UgdmFyaWFibGVzIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHJlb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgZGlzYWJsZSBwb2xsaW5nIGZvciByZWZldGNoZXMuXG4gICAgICAgICAgICBwb2xsSW50ZXJ2YWw6IDAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFVubGVzcyB0aGUgcHJvdmlkZWQgZmV0Y2hQb2xpY3kgYWx3YXlzIGNvbnN1bHRzIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vIChuby1jYWNoZSwgbmV0d29yay1vbmx5LCBvciBjYWNoZS1hbmQtbmV0d29yayksIG92ZXJyaWRlIGl0IHdpdGhcbiAgICAgICAgLy8gbmV0d29yay1vbmx5IHRvIGZvcmNlIHRoZSByZWZldGNoIGZvciB0aGlzIGZldGNoUXVlcnkgY2FsbC5cbiAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09IFwiY2FjaGUtYW5kLW5ldHdvcmtcIikge1xuICAgICAgICAgICAgcmVvYnNlcnZlT3B0aW9ucy5mZXRjaFBvbGljeSA9IGZldGNoUG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgPSBcIm5vLWNhY2hlXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW9ic2VydmVPcHRpb25zLmZldGNoUG9saWN5ID0gXCJuZXR3b3JrLW9ubHlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiB2YXJpYWJsZXMgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YXJpYWJsZXMsIFwidmFyaWFibGVzXCIpKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlEZWYgPSBnZXRRdWVyeURlZmluaXRpb24odGhpcy5xdWVyeSk7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHF1ZXJ5RGVmLnZhcmlhYmxlRGVmaW5pdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXZhcnMgfHwgIXZhcnMuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gdi52YXJpYWJsZS5uYW1lLnZhbHVlID09PSBcInZhcmlhYmxlc1wiOyB9KSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oXG4gICAgICAgICAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBxdWVyeURlZi5uYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIHx8IHF1ZXJ5RGVmXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVzICYmICFlcXVhbCh0aGlzLm9wdGlvbnMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIG9wdGlvbnMgd2l0aCBuZXcgdmFyaWFibGVzXG4gICAgICAgICAgICByZW9ic2VydmVPcHRpb25zLnZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zLnZhcmlhYmxlcyksIHZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyeUluZm8ucmVzZXRMYXN0V3JpdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVvYnNlcnZlKHJlb2JzZXJ2ZU9wdGlvbnMsIE5ldHdvcmtTdGF0dXMucmVmZXRjaCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgaGVscHMgeW91IGZldGNoIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzIGZvciBhIFtwYWdpbmF0ZWQgbGlzdCBmaWVsZF0oaHR0cHM6Ly93d3cuYXBvbGxvZ3JhcGhxbC5jb20vZG9jcy9yZWFjdC9wYWdpbmF0aW9uL2NvcmUtYXBpLykuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5mZXRjaE1vcmUgPSBmdW5jdGlvbiAoZmV0Y2hNb3JlT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tYmluZWRPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIChmZXRjaE1vcmVPcHRpb25zLnF1ZXJ5ID8gZmV0Y2hNb3JlT3B0aW9ucyA6IChfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgeyBxdWVyeTogdGhpcy5vcHRpb25zLnF1ZXJ5IH0pLCBmZXRjaE1vcmVPcHRpb25zKSwgeyB2YXJpYWJsZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgZmV0Y2hNb3JlT3B0aW9ucy52YXJpYWJsZXMpIH0pKSkpLCB7IFxuICAgICAgICAgICAgLy8gVGhlIGZldGNoTW9yZSByZXF1ZXN0IGdvZXMgaW1tZWRpYXRlbHkgdG8gdGhlIG5ldHdvcmsgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBhdXRvbWF0aWNhbGx5IHdyaXRlIGl0cyByZXN1bHQgdG8gdGhlIGNhY2hlIChoZW5jZSBuby1jYWNoZVxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBuZXR3b3JrLW9ubHkpLCBiZWNhdXNlIHdlIGFsbG93IHRoZSBjYWxsZXIgb2ZcbiAgICAgICAgICAgIC8vIGZldGNoTW9yZSB0byBwcm92aWRlIGFuIHVwZGF0ZVF1ZXJ5IGNhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lcyBob3dcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGdldHMgd3JpdHRlbiB0byB0aGUgY2FjaGUuXG4gICAgICAgICAgICBmZXRjaFBvbGljeTogXCJuby1jYWNoZVwiIH0pO1xuICAgICAgICBjb21iaW5lZE9wdGlvbnMucXVlcnkgPSB0aGlzLnRyYW5zZm9ybURvY3VtZW50KGNvbWJpbmVkT3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIHZhciBxaWQgPSB0aGlzLnF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgLy8gSWYgYSB0ZW1wb3JhcnkgcXVlcnkgaXMgcGFzc2VkIHRvIGBmZXRjaE1vcmVgLCB3ZSBkb24ndCB3YW50IHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IGFzIHRoZSBsYXN0IHF1ZXJ5IHJlc3VsdCBzaW5jZSBpdCBtYXkgYmUgYW4gb3B0aW1pemVkIHF1ZXJ5IGZvclxuICAgICAgICAvLyBwYWdpbmF0aW9uLiBXZSB3aWxsIGhvd2V2ZXIgcnVuIHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBvcmlnaW5hbCBkb2N1bWVudFxuICAgICAgICAvLyBhcyB3ZWxsIGFzIHRoZSBkb2N1bWVudCBwYXNzZWQgaW4gYGZldGNoTW9yZU9wdGlvbnNgIHRvIGVuc3VyZSB0aGUgY2FjaGVcbiAgICAgICAgLy8gdXNlcyB0aGUgbW9zdCB1cC10by1kYXRlIGRvY3VtZW50IHdoaWNoIG1heSByZWx5IG9uIHJ1bnRpbWUgY29uZGl0aW9uYWxzLlxuICAgICAgICB0aGlzLmxhc3RRdWVyeSA9XG4gICAgICAgICAgICBmZXRjaE1vcmVPcHRpb25zLnF1ZXJ5ID9cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybURvY3VtZW50KHRoaXMub3B0aW9ucy5xdWVyeSlcbiAgICAgICAgICAgICAgICA6IGNvbWJpbmVkT3B0aW9ucy5xdWVyeTtcbiAgICAgICAgLy8gU2ltdWxhdGUgYSBsb2FkaW5nIHJlc3VsdCBmb3IgdGhlIG9yaWdpbmFsIHF1ZXJ5IHdpdGhcbiAgICAgICAgLy8gcmVzdWx0Lm5ldHdvcmtTdGF0dXMgPT09IE5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlLlxuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyeUluZm87XG4gICAgICAgIHZhciBvcmlnaW5hbE5ldHdvcmtTdGF0dXMgPSBxdWVyeUluZm8ubmV0d29ya1N0YXR1cztcbiAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmZldGNoTW9yZTtcbiAgICAgICAgaWYgKGNvbWJpbmVkT3B0aW9ucy5ub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVkUXVlcnlTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciB1cGRhdGVRdWVyeSA9IGZldGNoTW9yZU9wdGlvbnMgPT09IG51bGwgfHwgZmV0Y2hNb3JlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hNb3JlT3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgdmFyIGlzQ2FjaGVkID0gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5ICE9PSBcIm5vLWNhY2hlXCI7XG4gICAgICAgIGlmICghaXNDYWNoZWQpIHtcbiAgICAgICAgICAgIGludmFyaWFudCh1cGRhdGVRdWVyeSwgMjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlclxuICAgICAgICAgICAgLmZldGNoUXVlcnkocWlkLCBjb21iaW5lZE9wdGlvbnMsIE5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZldGNoTW9yZVJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMucXVlcnlNYW5hZ2VyLnJlbW92ZVF1ZXJ5KHFpZCk7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPT09IE5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPSBvcmlnaW5hbE5ldHdvcmtTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtaW5nIHRoaXMgY2FjaGUgdXBkYXRlIGluc2lkZSBhIGNhY2hlLmJhdGNoIHRyYW5zYWN0aW9uIGVuc3VyZXNcbiAgICAgICAgICAgICAgICAvLyBhbnkgYWZmZWN0ZWQgY2FjaGUud2F0Y2ggd2F0Y2hlcnMgYXJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSBhYm91dCBhbnlcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzLiBNb3N0IHdhdGNoZXJzIHdpbGwgYmUgdXNpbmcgdGhlIFF1ZXJ5SW5mbyBjbGFzcywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyByZXNwb25kcyB0byBub3RpZmljYXRpb25zIGJ5IGNhbGxpbmcgcmVvYnNlcnZlQ2FjaGVGaXJzdCB0byBkZWxpdmVyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2hNb3JlIGNhY2hlIHJlc3VsdHMgYmFjayB0byB0aGlzIE9ic2VydmFibGVRdWVyeS5cbiAgICAgICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIuY2FjaGUuYmF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gZmV0Y2hNb3JlT3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnVwZGF0ZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IF90aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IF90aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUXVlcnkocHJldmlvdXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9yZVJlc3VsdDogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgYSBmaWVsZCBwb2xpY3kgaW5zdGVhZCBvZiB1cGRhdGVRdWVyeSwgdGhlIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGluZyB3ZSBuZWVkIHRvIGRvIGlzIHdyaXRlIHRoZSBuZXcgZGF0YSB0byB0aGUgY2FjaGUgdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzIChpbnN0ZWFkIG9mIHRoaXMudmFyaWFibGVzLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgdGhpcy51cGRhdGVRdWVyeSB1c2VzLCBiZWNhdXNlIGl0IHdvcmtzIGJ5IGFidXNpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgZmllbGQgdmFsdWUsIGtleWVkIGJ5IHRoZSBvcmlnaW5hbCB2YXJpYWJsZXMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLndyaXRlUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogY29tYmluZWRPcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoTW9yZVJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbldhdGNoVXBkYXRlZDogZnVuY3Rpb24gKHdhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIERvY3VtZW50Tm9kZSBhc3NvY2lhdGVkIHdpdGggYW55IHdhdGNoZWQgcXVlcnkgd2hvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgd2VyZSB1cGRhdGVkIGJ5IHRoZSBjYWNoZSB3cml0ZXMgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUXVlcnlTZXQuYWRkKHdhdGNoLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcG9zc2liaWxpdHkgYGxhc3RSZXN1bHRgIG1heSBub3QgYmUgc2V0IHdoZW5cbiAgICAgICAgICAgICAgICAvLyBgZmV0Y2hNb3JlYCBpcyBjYWxsZWQgd2hpY2ggd291bGQgY2F1c2UgdGhpcyB0byBjcmFzaC4gVGhpcyBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGhhcHBlbiBpZiB3ZSBoYXZlbid0IHByZXZpb3VzbHkgcmVwb3J0ZWQgYSByZXN1bHQuIFdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUga25vdyB3aGF0IHRoZSByaWdodCBiZWhhdmlvciBzaG91bGQgYmUgaGVyZSBzaW5jZSB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gb2YgY29kZSBydW5zIGFmdGVyIHRoZSBmZXRjaCByZXN1bHQgaGFzIGV4ZWN1dGVkIG9uIHRoZSBuZXR3b3JrLlxuICAgICAgICAgICAgICAgIC8vIFdlIHBsYW4gdG8gbGV0IGl0IGNyYXNoIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBidWcgcmVwb3J0cyBkdWUgdG8gdGhlIGBkYXRhYCBwcm9wZXJ0eSBhY2Nlc3Mgb25cbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQsIHRoaXMgc2hvdWxkIGdpdmUgdXMgYSByZWFsLXdvcmxkIHNjZW5hcmlvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRvIHRlc3QgYWdhaW5zdCBhbmQgZGV0ZXJtaW5lIHRoZSByaWdodCBiZWhhdmlvci4gSWYgd2UgZG8gZW5kXG4gICAgICAgICAgICAgICAgLy8gdXAgY2hhbmdpbmcgdGhpcyBiZWhhdmlvciwgdGhpcyBtYXkgcmVxdWlyZSwgZm9yIGV4YW1wbGUsIGFuXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0bWVudCB0byB0aGUgdHlwZXMgb24gYHVwZGF0ZVF1ZXJ5YCBzaW5jZSB0aGF0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0cyB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBhbHdheXMgY29udGFpbnMgcHJldmlvdXMgcmVzdWx0XG4gICAgICAgICAgICAgICAgLy8gZGF0YSwgYnV0IG5vdCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IF90aGlzLmdldExhc3QoXCJyZXN1bHRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1cGRhdGVRdWVyeShsYXN0UmVzdWx0LmRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlUmVzdWx0OiBmZXRjaE1vcmVSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydFJlc3VsdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGFzdFJlc3VsdCksIHsgZGF0YTogZGF0YSB9KSwgX3RoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaE1vcmVSZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBjYWNoZSB3cml0ZXMgYWJvdmUgZGlkIG5vdCBnZW5lcmF0ZSBhIGJyb2FkY2FzdFxuICAgICAgICAgICAgLy8gbm90aWZpY2F0aW9uICh3aGljaCB3b3VsZCBoYXZlIGJlZW4gaW50ZXJjZXB0ZWQgYnkgb25XYXRjaFVwZGF0ZWQpLFxuICAgICAgICAgICAgLy8gbGlrZWx5IGJlY2F1c2UgdGhlIHdyaXR0ZW4gZGF0YSB3ZXJlIHRoZSBzYW1lIGFzIHdoYXQgd2FzIGFscmVhZHkgaW5cbiAgICAgICAgICAgIC8vIHRoZSBjYWNoZSwgd2Ugc3RpbGwgd2FudCBmZXRjaE1vcmUgdG8gZGVsaXZlciBpdHMgZmluYWwgbG9hZGluZzpmYWxzZVxuICAgICAgICAgICAgLy8gcmVzdWx0IHdpdGggdGhlIHVuY2hhbmdlZCBkYXRhLlxuICAgICAgICAgICAgaWYgKGlzQ2FjaGVkICYmICF1cGRhdGVkUXVlcnlTZXQuaGFzKF90aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgIHJlb2JzZXJ2ZUNhY2hlRmlyc3QoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFhYWCB0aGUgc3Vic2NyaXB0aW9uIHZhcmlhYmxlcyBhcmUgc2VwYXJhdGUgZnJvbSB0aGUgcXVlcnkgdmFyaWFibGVzLlxuICAgIC8vIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBzdWJzY3JpcHRpb24gdmFyaWFibGVzLCByaWdodCBub3cgeW91IGhhdmUgdG8gZG8gdGhhdCBzZXBhcmF0ZWx5LFxuICAgIC8vIGFuZCB5b3UgY2FuIG9ubHkgZG8gaXQgYnkgc3RvcHBpbmcgdGhlIHN1YnNjcmlwdGlvbiBhbmQgdGhlbiBzdWJzY3JpYmluZyBhZ2FpbiB3aXRoIG5ldyB2YXJpYWJsZXMuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGVuYWJsZXMgeW91IHRvIGV4ZWN1dGUgYSBbc3Vic2NyaXB0aW9uXShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2RhdGEvc3Vic2NyaXB0aW9ucy8pLCB1c3VhbGx5IHRvIHN1YnNjcmliZSB0byBzcGVjaWZpYyBmaWVsZHMgdGhhdCB3ZXJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBfYW5vdGhlcl8gZnVuY3Rpb24gdGhhdCB5b3UgY2FuIGNhbGwgdG8gdGVybWluYXRlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5zdWJzY3JpYmVUb01vcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5xdWVyeU1hbmFnZXJcbiAgICAgICAgICAgIC5zdGFydEdyYXBoUUxTdWJzY3JpcHRpb24oe1xuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMuZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVRdWVyeSA9IG9wdGlvbnMudXBkYXRlUXVlcnk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVF1ZXJ5KGZ1bmN0aW9uIChwcmV2aW91cywgX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUXVlcnkocHJldmlvdXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhOiBzdWJzY3JpcHRpb25EYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQuZXJyb3IoMjIsIGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlb2JzZXJ2ZShuZXdPcHRpb25zKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2lsZW50U2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKSB7XG4gICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gY29tcGFjdCh0aGlzLm9wdGlvbnMsIG5ld09wdGlvbnMgfHwge30pO1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBtZXJnZWRPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmFyaWFibGVzIG9mIHRoaXMgb2JzZXJ2YWJsZSBxdWVyeSwgYW5kIGZldGNoIHRoZSBuZXcgcmVzdWx0c1xuICAgICAqIGlmIHRoZXkndmUgY2hhbmdlZC4gTW9zdCB1c2VycyBzaG91bGQgcHJlZmVyIGByZWZldGNoYCBpbnN0ZWFkIG9mXG4gICAgICogYHNldFZhcmlhYmxlc2AgaW4gb3JkZXIgdG8gdG8gYmUgcHJvcGVybHkgbm90aWZpZWQgb2YgcmVzdWx0cyBldmVuIHdoZW5cbiAgICAgKiB0aGV5IGNvbWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgYG5leHRgIGNhbGxiYWNrIHdpbGwgKm5vdCogZmlyZSBpZiB0aGUgdmFyaWFibGVzIGhhdmUgbm90IGNoYW5nZWRcbiAgICAgKiBvciBpZiB0aGUgcmVzdWx0IGlzIGNvbWluZyBmcm9tIGNhY2hlLlxuICAgICAqXG4gICAgICogTm90ZTogdGhlIHByb21pc2Ugd2lsbCByZXR1cm4gdGhlIG9sZCByZXN1bHRzIGltbWVkaWF0ZWx5IGlmIHRoZSB2YXJpYWJsZXNcbiAgICAgKiBoYXZlIG5vdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogTm90ZTogdGhlIHByb21pc2Ugd2lsbCByZXR1cm4gbnVsbCBpbW1lZGlhdGVseSBpZiB0aGUgcXVlcnkgaXMgbm90IGFjdGl2ZVxuICAgICAqICh0aGVyZSBhcmUgbm8gc3Vic2NyaWJlcnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhcmlhYmxlcyAtIFRoZSBuZXcgc2V0IG9mIHZhcmlhYmxlcy4gSWYgdGhlcmUgYXJlIG1pc3NpbmcgdmFyaWFibGVzLFxuICAgICAqIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgdGhvc2UgdmFyaWFibGVzIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldFZhcmlhYmxlcyA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGVxdWFsKHRoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIG9ic2VydmVycywgdGhlbiB3ZSBkb24ndCBhY3R1YWxseSB3YW50IHRvIG1ha2UgYSBuZXR3b3JrXG4gICAgICAgICAgICAvLyByZXF1ZXN0LiBBcyBzb29uIGFzIHNvbWVvbmUgb2JzZXJ2ZXMgdGhlIHF1ZXJ5LCB0aGUgcmVxdWVzdCB3aWxsIGtpY2tcbiAgICAgICAgICAgIC8vIG9mZi4gRm9yIG5vdywgd2UganVzdCBzdG9yZSBhbnkgY2hhbmdlcy4gKFNlZSAjMTA3NylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5zaXplID8gdGhpcy5yZXN1bHQoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlXG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICAvLyBSZXNldCBvcHRpb25zLmZldGNoUG9saWN5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgIGZldGNoUG9saWN5OiB0aGlzLm9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgIH0sIE5ldHdvcmtTdGF0dXMuc2V0VmFyaWFibGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBlbmFibGVzIHlvdSB0byB1cGRhdGUgdGhlIHF1ZXJ5J3MgY2FjaGVkIHJlc3VsdCB3aXRob3V0IGV4ZWN1dGluZyBhIGZvbGxvd3VwIEdyYXBoUUwgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogU2VlIFt1c2luZyB1cGRhdGVRdWVyeSBhbmQgdXBkYXRlRnJhZ21lbnRdKGh0dHBzOi8vd3d3LmFwb2xsb2dyYXBocWwuY29tL2RvY3MvcmVhY3QvY2FjaGluZy9jYWNoZS1pbnRlcmFjdGlvbi8jdXNpbmctdXBkYXRlcXVlcnktYW5kLXVwZGF0ZWZyYWdtZW50KSBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnVwZGF0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG1hcEZuKSB7XG4gICAgICAgIHZhciBxdWVyeU1hbmFnZXIgPSB0aGlzLnF1ZXJ5TWFuYWdlcjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHF1ZXJ5TWFuYWdlci5jYWNoZS5kaWZmKHtcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLm9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHRoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgfSkucmVzdWx0O1xuICAgICAgICB2YXIgbmV3UmVzdWx0ID0gbWFwRm4ocmVzdWx0LCB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IHRoaXMudmFyaWFibGVzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld1Jlc3VsdCkge1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLmNhY2hlLndyaXRlUXVlcnkoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLm9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICAgICAgZGF0YTogbmV3UmVzdWx0LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdGhpcy52YXJpYWJsZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBpbnN0cnVjdHMgdGhlIHF1ZXJ5IHRvIGJlZ2luIHJlLWV4ZWN1dGluZyBhdCBhIHNwZWNpZmllZCBpbnRlcnZhbCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IHBvbGxJbnRlcnZhbDtcbiAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgaW5zdHJ1Y3RzIHRoZSBxdWVyeSB0byBzdG9wIHBvbGxpbmcgYWZ0ZXIgYSBwcmV2aW91cyBjYWxsIHRvIGBzdGFydFBvbGxpbmdgLlxuICAgICAqL1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc3RvcFBvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb2xsSW50ZXJ2YWwgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvbGxpbmcoKTtcbiAgICB9O1xuICAgIC8vIFVwZGF0ZSBvcHRpb25zLmZldGNoUG9saWN5IGFjY29yZGluZyB0byBvcHRpb25zLm5leHRGZXRjaFBvbGljeS5cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmFwcGx5TmV4dEZldGNoUG9saWN5ID0gZnVuY3Rpb24gKHJlYXNvbiwgXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0byB1c2UgdGhpcyBtZXRob2QgdG8gYXBwbHkgb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kgdG9cbiAgICAvLyBvcHRpb25zLmZldGNoUG9saWN5IGV2ZW4gaWYgb3B0aW9ucyAhPT0gdGhpcy5vcHRpb25zLCB0aG91Z2ggdGhhdCBoYXBwZW5zXG4gICAgLy8gbW9zdCBvZnRlbiB3aGVuIHRoZSBvcHRpb25zIGFyZSB0ZW1wb3JhcnksIHVzZWQgZm9yIG9ubHkgb25lIHJlcXVlc3QgYW5kXG4gICAgLy8gdGhlbiB0aHJvd24gYXdheSwgc28gbmV4dEZldGNoUG9saWN5IG1heSBub3QgZW5kIHVwIG1hdHRlcmluZy5cbiAgICBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5leHRGZXRjaFBvbGljeSkge1xuICAgICAgICAgICAgdmFyIF9hID0gb3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfYSA9PT0gdm9pZCAwID8gXCJjYWNoZS1maXJzdFwiIDogX2EsIF9iID0gb3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3ksIGluaXRpYWxGZXRjaFBvbGljeSA9IF9iID09PSB2b2lkIDAgPyBmZXRjaFBvbGljeSA6IF9iO1xuICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSBcInN0YW5kYnlcIikge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcsIGxlYXZpbmcgb3B0aW9ucy5mZXRjaFBvbGljeSB1bmNoYW5nZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gc29tZW9uZSBjaG9vc2VzIFwiY2FjaGUtYW5kLW5ldHdvcmtcIiBvciBcIm5ldHdvcmstb25seVwiIGFzIHRoZWlyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbCBGZXRjaFBvbGljeSwgdGhleSBvZnRlbiBkbyBub3Qgd2FudCBmdXR1cmUgY2FjaGUgdXBkYXRlcyB0b1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgdW5jb25kaXRpb25hbCBuZXR3b3JrIHJlcXVlc3RzLCB3aGljaCBpcyB3aGF0IHJlcGVhdGVkbHlcbiAgICAgICAgICAgICAgICAvLyBhcHBseWluZyB0aGUgXCJjYWNoZS1hbmQtbmV0d29ya1wiIG9yIFwibmV0d29yay1vbmx5XCIgcG9saWNpZXMgd291bGRcbiAgICAgICAgICAgICAgICAvLyBzZWVtIHRvIGltcGx5LiBJbnN0ZWFkLCB3aGVuIHRoZSBjYWNoZSByZXBvcnRzIGFuIHVwZGF0ZSBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIG5ldHdvcmsgcmVxdWVzdCwgaXQgbWF5IGJlIGRlc2lyYWJsZSBmb3Igc3Vic2VxdWVudCBuZXR3b3JrXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgdG8gYmUgdHJpZ2dlcmVkIG9ubHkgaWYgdGhlIGNhY2hlIHJlc3VsdCBpcyBpbmNvbXBsZXRlLiBUb1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgZW5kLCB0aGUgb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kgb3B0aW9uIHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9wdGlvbnMuZmV0Y2hQb2xpY3kgYWZ0ZXIgdGhlIGluaXRpYWwgbmV0d29yayByZXF1ZXN0LCB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gaGF2aW5nIHRvIGNhbGwgb2JzZXJ2YWJsZVF1ZXJ5LnNldE9wdGlvbnMuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IG9wdGlvbnMubmV4dEZldGNoUG9saWN5KGZldGNoUG9saWN5LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3k6IGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlYXNvbiA9PT0gXCJ2YXJpYWJsZXMtY2hhbmdlZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IGluaXRpYWxGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPSBvcHRpb25zLm5leHRGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucywgbmV3TmV0d29ya1N0YXR1cywgcXVlcnkpIHtcbiAgICAgICAgLy8gVE9ETyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSBuZXR3b3JrU3RhdHVzIChhbmQgaW5mZXIgZmV0Y2hWYXJpYWJsZXMpXG4gICAgICAgIC8vIGJlZm9yZSBhY3R1YWxseSBjb21taXR0aW5nIHRvIHRoZSBmZXRjaC5cbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc2V0T2JzZXJ2YWJsZVF1ZXJ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXJbXCJmZXRjaENvbmNhc3RXaXRoSW5mb1wiXSh0aGlzLnF1ZXJ5SWQsIG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMsIHF1ZXJ5KTtcbiAgICB9O1xuICAgIC8vIFR1cm5zIHBvbGxpbmcgb24gb3Igb2ZmIGJhc2VkIG9uIHRoaXMub3B0aW9ucy5wb2xsSW50ZXJ2YWwuXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBdm9pZCBwb2xsaW5nIGluIFNTUiBtb2RlXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5TWFuYWdlci5zc3JNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgcG9sbGluZ0luZm8gPSBfYS5wb2xsaW5nSW5mbywgcG9sbEludGVydmFsID0gX2Eub3B0aW9ucy5wb2xsSW50ZXJ2YWw7XG4gICAgICAgIGlmICghcG9sbEludGVydmFsIHx8ICF0aGlzLmhhc09ic2VydmVycygpKSB7XG4gICAgICAgICAgICBpZiAocG9sbGluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocG9sbGluZ0luZm8udGltZW91dCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucG9sbGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbGxpbmdJbmZvICYmIHBvbGxpbmdJbmZvLmludGVydmFsID09PSBwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQocG9sbEludGVydmFsLCAyMyk7XG4gICAgICAgIHZhciBpbmZvID0gcG9sbGluZ0luZm8gfHwgKHRoaXMucG9sbGluZ0luZm8gPSB7fSk7XG4gICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgIHZhciBtYXliZUZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wb2xsaW5nSW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KF90aGlzLnF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKChfYiA9IChfYSA9IF90aGlzLm9wdGlvbnMpLnNraXBQb2xsQXR0ZW1wdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW9ic2VydmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9zdCBmZXRjaFBvbGljeSBvcHRpb25zIGRvbid0IG1ha2Ugc2Vuc2UgdG8gdXNlIGluIGEgcG9sbGluZyBjb250ZXh0LCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlcnMgd291bGRuJ3Qgd2FudCB0byBiZSBwb2xsaW5nIHRoZSBjYWNoZSBkaXJlY3RseS4gSG93ZXZlciwgbmV0d29yay1vbmx5IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tY2FjaGUgYXJlIGJvdGggdXNlZnVsIGZvciB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGNvbnRyb2wgd2hldGhlciBvciBub3QgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2xsZWQgcmVzdWx0cyBhcmUgd3JpdHRlbiB0byB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogX3RoaXMub3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuby1jYWNoZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5ldHdvcmstb25seVwiLFxuICAgICAgICAgICAgICAgICAgICB9LCBOZXR3b3JrU3RhdHVzLnBvbGwpLnRoZW4ocG9sbCwgcG9sbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gX3RoaXMucG9sbGluZ0luZm87XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmZvLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGluZm8udGltZW91dCA9IHNldFRpbWVvdXQobWF5YmVGZXRjaCwgaW5mby5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBvbGwoKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudXBkYXRlTGFzdFJlc3VsdCA9IGZ1bmN0aW9uIChuZXdSZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5nZXRMYXN0RXJyb3IoKTtcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcy5sYXN0LmVycm9yIHVubGVzcyB0aGUgdmFyaWFibGVzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMubGFzdCAmJiAhZXF1YWwodmFyaWFibGVzLCB0aGlzLmxhc3QudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmxhc3QgPSBfX2Fzc2lnbih7IHJlc3VsdDogdGhpcy5xdWVyeU1hbmFnZXIuYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA/XG4gICAgICAgICAgICAgICAgbmV3UmVzdWx0XG4gICAgICAgICAgICAgICAgOiBjbG9uZURlZXAobmV3UmVzdWx0KSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSwgKGVycm9yID8geyBlcnJvcjogZXJyb3IgfSA6IG51bGwpKSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlb2JzZXJ2ZUFzQ29uY2FzdCA9IGZ1bmN0aW9uIChuZXdPcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgdXNlRGlzcG9zYWJsZUNvbmNhc3QgPSBcbiAgICAgICAgLy8gUmVmZXRjaGluZyB1c2VzIGEgZGlzcG9zYWJsZSBDb25jYXN0IHRvIGFsbG93IHJlZmV0Y2hlcyB1c2luZyBkaWZmZXJlbnRcbiAgICAgICAgLy8gb3B0aW9ucy92YXJpYWJsZXMsIHdpdGhvdXQgcGVybWFuZW50bHkgYWx0ZXJpbmcgdGhlIG9wdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIE9ic2VydmFibGVRdWVyeS5cbiAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5yZWZldGNoIHx8XG4gICAgICAgICAgICAvLyBUaGUgZmV0Y2hNb3JlIG1ldGhvZCBkb2VzIG5vdCBhY3R1YWxseSBjYWxsIHRoZSByZW9ic2VydmUgbWV0aG9kLCBidXQsXG4gICAgICAgICAgICAvLyBpZiBpdCBkaWQsIGl0IHdvdWxkIGRlZmluaXRlbHkgdXNlIGEgZGlzcG9zYWJsZSBDb25jYXN0LlxuICAgICAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUgfHxcbiAgICAgICAgICAgIC8vIFBvbGxpbmcgdXNlcyBhIGRpc3Bvc2FibGUgQ29uY2FzdCBzbyB0aGUgcG9sbGluZyBvcHRpb25zICh3aGljaCBmb3JjZVxuICAgICAgICAgICAgLy8gZmV0Y2hQb2xpY3kgdG8gYmUgXCJuZXR3b3JrLW9ubHlcIiBvciBcIm5vLWNhY2hlXCIpIHdvbid0IG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBvcHRpb25zLlxuICAgICAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5wb2xsO1xuICAgICAgICAvLyBTYXZlIHRoZSBvbGQgdmFyaWFibGVzLCBzaW5jZSBPYmplY3QuYXNzaWduIG1heSBtb2RpZnkgdGhlbSBiZWxvdy5cbiAgICAgICAgdmFyIG9sZFZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgIHZhciBvbGRGZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBjb21wYWN0KHRoaXMub3B0aW9ucywgbmV3T3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdXNlRGlzcG9zYWJsZUNvbmNhc3QgP1xuICAgICAgICAgICAgLy8gRGlzcG9zYWJsZSBDb25jYXN0IGZldGNoZXMgcmVjZWl2ZSBhIHNoYWxsb3cgY29weSBvZiB0aGlzLm9wdGlvbnNcbiAgICAgICAgICAgIC8vIChtZXJnZWQgd2l0aCBuZXdPcHRpb25zKSwgbGVhdmluZyB0aGlzLm9wdGlvbnMgdW5tb2RpZmllZC5cbiAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNcbiAgICAgICAgICAgIDogYXNzaWduKHRoaXMub3B0aW9ucywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSBvcHRpb25zLnF1ZXJ5IHdpdGggdGhlIHRyYW5zZm9ybWVkIHF1ZXJ5IHRvIGF2b2lkXG4gICAgICAgIC8vIG92ZXJ3cml0aW5nIHRoaXMub3B0aW9ucy5xdWVyeSB3aGVuIHdlIGFyZW4ndCB1c2luZyBhIGRpc3Bvc2FibGUgY29uY2FzdC5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBlbnN1cmUgd2UgY2FuIHJlLXJ1biB0aGUgY3VzdG9tIGRvY3VtZW50IHRyYW5zZm9ybXMgdGhlIG5leHRcbiAgICAgICAgLy8gdGltZSBhIHJlcXVlc3QgaXMgbWFkZSBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBxdWVyeS5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1Eb2N1bWVudChvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgdGhpcy5sYXN0UXVlcnkgPSBxdWVyeTtcbiAgICAgICAgaWYgKCF1c2VEaXNwb3NhYmxlQ29uY2FzdCkge1xuICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgY2FsbGluZyB1cGRhdGVQb2xsaW5nIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGlzLm9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvbGxpbmcoKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IG9wdGlvbnMuZmV0Y2hQb2xpY3kgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIHdoZW4gdmFyaWFibGVzIGNoYW5nZSxcbiAgICAgICAgICAgIC8vIHVubGVzcyBhIG5ldyBmZXRjaFBvbGljeSB3YXMgcHJvdmlkZWQgYnkgbmV3T3B0aW9ucy5cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zICYmXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy52YXJpYWJsZXMgJiZcbiAgICAgICAgICAgICAgICAhZXF1YWwobmV3T3B0aW9ucy52YXJpYWJsZXMsIG9sZFZhcmlhYmxlcykgJiZcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtZXNzIHdpdGggdGhlIGZldGNoUG9saWN5IGlmIGl0J3MgY3VycmVudGx5IFwic3RhbmRieVwiLlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgIT09IFwic3RhbmRieVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgY2hhbmdpbmcgdGhlIGZldGNoUG9saWN5IGFueXdheSwgZG9uJ3QgdHJ5IHRvIGNoYW5nZSBpdCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgYXBwbHlOZXh0RmV0Y2hQb2xpY3kuIFRoZSBleHBsaWNpdCBvcHRpb25zLmZldGNoUG9saWN5IHdpbnMuXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IG9sZEZldGNoUG9saWN5IHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYG5leHRGZXRjaFBvbGljeWAgZnVuY3Rpb24gaGFzIGV2ZW4gaGlnaGVyIHByaW9yaXR5LCB0aG91Z2gsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGluIHRoYXQgY2FzZSBgYXBwbHlOZXh0RmV0Y2hQb2xpY3lgIG11c3QgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TmV4dEZldGNoUG9saWN5KFwidmFyaWFibGVzLWNoYW5nZWRcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld05ldHdvcmtTdGF0dXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5zZXRWYXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdEZvck93blJlc3VsdCAmJiAodGhpcy53YWl0Rm9yT3duUmVzdWx0ID0gc2tpcENhY2hlRGF0YUZvcihvcHRpb25zLmZldGNoUG9saWN5KSk7XG4gICAgICAgIHZhciBmaW5pc2hXYWl0aW5nRm9yT3duUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmNhc3QgPT09IGNvbmNhc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWl0Rm9yT3duUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyAmJiBfX2Fzc2lnbih7fSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmZldGNoKG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMsIHF1ZXJ5KSwgY29uY2FzdCA9IF9hLmNvbmNhc3QsIGZyb21MaW5rID0gX2EuZnJvbUxpbms7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoX3RoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFdhaXRpbmdGb3JPd25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbChfdGhpcy52YXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29taW5nIGZyb20gYGdldFJlc3VsdHNGcm9tTGlua2AsIGBlcnJvcmAgaGVyZSBzaG91bGQgYWx3YXlzIGJlIGFuIGBBcG9sbG9FcnJvcmAuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGNhbGxpbmcgYGNvbmNhc3QuY2FuY2VsYCBjYW4gaW5qZWN0IGFub3RoZXIgdHlwZSBvZiBlcnJvciwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB3cmFwIGl0IGFnYWluIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcG9sbG9FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEFwb2xsb0Vycm9yKHsgbmV0d29ya0Vycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hXYWl0aW5nRm9yT3duUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydEVycm9yKGVycm9yLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdXNlRGlzcG9zYWJsZUNvbmNhc3QgJiYgKGZyb21MaW5rIHx8ICF0aGlzLmNvbmNhc3QpKSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHthZGQscmVtb3ZlfU9ic2VydmVyIG1ldGhvZHMgZGlyZWN0bHkgdG8gYXZvaWQgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIHdpdGggYW4gdW5uZWNlc3NhcnkgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHRoaXMuY29uY2FzdCAmJiB0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25jYXN0LnJlbW92ZU9ic2VydmVyKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25jYXN0ID0gY29uY2FzdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25jYXN0LmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhc3Q7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlb2JzZXJ2ZSA9IGZ1bmN0aW9uIChuZXdPcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlb2JzZXJ2ZUFzQ29uY2FzdChuZXdPcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKVxuICAgICAgICAgICAgLnByb21pc2U7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc3Vic2NyaWJlQWZ0ZXJFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBgbGFzdEVycm9yYCBpcyBzZXQgaW4gdGhlIGN1cnJlbnQgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlLWNyZWF0ZWQsXG4gICAgICAgIC8vIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBpbW1lZGlhdGVseSByZWNlaXZlIHRoZSBlcnJvciwgd2hpY2ggd2lsbFxuICAgICAgICAvLyBjYXVzZSBpdCB0byB0ZXJtaW5hdGUgYWdhaW4uIFRvIGF2b2lkIHRoaXMsIHdlIGZpcnN0IGNsZWFyXG4gICAgICAgIC8vIHRoZSBsYXN0IGVycm9yL3Jlc3VsdCBmcm9tIHRoZSBgb2JzZXJ2YWJsZVF1ZXJ5YCBiZWZvcmUgcmUtc3RhcnRpbmdcbiAgICAgICAgLy8gdGhlIHN1YnNjcmlwdGlvbiwgYW5kIHJlc3RvcmUgdGhlIGxhc3QgdmFsdWUgYWZ0ZXJ3YXJkcyBzbyB0aGF0IHRoZVxuICAgICAgICAvLyBzdWJzY3JpcHRpb24gaGFzIGEgY2hhbmNlIHRvIHN0YXkgb3Blbi5cbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmxhc3Q7XG4gICAgICAgIHRoaXMucmVzZXRMYXN0UmVzdWx0cygpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRoaXMubGFzdCA9IGxhc3Q7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvLyAoUmUpZGVsaXZlciB0aGUgY3VycmVudCByZXN1bHQgdG8gdGhpcy5vYnNlcnZlcnMgd2l0aG91dCBhcHBseWluZyBmZXRjaFxuICAgIC8vIHBvbGljaWVzIG9yIG1ha2luZyBuZXR3b3JrIHJlcXVlc3RzLlxuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRSZXN1bHQoXG4gICAgICAgIC8vIFBhc3NpbmcgZmFsc2UgaXMgaW1wb3J0YW50IHNvIHRoYXQgdGhpcy5nZXRDdXJyZW50UmVzdWx0IGRvZXNuJ3RcbiAgICAgICAgLy8gc2F2ZSB0aGUgZmV0Y2hNb3JlIHJlc3VsdCBhcyB0aGlzLmxhc3RSZXN1bHQsIGNhdXNpbmcgaXQgdG8gYmVcbiAgICAgICAgLy8gaWdub3JlZCBkdWUgdG8gdGhlIHRoaXMuaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdCBjaGVjayBpblxuICAgICAgICAvLyB0aGlzLnJlcG9ydFJlc3VsdC5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UmVzdWx0KGZhbHNlKSwgdGhpcy52YXJpYWJsZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXBvcnRSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RFcnJvciA9IHRoaXMuZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgIHZhciBpc0RpZmZlcmVudCA9IHRoaXMuaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdChyZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCByZXN1bHQgZXZlbiB3aGVuIGlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQgcmV0dXJucyBmYWxzZSxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgcXVlcnkgbWF5IGJlIHVzaW5nIHRoZSBAbm9ucmVhY3RpdmUgZGlyZWN0aXZlLCBhbmQgd2Ugd2FudCB0b1xuICAgICAgICAvLyBzYXZlIHRoZSB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgYW55IG5vbnJlYWN0aXZlIHN1YnRyZWVzIChpbiBjYXNlXG4gICAgICAgIC8vIGdldEN1cnJlbnRSZXN1bHQgaXMgY2FsbGVkKSwgZXZlbiB0aG91Z2ggd2Ugc2tpcCBicm9hZGNhc3RpbmcgY2hhbmdlcy5cbiAgICAgICAgaWYgKGxhc3RFcnJvciB8fCAhcmVzdWx0LnBhcnRpYWwgfHwgdGhpcy5vcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0LCB2YXJpYWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyb3IgfHwgaXNEaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkodGhpcy5vYnNlcnZlcnMsIFwibmV4dFwiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgZ2V0IHRoZSBjdXJyZW50IHJlc3VsdCBvbiBlcnJvcnMsIG9ubHkgdGhlIGVycm9yLCB3ZVxuICAgICAgICAvLyBtdXN0IG1pcnJvciB0aGUgdXBkYXRlcyB0aGF0IG9jY3VyIGluIFF1ZXJ5U3RvcmUubWFya1F1ZXJ5RXJyb3IgaGVyZVxuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5nZXRMYXN0UmVzdWx0KCkpLCB7IGVycm9yOiBlcnJvciwgZXJyb3JzOiBlcnJvci5ncmFwaFFMRXJyb3JzLCBuZXR3b3JrU3RhdHVzOiBOZXR3b3JrU3RhdHVzLmVycm9yLCBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXN0UmVzdWx0KGVycm9yUmVzdWx0LCB2YXJpYWJsZXMpO1xuICAgICAgICBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KHRoaXMub2JzZXJ2ZXJzLCBcImVycm9yXCIsICh0aGlzLmxhc3QuZXJyb3IgPSBlcnJvcikpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5oYXNPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5zaXplID4gMDtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudGVhckRvd25RdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUb3JuRG93bilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuY29uY2FzdCAmJiB0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmNhc3QucmVtb3ZlT2JzZXJ2ZXIodGhpcy5vYnNlcnZlcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb25jYXN0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAvLyBzdG9wIGFsbCBhY3RpdmUgR3JhcGhRTCBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLnN0b3BRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSB0cnVlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIudHJhbnNmb3JtKGRvY3VtZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlUXVlcnk7XG59KE9ic2VydmFibGUpKTtcbmV4cG9ydCB7IE9ic2VydmFibGVRdWVyeSB9O1xuLy8gTmVjZXNzYXJ5IGJlY2F1c2UgdGhlIE9ic2VydmFibGVRdWVyeSBjb25zdHJ1Y3RvciBoYXMgYSBkaWZmZXJlbnRcbi8vIHNpZ25hdHVyZSB0aGFuIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yLlxuZml4T2JzZXJ2YWJsZVN1YmNsYXNzKE9ic2VydmFibGVRdWVyeSk7XG4vLyBSZW9ic2VydmUgd2l0aCBmZXRjaFBvbGljeSBlZmZlY3RpdmVseSBzZXQgdG8gXCJjYWNoZS1maXJzdFwiLCB0cmlnZ2VyaW5nXG4vLyBkZWxpdmVyeSBvZiBhbnkgbmV3IGRhdGEgZnJvbSB0aGUgY2FjaGUsIHBvc3NpYmx5IGZhbGxpbmcgYmFjayB0byB0aGUgbmV0d29ya1xuLy8gaWYgYW55IGNhY2hlIGRhdGEgYXJlIG1pc3NpbmcuIFRoaXMgYWxsb3dzIF9jb21wbGV0ZV8gY2FjaGUgcmVzdWx0cyB0byBiZVxuLy8gZGVsaXZlcmVkIHdpdGhvdXQgYWxzbyBraWNraW5nIG9mZiB1bm5lY2Vzc2FyeSBuZXR3b3JrIHJlcXVlc3RzIHdoZW5cbi8vIHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeSBpcyBcImNhY2hlLWFuZC1uZXR3b3JrXCIgb3IgXCJuZXR3b3JrLW9ubHlcIi4gV2hlblxuLy8gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5IGlzIGFueSBvdGhlciBwb2xpY3kgKFwiY2FjaGUtZmlyc3RcIiwgXCJjYWNoZS1vbmx5XCIsXG4vLyBcInN0YW5kYnlcIiwgb3IgXCJuby1jYWNoZVwiKSwgd2UgY2FsbCB0aGlzLnJlb2JzZXJ2ZSgpIGFzIHVzdWFsLlxuZXhwb3J0IGZ1bmN0aW9uIHJlb2JzZXJ2ZUNhY2hlRmlyc3Qob2JzUXVlcnkpIHtcbiAgICB2YXIgX2EgPSBvYnNRdWVyeS5vcHRpb25zLCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCBuZXh0RmV0Y2hQb2xpY3kgPSBfYS5uZXh0RmV0Y2hQb2xpY3k7XG4gICAgaWYgKGZldGNoUG9saWN5ID09PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIgfHwgZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIG9ic1F1ZXJ5LnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICBmZXRjaFBvbGljeTogXCJjYWNoZS1maXJzdFwiLFxuICAgICAgICAgICAgLy8gVXNlIGEgdGVtcG9yYXJ5IG5leHRGZXRjaFBvbGljeSBmdW5jdGlvbiB0aGF0IHJlcGxhY2VzIGl0c2VsZiB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgbmV4dEZldGNoUG9saWN5IHZhbHVlIGFuZCByZXR1cm5zIHRoZSBvcmlnaW5hbCBmZXRjaFBvbGljeS5cbiAgICAgICAgICAgIG5leHRGZXRjaFBvbGljeTogZnVuY3Rpb24gKGN1cnJlbnRGZXRjaFBvbGljeSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhpcyBuZXh0RmV0Y2hQb2xpY3kgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgdGhpcy5vcHRpb25zLm5leHRGZXRjaFBvbGljeSB2YWx1ZS5cbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGZXRjaFBvbGljeSA9IG5leHRGZXRjaFBvbGljeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgbmV4dEZldGNoUG9saWN5IHZhbHVlIHdhcyBhIGZ1bmN0aW9uLCBnaXZlIGl0IGFcbiAgICAgICAgICAgICAgICAvLyBjaGFuY2UgdG8gZGVjaWRlIHdoYXQgaGFwcGVucyBoZXJlLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5uZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0RmV0Y2hQb2xpY3koY3VycmVudEZldGNoUG9saWN5LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdvIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic1F1ZXJ5LnJlb2JzZXJ2ZSgpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjayhlcnJvcikge1xuICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmVycm9yKDI0LCBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjayk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKG1pc3NpbmcpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBtaXNzaW5nKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmRlYnVnKDI1LCBtaXNzaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQ2FjaGVEYXRhRm9yKGZldGNoUG9saWN5IC8qIGB1bmRlZmluZWRgIHdvdWxkIG1lYW4gYFwiY2FjaGUtZmlyc3RcImAgKi8pIHtcbiAgICByZXR1cm4gKGZldGNoUG9saWN5ID09PSBcIm5ldHdvcmstb25seVwiIHx8XG4gICAgICAgIGZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIgfHxcbiAgICAgICAgZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVRdWVyeS5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX2V4dGVuZHMiLCJpbnZhcmlhbnQiLCJlcXVhbCIsIk5ldHdvcmtTdGF0dXMiLCJpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQiLCJjbG9uZURlZXAiLCJjb21wYWN0IiwiZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiIsIk9ic2VydmFibGUiLCJpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5IiwiZml4T2JzZXJ2YWJsZVN1YmNsYXNzIiwiZ2V0UXVlcnlEZWZpbml0aW9uIiwiQXBvbGxvRXJyb3IiLCJpc0Fwb2xsb0Vycm9yIiwiZXF1YWxCeVF1ZXJ5IiwiYXNzaWduIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJPYnNlcnZhYmxlUXVlcnkiLCJfc3VwZXIiLCJfYSIsInF1ZXJ5TWFuYWdlciIsInF1ZXJ5SW5mbyIsIm9wdGlvbnMiLCJfdGhpcyIsImNhbGwiLCJvYnNlcnZlciIsInN1Yk9ic2VydmVyIiwiX3N1YnNjcmlwdGlvbiIsIl9vYnNlcnZlciIsImVycm9yIiwiZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjayIsImZpcnN0Iiwib2JzZXJ2ZXJzIiwic2l6ZSIsImFkZCIsImxhc3QiLCJyZXN1bHQiLCJuZXh0IiwicmVvYnNlcnZlIiwiY2F0Y2giLCJkZWxldGUiLCJ0ZWFyRG93blF1ZXJ5IiwiU2V0Iiwic3Vic2NyaXB0aW9ucyIsIndhaXRGb3JPd25SZXN1bHQiLCJza2lwQ2FjaGVEYXRhRm9yIiwiZmV0Y2hQb2xpY3kiLCJpc1Rvcm5Eb3duIiwic3Vic2NyaWJlVG9Nb3JlIiwiYmluZCIsIl9iIiwiZGVmYXVsdE9wdGlvbnMiLCJ3YXRjaFF1ZXJ5IiwiX2MiLCJfZCIsImRlZmF1bHRGZXRjaFBvbGljeSIsIl9lIiwiX2YiLCJpbml0aWFsRmV0Y2hQb2xpY3kiLCJxdWVyeUlkIiwiZ2VuZXJhdGVRdWVyeUlkIiwib3BEZWYiLCJxdWVyeSIsInF1ZXJ5TmFtZSIsIm5hbWUiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwibGFzdFF1ZXJ5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhcmlhYmxlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVtb3ZlUXVlcnkiLCJzZXRUaW1lb3V0Iiwic3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJyZXNldERpZmYiLCJnZXRDdXJyZW50UmVzdWx0Iiwic2F2ZUFzTGFzdFJlc3VsdCIsImxhc3RSZXN1bHQiLCJnZXRMYXN0UmVzdWx0IiwibmV0d29ya1N0YXR1cyIsInJlYWR5IiwibG9hZGluZyIsImdldERvY3VtZW50SW5mbyIsImhhc0ZvcmNlZFJlc29sdmVycyIsImRpZmYiLCJnZXREaWZmIiwiY29tcGxldGUiLCJyZXR1cm5QYXJ0aWFsRGF0YSIsImRhdGEiLCJwYXJ0aWFsIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJwYXJ0aWFsUmVmZXRjaCIsImxvZ01pc3NpbmdGaWVsZEVycm9ycyIsIm1pc3NpbmciLCJ1cGRhdGVMYXN0UmVzdWx0IiwiaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdCIsIm5ld1Jlc3VsdCIsInJlc3VsdElzRGlmZmVyZW50IiwiaGFzTm9ucmVhY3RpdmVEaXJlY3RpdmUiLCJnZXRMYXN0Iiwia2V5IiwidmFyaWFibGVzTXVzdE1hdGNoIiwiZ2V0TGFzdEVycm9yIiwicmVzZXRMYXN0UmVzdWx0cyIsInJlc2V0UXVlcnlTdG9yZUVycm9ycyIsInJlc2V0RXJyb3JzIiwicmVmZXRjaCIsInJlb2JzZXJ2ZU9wdGlvbnMiLCJwb2xsSW50ZXJ2YWwiLCJxdWVyeURlZiIsInZhcnMiLCJ2YXJpYWJsZURlZmluaXRpb25zIiwic29tZSIsInYiLCJ2YXJpYWJsZSIsIndhcm4iLCJyZXNldExhc3RXcml0ZSIsImZldGNoTW9yZSIsImZldGNoTW9yZU9wdGlvbnMiLCJjb21iaW5lZE9wdGlvbnMiLCJ0cmFuc2Zvcm1Eb2N1bWVudCIsInFpZCIsIm9yaWdpbmFsTmV0d29ya1N0YXR1cyIsIm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSIsIm9ic2VydmUiLCJ1cGRhdGVkUXVlcnlTZXQiLCJ1cGRhdGVRdWVyeSIsImlzQ2FjaGVkIiwiZmV0Y2hRdWVyeSIsInRoZW4iLCJmZXRjaE1vcmVSZXN1bHQiLCJjYWNoZSIsImJhdGNoIiwidXBkYXRlIiwib3B0aW1pc3RpYyIsInByZXZpb3VzIiwid3JpdGVRdWVyeSIsIm9uV2F0Y2hVcGRhdGVkIiwid2F0Y2giLCJyZXBvcnRSZXN1bHQiLCJmaW5hbGx5IiwiaGFzIiwicmVvYnNlcnZlQ2FjaGVGaXJzdCIsInN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbiIsImRvY3VtZW50IiwiY29udGV4dCIsInN1YnNjcmlwdGlvbkRhdGEiLCJlcnIiLCJvbkVycm9yIiwic2V0T3B0aW9ucyIsIm5ld09wdGlvbnMiLCJzaWxlbnRTZXRPcHRpb25zIiwibWVyZ2VkT3B0aW9ucyIsInNldFZhcmlhYmxlcyIsIm1hcEZuIiwiYnJvYWRjYXN0UXVlcmllcyIsInN0YXJ0UG9sbGluZyIsInVwZGF0ZVBvbGxpbmciLCJzdG9wUG9sbGluZyIsImFwcGx5TmV4dEZldGNoUG9saWN5IiwicmVhc29uIiwibmV4dEZldGNoUG9saWN5Iiwib2JzZXJ2YWJsZSIsImZldGNoIiwibmV3TmV0d29ya1N0YXR1cyIsInNldE9ic2VydmFibGVRdWVyeSIsInNzck1vZGUiLCJwb2xsaW5nSW5mbyIsImhhc09ic2VydmVycyIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJpbnRlcnZhbCIsImluZm8iLCJtYXliZUZldGNoIiwic2tpcFBvbGxBdHRlbXB0IiwicG9sbCIsImFzc3VtZUltbXV0YWJsZVJlc3VsdHMiLCJyZW9ic2VydmVBc0NvbmNhc3QiLCJ1c2VEaXNwb3NhYmxlQ29uY2FzdCIsIm9sZFZhcmlhYmxlcyIsIm9sZEZldGNoUG9saWN5IiwiZmluaXNoV2FpdGluZ0Zvck93blJlc3VsdCIsImNvbmNhc3QiLCJmcm9tTGluayIsIm5ldHdvcmtFcnJvciIsInJlcG9ydEVycm9yIiwicmVtb3ZlT2JzZXJ2ZXIiLCJhZGRPYnNlcnZlciIsInByb21pc2UiLCJyZXN1YnNjcmliZUFmdGVyRXJyb3IiLCJhcmdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsImxhc3RFcnJvciIsImlzRGlmZmVyZW50IiwiZXJyb3JSZXN1bHQiLCJlcnJvcnMiLCJncmFwaFFMRXJyb3JzIiwiZm9yRWFjaCIsInN1YiIsImNsZWFyIiwic3RvcFF1ZXJ5IiwidHJhbnNmb3JtIiwib2JzUXVlcnkiLCJjdXJyZW50RmV0Y2hQb2xpY3kiLCJtZXNzYWdlIiwic3RhY2siLCJkZWJ1ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/QueryInfo.js":
/*!*******************************************************!*\
  !*** ./node_modules/@apollo/client/core/QueryInfo.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryInfo: function() { return /* binding */ QueryInfo; },\n/* harmony export */   shouldWriteResult: function() { return /* binding */ shouldWriteResult; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js\");\n/* harmony import */ var _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObservableQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/errorHandling.js\");\n/* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./networkStatus.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\");\n\n\n\n\n\n\n\nvar destructiveMethodCounts = new (_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n    var original = cache[methodName];\n    if (typeof original === \"function\") {\n        // @ts-expect-error this is just too generic to be typed correctly\n        cache[methodName] = function() {\n            destructiveMethodCounts.set(cache, // The %1e15 allows the count to wrap around to 0 safely every\n            // quadrillion evictions, so there's no risk of overflow. To be\n            // clear, this is more of a pedantic principle than something\n            // that matters in any conceivable practical scenario.\n            (destructiveMethodCounts.get(cache) + 1) % 1e15);\n            // @ts-expect-error this is just too generic to be typed correctly\n            return original.apply(this, arguments);\n        };\n    }\n}\nfunction cancelNotifyTimeout(info) {\n    if (info[\"notifyTimeout\"]) {\n        clearTimeout(info[\"notifyTimeout\"]);\n        info[\"notifyTimeout\"] = void 0;\n    }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */ function() {\n    function QueryInfo(queryManager, queryId) {\n        if (queryId === void 0) {\n            queryId = queryManager.generateQueryId();\n        }\n        this.queryId = queryId;\n        this.listeners = new Set();\n        this.document = null;\n        this.lastRequestId = 1;\n        this.stopped = false;\n        this.dirty = false;\n        this.observableQuery = null;\n        var cache = this.cache = queryManager.cache;\n        // Track how often cache.evict is called, since we want eviction to\n        // override the feud-stopping logic in the markResult method, by\n        // causing shouldWrite to return true. Wrapping the cache.evict method\n        // is a bit of a hack, but it saves us from having to make eviction\n        // counting an official part of the ApolloCache API.\n        if (!destructiveMethodCounts.has(cache)) {\n            destructiveMethodCounts.set(cache, 0);\n            wrapDestructiveCacheMethod(cache, \"evict\");\n            wrapDestructiveCacheMethod(cache, \"modify\");\n            wrapDestructiveCacheMethod(cache, \"reset\");\n        }\n    }\n    QueryInfo.prototype.init = function(query) {\n        var networkStatus = query.networkStatus || _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.NetworkStatus.loading;\n        if (this.variables && this.networkStatus !== _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.NetworkStatus.loading && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(this.variables, query.variables)) {\n            networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.NetworkStatus.setVariables;\n        }\n        if (!(0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(query.variables, this.variables)) {\n            this.lastDiff = void 0;\n        }\n        Object.assign(this, {\n            document: query.document,\n            variables: query.variables,\n            networkError: null,\n            graphQLErrors: this.graphQLErrors || [],\n            networkStatus: networkStatus\n        });\n        if (query.observableQuery) {\n            this.setObservableQuery(query.observableQuery);\n        }\n        if (query.lastRequestId) {\n            this.lastRequestId = query.lastRequestId;\n        }\n        return this;\n    };\n    QueryInfo.prototype.reset = function() {\n        cancelNotifyTimeout(this);\n        this.dirty = false;\n    };\n    QueryInfo.prototype.resetDiff = function() {\n        this.lastDiff = void 0;\n    };\n    QueryInfo.prototype.getDiff = function() {\n        var options = this.getDiffOptions();\n        if (this.lastDiff && (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(options, this.lastDiff.options)) {\n            return this.lastDiff.diff;\n        }\n        this.updateWatch(this.variables);\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return {\n                complete: false\n            };\n        }\n        var diff = this.cache.diff(options);\n        this.updateLastDiff(diff, options);\n        return diff;\n    };\n    QueryInfo.prototype.updateLastDiff = function(diff, options) {\n        this.lastDiff = diff ? {\n            diff: diff,\n            options: options || this.getDiffOptions()\n        } : void 0;\n    };\n    QueryInfo.prototype.getDiffOptions = function(variables) {\n        var _a;\n        if (variables === void 0) {\n            variables = this.variables;\n        }\n        return {\n            query: this.document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: true,\n            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults\n        };\n    };\n    QueryInfo.prototype.setDiff = function(diff) {\n        var _this = this;\n        var _a;\n        var oldDiff = this.lastDiff && this.lastDiff.diff;\n        // If we are trying to deliver an incomplete cache result, we avoid\n        // reporting it if the query has errored, otherwise we let the broadcast try\n        // and repair the partial result by refetching the query. This check avoids\n        // a situation where a query that errors and another succeeds with\n        // overlapping data does not report the partial data result to the errored\n        // query.\n        //\n        // See https://github.com/apollographql/apollo-client/issues/11400 for more\n        // information on this issue.\n        if (diff && !diff.complete && ((_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError())) {\n            return;\n        }\n        this.updateLastDiff(diff);\n        if (!this.dirty && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(oldDiff && oldDiff.result, diff && diff.result)) {\n            this.dirty = true;\n            if (!this.notifyTimeout) {\n                this.notifyTimeout = setTimeout(function() {\n                    return _this.notify();\n                }, 0);\n            }\n        }\n    };\n    QueryInfo.prototype.setObservableQuery = function(oq) {\n        var _this = this;\n        if (oq === this.observableQuery) return;\n        if (this.oqListener) {\n            this.listeners.delete(this.oqListener);\n        }\n        this.observableQuery = oq;\n        if (oq) {\n            oq[\"queryInfo\"] = this;\n            this.listeners.add(this.oqListener = function() {\n                var diff = _this.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    // If this diff came from an optimistic transaction, deliver the\n                    // current cache data to the ObservableQuery, but don't perform a\n                    // reobservation, since oq.reobserveCacheFirst might make a network\n                    // request, and we never want to trigger network requests in the\n                    // middle of optimistic updates.\n                    oq[\"observe\"]();\n                } else {\n                    // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n                    // using a temporary fetch policy of \"cache-first\", so complete cache\n                    // results have a chance to be delivered without triggering additional\n                    // network requests, even when options.fetchPolicy is \"network-only\"\n                    // or \"cache-and-network\". All other fetch policies are preserved by\n                    // this method, and are handled by calling oq.reobserve(). If this\n                    // reobservation is spurious, isDifferentFromLastResult still has a\n                    // chance to catch it before delivery to ObservableQuery subscribers.\n                    (0,_ObservableQuery_js__WEBPACK_IMPORTED_MODULE_3__.reobserveCacheFirst)(oq);\n                }\n            });\n        } else {\n            delete this.oqListener;\n        }\n    };\n    QueryInfo.prototype.notify = function() {\n        var _this = this;\n        cancelNotifyTimeout(this);\n        if (this.shouldNotify()) {\n            this.listeners.forEach(function(listener) {\n                return listener(_this);\n            });\n        }\n        this.dirty = false;\n    };\n    QueryInfo.prototype.shouldNotify = function() {\n        if (!this.dirty || !this.listeners.size) {\n            return false;\n        }\n        if ((0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.isNetworkRequestInFlight)(this.networkStatus) && this.observableQuery) {\n            var fetchPolicy = this.observableQuery.options.fetchPolicy;\n            if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    QueryInfo.prototype.stop = function() {\n        if (!this.stopped) {\n            this.stopped = true;\n            // Cancel the pending notify timeout\n            this.reset();\n            this.cancel();\n            // Revert back to the no-op version of cancel inherited from\n            // QueryInfo.prototype.\n            this.cancel = QueryInfo.prototype.cancel;\n            var oq = this.observableQuery;\n            if (oq) oq.stopPolling();\n        }\n    };\n    // This method is a no-op by default, until/unless overridden by the\n    // updateWatch method.\n    QueryInfo.prototype.cancel = function() {};\n    QueryInfo.prototype.updateWatch = function(variables) {\n        var _this = this;\n        if (variables === void 0) {\n            variables = this.variables;\n        }\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return;\n        }\n        var watchOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, this.getDiffOptions(variables)), {\n            watcher: this,\n            callback: function(diff) {\n                return _this.setDiff(diff);\n            }\n        });\n        if (!this.lastWatch || !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(watchOptions, this.lastWatch)) {\n            this.cancel();\n            this.cancel = this.cache.watch(this.lastWatch = watchOptions);\n        }\n    };\n    QueryInfo.prototype.resetLastWrite = function() {\n        this.lastWrite = void 0;\n    };\n    QueryInfo.prototype.shouldWrite = function(result, variables) {\n        var lastWrite = this.lastWrite;\n        return !(lastWrite && // If cache.evict has been called since the last time we wrote this\n        // data into the cache, there's a chance writing this result into\n        // the cache will repair what was evicted.\n        lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(variables, lastWrite.variables) && (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(result.data, lastWrite.result.data));\n    };\n    QueryInfo.prototype.markResult = function(result, document, options, cacheWriteBehavior) {\n        var _this = this;\n        var merger = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.DeepMerger();\n        var graphQLErrors = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.isNonEmptyArray)(result.errors) ? result.errors.slice(0) : [];\n        // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n        // requests. To allow future notify timeouts, diff and dirty are reset as well.\n        this.reset();\n        if (\"incremental\" in result && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.isNonEmptyArray)(result.incremental)) {\n            var mergedData = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.mergeIncrementalData)(this.getDiff().result, result);\n            result.data = mergedData;\n        // Detect the first chunk of a deferred query and merge it with existing\n        // cache data. This ensures a `cache-first` fetch policy that returns\n        // partial cache data or a `cache-and-network` fetch policy that already\n        // has full data in the cache does not complain when trying to merge the\n        // initial deferred server data with existing cache data.\n        } else if (\"hasNext\" in result && result.hasNext) {\n            var diff = this.getDiff();\n            result.data = merger.merge(diff.result, result.data);\n        }\n        this.graphQLErrors = graphQLErrors;\n        if (options.fetchPolicy === \"no-cache\") {\n            this.updateLastDiff({\n                result: result.data,\n                complete: true\n            }, this.getDiffOptions(options.variables));\n        } else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */ ) {\n            if (shouldWriteResult(result, options.errorPolicy)) {\n                // Using a transaction here so we have a chance to read the result\n                // back from the cache before the watch callback fires as a result\n                // of writeQuery, so we can store the new diff quietly and ignore\n                // it when we receive it redundantly from the watch callback.\n                this.cache.performTransaction(function(cache) {\n                    if (_this.shouldWrite(result, options.variables)) {\n                        cache.writeQuery({\n                            query: document,\n                            data: result.data,\n                            variables: options.variables,\n                            overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */ \n                        });\n                        _this.lastWrite = {\n                            result: result,\n                            variables: options.variables,\n                            dmCount: destructiveMethodCounts.get(_this.cache)\n                        };\n                    } else {\n                        // If result is the same as the last result we received from\n                        // the network (and the variables match too), avoid writing\n                        // result into the cache again. The wisdom of skipping this\n                        // cache write is far from obvious, since any cache write\n                        // could be the one that puts the cache back into a desired\n                        // state, fixing corruption or missing data. However, if we\n                        // always write every network result into the cache, we enable\n                        // feuds between queries competing to update the same data in\n                        // incompatible ways, which can lead to an endless cycle of\n                        // cache broadcasts and useless network requests. As with any\n                        // feud, eventually one side must step back from the brink,\n                        // letting the other side(s) have the last word(s). There may\n                        // be other points where we could break this cycle, such as\n                        // silencing the broadcast for cache.writeQuery (not a good\n                        // idea, since it just delays the feud a bit) or somehow\n                        // avoiding the network request that just happened (also bad,\n                        // because the server could return useful new data). All\n                        // options considered, skipping this cache write seems to be\n                        // the least damaging place to break the cycle, because it\n                        // reflects the intuition that we recently wrote this exact\n                        // result into the cache, so the cache *should* already/still\n                        // contain this data. If some other query has clobbered that\n                        // data in the meantime, that's too bad, but there will be no\n                        // winners if every query blindly reverts to its own version\n                        // of the data. This approach also gives the network a chance\n                        // to return new data, which will be written into the cache as\n                        // usual, notifying only those queries that are directly\n                        // affected by the cache updates, as usual. In the future, an\n                        // even more sophisticated cache could perhaps prevent or\n                        // mitigate the clobbering somehow, but that would make this\n                        // particular cache write even less important, and thus\n                        // skipping it would be even safer than it is today.\n                        if (_this.lastDiff && _this.lastDiff.diff.complete) {\n                            // Reuse data from the last good (complete) diff that we\n                            // received, when possible.\n                            result.data = _this.lastDiff.diff.result;\n                            return;\n                        }\n                    // If the previous this.diff was incomplete, fall through to\n                    // re-reading the latest data with cache.diff, below.\n                    }\n                    var diffOptions = _this.getDiffOptions(options.variables);\n                    var diff = cache.diff(diffOptions);\n                    // In case the QueryManager stops this QueryInfo before its\n                    // results are delivered, it's important to avoid restarting the\n                    // cache watch when markResult is called. We also avoid updating\n                    // the watch if we are writing a result that doesn't match the current\n                    // variables to avoid race conditions from broadcasting the wrong\n                    // result.\n                    if (!_this.stopped && (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__.equal)(_this.variables, options.variables)) {\n                        // Any time we're about to update this.diff, we need to make\n                        // sure we've started watching the cache.\n                        _this.updateWatch(options.variables);\n                    }\n                    // If we're allowed to write to the cache, and we can read a\n                    // complete result from the cache, update result.data to be the\n                    // result from the cache, rather than the raw network result.\n                    // Set without setDiff to avoid triggering a notify call, since\n                    // we have other ways of notifying for this result.\n                    _this.updateLastDiff(diff, diffOptions);\n                    if (diff.complete) {\n                        result.data = diff.result;\n                    }\n                });\n            } else {\n                this.lastWrite = void 0;\n            }\n        }\n    };\n    QueryInfo.prototype.markReady = function() {\n        this.networkError = null;\n        return this.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.NetworkStatus.ready;\n    };\n    QueryInfo.prototype.markError = function(error) {\n        this.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__.NetworkStatus.error;\n        this.lastWrite = void 0;\n        this.reset();\n        if (error.graphQLErrors) {\n            this.graphQLErrors = error.graphQLErrors;\n        }\n        if (error.networkError) {\n            this.networkError = error.networkError;\n        }\n        return error;\n    };\n    return QueryInfo;\n}();\n\nfunction shouldWriteResult(result, errorPolicy) {\n    if (errorPolicy === void 0) {\n        errorPolicy = \"none\";\n    }\n    var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n    var writeWithErrors = !(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.graphQLResultHasError)(result);\n    if (!writeWithErrors && ignoreErrors && result.data) {\n        writeWithErrors = true;\n    }\n    return writeWithErrors;\n} //# sourceMappingURL=QueryInfo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL1F1ZXJ5SW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNLO0FBQ2E7QUFDVTtBQUNGO0FBQ29DO0FBQ2xCO0FBQzdFLElBQUlVLDBCQUEwQixJQUFLSCxDQUFBQSw4REFBYUEsR0FBR0ksVUFBVUMsR0FBRTtBQUMvRCxTQUFTQywyQkFBMkJDLEtBQUssRUFBRUMsVUFBVTtJQUNqRCxJQUFJQyxXQUFXRixLQUFLLENBQUNDLFdBQVc7SUFDaEMsSUFBSSxPQUFPQyxhQUFhLFlBQVk7UUFDaEMsa0VBQWtFO1FBQ2xFRixLQUFLLENBQUNDLFdBQVcsR0FBRztZQUNoQkwsd0JBQXdCTyxHQUFHLENBQUNILE9BSzVCLDhEQUo4RDtZQUM5RCwrREFBK0Q7WUFDL0QsNkRBQTZEO1lBQzdELHNEQUFzRDtZQUNyREosQ0FBQUEsd0JBQXdCUSxHQUFHLENBQUNKLFNBQVMsS0FBSztZQUMzQyxrRUFBa0U7WUFDbEUsT0FBT0UsU0FBU0csS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDaEM7SUFDSjtBQUNKO0FBQ0EsU0FBU0Msb0JBQW9CQyxJQUFJO0lBQzdCLElBQUlBLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtRQUN2QkMsYUFBYUQsSUFBSSxDQUFDLGdCQUFnQjtRQUNsQ0EsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUs7SUFDakM7QUFDSjtBQUNBLDhEQUE4RDtBQUM5RCxxRUFBcUU7QUFDckUsMEVBQTBFO0FBQzFFLDBFQUEwRTtBQUMxRSxzRUFBc0U7QUFDdEUsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRSx5RUFBeUU7QUFDekUsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsOERBQThEO0FBQzlELElBQUlFLFlBQVksV0FBVyxHQUFJO0lBQzNCLFNBQVNBLFVBQVVDLFlBQVksRUFBRUMsT0FBTztRQUNwQyxJQUFJQSxZQUFZ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R0FBRyxLQUFLO1lBQzFCO1FBQ0o7SUFDSjtJQUNBakUsVUFBVVksU0FBUyxDQUFDd0UsU0FBUyxHQUFHO1FBQzVCLElBQUksQ0FBQzlELFlBQVksR0FBRztRQUNwQixPQUFRLElBQUksQ0FBQ1AsYUFBYSxHQUFHL0IsNERBQWFBLENBQUNxRyxLQUFLO0lBQ3BEO0lBQ0FyRixVQUFVWSxTQUFTLENBQUMwRSxTQUFTLEdBQUcsU0FBVUMsS0FBSztRQUMzQyxJQUFJLENBQUN4RSxhQUFhLEdBQUcvQiw0REFBYUEsQ0FBQ3VHLEtBQUs7UUFDeEMsSUFBSSxDQUFDdEIsU0FBUyxHQUFHLEtBQUs7UUFDdEIsSUFBSSxDQUFDeEMsS0FBSztRQUNWLElBQUk4RCxNQUFNaEUsYUFBYSxFQUFFO1lBQ3JCLElBQUksQ0FBQ0EsYUFBYSxHQUFHZ0UsTUFBTWhFLGFBQWE7UUFDNUM7UUFDQSxJQUFJZ0UsTUFBTWpFLFlBQVksRUFBRTtZQUNwQixJQUFJLENBQUNBLFlBQVksR0FBR2lFLE1BQU1qRSxZQUFZO1FBQzFDO1FBQ0EsT0FBT2lFO0lBQ1g7SUFDQSxPQUFPdkY7QUFDWDtBQUNxQjtBQUNkLFNBQVM4RSxrQkFBa0JsQyxNQUFNLEVBQUVtQyxXQUFXO0lBQ2pELElBQUlBLGdCQUFnQixLQUFLLEdBQUc7UUFBRUEsY0FBYztJQUFRO0lBQ3BELElBQUlTLGVBQWVULGdCQUFnQixZQUFZQSxnQkFBZ0I7SUFDL0QsSUFBSVUsa0JBQWtCLENBQUMzRywwRUFBcUJBLENBQUM4RDtJQUM3QyxJQUFJLENBQUM2QyxtQkFBbUJELGdCQUFnQjVDLE9BQU93QixJQUFJLEVBQUU7UUFDakRxQixrQkFBa0I7SUFDdEI7SUFDQSxPQUFPQTtBQUNYLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL1F1ZXJ5SW5mby5qcz9iZjcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBlcXVhbCB9IGZyb20gXCJAd3J5L2VxdWFsaXR5XCI7XG5pbXBvcnQgeyBEZWVwTWVyZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbWVyZ2VJbmNyZW1lbnRhbERhdGEgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZW9ic2VydmVDYWNoZUZpcnN0IH0gZnJvbSBcIi4vT2JzZXJ2YWJsZVF1ZXJ5LmpzXCI7XG5pbXBvcnQgeyBpc05vbkVtcHR5QXJyYXksIGdyYXBoUUxSZXN1bHRIYXNFcnJvciwgY2FuVXNlV2Vha01hcCwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrU3RhdHVzLCBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQgfSBmcm9tIFwiLi9uZXR3b3JrU3RhdHVzLmpzXCI7XG52YXIgZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMgPSBuZXcgKGNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuZnVuY3Rpb24gd3JhcERlc3RydWN0aXZlQ2FjaGVNZXRob2QoY2FjaGUsIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBjYWNoZVttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGp1c3QgdG9vIGdlbmVyaWMgdG8gYmUgdHlwZWQgY29ycmVjdGx5XG4gICAgICAgIGNhY2hlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuc2V0KGNhY2hlLCBcbiAgICAgICAgICAgIC8vIFRoZSAlMWUxNSBhbGxvd3MgdGhlIGNvdW50IHRvIHdyYXAgYXJvdW5kIHRvIDAgc2FmZWx5IGV2ZXJ5XG4gICAgICAgICAgICAvLyBxdWFkcmlsbGlvbiBldmljdGlvbnMsIHNvIHRoZXJlJ3Mgbm8gcmlzayBvZiBvdmVyZmxvdy4gVG8gYmVcbiAgICAgICAgICAgIC8vIGNsZWFyLCB0aGlzIGlzIG1vcmUgb2YgYSBwZWRhbnRpYyBwcmluY2lwbGUgdGhhbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgbWF0dGVycyBpbiBhbnkgY29uY2VpdmFibGUgcHJhY3RpY2FsIHNjZW5hcmlvLlxuICAgICAgICAgICAgKGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLmdldChjYWNoZSkgKyAxKSAlIDFlMTUpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGp1c3QgdG9vIGdlbmVyaWMgdG8gYmUgdHlwZWQgY29ycmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5jZWxOb3RpZnlUaW1lb3V0KGluZm8pIHtcbiAgICBpZiAoaW5mb1tcIm5vdGlmeVRpbWVvdXRcIl0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluZm9bXCJub3RpZnlUaW1lb3V0XCJdKTtcbiAgICAgICAgaW5mb1tcIm5vdGlmeVRpbWVvdXRcIl0gPSB2b2lkIDA7XG4gICAgfVxufVxuLy8gQSBRdWVyeUluZm8gb2JqZWN0IHJlcHJlc2VudHMgYSBzaW5nbGUgcXVlcnkgbWFuYWdlZCBieSB0aGVcbi8vIFF1ZXJ5TWFuYWdlciwgd2hpY2ggdHJhY2tzIGFsbCBRdWVyeUluZm8gb2JqZWN0cyBieSBxdWVyeUlkIGluIGl0c1xuLy8gdGhpcy5xdWVyaWVzIE1hcC4gUXVlcnlJbmZvIG9iamVjdHMgc3RvcmUgdGhlIGxhdGVzdCByZXN1bHRzIGFuZCBlcnJvcnNcbi8vIGZvciB0aGUgZ2l2ZW4gcXVlcnksIGFuZCBhcmUgcmVzcG9uc2libGUgZm9yIHJlcG9ydGluZyB0aG9zZSByZXN1bHRzIHRvXG4vLyB0aGUgY29ycmVzcG9uZGluZyBPYnNlcnZhYmxlUXVlcnksIHZpYSB0aGUgUXVlcnlJbmZvLm5vdGlmeSBtZXRob2QuXG4vLyBSZXN1bHRzIGFyZSByZXBvcnRlZCBhc3luY2hyb25vdXNseSB3aGVuZXZlciBzZXREaWZmIG1hcmtzIHRoZVxuLy8gUXVlcnlJbmZvIG9iamVjdCBhcyBkaXJ0eSwgdGhvdWdoIGEgY2FsbCB0byB0aGUgUXVlcnlNYW5hZ2VyJ3Ncbi8vIGJyb2FkY2FzdFF1ZXJpZXMgbWV0aG9kIG1heSB0cmlnZ2VyIHRoZSBub3RpZmljYXRpb24gYmVmb3JlIGl0IGhhcHBlbnNcbi8vIGF1dG9tYXRpY2FsbHkuIFRoaXMgY2xhc3MgdXNlZCB0byBiZSBhIHNpbXBsZSBpbnRlcmZhY2UgdHlwZSB3aXRob3V0XG4vLyBhbnkgZmllbGQgcHJpdmFjeSBvciBtZWFuaW5nZnVsIG1ldGhvZHMsIHdoaWNoIGlzIHdoeSBpdCBzdGlsbCBoYXMgc29cbi8vIG1hbnkgcHVibGljIGZpZWxkcy4gVGhlIGVmZm9ydCB0byBsb2NrIGRvd24gYW5kIHNpbXBsaWZ5IHRoZSBRdWVyeUluZm9cbi8vIGludGVyZmFjZSBpcyBvbmdvaW5nLCBhbmQgZnVydGhlciBpbXByb3ZlbWVudHMgYXJlIHdlbGNvbWUuXG52YXIgUXVlcnlJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5SW5mbyhxdWVyeU1hbmFnZXIsIHF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgPT09IHZvaWQgMCkgeyBxdWVyeUlkID0gcXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpOyB9XG4gICAgICAgIHRoaXMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0UmVxdWVzdElkID0gMTtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlUXVlcnkgPSBudWxsO1xuICAgICAgICB2YXIgY2FjaGUgPSAodGhpcy5jYWNoZSA9IHF1ZXJ5TWFuYWdlci5jYWNoZSk7XG4gICAgICAgIC8vIFRyYWNrIGhvdyBvZnRlbiBjYWNoZS5ldmljdCBpcyBjYWxsZWQsIHNpbmNlIHdlIHdhbnQgZXZpY3Rpb24gdG9cbiAgICAgICAgLy8gb3ZlcnJpZGUgdGhlIGZldWQtc3RvcHBpbmcgbG9naWMgaW4gdGhlIG1hcmtSZXN1bHQgbWV0aG9kLCBieVxuICAgICAgICAvLyBjYXVzaW5nIHNob3VsZFdyaXRlIHRvIHJldHVybiB0cnVlLiBXcmFwcGluZyB0aGUgY2FjaGUuZXZpY3QgbWV0aG9kXG4gICAgICAgIC8vIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IGl0IHNhdmVzIHVzIGZyb20gaGF2aW5nIHRvIG1ha2UgZXZpY3Rpb25cbiAgICAgICAgLy8gY291bnRpbmcgYW4gb2ZmaWNpYWwgcGFydCBvZiB0aGUgQXBvbGxvQ2FjaGUgQVBJLlxuICAgICAgICBpZiAoIWRlc3RydWN0aXZlTWV0aG9kQ291bnRzLmhhcyhjYWNoZSkpIHtcbiAgICAgICAgICAgIGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLnNldChjYWNoZSwgMCk7XG4gICAgICAgICAgICB3cmFwRGVzdHJ1Y3RpdmVDYWNoZU1ldGhvZChjYWNoZSwgXCJldmljdFwiKTtcbiAgICAgICAgICAgIHdyYXBEZXN0cnVjdGl2ZUNhY2hlTWV0aG9kKGNhY2hlLCBcIm1vZGlmeVwiKTtcbiAgICAgICAgICAgIHdyYXBEZXN0cnVjdGl2ZUNhY2hlTWV0aG9kKGNhY2hlLCBcInJlc2V0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgbmV0d29ya1N0YXR1cyA9IHF1ZXJ5Lm5ldHdvcmtTdGF0dXMgfHwgTmV0d29ya1N0YXR1cy5sb2FkaW5nO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMgJiZcbiAgICAgICAgICAgIHRoaXMubmV0d29ya1N0YXR1cyAhPT0gTmV0d29ya1N0YXR1cy5sb2FkaW5nICYmXG4gICAgICAgICAgICAhZXF1YWwodGhpcy52YXJpYWJsZXMsIHF1ZXJ5LnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnNldFZhcmlhYmxlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVxdWFsKHF1ZXJ5LnZhcmlhYmxlcywgdGhpcy52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3REaWZmID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBncmFwaFFMRXJyb3JzOiB0aGlzLmdyYXBoUUxFcnJvcnMgfHwgW10sXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHF1ZXJ5Lm9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPYnNlcnZhYmxlUXVlcnkocXVlcnkub2JzZXJ2YWJsZVF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkubGFzdFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdElkID0gcXVlcnkubGFzdFJlcXVlc3RJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbE5vdGlmeVRpbWVvdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUucmVzZXREaWZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3REaWZmID0gdm9pZCAwO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0RGlmZk9wdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdERpZmYgJiYgZXF1YWwob3B0aW9ucywgdGhpcy5sYXN0RGlmZi5vcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdERpZmYuZGlmZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVdhdGNoKHRoaXMudmFyaWFibGVzKTtcbiAgICAgICAgdmFyIG9xID0gdGhpcy5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgIGlmIChvcSAmJiBvcS5vcHRpb25zLmZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBsZXRlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWZmID0gdGhpcy5jYWNoZS5kaWZmKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhc3REaWZmKGRpZmYsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUudXBkYXRlTGFzdERpZmYgPSBmdW5jdGlvbiAoZGlmZiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxhc3REaWZmID1cbiAgICAgICAgICAgIGRpZmYgP1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZjogZGlmZixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB0aGlzLmdldERpZmZPcHRpb25zKCksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5nZXREaWZmT3B0aW9ucyA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IHRydWUsXG4gICAgICAgICAgICBjYW5vbml6ZVJlc3VsdHM6IChfYSA9IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5jYW5vbml6ZVJlc3VsdHMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnNldERpZmYgPSBmdW5jdGlvbiAoZGlmZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBvbGREaWZmID0gdGhpcy5sYXN0RGlmZiAmJiB0aGlzLmxhc3REaWZmLmRpZmY7XG4gICAgICAgIC8vIElmIHdlIGFyZSB0cnlpbmcgdG8gZGVsaXZlciBhbiBpbmNvbXBsZXRlIGNhY2hlIHJlc3VsdCwgd2UgYXZvaWRcbiAgICAgICAgLy8gcmVwb3J0aW5nIGl0IGlmIHRoZSBxdWVyeSBoYXMgZXJyb3JlZCwgb3RoZXJ3aXNlIHdlIGxldCB0aGUgYnJvYWRjYXN0IHRyeVxuICAgICAgICAvLyBhbmQgcmVwYWlyIHRoZSBwYXJ0aWFsIHJlc3VsdCBieSByZWZldGNoaW5nIHRoZSBxdWVyeS4gVGhpcyBjaGVjayBhdm9pZHNcbiAgICAgICAgLy8gYSBzaXR1YXRpb24gd2hlcmUgYSBxdWVyeSB0aGF0IGVycm9ycyBhbmQgYW5vdGhlciBzdWNjZWVkcyB3aXRoXG4gICAgICAgIC8vIG92ZXJsYXBwaW5nIGRhdGEgZG9lcyBub3QgcmVwb3J0IHRoZSBwYXJ0aWFsIGRhdGEgcmVzdWx0IHRvIHRoZSBlcnJvcmVkXG4gICAgICAgIC8vIHF1ZXJ5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvYXBvbGxvLWNsaWVudC9pc3N1ZXMvMTE0MDAgZm9yIG1vcmVcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gb24gdGhpcyBpc3N1ZS5cbiAgICAgICAgaWYgKGRpZmYgJiYgIWRpZmYuY29tcGxldGUgJiYgKChfYSA9IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0TGFzdEVycm9yKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVMYXN0RGlmZihkaWZmKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5ICYmICFlcXVhbChvbGREaWZmICYmIG9sZERpZmYucmVzdWx0LCBkaWZmICYmIGRpZmYucmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm90aWZ5VGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubm90aWZ5KCk7IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnNldE9ic2VydmFibGVRdWVyeSA9IGZ1bmN0aW9uIChvcSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3EgPT09IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5vcUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUodGhpcy5vcUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmFibGVRdWVyeSA9IG9xO1xuICAgICAgICBpZiAob3EpIHtcbiAgICAgICAgICAgIG9xW1wicXVlcnlJbmZvXCJdID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmFkZCgodGhpcy5vcUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gX3RoaXMuZ2V0RGlmZigpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmZyb21PcHRpbWlzdGljVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBkaWZmIGNhbWUgZnJvbSBhbiBvcHRpbWlzdGljIHRyYW5zYWN0aW9uLCBkZWxpdmVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGNhY2hlIGRhdGEgdG8gdGhlIE9ic2VydmFibGVRdWVyeSwgYnV0IGRvbid0IHBlcmZvcm0gYVxuICAgICAgICAgICAgICAgICAgICAvLyByZW9ic2VydmF0aW9uLCBzaW5jZSBvcS5yZW9ic2VydmVDYWNoZUZpcnN0IG1pZ2h0IG1ha2UgYSBuZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QsIGFuZCB3ZSBuZXZlciB3YW50IHRvIHRyaWdnZXIgbmV0d29yayByZXF1ZXN0cyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlkZGxlIG9mIG9wdGltaXN0aWMgdXBkYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgb3FbXCJvYnNlcnZlXCJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1ha2UgdGhlIE9ic2VydmFibGVRdWVyeSBcInJlb2JzZXJ2ZVwiIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBhIHRlbXBvcmFyeSBmZXRjaCBwb2xpY3kgb2YgXCJjYWNoZS1maXJzdFwiLCBzbyBjb21wbGV0ZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGhhdmUgYSBjaGFuY2UgdG8gYmUgZGVsaXZlcmVkIHdpdGhvdXQgdHJpZ2dlcmluZyBhZGRpdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgcmVxdWVzdHMsIGV2ZW4gd2hlbiBvcHRpb25zLmZldGNoUG9saWN5IGlzIFwibmV0d29yay1vbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgXCJjYWNoZS1hbmQtbmV0d29ya1wiLiBBbGwgb3RoZXIgZmV0Y2ggcG9saWNpZXMgYXJlIHByZXNlcnZlZCBieVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1ldGhvZCwgYW5kIGFyZSBoYW5kbGVkIGJ5IGNhbGxpbmcgb3EucmVvYnNlcnZlKCkuIElmIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVvYnNlcnZhdGlvbiBpcyBzcHVyaW91cywgaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdCBzdGlsbCBoYXMgYVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2F0Y2ggaXQgYmVmb3JlIGRlbGl2ZXJ5IHRvIE9ic2VydmFibGVRdWVyeSBzdWJzY3JpYmVycy5cbiAgICAgICAgICAgICAgICAgICAgcmVvYnNlcnZlQ2FjaGVGaXJzdChvcSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3FMaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNhbmNlbE5vdGlmeVRpbWVvdXQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnNob3VsZE5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5IHx8ICF0aGlzLmxpc3RlbmVycy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodCh0aGlzLm5ldHdvcmtTdGF0dXMpICYmIHRoaXMub2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgZmV0Y2hQb2xpY3kgPSB0aGlzLm9ic2VydmFibGVRdWVyeS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ICE9PSBcImNhY2hlLW9ubHlcIiAmJiBmZXRjaFBvbGljeSAhPT0gXCJjYWNoZS1hbmQtbmV0d29ya1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgcGVuZGluZyBub3RpZnkgdGltZW91dFxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIC8vIFJldmVydCBiYWNrIHRvIHRoZSBuby1vcCB2ZXJzaW9uIG9mIGNhbmNlbCBpbmhlcml0ZWQgZnJvbVxuICAgICAgICAgICAgLy8gUXVlcnlJbmZvLnByb3RvdHlwZS5cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gUXVlcnlJbmZvLnByb3RvdHlwZS5jYW5jZWw7XG4gICAgICAgICAgICB2YXIgb3EgPSB0aGlzLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgICAgIGlmIChvcSlcbiAgICAgICAgICAgICAgICBvcS5zdG9wUG9sbGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBhIG5vLW9wIGJ5IGRlZmF1bHQsIHVudGlsL3VubGVzcyBvdmVycmlkZGVuIGJ5IHRoZVxuICAgIC8vIHVwZGF0ZVdhdGNoIG1ldGhvZC5cbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnVwZGF0ZVdhdGNoID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdmFyIG9xID0gdGhpcy5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgIGlmIChvcSAmJiBvcS5vcHRpb25zLmZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2F0Y2hPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZ2V0RGlmZk9wdGlvbnModmFyaWFibGVzKSksIHsgd2F0Y2hlcjogdGhpcywgY2FsbGJhY2s6IGZ1bmN0aW9uIChkaWZmKSB7IHJldHVybiBfdGhpcy5zZXREaWZmKGRpZmYpOyB9IH0pO1xuICAgICAgICBpZiAoIXRoaXMubGFzdFdhdGNoIHx8ICFlcXVhbCh3YXRjaE9wdGlvbnMsIHRoaXMubGFzdFdhdGNoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gdGhpcy5jYWNoZS53YXRjaCgodGhpcy5sYXN0V2F0Y2ggPSB3YXRjaE9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5yZXNldExhc3RXcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0V3JpdGUgPSB2b2lkIDA7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnNob3VsZFdyaXRlID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBsYXN0V3JpdGUgPSB0aGlzLmxhc3RXcml0ZTtcbiAgICAgICAgcmV0dXJuICEobGFzdFdyaXRlICYmXG4gICAgICAgICAgICAvLyBJZiBjYWNoZS5ldmljdCBoYXMgYmVlbiBjYWxsZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSB3cm90ZSB0aGlzXG4gICAgICAgICAgICAvLyBkYXRhIGludG8gdGhlIGNhY2hlLCB0aGVyZSdzIGEgY2hhbmNlIHdyaXRpbmcgdGhpcyByZXN1bHQgaW50b1xuICAgICAgICAgICAgLy8gdGhlIGNhY2hlIHdpbGwgcmVwYWlyIHdoYXQgd2FzIGV2aWN0ZWQuXG4gICAgICAgICAgICBsYXN0V3JpdGUuZG1Db3VudCA9PT0gZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuZ2V0KHRoaXMuY2FjaGUpICYmXG4gICAgICAgICAgICBlcXVhbCh2YXJpYWJsZXMsIGxhc3RXcml0ZS52YXJpYWJsZXMpICYmXG4gICAgICAgICAgICBlcXVhbChyZXN1bHQuZGF0YSwgbGFzdFdyaXRlLnJlc3VsdC5kYXRhKSk7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLm1hcmtSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBkb2N1bWVudCwgb3B0aW9ucywgY2FjaGVXcml0ZUJlaGF2aW9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXJnZXIgPSBuZXcgRGVlcE1lcmdlcigpO1xuICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IGlzTm9uRW1wdHlBcnJheShyZXN1bHQuZXJyb3JzKSA/IHJlc3VsdC5lcnJvcnMuc2xpY2UoMCkgOiBbXTtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBwZW5kaW5nIG5vdGlmeSB0aW1lb3V0IChpZiBpdCBleGlzdHMpIHRvIHByZXZlbnQgZXh0cmFuZW91cyBuZXR3b3JrXG4gICAgICAgIC8vIHJlcXVlc3RzLiBUbyBhbGxvdyBmdXR1cmUgbm90aWZ5IHRpbWVvdXRzLCBkaWZmIGFuZCBkaXJ0eSBhcmUgcmVzZXQgYXMgd2VsbC5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBpZiAoXCJpbmNyZW1lbnRhbFwiIGluIHJlc3VsdCAmJiBpc05vbkVtcHR5QXJyYXkocmVzdWx0LmluY3JlbWVudGFsKSkge1xuICAgICAgICAgICAgdmFyIG1lcmdlZERhdGEgPSBtZXJnZUluY3JlbWVudGFsRGF0YSh0aGlzLmdldERpZmYoKS5yZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IG1lcmdlZERhdGE7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGZpcnN0IGNodW5rIG9mIGEgZGVmZXJyZWQgcXVlcnkgYW5kIG1lcmdlIGl0IHdpdGggZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIGNhY2hlIGRhdGEuIFRoaXMgZW5zdXJlcyBhIGBjYWNoZS1maXJzdGAgZmV0Y2ggcG9saWN5IHRoYXQgcmV0dXJuc1xuICAgICAgICAgICAgLy8gcGFydGlhbCBjYWNoZSBkYXRhIG9yIGEgYGNhY2hlLWFuZC1uZXR3b3JrYCBmZXRjaCBwb2xpY3kgdGhhdCBhbHJlYWR5XG4gICAgICAgICAgICAvLyBoYXMgZnVsbCBkYXRhIGluIHRoZSBjYWNoZSBkb2VzIG5vdCBjb21wbGFpbiB3aGVuIHRyeWluZyB0byBtZXJnZSB0aGVcbiAgICAgICAgICAgIC8vIGluaXRpYWwgZGVmZXJyZWQgc2VydmVyIGRhdGEgd2l0aCBleGlzdGluZyBjYWNoZSBkYXRhLlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiaGFzTmV4dFwiIGluIHJlc3VsdCAmJiByZXN1bHQuaGFzTmV4dCkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmdldERpZmYoKTtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gbWVyZ2VyLm1lcmdlKGRpZmYucmVzdWx0LCByZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFFMRXJyb3JzID0gZ3JhcGhRTEVycm9ycztcbiAgICAgICAgaWYgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0RGlmZih7IHJlc3VsdDogcmVzdWx0LmRhdGEsIGNvbXBsZXRlOiB0cnVlIH0sIHRoaXMuZ2V0RGlmZk9wdGlvbnMob3B0aW9ucy52YXJpYWJsZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWNoZVdyaXRlQmVoYXZpb3IgIT09IDAgLyogQ2FjaGVXcml0ZUJlaGF2aW9yLkZPUkJJRCAqLykge1xuICAgICAgICAgICAgaWYgKHNob3VsZFdyaXRlUmVzdWx0KHJlc3VsdCwgb3B0aW9ucy5lcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBhIHRyYW5zYWN0aW9uIGhlcmUgc28gd2UgaGF2ZSBhIGNoYW5jZSB0byByZWFkIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBiYWNrIGZyb20gdGhlIGNhY2hlIGJlZm9yZSB0aGUgd2F0Y2ggY2FsbGJhY2sgZmlyZXMgYXMgYSByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBvZiB3cml0ZVF1ZXJ5LCBzbyB3ZSBjYW4gc3RvcmUgdGhlIG5ldyBkaWZmIHF1aWV0bHkgYW5kIGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIGl0IHdoZW4gd2UgcmVjZWl2ZSBpdCByZWR1bmRhbnRseSBmcm9tIHRoZSB3YXRjaCBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnBlcmZvcm1UcmFuc2FjdGlvbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNob3VsZFdyaXRlKHJlc3VsdCwgb3B0aW9ucy52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS53cml0ZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdGU6IGNhY2hlV3JpdGVCZWhhdmlvciA9PT0gMSAvKiBDYWNoZVdyaXRlQmVoYXZpb3IuT1ZFUldSSVRFICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0V3JpdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbUNvdW50OiBkZXN0cnVjdGl2ZU1ldGhvZENvdW50cy5nZXQoX3RoaXMuY2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJlc3VsdCBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCByZXN1bHQgd2UgcmVjZWl2ZWQgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5ldHdvcmsgKGFuZCB0aGUgdmFyaWFibGVzIG1hdGNoIHRvbyksIGF2b2lkIHdyaXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBpbnRvIHRoZSBjYWNoZSBhZ2Fpbi4gVGhlIHdpc2RvbSBvZiBza2lwcGluZyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB3cml0ZSBpcyBmYXIgZnJvbSBvYnZpb3VzLCBzaW5jZSBhbnkgY2FjaGUgd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlIHRoZSBvbmUgdGhhdCBwdXRzIHRoZSBjYWNoZSBiYWNrIGludG8gYSBkZXNpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSwgZml4aW5nIGNvcnJ1cHRpb24gb3IgbWlzc2luZyBkYXRhLiBIb3dldmVyLCBpZiB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHdyaXRlIGV2ZXJ5IG5ldHdvcmsgcmVzdWx0IGludG8gdGhlIGNhY2hlLCB3ZSBlbmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZldWRzIGJldHdlZW4gcXVlcmllcyBjb21wZXRpbmcgdG8gdXBkYXRlIHRoZSBzYW1lIGRhdGEgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY29tcGF0aWJsZSB3YXlzLCB3aGljaCBjYW4gbGVhZCB0byBhbiBlbmRsZXNzIGN5Y2xlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBicm9hZGNhc3RzIGFuZCB1c2VsZXNzIG5ldHdvcmsgcmVxdWVzdHMuIEFzIHdpdGggYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXVkLCBldmVudHVhbGx5IG9uZSBzaWRlIG11c3Qgc3RlcCBiYWNrIGZyb20gdGhlIGJyaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0dGluZyB0aGUgb3RoZXIgc2lkZShzKSBoYXZlIHRoZSBsYXN0IHdvcmQocykuIFRoZXJlIG1heVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgb3RoZXIgcG9pbnRzIHdoZXJlIHdlIGNvdWxkIGJyZWFrIHRoaXMgY3ljbGUsIHN1Y2ggYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbGVuY2luZyB0aGUgYnJvYWRjYXN0IGZvciBjYWNoZS53cml0ZVF1ZXJ5IChub3QgYSBnb29kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZGVhLCBzaW5jZSBpdCBqdXN0IGRlbGF5cyB0aGUgZmV1ZCBhIGJpdCkgb3Igc29tZWhvd1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWRpbmcgdGhlIG5ldHdvcmsgcmVxdWVzdCB0aGF0IGp1c3QgaGFwcGVuZWQgKGFsc28gYmFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2VydmVyIGNvdWxkIHJldHVybiB1c2VmdWwgbmV3IGRhdGEpLiBBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgY29uc2lkZXJlZCwgc2tpcHBpbmcgdGhpcyBjYWNoZSB3cml0ZSBzZWVtcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxlYXN0IGRhbWFnaW5nIHBsYWNlIHRvIGJyZWFrIHRoZSBjeWNsZSwgYmVjYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmbGVjdHMgdGhlIGludHVpdGlvbiB0aGF0IHdlIHJlY2VudGx5IHdyb3RlIHRoaXMgZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBpbnRvIHRoZSBjYWNoZSwgc28gdGhlIGNhY2hlICpzaG91bGQqIGFscmVhZHkvc3RpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW4gdGhpcyBkYXRhLiBJZiBzb21lIG90aGVyIHF1ZXJ5IGhhcyBjbG9iYmVyZWQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBpbiB0aGUgbWVhbnRpbWUsIHRoYXQncyB0b28gYmFkLCBidXQgdGhlcmUgd2lsbCBiZSBub1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lubmVycyBpZiBldmVyeSBxdWVyeSBibGluZGx5IHJldmVydHMgdG8gaXRzIG93biB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZGF0YS4gVGhpcyBhcHByb2FjaCBhbHNvIGdpdmVzIHRoZSBuZXR3b3JrIGEgY2hhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byByZXR1cm4gbmV3IGRhdGEsIHdoaWNoIHdpbGwgYmUgd3JpdHRlbiBpbnRvIHRoZSBjYWNoZSBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXN1YWwsIG5vdGlmeWluZyBvbmx5IHRob3NlIHF1ZXJpZXMgdGhhdCBhcmUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBjYWNoZSB1cGRhdGVzLCBhcyB1c3VhbC4gSW4gdGhlIGZ1dHVyZSwgYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gbW9yZSBzb3BoaXN0aWNhdGVkIGNhY2hlIGNvdWxkIHBlcmhhcHMgcHJldmVudCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWl0aWdhdGUgdGhlIGNsb2JiZXJpbmcgc29tZWhvdywgYnV0IHRoYXQgd291bGQgbWFrZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWN1bGFyIGNhY2hlIHdyaXRlIGV2ZW4gbGVzcyBpbXBvcnRhbnQsIGFuZCB0aHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwcGluZyBpdCB3b3VsZCBiZSBldmVuIHNhZmVyIHRoYW4gaXQgaXMgdG9kYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdERpZmYgJiYgX3RoaXMubGFzdERpZmYuZGlmZi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldXNlIGRhdGEgZnJvbSB0aGUgbGFzdCBnb29kIChjb21wbGV0ZSkgZGlmZiB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQsIHdoZW4gcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBfdGhpcy5sYXN0RGlmZi5kaWZmLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGhpcy5kaWZmIHdhcyBpbmNvbXBsZXRlLCBmYWxsIHRocm91Z2ggdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLXJlYWRpbmcgdGhlIGxhdGVzdCBkYXRhIHdpdGggY2FjaGUuZGlmZiwgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZPcHRpb25zID0gX3RoaXMuZ2V0RGlmZk9wdGlvbnMob3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGNhY2hlLmRpZmYoZGlmZk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBRdWVyeU1hbmFnZXIgc3RvcHMgdGhpcyBRdWVyeUluZm8gYmVmb3JlIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFyZSBkZWxpdmVyZWQsIGl0J3MgaW1wb3J0YW50IHRvIGF2b2lkIHJlc3RhcnRpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIHdhdGNoIHdoZW4gbWFya1Jlc3VsdCBpcyBjYWxsZWQuIFdlIGFsc28gYXZvaWQgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHdhdGNoIGlmIHdlIGFyZSB3cml0aW5nIGEgcmVzdWx0IHRoYXQgZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZXMgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIGZyb20gYnJvYWRjYXN0aW5nIHRoZSB3cm9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc3RvcHBlZCAmJiBlcXVhbChfdGhpcy52YXJpYWJsZXMsIG9wdGlvbnMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW55IHRpbWUgd2UncmUgYWJvdXQgdG8gdXBkYXRlIHRoaXMuZGlmZiwgd2UgbmVlZCB0byBtYWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXJlIHdlJ3ZlIHN0YXJ0ZWQgd2F0Y2hpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlV2F0Y2gob3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gd3JpdGUgdG8gdGhlIGNhY2hlLCBhbmQgd2UgY2FuIHJlYWQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZSByZXN1bHQgZnJvbSB0aGUgY2FjaGUsIHVwZGF0ZSByZXN1bHQuZGF0YSB0byBiZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IGZyb20gdGhlIGNhY2hlLCByYXRoZXIgdGhhbiB0aGUgcmF3IG5ldHdvcmsgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2l0aG91dCBzZXREaWZmIHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBub3RpZnkgY2FsbCwgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBvdGhlciB3YXlzIG9mIG5vdGlmeWluZyBmb3IgdGhpcyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3REaWZmKGRpZmYsIGRpZmZPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGlmZi5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFdyaXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLm1hcmtSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrRXJyb3IgPSBudWxsO1xuICAgICAgICByZXR1cm4gKHRoaXMubmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMucmVhZHkpO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5tYXJrRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5lcnJvcjtcbiAgICAgICAgdGhpcy5sYXN0V3JpdGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgaWYgKGVycm9yLmdyYXBoUUxFcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhRTEVycm9ycyA9IGVycm9yLmdyYXBoUUxFcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLm5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5uZXR3b3JrRXJyb3IgPSBlcnJvci5uZXR3b3JrRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXJ5SW5mbztcbn0oKSk7XG5leHBvcnQgeyBRdWVyeUluZm8gfTtcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRXcml0ZVJlc3VsdChyZXN1bHQsIGVycm9yUG9saWN5KSB7XG4gICAgaWYgKGVycm9yUG9saWN5ID09PSB2b2lkIDApIHsgZXJyb3JQb2xpY3kgPSBcIm5vbmVcIjsgfVxuICAgIHZhciBpZ25vcmVFcnJvcnMgPSBlcnJvclBvbGljeSA9PT0gXCJpZ25vcmVcIiB8fCBlcnJvclBvbGljeSA9PT0gXCJhbGxcIjtcbiAgICB2YXIgd3JpdGVXaXRoRXJyb3JzID0gIWdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpO1xuICAgIGlmICghd3JpdGVXaXRoRXJyb3JzICYmIGlnbm9yZUVycm9ycyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICB3cml0ZVdpdGhFcnJvcnMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVXaXRoRXJyb3JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlJbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsImVxdWFsIiwiRGVlcE1lcmdlciIsIm1lcmdlSW5jcmVtZW50YWxEYXRhIiwicmVvYnNlcnZlQ2FjaGVGaXJzdCIsImlzTm9uRW1wdHlBcnJheSIsImdyYXBoUUxSZXN1bHRIYXNFcnJvciIsImNhblVzZVdlYWtNYXAiLCJOZXR3b3JrU3RhdHVzIiwiaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0IiwiZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMiLCJXZWFrTWFwIiwiTWFwIiwid3JhcERlc3RydWN0aXZlQ2FjaGVNZXRob2QiLCJjYWNoZSIsIm1ldGhvZE5hbWUiLCJvcmlnaW5hbCIsInNldCIsImdldCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FuY2VsTm90aWZ5VGltZW91dCIsImluZm8iLCJjbGVhclRpbWVvdXQiLCJRdWVyeUluZm8iLCJxdWVyeU1hbmFnZXIiLCJxdWVyeUlkIiwiZ2VuZXJhdGVRdWVyeUlkIiwibGlzdGVuZXJzIiwiU2V0IiwiZG9jdW1lbnQiLCJsYXN0UmVxdWVzdElkIiwic3RvcHBlZCIsImRpcnR5Iiwib2JzZXJ2YWJsZVF1ZXJ5IiwiaGFzIiwicHJvdG90eXBlIiwiaW5pdCIsInF1ZXJ5IiwibmV0d29ya1N0YXR1cyIsImxvYWRpbmciLCJ2YXJpYWJsZXMiLCJzZXRWYXJpYWJsZXMiLCJsYXN0RGlmZiIsIk9iamVjdCIsImFzc2lnbiIsIm5ldHdvcmtFcnJvciIsImdyYXBoUUxFcnJvcnMiLCJzZXRPYnNlcnZhYmxlUXVlcnkiLCJyZXNldCIsInJlc2V0RGlmZiIsImdldERpZmYiLCJvcHRpb25zIiwiZ2V0RGlmZk9wdGlvbnMiLCJkaWZmIiwidXBkYXRlV2F0Y2giLCJvcSIsImZldGNoUG9saWN5IiwiY29tcGxldGUiLCJ1cGRhdGVMYXN0RGlmZiIsIl9hIiwicmV0dXJuUGFydGlhbERhdGEiLCJvcHRpbWlzdGljIiwiY2Fub25pemVSZXN1bHRzIiwic2V0RGlmZiIsIl90aGlzIiwib2xkRGlmZiIsImdldExhc3RFcnJvciIsInJlc3VsdCIsIm5vdGlmeVRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwibm90aWZ5Iiwib3FMaXN0ZW5lciIsImRlbGV0ZSIsImFkZCIsImZyb21PcHRpbWlzdGljVHJhbnNhY3Rpb24iLCJzaG91bGROb3RpZnkiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJzaXplIiwic3RvcCIsImNhbmNlbCIsInN0b3BQb2xsaW5nIiwid2F0Y2hPcHRpb25zIiwid2F0Y2hlciIsImNhbGxiYWNrIiwibGFzdFdhdGNoIiwid2F0Y2giLCJyZXNldExhc3RXcml0ZSIsImxhc3RXcml0ZSIsInNob3VsZFdyaXRlIiwiZG1Db3VudCIsImRhdGEiLCJtYXJrUmVzdWx0IiwiY2FjaGVXcml0ZUJlaGF2aW9yIiwibWVyZ2VyIiwiZXJyb3JzIiwic2xpY2UiLCJpbmNyZW1lbnRhbCIsIm1lcmdlZERhdGEiLCJoYXNOZXh0IiwibWVyZ2UiLCJzaG91bGRXcml0ZVJlc3VsdCIsImVycm9yUG9saWN5IiwicGVyZm9ybVRyYW5zYWN0aW9uIiwid3JpdGVRdWVyeSIsIm92ZXJ3cml0ZSIsImRpZmZPcHRpb25zIiwibWFya1JlYWR5IiwicmVhZHkiLCJtYXJrRXJyb3IiLCJlcnJvciIsImlnbm9yZUVycm9ycyIsIndyaXRlV2l0aEVycm9ycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/QueryInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/QueryManager.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/QueryManager.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryManager: function() { return /* binding */ QueryManager; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../link/core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/execute.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utilities/common/incrementalResult.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _cache_index_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../cache/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/DocumentTransform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/asyncMap.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/errorHandling.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/makeUniqueId.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/Concast.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\");\n/* harmony import */ var _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ObservableQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js\");\n/* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./networkStatus.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\");\n/* harmony import */ var _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./QueryInfo.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/QueryInfo.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/print.js\");\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\n\n\nvar QueryManager = /** @class */ function() {\n    function QueryManager(options) {\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.AutoCleanedWeakCache(_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */ );\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new _wry_trie__WEBPACK_IMPORTED_MODULE_2__.Trie(false);\n        var defaultDocumentTransform = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.DocumentTransform(function(document) {\n            return _this.cache.transformDocument(document);\n        }, // Allow the apollo cache to manage its own transform caches\n        {\n            cache: false\n        });\n        this.cache = options.cache;\n        this.link = options.link;\n        this.defaultOptions = options.defaultOptions;\n        this.queryDeduplication = options.queryDeduplication;\n        this.clientAwareness = options.clientAwareness;\n        this.localState = options.localState;\n        this.ssrMode = options.ssrMode;\n        this.assumeImmutableResults = options.assumeImmutableResults;\n        var documentTransform = options.documentTransform;\n        this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)// The custom document transform may add new fragment spreads or new\n        // field selections, so we want to give the cache a chance to run\n        // again. For example, the InMemoryCache adds __typename to field\n        // selections and fragments from the fragment registry.\n        .concat(defaultDocumentTransform) : defaultDocumentTransform;\n        this.defaultContext = options.defaultContext || Object.create(null);\n        if (this.onBroadcast = options.onBroadcast) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */ QueryManager.prototype.stop = function() {\n        var _this = this;\n        this.queries.forEach(function(_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches((0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(26));\n    };\n    QueryManager.prototype.cancelPendingFetches = function(error) {\n        this.fetchCancelFns.forEach(function(cancel) {\n            return cancel(error);\n        });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function(_a) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, arguments, void 0, function(_b) {\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n            var _c, _d;\n            var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h, keepRootFields = _b.keepRootFields, context = _b.context;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__generator)(this, function(_j) {\n                switch(_j.label){\n                    case 0:\n                        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(mutation, 27);\n                        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 28);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.localState.addExportedVariables(mutation, variables, context)\n                        ];\n                    case 1:\n                        variables = _j.sent();\n                        _j.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n                            mutation: mutation,\n                            variables: variables,\n                            loading: true,\n                            error: null\n                        });\n                        isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n                            mutationId: mutationId,\n                            document: mutation,\n                            variables: variables,\n                            fetchPolicy: fetchPolicy,\n                            errorPolicy: errorPolicy,\n                            context: context,\n                            updateQueries: updateQueries,\n                            update: updateWithProxyFn,\n                            keepRootFields: keepRootFields\n                        });\n                        this.broadcastQueries();\n                        self = this;\n                        return [\n                            2 /*return*/ ,\n                            new Promise(function(resolve, reject) {\n                                return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.asyncMap)(self.getObservableFromLink(mutation, (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, context), {\n                                    optimisticResponse: isOptimistic ? optimisticResponse : void 0\n                                }), variables, {}, false), function(result) {\n                                    if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.graphQLResultHasError)(result) && errorPolicy === \"none\") {\n                                        throw new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError({\n                                            graphQLErrors: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.getGraphQLErrorsFromResult)(result)\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.graphQLResultHasError)(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields\n                                    });\n                                }).subscribe({\n                                    next: function(storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(storeResult);\n                                        }\n                                    },\n                                    error: function(err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (isOptimistic) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError ? err : new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError({\n                                            networkError: err\n                                        }));\n                                    }\n                                });\n                            })\n                        ];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function(mutation, cache) {\n        var _this = this;\n        if (cache === void 0) {\n            cache = this.cache;\n        }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && (0,_QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__.shouldWriteResult)(result, mutation.errorPolicy)) {\n            if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.isExecutionPatchIncrementalResult)(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables\n                });\n            }\n            if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.isExecutionPatchIncrementalResult)(result) && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_12__.isNonEmptyArray)(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.mergeIncrementalData)(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function(_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: document && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.getOperationName)(document) || void 0,\n                            queryVariables: variables\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function(cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function(write) {\n                            return cache.write(write);\n                        });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.isExecutionPatchResult)(result) || (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.isExecutionPatchIncrementalResult)(result) && !result.hasNext;\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true\n                            });\n                            if (diff.complete) {\n                                result = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, result), {\n                                    data: diff.result\n                                });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function(value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            }\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null\n            }).forEach(function(result) {\n                return results_1.push(result);\n            });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function() {\n                    return result;\n                });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n            IGNORE: IGNORE\n        }) : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction(function(cache) {\n            try {\n                _this.markMutationResult((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, mutation), {\n                    result: {\n                        data: data\n                    }\n                }), cache);\n            } catch (error) {\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(error);\n            }\n        }, mutation.mutationId);\n        return true;\n    };\n    QueryManager.prototype.fetchQuery = function(queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n    };\n    QueryManager.prototype.getQueryStore = function() {\n        var store = Object.create(null);\n        this.queries.forEach(function(info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function(queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function(document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function(document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_14__.hasClientExports)(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_14__.hasDirectives)([\n                    \"nonreactive\"\n                ], document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_15__.removeDirectivesFromDocument)([\n                    {\n                        name: \"client\",\n                        remove: true\n                    },\n                    {\n                        name: \"connection\"\n                    },\n                    {\n                        name: \"nonreactive\"\n                    }\n                ], document),\n                defaultVars: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.getDefaultValues)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.getOperationDefinition)(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, document), {\n                    definitions: document.definitions.map(function(def) {\n                        if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n                            return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, def), {\n                                operation: \"query\"\n                            });\n                        }\n                        return def;\n                    })\n                })\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function(document, variables) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function(options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, options), {\n            variables: this.getVariables(query, options.variables)\n        });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__.QueryInfo(this);\n        var observable = new _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_16__.ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options\n        });\n        observable[\"lastQuery\"] = query;\n        this.queries.set(observable.queryId, queryInfo);\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function(options, queryId) {\n        var _this = this;\n        if (queryId === void 0) {\n            queryId = this.generateQueryId();\n        }\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(options.query, 29);\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(options.query.kind === \"Document\", 30);\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(!options.returnPartialData, 31);\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(!options.pollInterval, 32);\n        return this.fetchQuery(queryId, (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, options), {\n            query: this.transform(options.query)\n        })).finally(function() {\n            return _this.stopQuery(queryId);\n        });\n    };\n    QueryManager.prototype.generateQueryId = function() {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function() {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function() {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function(queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function(queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function(options) {\n        if (options === void 0) {\n            options = {\n                discardWatches: true\n            };\n        }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches((0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(33));\n        this.queries.forEach(function(queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.loading;\n            } else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function(include) {\n        var _this = this;\n        if (include === void 0) {\n            include = \"active\";\n        }\n        var queries = new Map();\n        var queryNamesAndDocs = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function(desc) {\n                if (typeof desc === \"string\") {\n                    queryNamesAndDocs.set(desc, false);\n                } else if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_18__.isDocumentNode)(desc)) {\n                    queryNamesAndDocs.set(_this.transform(desc), false);\n                } else if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_19__.isNonNullObject)(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function(_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n                    return;\n                }\n                if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n                    queries.set(queryId, oq);\n                    if (queryName) queryNamesAndDocs.set(queryName, true);\n                    if (document) queryNamesAndDocs.set(document, true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function(options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_20__.makeUniqueId)(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables\n                });\n                var oq = new _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_16__.ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, options), {\n                        fetchPolicy: \"network-only\"\n                    })\n                });\n                (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n            queryNamesAndDocs.forEach(function(included, nameOrDoc) {\n                if (!included) {\n                    globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(typeof nameOrDoc === \"string\" ? 34 : 35, nameOrDoc);\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function(includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) {\n            includeStandby = false;\n        }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function(observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function(observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function(_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \"none\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c, _d = _a.extensions, extensions = _d === void 0 ? {} : _d;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function(variables) {\n            return _this.getObservableFromLink(query, context, variables, extensions).map(function(result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if ((0,_QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__.shouldWriteResult)(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.graphQLResultHasError)(result);\n                var hasProtocolErrors = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_9__.graphQLResultHasProtocolErrors)(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[_errors_index_js__WEBPACK_IMPORTED_MODULE_9__.PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n            return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_21__.Observable(function(observer) {\n                var sub = null;\n                observablePromise_1.then(function(observable) {\n                    return sub = observable.subscribe(observer);\n                }, observer.error);\n                return function() {\n                    return sub && sub.unsubscribe();\n                };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function(queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function(queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function(queryId) {\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function() {\n        if (this.onBroadcast) this.onBroadcast();\n        this.queries.forEach(function(info) {\n            return info.notify();\n        });\n    };\n    QueryManager.prototype.getLocalState = function() {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function(query, context, variables, extensions, // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) {\n            deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n        }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.getOperationName)(serverQuery) || void 0,\n                context: this.prepareContext((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, context), {\n                    forceFetch: !deduplication\n                })),\n                extensions: extensions\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_22__.print)(serverQuery);\n                var varJson_1 = (0,_cache_index_js__WEBPACK_IMPORTED_MODULE_23__.canonicalStringify)(variables);\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n                observable = entry.observable;\n                if (!observable) {\n                    var concast = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__.Concast([\n                        (0,_link_core_index_js__WEBPACK_IMPORTED_MODULE_25__.execute)(link, operation)\n                    ]);\n                    observable = entry.observable = concast;\n                    concast.beforeNext(function() {\n                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n                    });\n                }\n            } else {\n                observable = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__.Concast([\n                    (0,_link_core_index_js__WEBPACK_IMPORTED_MODULE_25__.execute)(link, operation)\n                ]);\n            }\n        } else {\n            observable = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__.Concast([\n                _utilities_index_js__WEBPACK_IMPORTED_MODULE_21__.Observable.of({\n                    data: {}\n                })\n            ]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.asyncMap)(observable, function(result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {\n        var requestId = queryInfo.lastRequestId = this.generateRequestId();\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.asyncMap)(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {\n            var graphQLErrors = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.getGraphQLErrorsFromResult)(result);\n            var hasErrors = graphQLErrors.length > 0;\n            var errorPolicy = options.errorPolicy;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError({\n                        graphQLErrors: graphQLErrors\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.ready\n            };\n            // In the case we start multiple network requests simulatenously, we\n            // want to ensure we properly set `data` if we're reporting on an old\n            // result which will not be caught by the conditional above that ends up\n            // throwing the markError result.\n            if (hasErrors && errorPolicy === \"none\") {\n                aqr.data = void 0;\n            }\n            if (hasErrors && errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.error;\n            }\n            return aqr;\n        }, function(networkError) {\n            var error = (0,_errors_index_js__WEBPACK_IMPORTED_MODULE_9__.isApolloError)(networkError) ? networkError : new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError({\n                networkError: networkError\n            });\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function(queryId, options, // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) {\n            networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.loading;\n        }\n        if (query === void 0) {\n            query = options.query;\n        }\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context\n        });\n        var fromVariables = function(variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (// If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" && // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n            // this is another way to detect when nothing was done/fetched.\n            sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function() {\n            return _this.fetchCancelFns.delete(queryId);\n        };\n        this.fetchCancelFns.set(queryId, function(reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function() {\n                return concast.cancel(reason);\n            });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo) {\n                return sourcesWithInfo.sources;\n            }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        } else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_24__.Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink\n        };\n    };\n    QueryManager.prototype.refetchQueries = function(_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_20__.makeUniqueId)(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function(oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff()\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: optimistic && removeOptimistic || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function(watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__.QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, {\n                                oq: oq,\n                                lastDiff: lastDiff,\n                                diff: diff\n                            });\n                        }\n                    }\n                }\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function(_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset(); // Force info.getDiff() to read from cache.\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function(queryInfo, _a, // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus\n        });\n        var readCache = function() {\n            return queryInfo.getDiff();\n        };\n        var resultsFromCache = function(diff, networkStatus) {\n            if (networkStatus === void 0) {\n                networkStatus = queryInfo.networkStatus || _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.loading;\n            }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(data, {})) {\n                (0,_ObservableQuery_js__WEBPACK_IMPORTED_MODULE_16__.logMissingFieldErrors)(diff.missing);\n            }\n            var fromData = function(data) {\n                return _utilities_index_js__WEBPACK_IMPORTED_MODULE_21__.Observable.of((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({\n                    data: data,\n                    loading: (0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.isNetworkRequestInFlight)(networkStatus),\n                    networkStatus: networkStatus\n                }, diff.complete ? null : {\n                    partial: true\n                }));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState.runResolvers({\n                    document: query,\n                    remoteResult: {\n                        data: data\n                    },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true\n                }).then(function(resolved) {\n                    return fromData(resolved.data || void 0);\n                });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" && networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.refetch && Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */  : networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */  : 2 /* CacheWriteBehavior.MERGE */ ;\n        var resultsFromLink = function() {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && (0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_17__.isNetworkRequestInFlight)(networkStatus);\n        switch(fetchPolicy){\n            default:\n            case \"cache-first\":\n                {\n                    var diff = readCache();\n                    if (diff.complete) {\n                        return {\n                            fromLink: false,\n                            sources: [\n                                resultsFromCache(diff, queryInfo.markReady())\n                            ]\n                        };\n                    }\n                    if (returnPartialData || shouldNotify) {\n                        return {\n                            fromLink: true,\n                            sources: [\n                                resultsFromCache(diff),\n                                resultsFromLink()\n                            ]\n                        };\n                    }\n                    return {\n                        fromLink: true,\n                        sources: [\n                            resultsFromLink()\n                        ]\n                    };\n                }\n            case \"cache-and-network\":\n                {\n                    var diff = readCache();\n                    if (diff.complete || returnPartialData || shouldNotify) {\n                        return {\n                            fromLink: true,\n                            sources: [\n                                resultsFromCache(diff),\n                                resultsFromLink()\n                            ]\n                        };\n                    }\n                    return {\n                        fromLink: true,\n                        sources: [\n                            resultsFromLink()\n                        ]\n                    };\n                }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [\n                        resultsFromCache(readCache(), queryInfo.markReady())\n                    ]\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [\n                            resultsFromCache(readCache()),\n                            resultsFromLink()\n                        ]\n                    };\n                }\n                return {\n                    fromLink: true,\n                    sources: [\n                        resultsFromLink()\n                    ]\n                };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [\n                            resultsFromCache(queryInfo.getDiff()),\n                            resultsFromLink()\n                        ]\n                    };\n                }\n                return {\n                    fromLink: true,\n                    sources: [\n                        resultsFromLink()\n                    ]\n                };\n            case \"standby\":\n                return {\n                    fromLink: false,\n                    sources: []\n                };\n        }\n    };\n    QueryManager.prototype.getQuery = function(queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__.QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function(context) {\n        if (context === void 0) {\n            context = {};\n        }\n        var newContext = this.localState.prepareContext(context);\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, this.defaultContext), newContext), {\n            clientAwareness: this.clientAwareness\n        });\n    };\n    return QueryManager;\n}();\n //# sourceMappingURL=QueryManager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL1F1ZXJ5TWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDb0I7QUFDdkM7QUFDVTtBQUNnRztBQUN6RjtBQUNvTztBQUMzTTtBQUNpQjtBQUNuQjtBQUNEO0FBQ2Q7QUFDSDtBQUNkO0FBQzlDLElBQUlzQyxpQkFBaUJDLE9BQU9DLFNBQVMsQ0FBQ0YsY0FBYztBQUNwRCxJQUFJRyxTQUFTRixPQUFPRyxNQUFNLENBQUM7QUFDTTtBQUN3QztBQUN6RSxJQUFJSSxlQUFlLFdBQVcsR0FBSTtJQUM5QixTQUFTQSxhQUFhQyxPQUFPO1FBQ3pCLElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFDO1FBQ3hCLG1FQUFtRTtRQUNuRSwwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkIsK0RBQStEO1FBQy9ELHdDQUF3QztRQUN4Qyw0Q0FBNEM7UUFDNUMsZ0VBQWdFO1FBQ2hFLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUlEO1FBQzFCLElBQUksQ0FBQ0UsY0FBYyxHQUFHLElBQUlULHFFQUFvQkEsQ0FBQ0MsMkRBQVUsQ0FBQywrQkFBK0IsSUFDckYsS0FBSyxxREFBcUQ7UUFDOUQsSUFBSSxDQUFDUyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLDRDQUE0QztRQUM1QyxnRUFBZ0U7UUFDaEUsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRyxJQUFJZCwyQ0FBSUEsQ0FBQztRQUN4QyxJQUFJZSwyQkFBMkIsSUFBSWpDLGtFQUFpQkEsQ0FBQyxTQUFVa0MsUUFBUTtZQUFJLE9BQU9YLE1BQU1ZLEtBQUssQ0FBQ0MsaUJBQWlCLENBQUNGO1FBQVcsR0FDM0gsNERBQTRE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QUFJLENBQUNBLGVBQWU7UUFBQztJQUNySDtJQUNBLE9BQU9IO0FBQ1g7QUFDd0IsQ0FDeEIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL1F1ZXJ5TWFuYWdlci5qcz8wMWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQsIG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9nbG9iYWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlcXVhbCB9IGZyb20gXCJAd3J5L2VxdWFsaXR5XCI7XG5pbXBvcnQgeyBleGVjdXRlIH0gZnJvbSBcIi4uL2xpbmsvY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaGFzRGlyZWN0aXZlcywgaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0LCBpc0V4ZWN1dGlvblBhdGNoUmVzdWx0LCByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50LCB9IGZyb20gXCIuLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNhbm9uaWNhbFN0cmluZ2lmeSB9IGZyb20gXCIuLi9jYWNoZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFZhbHVlcywgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgZ2V0T3BlcmF0aW9uTmFtZSwgaGFzQ2xpZW50RXhwb3J0cywgZ3JhcGhRTFJlc3VsdEhhc0Vycm9yLCBnZXRHcmFwaFFMRXJyb3JzRnJvbVJlc3VsdCwgT2JzZXJ2YWJsZSwgYXN5bmNNYXAsIGlzTm9uRW1wdHlBcnJheSwgQ29uY2FzdCwgbWFrZVVuaXF1ZUlkLCBpc0RvY3VtZW50Tm9kZSwgaXNOb25OdWxsT2JqZWN0LCBEb2N1bWVudFRyYW5zZm9ybSwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBtZXJnZUluY3JlbWVudGFsRGF0YSB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29tbW9uL2luY3JlbWVudGFsUmVzdWx0LmpzXCI7XG5pbXBvcnQgeyBBcG9sbG9FcnJvciwgaXNBcG9sbG9FcnJvciwgZ3JhcGhRTFJlc3VsdEhhc1Byb3RvY29sRXJyb3JzLCB9IGZyb20gXCIuLi9lcnJvcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IE9ic2VydmFibGVRdWVyeSwgbG9nTWlzc2luZ0ZpZWxkRXJyb3JzIH0gZnJvbSBcIi4vT2JzZXJ2YWJsZVF1ZXJ5LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrU3RhdHVzLCBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQgfSBmcm9tIFwiLi9uZXR3b3JrU3RhdHVzLmpzXCI7XG5pbXBvcnQgeyBRdWVyeUluZm8sIHNob3VsZFdyaXRlUmVzdWx0LCB9IGZyb20gXCIuL1F1ZXJ5SW5mby5qc1wiO1xuaW1wb3J0IHsgUFJPVE9DT0xfRVJST1JTX1NZTUJPTCB9IGZyb20gXCIuLi9lcnJvcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IHByaW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBJR05PUkUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuaW1wb3J0IHsgVHJpZSB9IGZyb20gXCJAd3J5L3RyaWVcIjtcbmltcG9ydCB7IEF1dG9DbGVhbmVkV2Vha0NhY2hlLCBjYWNoZVNpemVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xudmFyIFF1ZXJ5TWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeU1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsaWVudEF3YXJlbmVzcyA9IHt9O1xuICAgICAgICAvLyBBbGwgdGhlIHF1ZXJpZXMgdGhhdCB0aGUgUXVlcnlNYW5hZ2VyIGlzIGN1cnJlbnRseSBtYW5hZ2luZyAobm90XG4gICAgICAgIC8vIGluY2x1ZGluZyBtdXRhdGlvbnMgYW5kIHN1YnNjcmlwdGlvbnMpLlxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcHMgZnJvbSBxdWVyeUlkIHN0cmluZ3MgdG8gUHJvbWlzZSByZWplY3Rpb24gZnVuY3Rpb25zIGZvclxuICAgICAgICAvLyBjdXJyZW50bHkgYWN0aXZlIHF1ZXJpZXMgYW5kIGZldGNoZXMuXG4gICAgICAgIC8vIFVzZSBwcm90ZWN0ZWQgaW5zdGVhZCBvZiBwcml2YXRlIGZpZWxkIHNvXG4gICAgICAgIC8vIEBhcG9sbG8vZXhwZXJpbWVudGFsLW5leHRqcy1hcHAtc3VwcG9ydCBjYW4gYWNjZXNzIHR5cGUgaW5mby5cbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYWNoZSA9IG5ldyBBdXRvQ2xlYW5lZFdlYWtDYWNoZShjYWNoZVNpemVzW1wicXVlcnlNYW5hZ2VyLmdldERvY3VtZW50SW5mb1wiXSB8fFxuICAgICAgICAgICAgMjAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcInF1ZXJ5TWFuYWdlci5nZXREb2N1bWVudEluZm9cIl0gKi8pO1xuICAgICAgICB0aGlzLnF1ZXJ5SWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbklkQ291bnRlciA9IDE7XG4gICAgICAgIC8vIFVzZSBwcm90ZWN0ZWQgaW5zdGVhZCBvZiBwcml2YXRlIGZpZWxkIHNvXG4gICAgICAgIC8vIEBhcG9sbG8vZXhwZXJpbWVudGFsLW5leHRqcy1hcHAtc3VwcG9ydCBjYW4gYWNjZXNzIHR5cGUgaW5mby5cbiAgICAgICAgdGhpcy5pbkZsaWdodExpbmtPYnNlcnZhYmxlcyA9IG5ldyBUcmllKGZhbHNlKTtcbiAgICAgICAgdmFyIGRlZmF1bHREb2N1bWVudFRyYW5zZm9ybSA9IG5ldyBEb2N1bWVudFRyYW5zZm9ybShmdW5jdGlvbiAoZG9jdW1lbnQpIHsgcmV0dXJuIF90aGlzLmNhY2hlLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTsgfSwgXG4gICAgICAgIC8vIEFsbG93IHRoZSBhcG9sbG8gY2FjaGUgdG8gbWFuYWdlIGl0cyBvd24gdHJhbnNmb3JtIGNhY2hlc1xuICAgICAgICB7IGNhY2hlOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGU7XG4gICAgICAgIHRoaXMubGluayA9IG9wdGlvbnMubGluaztcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIHRoaXMucXVlcnlEZWR1cGxpY2F0aW9uID0gb3B0aW9ucy5xdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuY2xpZW50QXdhcmVuZXNzID0gb3B0aW9ucy5jbGllbnRBd2FyZW5lc3M7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZSA9IG9wdGlvbnMubG9jYWxTdGF0ZTtcbiAgICAgICAgdGhpcy5zc3JNb2RlID0gb3B0aW9ucy5zc3JNb2RlO1xuICAgICAgICB0aGlzLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgPSBvcHRpb25zLmFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgICAgIHZhciBkb2N1bWVudFRyYW5zZm9ybSA9IG9wdGlvbnMuZG9jdW1lbnRUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUcmFuc2Zvcm0gPVxuICAgICAgICAgICAgZG9jdW1lbnRUcmFuc2Zvcm0gP1xuICAgICAgICAgICAgICAgIGRlZmF1bHREb2N1bWVudFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGRvY3VtZW50VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VzdG9tIGRvY3VtZW50IHRyYW5zZm9ybSBtYXkgYWRkIG5ldyBmcmFnbWVudCBzcHJlYWRzIG9yIG5ld1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBzZWxlY3Rpb25zLCBzbyB3ZSB3YW50IHRvIGdpdmUgdGhlIGNhY2hlIGEgY2hhbmNlIHRvIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyBhZ2Fpbi4gRm9yIGV4YW1wbGUsIHRoZSBJbk1lbW9yeUNhY2hlIGFkZHMgX190eXBlbmFtZSB0byBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb25zIGFuZCBmcmFnbWVudHMgZnJvbSB0aGUgZnJhZ21lbnQgcmVnaXN0cnkuXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZGVmYXVsdERvY3VtZW50VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdERvY3VtZW50VHJhbnNmb3JtO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb250ZXh0ID0gb3B0aW9ucy5kZWZhdWx0Q29udGV4dCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoKHRoaXMub25Ccm9hZGNhc3QgPSBvcHRpb25zLm9uQnJvYWRjYXN0KSkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgYWN0aXZlIHF1ZXJ5IHByb2Nlc3NlcywgbWFraW5nIGl0IHNhZmVcbiAgICAgKiB0byBkaXNwb3NlIG9mIHRoaXMgUXVlcnlNYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9pbmZvLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FuY2VsUGVuZGluZ0ZldGNoZXMobmV3SW52YXJpYW50RXJyb3IoMjYpKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuY2FuY2VsUGVuZGluZ0ZldGNoZXMgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5mb3JFYWNoKGZ1bmN0aW9uIChjYW5jZWwpIHsgcmV0dXJuIGNhbmNlbChlcnJvcik7IH0pO1xuICAgICAgICB0aGlzLmZldGNoQ2FuY2VsRm5zLmNsZWFyKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbklkLCBoYXNDbGllbnRFeHBvcnRzLCBtdXRhdGlvblN0b3JlVmFsdWUsIGlzT3B0aW1pc3RpYywgc2VsZjtcbiAgICAgICAgICAgIHZhciBfYywgX2Q7XG4gICAgICAgICAgICB2YXIgbXV0YXRpb24gPSBfYi5tdXRhdGlvbiwgdmFyaWFibGVzID0gX2IudmFyaWFibGVzLCBvcHRpbWlzdGljUmVzcG9uc2UgPSBfYi5vcHRpbWlzdGljUmVzcG9uc2UsIHVwZGF0ZVF1ZXJpZXMgPSBfYi51cGRhdGVRdWVyaWVzLCBfZSA9IF9iLnJlZmV0Y2hRdWVyaWVzLCByZWZldGNoUXVlcmllcyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IF9iLmF3YWl0UmVmZXRjaFF1ZXJpZXMsIGF3YWl0UmVmZXRjaFF1ZXJpZXMgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZiwgdXBkYXRlV2l0aFByb3h5Rm4gPSBfYi51cGRhdGUsIG9uUXVlcnlVcGRhdGVkID0gX2Iub25RdWVyeVVwZGF0ZWQsIF9nID0gX2IuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2cgPT09IHZvaWQgMCA/ICgoX2MgPSB0aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZldGNoUG9saWN5KSB8fCBcIm5ldHdvcmstb25seVwiIDogX2csIF9oID0gX2IuZXJyb3JQb2xpY3ksIGVycm9yUG9saWN5ID0gX2ggPT09IHZvaWQgMCA/ICgoX2QgPSB0aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVycm9yUG9saWN5KSB8fCBcIm5vbmVcIiA6IF9oLCBrZWVwUm9vdEZpZWxkcyA9IF9iLmtlZXBSb290RmllbGRzLCBjb250ZXh0ID0gX2IuY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudChtdXRhdGlvbiwgMjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50KGZldGNoUG9saWN5ID09PSBcIm5ldHdvcmstb25seVwiIHx8IGZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIsIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQgPSB0aGlzLmdlbmVyYXRlTXV0YXRpb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSB0aGlzLmNhY2hlLnRyYW5zZm9ybUZvckxpbmsodGhpcy50cmFuc2Zvcm0obXV0YXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsaWVudEV4cG9ydHMgPSB0aGlzLmdldERvY3VtZW50SW5mbyhtdXRhdGlvbikuaGFzQ2xpZW50RXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNDbGllbnRFeHBvcnRzKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubG9jYWxTdGF0ZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhtdXRhdGlvbiwgdmFyaWFibGVzLCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IChfai5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2oubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUgPSB0aGlzLm11dGF0aW9uU3RvcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5tdXRhdGlvblN0b3JlW211dGF0aW9uSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbjogbXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW1pc3RpYyA9IG9wdGltaXN0aWNSZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya011dGF0aW9uT3B0aW1pc3RpYyhvcHRpbWlzdGljUmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZDogbXV0YXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IHVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlV2l0aFByb3h5Rm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBSb290RmllbGRzOiBrZWVwUm9vdEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNNYXAoc2VsZi5nZXRPYnNlcnZhYmxlRnJvbUxpbmsobXV0YXRpb24sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBvcHRpbWlzdGljUmVzcG9uc2U6IGlzT3B0aW1pc3RpYyA/IG9wdGltaXN0aWNSZXNwb25zZSA6IHZvaWQgMCB9KSwgdmFyaWFibGVzLCB7fSwgZmFsc2UpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCkgJiYgZXJyb3JQb2xpY3kgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogZ2V0R3JhcGhRTEVycm9yc0Zyb21SZXN1bHQocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvblN0b3JlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uU3RvcmVWYWx1ZS5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVSZXN1bHQgPSBfX2Fzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXRjaFF1ZXJpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyaWVzID0gcmVmZXRjaFF1ZXJpZXMoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSBcImlnbm9yZVwiICYmIGdyYXBoUUxSZXN1bHRIYXNFcnJvcihzdG9yZVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubWFya011dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogc3RvcmVSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVdpdGhQcm94eUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IHVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRSZWZldGNoUXVlcmllczogYXdhaXRSZWZldGNoUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZldGNoUXVlcmllczogcmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT3B0aW1pc3RpYzogaXNPcHRpbWlzdGljID8gbXV0YXRpb25JZCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXJ5VXBkYXRlZDogb25RdWVyeVVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcFJvb3RGaWVsZHM6IGtlZXBSb290RmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoc3RvcmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBtdXRhdGlvbnMgbWlnaHQgcmVjZWl2ZSBtdWx0aXBsZSBwYXlsb2FkcyBmcm9tIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwb2xsb0xpbmsgY2hhaW4gKGUuZy4gd2hlbiB1c2VkIHdpdGggQGRlZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXNvbHZlIHdpdGggYSBTaW5nbGVFeGVjdXRpb25SZXN1bHQgb3IgYWZ0ZXIgdGhlIGZpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0aW9uUGF0Y2hSZXN1bHQgaGFzIGFycml2ZWQgYW5kIHdlIGhhdmUgYXNzZW1ibGVkIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11bHRpcGFydCByZXNwb25zZSBpbnRvIGEgc2luZ2xlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShcImhhc05leHRcIiBpbiBzdG9yZVJlc3VsdCkgfHwgc3RvcmVSZXN1bHQuaGFzTmV4dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdG9yZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uU3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wdGltaXN0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZS5yZW1vdmVPcHRpbWlzdGljKG11dGF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyIGluc3RhbmNlb2YgQXBvbGxvRXJyb3IgPyBlcnIgOiAobmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLm1hcmtNdXRhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChtdXRhdGlvbiwgY2FjaGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNhY2hlID09PSB2b2lkIDApIHsgY2FjaGUgPSB0aGlzLmNhY2hlOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBtdXRhdGlvbi5yZXN1bHQ7XG4gICAgICAgIHZhciBjYWNoZVdyaXRlcyA9IFtdO1xuICAgICAgICB2YXIgc2tpcENhY2hlID0gbXV0YXRpb24uZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIjtcbiAgICAgICAgaWYgKCFza2lwQ2FjaGUgJiYgc2hvdWxkV3JpdGVSZXN1bHQocmVzdWx0LCBtdXRhdGlvbi5lcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgIGlmICghaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVdyaXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiBcIlJPT1RfTVVUQVRJT05cIixcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG11dGF0aW9uLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4ZWN1dGlvblBhdGNoSW5jcmVtZW50YWxSZXN1bHQocmVzdWx0KSAmJlxuICAgICAgICAgICAgICAgIGlzTm9uRW1wdHlBcnJheShyZXN1bHQuaW5jcmVtZW50YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjYWNoZS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwiUk9PVF9NVVRBVElPTlwiLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FjaGUgY29tcGxhaW5zIGlmIHBhc3NlZCBhIG11dGF0aW9uIHdoZXJlIGl0IGV4cGVjdHMgYVxuICAgICAgICAgICAgICAgICAgICAvLyBxdWVyeSwgc28gd2UgdHJhbnNmb3JtIG11dGF0aW9ucyBhbmQgc3Vic2NyaXB0aW9ucyB0byBxdWVyaWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIChvbmx5IG9uY2UsIHRoYW5rcyB0byB0aGlzLnRyYW5zZm9ybUNhY2hlKS5cbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRoaXMuZ2V0RG9jdW1lbnRJbmZvKG11dGF0aW9uLmRvY3VtZW50KS5hc1F1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZWREYXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWREYXRhID0gbWVyZ2VJbmNyZW1lbnRhbERhdGEoZGlmZi5yZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVyZ2VkRGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXN0IHRoZSBFeGVjdXRpb25QYXRjaFJlc3VsdCB0byBGZXRjaFJlc3VsdCBoZXJlIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGlvblBhdGNoUmVzdWx0IG5ldmVyIGhhcyBgZGF0YWAgd2hlbiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBtZXJnZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVdyaXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogbWVyZ2VkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJZDogXCJST09UX01VVEFUSU9OXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogbXV0YXRpb24uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJpZXNfMSA9IG11dGF0aW9uLnVwZGF0ZVF1ZXJpZXM7XG4gICAgICAgICAgICBpZiAodXBkYXRlUXVlcmllc18xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU5hbWUgPSBvYnNlcnZhYmxlUXVlcnkgJiYgb2JzZXJ2YWJsZVF1ZXJ5LnF1ZXJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeU5hbWUgfHwgIWhhc093blByb3BlcnR5LmNhbGwodXBkYXRlUXVlcmllc18xLCBxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXIgPSB1cGRhdGVRdWVyaWVzXzFbcXVlcnlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucXVlcmllcy5nZXQocXVlcnlJZCksIGRvY3VtZW50ID0gX2IuZG9jdW1lbnQsIHZhcmlhYmxlcyA9IF9iLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgY3VycmVudCBxdWVyeSByZXN1bHQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGNhY2hlLmRpZmYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgY3VycmVudFF1ZXJ5UmVzdWx0ID0gX2MucmVzdWx0LCBjb21wbGV0ZSA9IF9jLmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUgJiYgY3VycmVudFF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW4gb3VyIHJlZHVjZXIgdXNpbmcgdGhlIGN1cnJlbnQgcXVlcnkgcmVzdWx0IGFuZCB0aGUgbXV0YXRpb24gcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRRdWVyeVJlc3VsdCA9IHVwZGF0ZXIoY3VycmVudFF1ZXJ5UmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25SZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWU6IChkb2N1bWVudCAmJiBnZXRPcGVyYXRpb25OYW1lKGRvY3VtZW50KSkgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBtb2RpZmllZCByZXN1bHQgYmFjayBpbnRvIHRoZSBzdG9yZSBpZiB3ZSBnb3QgYSBuZXcgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRRdWVyeVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlV3JpdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG5leHRRdWVyeVJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiBcIlJPT1RfUVVFUllcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZVdyaXRlcy5sZW5ndGggPiAwIHx8XG4gICAgICAgICAgICAobXV0YXRpb24ucmVmZXRjaFF1ZXJpZXMgfHwgXCJcIikubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgbXV0YXRpb24udXBkYXRlIHx8XG4gICAgICAgICAgICBtdXRhdGlvbi5vblF1ZXJ5VXBkYXRlZCB8fFxuICAgICAgICAgICAgbXV0YXRpb24ucmVtb3ZlT3B0aW1pc3RpYykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHNfMSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWZldGNoUXVlcmllcyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVXcml0ZXMuZm9yRWFjaChmdW5jdGlvbiAod3JpdGUpIHsgcmV0dXJuIGNhY2hlLndyaXRlKHdyaXRlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG11dGF0aW9uIGhhcyBzb21lIHdyaXRlcyBhc3NvY2lhdGVkIHdpdGggaXQgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRob3NlIHdyaXRlcyB0byB0aGUgc3RvcmUgYnkgcnVubmluZyB0aGlzIHJlZHVjZXIgYWdhaW4gd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBhIHdyaXRlIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IG11dGF0aW9uLnVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgcmVzdWx0IGlzIGEgU2luZ2xlRXhlY3V0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0aGUgZmluYWwgRXhlY3V0aW9uUGF0Y2hSZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0ZpbmFsUmVzdWx0ID0gIWlzRXhlY3V0aW9uUGF0Y2hSZXN1bHQocmVzdWx0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdChyZXN1bHQpICYmICFyZXN1bHQuaGFzTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtcmVhZCB0aGUgUk9PVF9NVVRBVElPTiBkYXRhIHdlIGp1c3Qgd3JvdGUgaW50byB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAodGhlIGZpcnN0IGNhY2hlLndyaXRlIGNhbGwgaW4gdGhlIGNhY2hlV3JpdGVzLmZvckVhY2ggbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3ZlKSwgc28gZmllbGQgcmVhZCBmdW5jdGlvbnMgaGF2ZSBhIGNoYW5jZSB0byBydW4gZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIHdpdGhpbiBtdXRhdGlvbiByZXN1bHQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGNhY2hlLmRpZmYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJST09UX01VVEFUSU9OXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjYWNoZSBjb21wbGFpbnMgaWYgcGFzc2VkIGEgbXV0YXRpb24gd2hlcmUgaXQgZXhwZWN0cyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5LCBzbyB3ZSB0cmFuc2Zvcm0gbXV0YXRpb25zIGFuZCBzdWJzY3JpcHRpb25zIHRvIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG9ubHkgb25jZSwgdGhhbmtzIHRvIHRoaXMudHJhbnNmb3JtQ2FjaGUpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogX3RoaXMuZ2V0RG9jdW1lbnRJbmZvKG11dGF0aW9uLmRvY3VtZW50KS5hc1F1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IGRhdGE6IGRpZmYucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJpbmNyZW1lbnRhbFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5pbmNyZW1lbnRhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJoYXNOZXh0XCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0Lmhhc05leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWNlaXZlZCB0aGUgd2hvbGUgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgYSBTaW5nbGVFeGVjdXRpb25SZXN1bHQgb3IgdGhlIGZpbmFsIEV4ZWN1dGlvblBhdGNoUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmluYWxSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoY2FjaGUsIHJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBtdXRhdGlvbi5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIERvIHRoaXMgd2l0aCBjYWNoZS5ldmljdCh7IGlkOiAnUk9PVF9NVVRBVElPTicgfSkgYnV0IG1ha2UgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyB0byBhbGxvdyByb2xsaW5nIGJhY2sgb3B0aW1pc3RpYyBldmljdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhY2hlICYmICFtdXRhdGlvbi5rZWVwUm9vdEZpZWxkcyAmJiBpc0ZpbmFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5tb2RpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIlJPT1RfTVVUQVRJT05cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IF9hLmZpZWxkTmFtZSwgREVMRVRFID0gX2EuREVMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGROYW1lID09PSBcIl9fdHlwZW5hbWVcIiA/IHZhbHVlIDogREVMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogbXV0YXRpb24ucmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGZpbmFsIG11dGF0aW9uLnJlc3VsdCB0byB0aGUgcm9vdCBsYXllciBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgbGF5ZXIgYXQgdGhlIHNhbWUgdGltZSBhcyB3ZVxuICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRoZSBmaW5hbCBub24tb3B0aW1pc3RpYyByZXN1bHQuXG4gICAgICAgICAgICAgICAgcmVtb3ZlT3B0aW1pc3RpYzogbXV0YXRpb24ucmVtb3ZlT3B0aW1pc3RpYyxcbiAgICAgICAgICAgICAgICAvLyBMZXQgdGhlIGNhbGxlciBvZiBjbGllbnQubXV0YXRlIG9wdGlvbmFsbHkgZGV0ZXJtaW5lIHRoZSByZWZldGNoaW5nXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgZm9yIHdhdGNoZWQgcXVlcmllcyBhZnRlciB0aGUgbXV0YXRpb24udXBkYXRlIGZ1bmN0aW9uIHJ1bnMuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb25RdWVyeVVwZGF0ZWQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkIGZvciB0aGlzIG11dGF0aW9uLCBwYXNzXG4gICAgICAgICAgICAgICAgLy8gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCB0byBkaXNhYmxlIHRoZSBkZWZhdWx0IHJlZmV0Y2hpbmcgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgb25RdWVyeVVwZGF0ZWQ6IG11dGF0aW9uLm9uUXVlcnlVcGRhdGVkIHx8IG51bGwsXG4gICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdHNfMS5wdXNoKHJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmF3YWl0UmVmZXRjaFF1ZXJpZXMgfHwgbXV0YXRpb24ub25RdWVyeVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5pbmcgYSBwcm9taXNlIGhlcmUgbWFrZXMgdGhlIG11dGF0aW9uIGF3YWl0IHRoYXQgcHJvbWlzZSwgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHJlc3VsdHMgaW4gdGhhdCBwcm9taXNlJ3Mgd29yayBpZiBhd2FpdFJlZmV0Y2hRdWVyaWVzIG9yIGFuXG4gICAgICAgICAgICAgICAgLy8gb25RdWVyeVVwZGF0ZWQgZnVuY3Rpb24gd2FzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0c18xKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5tYXJrTXV0YXRpb25PcHRpbWlzdGljID0gZnVuY3Rpb24gKG9wdGltaXN0aWNSZXNwb25zZSwgbXV0YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSB0eXBlb2Ygb3B0aW1pc3RpY1Jlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIgP1xuICAgICAgICAgICAgb3B0aW1pc3RpY1Jlc3BvbnNlKG11dGF0aW9uLnZhcmlhYmxlcywgeyBJR05PUkU6IElHTk9SRSB9KVxuICAgICAgICAgICAgOiBvcHRpbWlzdGljUmVzcG9uc2U7XG4gICAgICAgIGlmIChkYXRhID09PSBJR05PUkUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLnJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFya011dGF0aW9uUmVzdWx0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBtdXRhdGlvbiksIHsgcmVzdWx0OiB7IGRhdGE6IGRhdGEgfSB9KSwgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBtdXRhdGlvbi5tdXRhdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmZldGNoUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgbmV0d29ya1N0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaENvbmNhc3RXaXRoSW5mbyhxdWVyeUlkLCBvcHRpb25zLCBuZXR3b3JrU3RhdHVzKS5jb25jYXN0XG4gICAgICAgICAgICAucHJvbWlzZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0UXVlcnlTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHN0b3JlW3F1ZXJ5SWRdID0ge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogaW5mby52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogaW5mby5uZXR3b3JrU3RhdHVzLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogaW5mby5uZXR3b3JrRXJyb3IsXG4gICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogaW5mby5ncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUucmVzZXRFcnJvcnMgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5ncmFwaFFMRXJyb3JzID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHJhbnNmb3JtLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0RG9jdW1lbnRJbmZvID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1DYWNoZSA9IHRoaXMudHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICghdHJhbnNmb3JtQ2FjaGUuaGFzKGRvY3VtZW50KSkge1xuICAgICAgICAgICAgdmFyIGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBUaGVzZSB0aHJlZSBjYWxscyAoaGFzQ2xpZW50RXhwb3J0cywgc2hvdWxkRm9yY2VSZXNvbHZlcnMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHVzZXNOb25yZWFjdGl2ZURpcmVjdGl2ZSkgYXJlIHBlcmZvcm1pbmcgaW5kZXBlbmRlbnQgZnVsbCB0cmF2ZXJzYWxzXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50LiBXZSBzaG91bGQgY29uc2lkZXIgbWVyZ2luZyB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIHRyYXZlcnNhbHMgaW50byBhIHNpbmdsZSBwYXNzIGluIHRoZSBmdXR1cmUsIHRob3VnaCB0aGUgd29yayBpc1xuICAgICAgICAgICAgICAgIC8vIGNhY2hlZCBhZnRlciB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgICAgICAgICBoYXNDbGllbnRFeHBvcnRzOiBoYXNDbGllbnRFeHBvcnRzKGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICBoYXNGb3JjZWRSZXNvbHZlcnM6IHRoaXMubG9jYWxTdGF0ZS5zaG91bGRGb3JjZVJlc29sdmVycyhkb2N1bWVudCksXG4gICAgICAgICAgICAgICAgaGFzTm9ucmVhY3RpdmVEaXJlY3RpdmU6IGhhc0RpcmVjdGl2ZXMoW1wibm9ucmVhY3RpdmVcIl0sIGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICBjbGllbnRRdWVyeTogdGhpcy5sb2NhbFN0YXRlLmNsaWVudFF1ZXJ5KGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJRdWVyeTogcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJjbGllbnRcIiwgcmVtb3ZlOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJjb25uZWN0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIm5vbnJlYWN0aXZlXCIgfSxcbiAgICAgICAgICAgICAgICBdLCBkb2N1bWVudCksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhcnM6IGdldERlZmF1bHRWYWx1ZXMoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2N1bWVudCkpLFxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBhbnkgbXV0YXRpb24gb3Igc3Vic2NyaXB0aW9uIG9wZXJhdGlvbnMgdG8gcXVlcnkgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiByZWFkL3dyaXRlIHRoZW0gZnJvbS90byB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgYXNRdWVyeTogX19hc3NpZ24oX19hc3NpZ24oe30sIGRvY3VtZW50KSwgeyBkZWZpbml0aW9uczogZG9jdW1lbnQuZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYub3BlcmF0aW9uICE9PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZiksIHsgb3BlcmF0aW9uOiBcInF1ZXJ5XCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICAgICAgICAgICAgICB9KSB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFuc2Zvcm1DYWNoZS5zZXQoZG9jdW1lbnQsIGNhY2hlRW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQoZG9jdW1lbnQpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZ2V0RG9jdW1lbnRJbmZvKGRvY3VtZW50KS5kZWZhdWx0VmFycyksIHZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLndhdGNoUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnRyYW5zZm9ybShvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgLy8gYXNzaWduIHZhcmlhYmxlIGRlZmF1bHQgdmFsdWVzIGlmIHN1cHBsaWVkXG4gICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IG1vZGlmeSBvcHRpb25zLnF1ZXJ5IGhlcmUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgcXVlcnkgdG9cbiAgICAgICAgLy8gZW5zdXJlIG9ic2VydmFibGUub3B0aW9ucy5xdWVyeSBpcyBzZXQgdG8gdGhlIHJhdyB1bnRyYW5zZm9ybWVkIHF1ZXJ5LlxuICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZhcmlhYmxlczogdGhpcy5nZXRWYXJpYWJsZXMocXVlcnksIG9wdGlvbnMudmFyaWFibGVzKSB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5ub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnlJbmZvID0gbmV3IFF1ZXJ5SW5mbyh0aGlzKTtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVF1ZXJ5KHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlcjogdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5SW5mbzogcXVlcnlJbmZvLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmFibGVbXCJsYXN0UXVlcnlcIl0gPSBxdWVyeTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLnNldChvYnNlcnZhYmxlLnF1ZXJ5SWQsIHF1ZXJ5SW5mbyk7XG4gICAgICAgIC8vIFdlIGdpdmUgcXVlcnlJbmZvIHRoZSB0cmFuc2Zvcm1lZCBxdWVyeSB0byBlbnN1cmUgdGhlIGZpcnN0IGNhY2hlIGRpZmZcbiAgICAgICAgLy8gdXNlcyB0aGUgdHJhbnNmb3JtZWQgcXVlcnkgaW5zdGVhZCBvZiB0aGUgcmF3IHF1ZXJ5XG4gICAgICAgIHF1ZXJ5SW5mby5pbml0KHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeTogb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb2JzZXJ2YWJsZS52YXJpYWJsZXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgcXVlcnlJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocXVlcnlJZCA9PT0gdm9pZCAwKSB7IHF1ZXJ5SWQgPSB0aGlzLmdlbmVyYXRlUXVlcnlJZCgpOyB9XG4gICAgICAgIGludmFyaWFudChvcHRpb25zLnF1ZXJ5LCAyOSk7XG4gICAgICAgIGludmFyaWFudChvcHRpb25zLnF1ZXJ5LmtpbmQgPT09IFwiRG9jdW1lbnRcIiwgMzApO1xuICAgICAgICBpbnZhcmlhbnQoIW9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIDMxKTtcbiAgICAgICAgaW52YXJpYW50KCFvcHRpb25zLnBvbGxJbnRlcnZhbCwgMzIpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFF1ZXJ5KHF1ZXJ5SWQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBxdWVyeTogdGhpcy50cmFuc2Zvcm0ob3B0aW9ucy5xdWVyeSkgfSkpLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RvcFF1ZXJ5KHF1ZXJ5SWQpOyB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMucXVlcnlJZENvdW50ZXIrKyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlUmVxdWVzdElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SWRDb3VudGVyKys7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlTXV0YXRpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLm11dGF0aW9uSWRDb3VudGVyKyspO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbylcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5zdG9wKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmNsZWFyU3RvcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkaXNjYXJkV2F0Y2hlczogdHJ1ZSxcbiAgICAgICAgfTsgfVxuICAgICAgICAvLyBCZWZvcmUgd2UgaGF2ZSBzZW50IHRoZSByZXNldCBhY3Rpb24gdG8gdGhlIHN0b3JlLCB3ZSBjYW4gbm8gbG9uZ2VyXG4gICAgICAgIC8vIHJlbHkgb24gdGhlIHJlc3VsdHMgcmV0dXJuZWQgYnkgaW4tZmxpZ2h0IHJlcXVlc3RzIHNpbmNlIHRoZXNlIG1heVxuICAgICAgICAvLyBkZXBlbmQgb24gdmFsdWVzIHRoYXQgcHJldmlvdXNseSBleGlzdGVkIGluIHRoZSBkYXRhIHBvcnRpb24gb2YgdGhlXG4gICAgICAgIC8vIHN0b3JlLiBTbywgd2UgY2FuY2VsIHRoZSBwcm9taXNlcyBhbmQgb2JzZXJ2ZXJzIHRoYXQgd2UgaGF2ZSBpc3N1ZWRcbiAgICAgICAgLy8gc28gZmFyIGFuZCBub3QgeWV0IHJlc29sdmVkIChpbiB0aGUgY2FzZSBvZiBxdWVyaWVzKS5cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nRmV0Y2hlcyhuZXdJbnZhcmlhbnRFcnJvcigzMykpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJbmZvKSB7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLm9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBsb2FkaW5nIHRvIHRydWUgc28gbGlzdGVuZXJzIGRvbid0IHRyaWdnZXIgdW5sZXNzIHRoZXkgd2FudFxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgd2l0aCBwYXJ0aWFsIGRhdGEuXG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmxvYWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25TdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWdpbiByZW1vdmluZyBkYXRhIGZyb20gdGhlIHN0b3JlXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnJlc2V0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpbmNsdWRlID09PSB2b2lkIDApIHsgaW5jbHVkZSA9IFwiYWN0aXZlXCI7IH1cbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBxdWVyeU5hbWVzQW5kRG9jcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGxlZ2FjeVF1ZXJ5T3B0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5jbHVkZSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5zZXQoZGVzYywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RvY3VtZW50Tm9kZShkZXNjKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5zZXQoX3RoaXMudHJhbnNmb3JtKGRlc2MpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9uTnVsbE9iamVjdChkZXNjKSAmJiBkZXNjLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5T3B0aW9ucy5hZGQoZGVzYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICB2YXIgb3EgPSBfYS5vYnNlcnZhYmxlUXVlcnksIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAob3EpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzLnNldChxdWVyeUlkLCBvcSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5TmFtZSA9IG9xLnF1ZXJ5TmFtZSwgZmV0Y2hQb2xpY3kgPSBvcS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGluY2x1ZGUgPT09IFwiYWN0aXZlXCIgJiYgIW9xLmhhc09ic2VydmVycygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlID09PSBcImFjdGl2ZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChxdWVyeU5hbWUgJiYgcXVlcnlOYW1lc0FuZERvY3MuaGFzKHF1ZXJ5TmFtZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkb2N1bWVudCAmJiBxdWVyeU5hbWVzQW5kRG9jcy5oYXMoZG9jdW1lbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzLnNldChxdWVyeUlkLCBvcSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5zZXQocXVlcnlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lc0FuZERvY3Muc2V0KGRvY3VtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGVnYWN5UXVlcnlPcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5T3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBiZSBpc3N1aW5nIGEgZnJlc2ggbmV0d29yayByZXF1ZXN0IGZvciB0aGlzIHF1ZXJ5LCBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIHByZS1hbGxvY2F0ZSBhIG5ldyBxdWVyeSBJRCBoZXJlLCB1c2luZyBhIHNwZWNpYWwgcHJlZml4IHRvIGVuYWJsZVxuICAgICAgICAgICAgICAgIC8vIGNsZWFuaW5nIHVwIHRoZXNlIHRlbXBvcmFyeSBxdWVyaWVzIGxhdGVyLCBhZnRlciBmZXRjaGluZy5cbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlJZCA9IG1ha2VVbmlxdWVJZChcImxlZ2FjeU9uZVRpbWVRdWVyeVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlJbmZvID0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkuaW5pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBvcSA9IG5ldyBPYnNlcnZhYmxlUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeU1hbmFnZXI6IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeUluZm86IHF1ZXJ5SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiBcIm5ldHdvcmstb25seVwiIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGludmFyaWFudChvcS5xdWVyeUlkID09PSBxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8uc2V0T2JzZXJ2YWJsZVF1ZXJ5KG9xKTtcbiAgICAgICAgICAgICAgICBxdWVyaWVzLnNldChxdWVyeUlkLCBvcSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBxdWVyeU5hbWVzQW5kRG9jcy5zaXplKSB7XG4gICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmNsdWRlZCwgbmFtZU9yRG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmIGludmFyaWFudC53YXJuKHR5cGVvZiBuYW1lT3JEb2MgPT09IFwic3RyaW5nXCIgPyAzNCA6IDM1LCBuYW1lT3JEb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyaWVzO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVN0YW5kYnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluY2x1ZGVTdGFuZGJ5ID09PSB2b2lkIDApIHsgaW5jbHVkZVN0YW5kYnkgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlU3RhbmRieSA/IFwiYWxsXCIgOiBcImFjdGl2ZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnksIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9ic2VydmFibGVRdWVyeS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5LnJlc2V0TGFzdFJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlU3RhbmRieSB8fFxuICAgICAgICAgICAgICAgIChmZXRjaFBvbGljeSAhPT0gXCJzdGFuZGJ5XCIgJiYgZmV0Y2hQb2xpY3kgIT09IFwiY2FjaGUtb25seVwiKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeVByb21pc2VzLnB1c2gob2JzZXJ2YWJsZVF1ZXJ5LnJlZmV0Y2goKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zZXREaWZmKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvYnNlcnZhYmxlUXVlcnlQcm9taXNlcyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnNldE9ic2VydmFibGVRdWVyeSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgdGhpcy5nZXRRdWVyeShvYnNlcnZhYmxlUXVlcnkucXVlcnlJZCkuc2V0T2JzZXJ2YWJsZVF1ZXJ5KG9ic2VydmFibGVRdWVyeSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgX2IgPSBfYS5lcnJvclBvbGljeSwgZXJyb3JQb2xpY3kgPSBfYiA9PT0gdm9pZCAwID8gXCJub25lXCIgOiBfYiwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBfYyA9IF9hLmNvbnRleHQsIGNvbnRleHQgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgX2QgPSBfYS5leHRlbnNpb25zLCBleHRlbnNpb25zID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2Q7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpO1xuICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIG1ha2VPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldE9ic2VydmFibGVGcm9tTGluayhxdWVyeSwgY29udGV4dCwgdmFyaWFibGVzLCBleHRlbnNpb25zKS5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSAhPT0gXCJuby1jYWNoZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJzY3JpcHRpb24gaW50ZXJmYWNlIHNob3VsZCBoYW5kbGUgbm90IHNlbmRpbmcgdXMgcmVzdWx0cyB3ZSBubyBsb25nZXIgc3Vic2NyaWJlIHRvLlxuICAgICAgICAgICAgICAgICAgICAvLyBYWFggSSBkb24ndCB0aGluayB3ZSBldmVyIHNlbmQgaW4gYW4gb2JqZWN0IHdpdGggZXJyb3JzLCBidXQgd2UgbWlnaHQgaW4gdGhlIGZ1dHVyZS4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkV3JpdGVSZXN1bHQocmVzdWx0LCBlcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhY2hlLndyaXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IFwiUk9PVF9TVUJTQ1JJUFRJT05cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNQcm90b2NvbEVycm9ycyA9IGdyYXBoUUxSZXN1bHRIYXNQcm90b2NvbEVycm9ycyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgfHwgaGFzUHJvdG9jb2xFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuZ3JhcGhRTEVycm9ycyA9IHJlc3VsdC5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvY29sRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHJvdG9jb2xFcnJvcnMgPSByZXN1bHQuZXh0ZW5zaW9uc1tQUk9UT0NPTF9FUlJPUlNfU1lNQk9MXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBgZXJyb3JQb2xpY3lgIGlzIGEgbWVjaGFuaXNtIGZvciBoYW5kbGluZyBHcmFwaFFMIGVycm9ycywgYWNjb3JkaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIG91ciBkb2N1bWVudGF0aW9uLCBzbyB3ZSB0aHJvdyBwcm90b2NvbCBlcnJvcnMgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGVycm9yIHBvbGljeS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSBcIm5vbmVcIiB8fCBoYXNQcm90b2NvbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwb2xsb0Vycm9yKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmdldERvY3VtZW50SW5mbyhxdWVyeSkuaGFzQ2xpZW50RXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGVQcm9taXNlXzEgPSB0aGlzLmxvY2FsU3RhdGVcbiAgICAgICAgICAgICAgICAuYWRkRXhwb3J0ZWRWYXJpYWJsZXMocXVlcnksIHZhcmlhYmxlcywgY29udGV4dClcbiAgICAgICAgICAgICAgICAudGhlbihtYWtlT2JzZXJ2YWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVByb21pc2VfMS50aGVuKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7IHJldHVybiAoc3ViID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpKTsgfSwgb2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIgJiYgc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU9ic2VydmFibGUodmFyaWFibGVzKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeU5vQnJvYWRjYXN0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUXVlcnkocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgLy8gdGVhcmRvd24gYWxsIGxpbmtzXG4gICAgICAgIC8vIEJvdGggYFF1ZXJ5TWFuYWdlci5mZXRjaFJlcXVlc3RgIGFuZCBgUXVlcnlNYW5hZ2VyLnF1ZXJ5YCBjcmVhdGUgc2VwYXJhdGUgcHJvbWlzZXNcbiAgICAgICAgLy8gdGhhdCBlYWNoIGFkZCB0aGVpciByZWplY3QgZnVuY3Rpb25zIHRvIGZldGNoQ2FuY2VsRm5zLlxuICAgICAgICAvLyBBIHF1ZXJ5IGNyZWF0ZWQgd2l0aCBgUXVlcnlNYW5hZ2VyLnF1ZXJ5KClgIGNvdWxkIHRyaWdnZXIgYSBgUXVlcnlNYW5hZ2VyLmZldGNoUmVxdWVzdGAuXG4gICAgICAgIC8vIFRoZSBzYW1lIHF1ZXJ5SWQgY291bGQgaGF2ZSB0d28gcmVqZWN0aW9uIGZucyBmb3IgdHdvIHByb21pc2VzXG4gICAgICAgIHRoaXMuZmV0Y2hDYW5jZWxGbnMuZGVsZXRlKHF1ZXJ5SWQpO1xuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLmhhcyhxdWVyeUlkKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmJyb2FkY2FzdFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uQnJvYWRjYXN0KVxuICAgICAgICAgICAgdGhpcy5vbkJyb2FkY2FzdCgpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5ub3RpZnkoKTsgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldExvY2FsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldE9ic2VydmFibGVGcm9tTGluayA9IGZ1bmN0aW9uIChxdWVyeSwgY29udGV4dCwgdmFyaWFibGVzLCBleHRlbnNpb25zLCBcbiAgICAvLyBQcmVmZXIgY29udGV4dC5xdWVyeURlZHVwbGljYXRpb24gaWYgc3BlY2lmaWVkLlxuICAgIGRlZHVwbGljYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGVkdXBsaWNhdGlvbiA9PT0gdm9pZCAwKSB7IGRlZHVwbGljYXRpb24gPSAoX2EgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQucXVlcnlEZWR1cGxpY2F0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbjsgfVxuICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5nZXREb2N1bWVudEluZm8ocXVlcnkpLCBzZXJ2ZXJRdWVyeSA9IF9iLnNlcnZlclF1ZXJ5LCBjbGllbnRRdWVyeSA9IF9iLmNsaWVudFF1ZXJ5O1xuICAgICAgICBpZiAoc2VydmVyUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBfYyA9IHRoaXMsIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEgPSBfYy5pbkZsaWdodExpbmtPYnNlcnZhYmxlcywgbGluayA9IF9jLmxpbms7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzZXJ2ZXJRdWVyeSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBnZXRPcGVyYXRpb25OYW1lKHNlcnZlclF1ZXJ5KSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5wcmVwYXJlQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgZm9yY2VGZXRjaDogIWRlZHVwbGljYXRpb24gfSkpLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGV4dCA9IG9wZXJhdGlvbi5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKGRlZHVwbGljYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbnRlZFNlcnZlclF1ZXJ5XzEgPSBwcmludChzZXJ2ZXJRdWVyeSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhckpzb25fMSA9IGNhbm9uaWNhbFN0cmluZ2lmeSh2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEubG9va3VwKHByaW50ZWRTZXJ2ZXJRdWVyeV8xLCB2YXJKc29uXzEpO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSBlbnRyeS5vYnNlcnZhYmxlO1xuICAgICAgICAgICAgICAgIGlmICghb2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uY2FzdCA9IG5ldyBDb25jYXN0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUobGluaywgb3BlcmF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSBlbnRyeS5vYnNlcnZhYmxlID0gY29uY2FzdDtcbiAgICAgICAgICAgICAgICAgICAgY29uY2FzdC5iZWZvcmVOZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEucmVtb3ZlKHByaW50ZWRTZXJ2ZXJRdWVyeV8xLCB2YXJKc29uXzEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gbmV3IENvbmNhc3QoW1xuICAgICAgICAgICAgICAgICAgICBleGVjdXRlKGxpbmssIG9wZXJhdGlvbiksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gbmV3IENvbmNhc3QoW09ic2VydmFibGUub2YoeyBkYXRhOiB7fSB9KV0pO1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFF1ZXJ5KSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gYXN5bmNNYXAob2JzZXJ2YWJsZSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sb2NhbFN0YXRlLnJ1blJlc29sdmVycyh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBjbGllbnRRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldFJlc3VsdHNGcm9tTGluayA9IGZ1bmN0aW9uIChxdWVyeUluZm8sIGNhY2hlV3JpdGVCZWhhdmlvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdElkID0gKHF1ZXJ5SW5mby5sYXN0UmVxdWVzdElkID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RJZCgpKTtcbiAgICAgICAgLy8gUGVyZm9ybWluZyB0cmFuc2Zvcm1Gb3JMaW5rIGhlcmUgZ2l2ZXMgdGhpcy5jYWNoZSBhIGNoYW5jZSB0byBmaWxsIGluXG4gICAgICAgIC8vIG1pc3NpbmcgZnJhZ21lbnQgZGVmaW5pdGlvbnMgKGZvciBleGFtcGxlKSBiZWZvcmUgc2VuZGluZyB0aGlzIGRvY3VtZW50XG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGxpbmsgY2hhaW4uXG4gICAgICAgIHZhciBsaW5rRG9jdW1lbnQgPSB0aGlzLmNhY2hlLnRyYW5zZm9ybUZvckxpbmsob3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIHJldHVybiBhc3luY01hcCh0aGlzLmdldE9ic2VydmFibGVGcm9tTGluayhsaW5rRG9jdW1lbnQsIG9wdGlvbnMuY29udGV4dCwgb3B0aW9ucy52YXJpYWJsZXMpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IGdldEdyYXBoUUxFcnJvcnNGcm9tUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB2YXIgaGFzRXJyb3JzID0gZ3JhcGhRTEVycm9ycy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGVycm9yUG9saWN5ID0gb3B0aW9ucy5lcnJvclBvbGljeTtcbiAgICAgICAgICAgIC8vIElmIHdlIGludGVycnVwdGVkIHRoaXMgcmVxdWVzdCBieSBjYWxsaW5nIGdldFJlc3VsdHNGcm9tTGluayBhZ2FpblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2FtZSBRdWVyeUluZm8gb2JqZWN0LCB3ZSBpZ25vcmUgdGhlIG9sZCByZXN1bHRzLlxuICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCA+PSBxdWVyeUluZm8ubGFzdFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgJiYgZXJyb3JQb2xpY3kgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93aW5nIGhlcmUgZWZmZWN0aXZlbHkgY2FsbHMgb2JzZXJ2ZXIuZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHF1ZXJ5SW5mby5tYXJrRXJyb3IobmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IGdyYXBoUUxFcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmtEb2N1bWVudCByYXRoZXIgdGhhbiBxdWVyeUluZm8uZG9jdW1lbnQgc28gdGhlXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uL2ZyYWdtZW50cyB1c2VkIHRvIHdyaXRlIHRoZSByZXN1bHQgYXJlIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9uZXMgdXNlZCB0byBvYnRhaW4gaXQgZnJvbSB0aGUgbGluay5cbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubWFya1Jlc3VsdChyZXN1bHQsIGxpbmtEb2N1bWVudCwgb3B0aW9ucywgY2FjaGVXcml0ZUJlaGF2aW9yKTtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubWFya1JlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXFyID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugd2Ugc3RhcnQgbXVsdGlwbGUgbmV0d29yayByZXF1ZXN0cyBzaW11bGF0ZW5vdXNseSwgd2VcbiAgICAgICAgICAgIC8vIHdhbnQgdG8gZW5zdXJlIHdlIHByb3Blcmx5IHNldCBgZGF0YWAgaWYgd2UncmUgcmVwb3J0aW5nIG9uIGFuIG9sZFxuICAgICAgICAgICAgLy8gcmVzdWx0IHdoaWNoIHdpbGwgbm90IGJlIGNhdWdodCBieSB0aGUgY29uZGl0aW9uYWwgYWJvdmUgdGhhdCBlbmRzIHVwXG4gICAgICAgICAgICAvLyB0aHJvd2luZyB0aGUgbWFya0Vycm9yIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgJiYgZXJyb3JQb2xpY3kgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgYXFyLmRhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRXJyb3JzICYmIGVycm9yUG9saWN5ICE9PSBcImlnbm9yZVwiKSB7XG4gICAgICAgICAgICAgICAgYXFyLmVycm9ycyA9IGdyYXBoUUxFcnJvcnM7XG4gICAgICAgICAgICAgICAgYXFyLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFxcjtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gaXNBcG9sbG9FcnJvcihuZXR3b3JrRXJyb3IpID8gbmV0d29ya0Vycm9yIDogKG5ldyBBcG9sbG9FcnJvcih7IG5ldHdvcmtFcnJvcjogbmV0d29ya0Vycm9yIH0pKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIHN0b3JpbmcgZXJyb3JzIGZyb20gb2xkZXIgaW50ZXJydXB0ZWQgcXVlcmllcy5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgPj0gcXVlcnlJbmZvLmxhc3RSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubWFya0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hDb25jYXN0V2l0aEluZm8gPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgXG4gICAgLy8gVGhlIGluaXRpYWwgbmV0d29ya1N0YXR1cyBmb3IgdGhpcyBmZXRjaCwgbW9zdCBvZnRlblxuICAgIC8vIE5ldHdvcmtTdGF0dXMubG9hZGluZywgYnV0IGFsc28gcG9zc2libHkgZmV0Y2hNb3JlLCBwb2xsLCByZWZldGNoLFxuICAgIC8vIG9yIHNldFZhcmlhYmxlcy5cbiAgICBuZXR3b3JrU3RhdHVzLCBxdWVyeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmV0d29ya1N0YXR1cyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmxvYWRpbmc7IH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5OyB9XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5O1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9hID09PSB2b2lkIDAgPyAoZGVmYXVsdHMgJiYgZGVmYXVsdHMuZmV0Y2hQb2xpY3kpIHx8IFwiY2FjaGUtZmlyc3RcIiA6IF9hLCBfYiA9IG9wdGlvbnMuZXJyb3JQb2xpY3ksIGVycm9yUG9saWN5ID0gX2IgPT09IHZvaWQgMCA/IChkZWZhdWx0cyAmJiBkZWZhdWx0cy5lcnJvclBvbGljeSkgfHwgXCJub25lXCIgOiBfYiwgX2MgPSBvcHRpb25zLnJldHVyblBhcnRpYWxEYXRhLCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IG9wdGlvbnMubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlLCBub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBvcHRpb25zLmNvbnRleHQsIGNvbnRleHQgPSBfZSA9PT0gdm9pZCAwID8ge30gOiBfZTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSxcbiAgICAgICAgICAgIGVycm9yUG9saWN5OiBlcnJvclBvbGljeSxcbiAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiByZXR1cm5QYXJ0aWFsRGF0YSxcbiAgICAgICAgICAgIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZTogbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmcm9tVmFyaWFibGVzID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgLy8gU2luY2Ugbm9ybWFsaXplZCBpcyBhbHdheXMgYSBmcmVzaCBjb3B5IG9mIG9wdGlvbnMsIGl0J3Mgc2FmZSB0b1xuICAgICAgICAgICAgLy8gbW9kaWZ5IGl0cyBwcm9wZXJ0aWVzIGhlcmUsIHJhdGhlciB0aGFuIGNyZWF0aW5nIHlldCBhbm90aGVyIG5ld1xuICAgICAgICAgICAgLy8gV2F0Y2hRdWVyeU9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgICAgbm9ybWFsaXplZC52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgICAgICB2YXIgc291cmNlc1dpdGhJbmZvID0gX3RoaXMuZmV0Y2hRdWVyeUJ5UG9saWN5KHF1ZXJ5SW5mbywgbm9ybWFsaXplZCwgbmV0d29ya1N0YXR1cyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBzdGFuZGJ5LCBwb3N0cG9uZSBhZHZhbmNpbmcgb3B0aW9ucy5mZXRjaFBvbGljeSB1c2luZ1xuICAgICAgICAgICAgLy8gYXBwbHlOZXh0RmV0Y2hQb2xpY3kuXG4gICAgICAgICAgICBub3JtYWxpemVkLmZldGNoUG9saWN5ICE9PSBcInN0YW5kYnlcIiAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcInN0YW5kYnlcIiBwb2xpY3kgY3VycmVudGx5IHJldHVybnMgW10gZnJvbSBmZXRjaFF1ZXJ5QnlQb2xpY3ksIHNvXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbm90aGVyIHdheSB0byBkZXRlY3Qgd2hlbiBub3RoaW5nIHdhcyBkb25lL2ZldGNoZWQuXG4gICAgICAgICAgICAgICAgc291cmNlc1dpdGhJbmZvLnNvdXJjZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ub2JzZXJ2YWJsZVF1ZXJ5W1wiYXBwbHlOZXh0RmV0Y2hQb2xpY3lcIl0oXCJhZnRlci1mZXRjaFwiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VzV2l0aEluZm87XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgY2FuY2VsIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgdGhlIGNvbmNhc3QgaXMgY3JlYXRlZCxcbiAgICAgICAgLy8gaW4gY2FzZSBjb25jYXN0IGNyZWF0aW9uIHN5bmNocm9ub3VzbHkgY2FuY2VscyB0aGUgcmVxdWVzdC5cbiAgICAgICAgdmFyIGNsZWFudXBDYW5jZWxGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZldGNoQ2FuY2VsRm5zLmRlbGV0ZShxdWVyeUlkKTsgfTtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5zZXQocXVlcnlJZCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY2xlYW51cENhbmNlbEZuKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGRlbGF5IGVuc3VyZXMgdGhlIGNvbmNhc3QgdmFyaWFibGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhc3QuY2FuY2VsKHJlYXNvbik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbmNhc3QsIGNvbnRhaW5zRGF0YUZyb21MaW5rO1xuICAgICAgICAvLyBJZiB0aGUgcXVlcnkgaGFzIEBleHBvcnQoYXM6IC4uLikgZGlyZWN0aXZlcywgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByb2Nlc3MgdGhvc2UgZGlyZWN0aXZlcyBhc3luY2hyb25vdXNseS4gV2hlbiB0aGVyZSBhcmUgbm9cbiAgICAgICAgLy8gQGV4cG9ydCBkaXJlY3RpdmVzICh0aGUgY29tbW9uIGNhc2UpLCB3ZSBkZWxpYmVyYXRlbHkgYXZvaWRcbiAgICAgICAgLy8gd3JhcHBpbmcgdGhlIHJlc3VsdCBvZiB0aGlzLmZldGNoUXVlcnlCeVBvbGljeSBpbiBhIFByb21pc2UsXG4gICAgICAgIC8vIHNpbmNlIHRoZSB0aW1pbmcgb2YgcmVzdWx0IGRlbGl2ZXJ5IGlzICh1bmZvcnR1bmF0ZWx5KSBpbXBvcnRhbnRcbiAgICAgICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUT0RPIFRoaXMgY29kZSBjb3VsZCBiZSBzaW1wbGVyIGlmXG4gICAgICAgIC8vIHdlIGRlcHJlY2F0ZWQgYW5kIHJlbW92ZWQgTG9jYWxTdGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuZ2V0RG9jdW1lbnRJbmZvKG5vcm1hbGl6ZWQucXVlcnkpLmhhc0NsaWVudEV4cG9ydHMpIHtcbiAgICAgICAgICAgIGNvbmNhc3QgPSBuZXcgQ29uY2FzdCh0aGlzLmxvY2FsU3RhdGVcbiAgICAgICAgICAgICAgICAuYWRkRXhwb3J0ZWRWYXJpYWJsZXMobm9ybWFsaXplZC5xdWVyeSwgbm9ybWFsaXplZC52YXJpYWJsZXMsIG5vcm1hbGl6ZWQuY29udGV4dClcbiAgICAgICAgICAgICAgICAudGhlbihmcm9tVmFyaWFibGVzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzb3VyY2VzV2l0aEluZm8pIHsgcmV0dXJuIHNvdXJjZXNXaXRoSW5mby5zb3VyY2VzOyB9KSk7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBqdXN0IG5vIHdheSB3ZSBjYW4gc3luY2hyb25vdXNseSBnZXQgdGhlICpyaWdodCogdmFsdWUgaGVyZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHdpbGwgYXNzdW1lIGB0cnVlYCwgd2hpY2ggaXMgdGhlIGJlaGF2aW91ciBiZWZvcmUgdGhlIGJ1ZyBmaXggaW5cbiAgICAgICAgICAgIC8vICMxMDU5Ny4gVGhpcyBtZWFucyB0aGF0IGJ1ZyBpcyBub3QgZml4ZWQgaW4gdGhhdCBjYXNlLCBhbmQgaXMgcHJvYmFibHlcbiAgICAgICAgICAgIC8vIHVuLWZpeGFibGUgd2l0aCByZWFzb25hYmxlIGVmZm9ydCBmb3IgdGhlIGVkZ2UgY2FzZSBvZiBAZXhwb3J0IGFzXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzLlxuICAgICAgICAgICAgY29udGFpbnNEYXRhRnJvbUxpbmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZXNXaXRoSW5mbyA9IGZyb21WYXJpYWJsZXMobm9ybWFsaXplZC52YXJpYWJsZXMpO1xuICAgICAgICAgICAgY29udGFpbnNEYXRhRnJvbUxpbmsgPSBzb3VyY2VzV2l0aEluZm8uZnJvbUxpbms7XG4gICAgICAgICAgICBjb25jYXN0ID0gbmV3IENvbmNhc3Qoc291cmNlc1dpdGhJbmZvLnNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmNhc3QucHJvbWlzZS50aGVuKGNsZWFudXBDYW5jZWxGbiwgY2xlYW51cENhbmNlbEZuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmNhc3Q6IGNvbmNhc3QsXG4gICAgICAgICAgICBmcm9tTGluazogY29udGFpbnNEYXRhRnJvbUxpbmssXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hRdWVyaWVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVDYWNoZSA9IF9hLnVwZGF0ZUNhY2hlLCBpbmNsdWRlID0gX2EuaW5jbHVkZSwgX2IgPSBfYS5vcHRpbWlzdGljLCBvcHRpbWlzdGljID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gX2EucmVtb3ZlT3B0aW1pc3RpYywgcmVtb3ZlT3B0aW1pc3RpYyA9IF9jID09PSB2b2lkIDAgPyBvcHRpbWlzdGljID8gbWFrZVVuaXF1ZUlkKFwicmVmZXRjaFF1ZXJpZXNcIikgOiB2b2lkIDAgOiBfYywgb25RdWVyeVVwZGF0ZWQgPSBfYS5vblF1ZXJ5VXBkYXRlZDtcbiAgICAgICAgdmFyIGluY2x1ZGVkUXVlcmllc0J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgICB0aGlzLmdldE9ic2VydmFibGVRdWVyaWVzKGluY2x1ZGUpLmZvckVhY2goZnVuY3Rpb24gKG9xLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5zZXQocXVlcnlJZCwge1xuICAgICAgICAgICAgICAgICAgICBvcTogb3EsXG4gICAgICAgICAgICAgICAgICAgIGxhc3REaWZmOiBfdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5nZXREaWZmKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmJhdGNoKHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZUNhY2hlLFxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHlvdSBjYW4gcGVyZm9ybSBhbnkgY29tYmluYXRpb24gb2YgY2FjaGUgcmVhZHMgYW5kL29yIHdyaXRlcyBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYWNoZS5iYXRjaCB1cGRhdGUgZnVuY3Rpb24sIGl0cyBvcHRpbWlzdGljIG9wdGlvbiBjYW4gYmUgZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gYSBib29sZWFuIG9yIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdGhyZWUgZGlzdGluY3QgbW9kZXMgb2ZcbiAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb246XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAqIGZhbHNlOiByZWFkL3dyaXRlIG9ubHkgdGhlIHJvb3QgbGF5ZXJcbiAgICAgICAgICAgICAgICAvLyAqIHRydWU6IHJlYWQvd3JpdGUgdGhlIHRvcG1vc3QgbGF5ZXJcbiAgICAgICAgICAgICAgICAvLyAqIHN0cmluZzogcmVhZC93cml0ZSBhIGZyZXNoIG9wdGltaXN0aWMgbGF5ZXIgd2l0aCB0aGF0IElEIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0eXBlb2Ygb3B0aW1pc3RpYyA9PT0gXCJzdHJpbmdcIiwgYSBuZXcgb3B0aW1pc3RpYyBsYXllciB3aWxsIGJlXG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgY3JlYXRlZCB3aXRoaW4gY2FjaGUuYmF0Y2ggd2l0aCB0aGF0IHN0cmluZyBhcyBpdHMgSUQuIElmXG4gICAgICAgICAgICAgICAgLy8gd2UgdGhlbiBwYXNzIHRoYXQgc2FtZSBzdHJpbmcgYXMgdGhlIHJlbW92ZU9wdGltaXN0aWMgb3B0aW9uLCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGNhY2hlLmJhdGNoIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgb3B0aW1pc3RpYyBsYXllciBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHJ1bm5pbmcgdGhlIHVwZGF0ZUNhY2hlIGZ1bmN0aW9uLCB0cmlnZ2VyaW5nIG9ubHkgb25lIGJyb2FkY2FzdC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSByZWZldGNoUXVlcmllcyBtZXRob2QgYWNjZXB0cyBvbmx5IHRydWUgb3IgZmFsc2UgZm9yIGl0c1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXN0aWMgb3B0aW9uIChub3Qgc3RyaW5nKS4gV2UgaW50ZXJwcmV0IHRydWUgdG8gbWVhbiBhIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIC8vIG9wdGltaXN0aWMgbGF5ZXIgc2hvdWxkIGJlIGNyZWF0ZWQsIHRvIGFsbG93IGVmZmljaWVudGx5IHJvbGxpbmcgYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlZmZlY3Qgb2YgdGhlIHVwZGF0ZUNhY2hlIGZ1bmN0aW9uLCB3aGljaCBpbnZvbHZlcyBwYXNzaW5nIGFcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0cnVlIGFzIHRoZSBvcHRpbWlzdGljIG9wdGlvbiB0byBjYWNoZS5iYXRjaCwgd2hlblxuICAgICAgICAgICAgICAgIC8vIHJlZmV0Y2hRdWVyaWVzIHJlY2VpdmVzIG9wdGltaXN0aWM6IHRydWUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiBvdGhlciB3b3Jkcywgd2UgYXJlIGRlbGliZXJhdGVseSBub3Qgc3VwcG9ydGluZyB0aGUgdXNlIGNhc2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyB3cml0aW5nIHRvIGFuICpleGlzdGluZyogb3B0aW1pc3RpYyBsYXllciAodXNpbmcgdGhlIHJlZmV0Y2hRdWVyaWVzXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ2FjaGUgZnVuY3Rpb24pLCBzaW5jZSB0aGF0IHdvdWxkIHBvdGVudGlhbGx5IGludGVyZmVyZSB3aXRoXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgb3B0aW1pc3RpYyB1cGRhdGVzIGluIHByb2dyZXNzLiBJbnN0ZWFkLCB5b3UgY2FuIHJlYWQvd3JpdGVcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSByb290IGxheWVyIGJ5IHBhc3Npbmcgb3B0aW1pc3RpYzogZmFsc2UgdG8gcmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgLy8gb3IgeW91IGNhbiByZWFkL3dyaXRlIGEgYnJhbmQgbmV3IG9wdGltaXN0aWMgbGF5ZXIgdGhhdCB3aWxsIGJlXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGJ5IHBhc3Npbmcgb3B0aW1pc3RpYzogdHJ1ZS5cbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiAob3B0aW1pc3RpYyAmJiByZW1vdmVPcHRpbWlzdGljKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlT3B0aW1pc3RpYyBvcHRpb24gY2FuIGFsc28gYmUgcHJvdmlkZWQgYnkgaXRzZWxmLCBldmVuIGlmXG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pc3RpYyA9PT0gZmFsc2UsIHRvIHJlbW92ZSBzb21lIHByZXZpb3VzbHktYWRkZWQgb3B0aW1pc3RpY1xuICAgICAgICAgICAgICAgIC8vIGxheWVyIHNhZmVseSBhbmQgZWZmaWNpZW50bHksIGxpa2Ugd2UgZG8gaW4gbWFya011dGF0aW9uUmVzdWx0LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZXhwbGljaXQgcmVtb3ZlT3B0aW1pc3RpYyBzdHJpbmcgaXMgcHJvdmlkZWQgd2l0aCBvcHRpbWlzdGljOlxuICAgICAgICAgICAgICAgIC8vIHRydWUsIHRoZSByZW1vdmVPcHRpbWlzdGljIHN0cmluZyB3aWxsIGRldGVybWluZSB0aGUgSUQgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IG9wdGltaXN0aWMgbGF5ZXIsIGluIGNhc2UgdGhhdCBldmVyIG1hdHRlcnMuXG4gICAgICAgICAgICAgICAgcmVtb3ZlT3B0aW1pc3RpYzogcmVtb3ZlT3B0aW1pc3RpYyxcbiAgICAgICAgICAgICAgICBvbldhdGNoVXBkYXRlZDogZnVuY3Rpb24gKHdhdGNoLCBkaWZmLCBsYXN0RGlmZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3EgPSB3YXRjaC53YXRjaGVyIGluc3RhbmNlb2YgUXVlcnlJbmZvICYmIHdhdGNoLndhdGNoZXIub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvblF1ZXJ5VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIGFib3V0IHRvIGhhbmRsZSB0aGlzIHF1ZXJ5IG5vdywgcmVtb3ZlIGl0IGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlZFF1ZXJpZXNCeUlkLCBpbiBjYXNlIGl0IHdhcyBhZGRlZCBlYXJsaWVyIGJlY2F1c2Ugb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmluY2x1ZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5kZWxldGUob3EucXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9uUXVlcnlVcGRhdGVkKG9xLCBkaWZmLCBsYXN0RGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb25RdWVyeVVwZGF0ZWQgZnVuY3Rpb24gcmVxdWVzdGVkIHRoZSBkZWZhdWx0IHJlZmV0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgYnkgcmV0dXJuaW5nIHRydWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9xLnJlZmV0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdHMgTWFwLCBhcyBsb25nIGFzIG9uUXVlcnlVcGRhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlkIG5vdCByZXR1cm4gZmFsc2UgdG8gc2tpcC9pZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zZXQob3EsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBkZWZhdWx0IGNhY2hlIGJyb2FkY2FzdCB0byBoYXBwZW4sIGV4Y2VwdCB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25RdWVyeVVwZGF0ZWQgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBvblF1ZXJ5VXBkYXRlZCBmdW5jdGlvbiwgYW5kIG9uUXVlcnlVcGRhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIG5vdCBkaXNhYmxlZCBieSBwYXNzaW5nIG51bGwsIG1ha2Ugc3VyZSB0aGlzIHF1ZXJ5IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJpbmNsdWRlZFwiIGxpa2UgYW55IG90aGVyIG9wdGlvbnMuaW5jbHVkZS1zcGVjaWZpZWQgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5zZXQob3EucXVlcnlJZCwgeyBvcTogb3EsIGxhc3REaWZmOiBsYXN0RGlmZiwgZGlmZjogZGlmZiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZWRRdWVyaWVzQnlJZC5zaXplKSB7XG4gICAgICAgICAgICBpbmNsdWRlZFF1ZXJpZXNCeUlkLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9xID0gX2Eub3EsIGxhc3REaWZmID0gX2EubGFzdERpZmYsIGRpZmYgPSBfYS5kaWZmO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgb25RdWVyeVVwZGF0ZWQgaXMgcHJvdmlkZWQsIHdlIHdhbnQgdG8gdXNlIGl0IGZvciBhbGwgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAvLyBxdWVyaWVzLCBldmVuIHRoZSBRdWVyeU9wdGlvbnMgb25lcy5cbiAgICAgICAgICAgICAgICBpZiAob25RdWVyeVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IG9xW1wicXVlcnlJbmZvXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5yZXNldCgpOyAvLyBGb3JjZSBpbmZvLmdldERpZmYoKSB0byByZWFkIGZyb20gY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gaW5mby5nZXREaWZmKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb25RdWVyeVVwZGF0ZWQob3EsIGRpZmYsIGxhc3REaWZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBmYWxsIGJhY2sgdG8gcmVmZXRjaGluZy5cbiAgICAgICAgICAgICAgICBpZiAoIW9uUXVlcnlVcGRhdGVkIHx8IHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcS5yZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KG9xLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlJZC5pbmRleE9mKFwibGVnYWN5T25lVGltZVF1ZXJ5XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZU9wdGltaXN0aWMpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugbm8gdXBkYXRlQ2FjaGUgY2FsbGJhY2sgd2FzIHByb3ZpZGVkIChzbyBjYWNoZS5iYXRjaCB3YXMgbm90XG4gICAgICAgICAgICAvLyBjYWxsZWQgYWJvdmUsIGFuZCB0aHVzIGRpZCBub3QgYWxyZWFkeSByZW1vdmUgdGhlIG9wdGltaXN0aWMgbGF5ZXIpLFxuICAgICAgICAgICAgLy8gcmVtb3ZlIGl0IGhlcmUuIFNpbmNlIHRoaXMgaXMgYSBuby1vcCB3aGVuIHRoZSBsYXllciBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgICAgICAvLyByZW1vdmVkLCB3ZSBkbyBpdCBldmVuIGlmIHdlIGNhbGxlZCBjYWNoZS5iYXRjaCBhYm92ZSwgc2luY2UgaXQnc1xuICAgICAgICAgICAgLy8gcG9zc2libGUgdGhpcy5jYWNoZSBpcyBhbiBpbnN0YW5jZSBvZiBzb21lIEFwb2xsb0NhY2hlIHN1YmNsYXNzIG90aGVyXG4gICAgICAgICAgICAvLyB0aGFuIEluTWVtb3J5Q2FjaGUsIGFuZCBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IHRoZSByZW1vdmVPcHRpbWlzdGljXG4gICAgICAgICAgICAvLyBvcHRpb24gZm9yIGNhY2hlLmJhdGNoLlxuICAgICAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmVPcHRpbWlzdGljKHJlbW92ZU9wdGltaXN0aWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5mZXRjaFF1ZXJ5QnlQb2xpY3kgPSBmdW5jdGlvbiAocXVlcnlJbmZvLCBfYSwgXG4gICAgLy8gVGhlIGluaXRpYWwgbmV0d29ya1N0YXR1cyBmb3IgdGhpcyBmZXRjaCwgbW9zdCBvZnRlblxuICAgIC8vIE5ldHdvcmtTdGF0dXMubG9hZGluZywgYnV0IGFsc28gcG9zc2libHkgZmV0Y2hNb3JlLCBwb2xsLCByZWZldGNoLFxuICAgIC8vIG9yIHNldFZhcmlhYmxlcy5cbiAgICBuZXR3b3JrU3RhdHVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGZldGNoUG9saWN5ID0gX2EuZmV0Y2hQb2xpY3ksIHJlZmV0Y2hXcml0ZVBvbGljeSA9IF9hLnJlZmV0Y2hXcml0ZVBvbGljeSwgZXJyb3JQb2xpY3kgPSBfYS5lcnJvclBvbGljeSwgcmV0dXJuUGFydGlhbERhdGEgPSBfYS5yZXR1cm5QYXJ0aWFsRGF0YSwgY29udGV4dCA9IF9hLmNvbnRleHQsIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9IF9hLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZTtcbiAgICAgICAgdmFyIG9sZE5ldHdvcmtTdGF0dXMgPSBxdWVyeUluZm8ubmV0d29ya1N0YXR1cztcbiAgICAgICAgcXVlcnlJbmZvLmluaXQoe1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYWRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5SW5mby5nZXREaWZmKCk7IH07XG4gICAgICAgIHZhciByZXN1bHRzRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRpZmYsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrU3RhdHVzID09PSB2b2lkIDApIHsgbmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8IE5ldHdvcmtTdGF0dXMubG9hZGluZzsgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkaWZmLnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmICFyZXR1cm5QYXJ0aWFsRGF0YSAmJiAhZXF1YWwoZGF0YSwge30pKSB7XG4gICAgICAgICAgICAgICAgbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKGRpZmYubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKF9fYXNzaWduKHsgZGF0YTogZGF0YSwgbG9hZGluZzogaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpLCBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzIH0sIChkaWZmLmNvbXBsZXRlID8gbnVsbCA6IHsgcGFydGlhbDogdHJ1ZSB9KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIF90aGlzLmdldERvY3VtZW50SW5mbyhxdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxvY2FsU3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLnJ1blJlc29sdmVycyh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUmVzdWx0OiB7IGRhdGE6IGRhdGEgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7IHJldHVybiBmcm9tRGF0YShyZXNvbHZlZC5kYXRhIHx8IHZvaWQgMCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzb2x2ZXMgaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvYXBvbGxvLWNsaWVudC9pc3N1ZXMvMTAzMTcuXG4gICAgICAgICAgICAvLyBJZiBlcnJvclBvbGljeSBpcyAnbm9uZScgYW5kIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSBpcyB0cnVlLFxuICAgICAgICAgICAgLy8gZGF0YSB3YXMgaW5jb3JyZWN0bHkgcmV0dXJuZWQgZnJvbSB0aGUgY2FjaGUgb24gcmVmZXRjaDpcbiAgICAgICAgICAgIC8vIGlmIGRpZmYubWlzc2luZyBleGlzdHMsIHdlIHNob3VsZCBub3QgcmV0dXJuIGNhY2hlIGRhdGEuXG4gICAgICAgICAgICBpZiAoZXJyb3JQb2xpY3kgPT09IFwibm9uZVwiICYmXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5yZWZldGNoICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkaWZmLm1pc3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYXRhKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbURhdGEoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYWNoZVdyaXRlQmVoYXZpb3IgPSBmZXRjaFBvbGljeSA9PT0gXCJuby1jYWNoZVwiID8gMCAvKiBDYWNoZVdyaXRlQmVoYXZpb3IuRk9SQklEICovXG4gICAgICAgICAgICAvLyBXYXRjaGVkIHF1ZXJpZXMgbXVzdCBvcHQgaW50byBvdmVyd3JpdGluZyBleGlzdGluZyBkYXRhIG9uIHJlZmV0Y2gsXG4gICAgICAgICAgICAvLyBieSBwYXNzaW5nIHJlZmV0Y2hXcml0ZVBvbGljeTogXCJvdmVyd3JpdGVcIiBpbiB0aGVpciBXYXRjaFF1ZXJ5T3B0aW9ucy5cbiAgICAgICAgICAgIDogKG5ldHdvcmtTdGF0dXMgPT09IE5ldHdvcmtTdGF0dXMucmVmZXRjaCAmJlxuICAgICAgICAgICAgICAgIHJlZmV0Y2hXcml0ZVBvbGljeSAhPT0gXCJtZXJnZVwiKSA/XG4gICAgICAgICAgICAgICAgMSAvKiBDYWNoZVdyaXRlQmVoYXZpb3IuT1ZFUldSSVRFICovXG4gICAgICAgICAgICAgICAgOiAyIC8qIENhY2hlV3JpdGVCZWhhdmlvci5NRVJHRSAqLztcbiAgICAgICAgdmFyIHJlc3VsdHNGcm9tTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSZXN1bHRzRnJvbUxpbmsocXVlcnlJbmZvLCBjYWNoZVdyaXRlQmVoYXZpb3IsIHtcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICAgICAgZXJyb3JQb2xpY3k6IGVycm9yUG9saWN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzaG91bGROb3RpZnkgPSBub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvbGROZXR3b3JrU3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBvbGROZXR3b3JrU3RhdHVzICE9PSBuZXR3b3JrU3RhdHVzICYmXG4gICAgICAgICAgICBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyk7XG4gICAgICAgIHN3aXRjaCAoZmV0Y2hQb2xpY3kpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlIFwiY2FjaGUtZmlyc3RcIjoge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gcmVhZENhY2hlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21MaW5rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtyZXN1bHRzRnJvbUNhY2hlKGRpZmYsIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKSldLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuUGFydGlhbERhdGEgfHwgc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTGluazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtyZXN1bHRzRnJvbUNhY2hlKGRpZmYpLCByZXN1bHRzRnJvbUxpbmsoKV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb21MaW5rOiB0cnVlLCBzb3VyY2VzOiBbcmVzdWx0c0Zyb21MaW5rKCldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiY2FjaGUtYW5kLW5ldHdvcmtcIjoge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gcmVhZENhY2hlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUgfHwgcmV0dXJuUGFydGlhbERhdGEgfHwgc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTGluazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtyZXN1bHRzRnJvbUNhY2hlKGRpZmYpLCByZXN1bHRzRnJvbUxpbmsoKV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb21MaW5rOiB0cnVlLCBzb3VyY2VzOiBbcmVzdWx0c0Zyb21MaW5rKCldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiY2FjaGUtb25seVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21MaW5rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3Jlc3VsdHNGcm9tQ2FjaGUocmVhZENhY2hlKCksIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKSldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwibmV0d29yay1vbmx5XCI6XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUxpbms6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbcmVzdWx0c0Zyb21DYWNoZShyZWFkQ2FjaGUoKSksIHJlc3VsdHNGcm9tTGluaygpXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbUxpbms6IHRydWUsIHNvdXJjZXM6IFtyZXN1bHRzRnJvbUxpbmsoKV0gfTtcbiAgICAgICAgICAgIGNhc2UgXCJuby1jYWNoZVwiOlxuICAgICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21MaW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHF1ZXJ5SW5mby5nZXREaWZmKCkgZm9yIG5vLWNhY2hlIHF1ZXJpZXMgZG9lcyBub3QgY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUuZGlmZiwgYnV0IGluc3RlYWQgcmV0dXJucyBhIHsgY29tcGxldGU6IGZhbHNlIH0gc3R1YiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlcmUgaXMgbm8gcXVlcnlJbmZvLmRpZmYgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3Jlc3VsdHNGcm9tQ2FjaGUocXVlcnlJbmZvLmdldERpZmYoKSksIHJlc3VsdHNGcm9tTGluaygpXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbUxpbms6IHRydWUsIHNvdXJjZXM6IFtyZXN1bHRzRnJvbUxpbmsoKV0gfTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGFuZGJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbUxpbms6IGZhbHNlLCBzb3VyY2VzOiBbXSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgJiYgIXRoaXMucXVlcmllcy5oYXMocXVlcnlJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5zZXQocXVlcnlJZCwgbmV3IFF1ZXJ5SW5mbyh0aGlzLCBxdWVyeUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5nZXQocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmxvY2FsU3RhdGUucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5kZWZhdWx0Q29udGV4dCksIG5ld0NvbnRleHQpLCB7IGNsaWVudEF3YXJlbmVzczogdGhpcy5jbGllbnRBd2FyZW5lc3MgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFF1ZXJ5TWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fYXdhaXRlciIsIl9fZ2VuZXJhdG9yIiwiaW52YXJpYW50IiwibmV3SW52YXJpYW50RXJyb3IiLCJlcXVhbCIsImV4ZWN1dGUiLCJoYXNEaXJlY3RpdmVzIiwiaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0IiwiaXNFeGVjdXRpb25QYXRjaFJlc3VsdCIsInJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQiLCJjYW5vbmljYWxTdHJpbmdpZnkiLCJnZXREZWZhdWx0VmFsdWVzIiwiZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiIsImdldE9wZXJhdGlvbk5hbWUiLCJoYXNDbGllbnRFeHBvcnRzIiwiZ3JhcGhRTFJlc3VsdEhhc0Vycm9yIiwiZ2V0R3JhcGhRTEVycm9yc0Zyb21SZXN1bHQiLCJPYnNlcnZhYmxlIiwiYXN5bmNNYXAiLCJpc05vbkVtcHR5QXJyYXkiLCJDb25jYXN0IiwibWFrZVVuaXF1ZUlkIiwiaXNEb2N1bWVudE5vZGUiLCJpc05vbk51bGxPYmplY3QiLCJEb2N1bWVudFRyYW5zZm9ybSIsIm1lcmdlSW5jcmVtZW50YWxEYXRhIiwiQXBvbGxvRXJyb3IiLCJpc0Fwb2xsb0Vycm9yIiwiZ3JhcGhRTFJlc3VsdEhhc1Byb3RvY29sRXJyb3JzIiwiT2JzZXJ2YWJsZVF1ZXJ5IiwibG9nTWlzc2luZ0ZpZWxkRXJyb3JzIiwiTmV0d29ya1N0YXR1cyIsImlzTmV0d29ya1JlcXVlc3RJbkZsaWdodCIsIlF1ZXJ5SW5mbyIsInNob3VsZFdyaXRlUmVzdWx0IiwiUFJPVE9DT0xfRVJST1JTX1NZTUJPTCIsInByaW50IiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJJR05PUkUiLCJjcmVhdGUiLCJUcmllIiwiQXV0b0NsZWFuZWRXZWFrQ2FjaGUiLCJjYWNoZVNpemVzIiwiUXVlcnlNYW5hZ2VyIiwib3B0aW9ucyIsIl90aGlzIiwiY2xpZW50QXdhcmVuZXNzIiwicXVlcmllcyIsIk1hcCIsImZldGNoQ2FuY2VsRm5zIiwidHJhbnNmb3JtQ2FjaGUiLCJxdWVyeUlkQ291bnRlciIsInJlcXVlc3RJZENvdW50ZXIiLCJtdXRhdGlvbklkQ291bnRlciIsImluRmxpZ2h0TGlua09ic2VydmFibGVzIiwiZGVmYXVsdERvY3VtZW50VHJhbnNmb3JtIiwiZG9jdW1lbnQiLCJjYWNoZSIsInRyYW5zZm9ybURvY3VtZW50IiwibGluayIsImRlZmF1bHRPcHRpb25zIiwicXVlcnlEZWR1cGxpY2F0aW9uIiwibG9jYWxTdGF0ZSIsInNzck1vZGUiLCJhc3N1bWVJbW11dGFibGVSZXN1bHRzIiwiZG9jdW1lbnRUcmFuc2Zvcm0iLCJjb25jYXQiLCJkZWZhdWx0Q29udGV4dCIsIm9uQnJvYWRjYXN0IiwibXV0YXRpb25TdG9yZSIsInN0b3AiLCJmb3JFYWNoIiwiX2luZm8iLCJxdWVyeUlkIiwic3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QiLCJjYW5jZWxQZW5kaW5nRmV0Y2hlcyIsImVycm9yIiwiY2FuY2VsIiwiY2xlYXIiLCJtdXRhdGUiLCJfYSIsImFyZ3VtZW50cyIsIl9iIiwibXV0YXRpb25JZCIsIm11dGF0aW9uU3RvcmVWYWx1ZSIsImlzT3B0aW1pc3RpYyIsInNlbGYiLCJfYyIsIl9kIiwibXV0YXRpb24iLCJ2YXJpYWJsZXMiLCJvcHRpbWlzdGljUmVzcG9uc2UiLCJ1cGRhdGVRdWVyaWVzIiwiX2UiLCJyZWZldGNoUXVlcmllcyIsIl9mIiwiYXdhaXRSZWZldGNoUXVlcmllcyIsInVwZGF0ZVdpdGhQcm94eUZuIiwidXBkYXRlIiwib25RdWVyeVVwZGF0ZWQiLCJfZyIsImZldGNoUG9saWN5IiwiX2giLCJlcnJvclBvbGljeSIsImtlZXBSb290RmllbGRzIiwiY29udGV4dCIsIl9qIiwibGFiZWwiLCJnZW5lcmF0ZU11dGF0aW9uSWQiLCJ0cmFuc2Zvcm1Gb3JMaW5rIiwidHJhbnNmb3JtIiwiZ2V0RG9jdW1lbnRJbmZvIiwiZ2V0VmFyaWFibGVzIiwiYWRkRXhwb3J0ZWRWYXJpYWJsZXMiLCJzZW50IiwibG9hZGluZyIsIm1hcmtNdXRhdGlvbk9wdGltaXN0aWMiLCJicm9hZGNhc3RRdWVyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXRPYnNlcnZhYmxlRnJvbUxpbmsiLCJyZXN1bHQiLCJncmFwaFFMRXJyb3JzIiwic3RvcmVSZXN1bHQiLCJlcnJvcnMiLCJtYXJrTXV0YXRpb25SZXN1bHQiLCJyZW1vdmVPcHRpbWlzdGljIiwic3Vic2NyaWJlIiwibmV4dCIsImhhc05leHQiLCJlcnIiLCJuZXR3b3JrRXJyb3IiLCJjYWNoZVdyaXRlcyIsInNraXBDYWNoZSIsInB1c2giLCJkYXRhIiwiZGF0YUlkIiwicXVlcnkiLCJpbmNyZW1lbnRhbCIsImRpZmYiLCJpZCIsImFzUXVlcnkiLCJvcHRpbWlzdGljIiwicmV0dXJuUGFydGlhbERhdGEiLCJtZXJnZWREYXRhIiwidXBkYXRlUXVlcmllc18xIiwib2JzZXJ2YWJsZVF1ZXJ5IiwicXVlcnlOYW1lIiwiY2FsbCIsInVwZGF0ZXIiLCJnZXQiLCJjdXJyZW50UXVlcnlSZXN1bHQiLCJjb21wbGV0ZSIsIm5leHRRdWVyeVJlc3VsdCIsIm11dGF0aW9uUmVzdWx0IiwicXVlcnlWYXJpYWJsZXMiLCJsZW5ndGgiLCJyZXN1bHRzXzEiLCJ1cGRhdGVDYWNoZSIsIndyaXRlIiwiaXNGaW5hbFJlc3VsdCIsIm1vZGlmeSIsImZpZWxkcyIsInZhbHVlIiwiZmllbGROYW1lIiwiREVMRVRFIiwiaW5jbHVkZSIsImFsbCIsInRoZW4iLCJyZWNvcmRPcHRpbWlzdGljVHJhbnNhY3Rpb24iLCJnbG9iYWxUaGlzIiwiX19ERVZfXyIsImZldGNoUXVlcnkiLCJuZXR3b3JrU3RhdHVzIiwiZmV0Y2hDb25jYXN0V2l0aEluZm8iLCJjb25jYXN0IiwicHJvbWlzZSIsImdldFF1ZXJ5U3RvcmUiLCJzdG9yZSIsImluZm8iLCJyZXNldEVycm9ycyIsInF1ZXJ5SW5mbyIsInVuZGVmaW5lZCIsImhhcyIsImNhY2hlRW50cnkiLCJoYXNGb3JjZWRSZXNvbHZlcnMiLCJzaG91bGRGb3JjZVJlc29sdmVycyIsImhhc05vbnJlYWN0aXZlRGlyZWN0aXZlIiwiY2xpZW50UXVlcnkiLCJzZXJ2ZXJRdWVyeSIsIm5hbWUiLCJyZW1vdmUiLCJkZWZhdWx0VmFycyIsImRlZmluaXRpb25zIiwibWFwIiwiZGVmIiwia2luZCIsIm9wZXJhdGlvbiIsInNldCIsIndhdGNoUXVlcnkiLCJub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UiLCJvYnNlcnZhYmxlIiwicXVlcnlNYW5hZ2VyIiwiaW5pdCIsImdlbmVyYXRlUXVlcnlJZCIsInBvbGxJbnRlcnZhbCIsImZpbmFsbHkiLCJzdG9wUXVlcnkiLCJTdHJpbmciLCJnZW5lcmF0ZVJlcXVlc3RJZCIsInN0b3BRdWVyeUluU3RvcmUiLCJzdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QiLCJjbGVhclN0b3JlIiwiZGlzY2FyZFdhdGNoZXMiLCJyZXNldCIsImdldE9ic2VydmFibGVRdWVyaWVzIiwicXVlcnlOYW1lc0FuZERvY3MiLCJsZWdhY3lRdWVyeU9wdGlvbnMiLCJTZXQiLCJBcnJheSIsImlzQXJyYXkiLCJkZXNjIiwiYWRkIiwib3EiLCJoYXNPYnNlcnZlcnMiLCJzaXplIiwiZ2V0UXVlcnkiLCJzZXRPYnNlcnZhYmxlUXVlcnkiLCJpbmNsdWRlZCIsIm5hbWVPckRvYyIsIndhcm4iLCJyZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMiLCJpbmNsdWRlU3RhbmRieSIsIm9ic2VydmFibGVRdWVyeVByb21pc2VzIiwicmVzZXRMYXN0UmVzdWx0cyIsInJlZmV0Y2giLCJzZXREaWZmIiwic3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uIiwiZXh0ZW5zaW9ucyIsIm1ha2VPYnNlcnZhYmxlIiwiaGFzRXJyb3JzIiwiaGFzUHJvdG9jb2xFcnJvcnMiLCJwcm90b2NvbEVycm9ycyIsIm9ic2VydmFibGVQcm9taXNlXzEiLCJvYnNlcnZlciIsInN1YiIsInVuc3Vic2NyaWJlIiwicmVtb3ZlUXVlcnkiLCJkZWxldGUiLCJub3RpZnkiLCJnZXRMb2NhbFN0YXRlIiwiZGVkdXBsaWNhdGlvbiIsImluRmxpZ2h0TGlua09ic2VydmFibGVzXzEiLCJvcGVyYXRpb25OYW1lIiwicHJlcGFyZUNvbnRleHQiLCJmb3JjZUZldGNoIiwicHJpbnRlZFNlcnZlclF1ZXJ5XzEiLCJ2YXJKc29uXzEiLCJlbnRyeSIsImxvb2t1cCIsImJlZm9yZU5leHQiLCJvZiIsInJ1blJlc29sdmVycyIsInJlbW90ZVJlc3VsdCIsImdldFJlc3VsdHNGcm9tTGluayIsImNhY2hlV3JpdGVCZWhhdmlvciIsInJlcXVlc3RJZCIsImxhc3RSZXF1ZXN0SWQiLCJsaW5rRG9jdW1lbnQiLCJtYXJrRXJyb3IiLCJtYXJrUmVzdWx0IiwibWFya1JlYWR5IiwiYXFyIiwicmVhZHkiLCJkZWZhdWx0cyIsIm5vcm1hbGl6ZWQiLCJhc3NpZ24iLCJmcm9tVmFyaWFibGVzIiwic291cmNlc1dpdGhJbmZvIiwiZmV0Y2hRdWVyeUJ5UG9saWN5Iiwic291cmNlcyIsImNsZWFudXBDYW5jZWxGbiIsInJlYXNvbiIsInNldFRpbWVvdXQiLCJjb250YWluc0RhdGFGcm9tTGluayIsImZyb21MaW5rIiwiaW5jbHVkZWRRdWVyaWVzQnlJZCIsImxhc3REaWZmIiwiZ2V0RGlmZiIsInJlc3VsdHMiLCJiYXRjaCIsIm9uV2F0Y2hVcGRhdGVkIiwid2F0Y2giLCJ3YXRjaGVyIiwiaW5kZXhPZiIsInJlZmV0Y2hXcml0ZVBvbGljeSIsIm9sZE5ldHdvcmtTdGF0dXMiLCJyZWFkQ2FjaGUiLCJyZXN1bHRzRnJvbUNhY2hlIiwibWlzc2luZyIsImZyb21EYXRhIiwicGFydGlhbCIsIm9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMiLCJyZXNvbHZlZCIsInJlc3VsdHNGcm9tTGluayIsInNob3VsZE5vdGlmeSIsIm5ld0NvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/QueryManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/equalByQuery.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalByQuery: function() { return /* binding */ equalByQuery; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n\n\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nfunction equalByQuery(query, _a, _b, variables) {\n    var aData = _a.data, aRest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, [\n        \"data\"\n    ]);\n    var bData = _b.data, bRest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_b, [\n        \"data\"\n    ]);\n    return (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(aRest, bRest) && equalBySelectionSet((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.getMainDefinition)(query).selectionSet, aData, bData, {\n        fragmentMap: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.createFragmentMap)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinitions)(query)),\n        variables: variables\n    });\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n    if (aResult === bResult) {\n        return true;\n    }\n    var seenSelections = new Set();\n    // Returning true from this Array.prototype.every callback function skips the\n    // current field/subtree. Returning false aborts the entire traversal\n    // immediately, causing equalBySelectionSet to return false.\n    return selectionSet.selections.every(function(selection) {\n        // Avoid re-processing the same selection at the same level of recursion, in\n        // case the same field gets included via multiple indirect fragment spreads.\n        if (seenSelections.has(selection)) return true;\n        seenSelections.add(selection);\n        // Ignore @skip(if: true) and @include(if: false) fields.\n        if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.shouldInclude)(selection, context.variables)) return true;\n        // If the field or (named) fragment spread has a @nonreactive directive on\n        // it, we don't care if it's different, so we pretend it's the same.\n        if (selectionHasNonreactiveDirective(selection)) return true;\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isField)(selection)) {\n            var resultKey = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.resultKeyNameFromField)(selection);\n            var aResultChild = aResult && aResult[resultKey];\n            var bResultChild = bResult && bResult[resultKey];\n            var childSelectionSet = selection.selectionSet;\n            if (!childSelectionSet) {\n                // These are scalar values, so we can compare them with deep equal\n                // without redoing the main recursive work.\n                return (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(aResultChild, bResultChild);\n            }\n            var aChildIsArray = Array.isArray(aResultChild);\n            var bChildIsArray = Array.isArray(bResultChild);\n            if (aChildIsArray !== bChildIsArray) return false;\n            if (aChildIsArray && bChildIsArray) {\n                var length_1 = aResultChild.length;\n                if (bResultChild.length !== length_1) {\n                    return false;\n                }\n                for(var i = 0; i < length_1; ++i){\n                    if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n        } else {\n            var fragment = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.getFragmentFromSelection)(selection, context.fragmentMap);\n            if (fragment) {\n                // The fragment might === selection if it's an inline fragment, but\n                // could be !== if it's a named fragment ...spread.\n                if (selectionHasNonreactiveDirective(fragment)) return true;\n                return equalBySelectionSet(fragment.selectionSet, // Notice that we reuse the same aResult and bResult values here,\n                // since the fragment ...spread does not specify a field name, but\n                // consists of multiple fields (within the fragment's selection set)\n                // that should be applied to the current result value(s).\n                aResult, bResult, context);\n            }\n        }\n    });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n    return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\nfunction directiveIsNonreactive(dir) {\n    return dir.name.value === \"nonreactive\";\n} //# sourceMappingURL=equalByQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL2VxdWFsQnlRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCO0FBQ0c7QUFDOEk7QUFDaEwsK0VBQStFO0FBQy9FLDJFQUEyRTtBQUNwRSxTQUFTUyxhQUFhQyxLQUFLLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQ2pELElBQUlDLFFBQVFILEdBQUdJLElBQUksRUFBRUMsUUFBUWhCLDZDQUFNQSxDQUFDVyxJQUFJO1FBQUM7S0FBTztJQUNoRCxJQUFJTSxRQUFRTCxHQUFHRyxJQUFJLEVBQUVHLFFBQVFsQiw2Q0FBTUEsQ0FBQ1ksSUFBSTtRQUFDO0tBQU87SUFDaEQsT0FBUVgseURBQUtBLENBQUNlLE9BQU9FLFVBQ2pCQyxvQkFBb0JkLHNFQUFpQkEsQ0FBQ0ssT0FBT1UsWUFBWSxFQUFFTixPQUFPRyxPQUFPO1FBQ3JFSSxhQUFhbkIsc0VBQWlCQSxDQUFDQywyRUFBc0JBLENBQUNPO1FBQ3RERyxXQUFXQTtJQUNmO0FBQ1I7QUFDQSxTQUFTTSxvQkFBb0JDLFlBQVksRUFBRUUsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDaEUsSUFBSUYsWUFBWUMsU0FBUztRQUNyQixPQUFPO0lBQ1g7SUFDQSxJQUFJRSxpQkFBaUIsSUFBSUM7SUFDekIsNkVBQTZFO0lBQzdFLHFFQUFxRTtJQUNyRSw0REFBNEQ7SUFDNUQsT0FBT04sYUFBYU8sVUFBVSxDQUFDQyxLQUFLLENBQUMsU0FBVUMsU0FBUztRQUNwRCw0RUFBNEU7UUFDNUUsNEVBQTRFO1FBQzVFLElBQUlKLGVBQWVLLEdBQUcsQ0FBQ0QsWUFDbkIsT0FBTztRQUNYSixlQUFlTSxHQUFHLENBQUNGO1FBQ25CLHlEQUF5RDtRQUN6RCxJQUFJLENBQUNyQixrRUFBYUEsQ0FBQ3FCLFdBQVdMLFFBQVFYLFNBQVMsR0FDM0MsT0FBTztRQUNYLDBFQUEwRTtRQUMxRSxvRUFBb0U7UUFDcEUsSUFBSW1CLGlDQUFpQ0gsWUFDakMsT0FBTztRQUNYLElBQUl2Qiw0REFBT0EsQ0FBQ3VCLFlBQVk7WUFDcEIsSUFBSUksWUFBWTFCLDJFQUFzQkEsQ0FBQ3NCO1lBQ3ZDLElBQUlLLGVBQWVaLFdBQVdBLE9BQU8sQ0FBQ1csVUFBVTtZQUNoRCxJQUFJRSxlQUFlWixXQUFXQSxPQUFPLENBQUNVLFVBQVU7WUFDaEQsSUFBSUcsb0JBQW9CUCxVQUFVVCxZQUFZO1lBQzlDLElBQUksQ0FBQ2dCLG1CQUFtQjtnQkFDcEIsa0VBQWtFO2dCQUNsRSwyQ0FBMkM7Z0JBQzNDLE9BQU9uQyx5REFBS0EsQ0FBQ2lDLGNBQWNDO1lBQy9CO1lBQ0EsSUFBSUUsZ0JBQWdCQyxNQUFNQyxPQUFPLENBQUNMO1lBQ2xDLElBQUlNLGdCQUFnQkYsTUFBTUMsT0FBTyxDQUFDSjtZQUNsQyxJQUFJRSxrQkFBa0JHLGVBQ2xCLE9BQU87WUFDWCxJQUFJSCxpQkFBaUJHLGVBQWU7Z0JBQ2hDLElBQUlDLFdBQVdQLGFBQWFRLE1BQU07Z0JBQ2xDLElBQUlQLGFBQWFPLE1BQU0sS0FBS0QsVUFBVTtvQkFDbEMsT0FBTztnQkFDWDtnQkFDQSxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsVUFBVSxFQUFFRSxFQUFHO29CQUMvQixJQUFJLENBQUN4QixvQkFBb0JpQixtQkFBbUJGLFlBQVksQ0FBQ1MsRUFBRSxFQUFFUixZQUFZLENBQUNRLEVBQUUsRUFBRW5CLFVBQVU7d0JBQ3BGLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBQ0EsT0FBTztZQUNYO1lBQ0EsT0FBT0wsb0JBQW9CaUIsbUJBQW1CRixjQUFjQyxjQUFjWDtRQUM5RSxPQUNLO1lBQ0QsSUFBSW9CLFdBQVd4Qyw2RUFBd0JBLENBQUN5QixXQUFXTCxRQUFRSCxXQUFXO1lBQ3RFLElBQUl1QixVQUFVO2dCQUNWLG1FQUFtRTtnQkFDbkUsbURBQW1EO2dCQUNuRCxJQUFJWixpQ0FBaUNZLFdBQ2pDLE9BQU87Z0JBQ1gsT0FBT3pCLG9CQUFvQnlCLFNBQVN4QixZQUFZLEVBQ2hELGlFQUFpRTtnQkFDakUsa0VBQWtFO2dCQUNsRSxvRUFBb0U7Z0JBQ3BFLHlEQUF5RDtnQkFDekRFLFNBQVNDLFNBQVNDO1lBQ3RCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU1EsaUNBQWlDSCxTQUFTO0lBQy9DLE9BQVEsQ0FBQyxDQUFDQSxVQUFVZ0IsVUFBVSxJQUFJaEIsVUFBVWdCLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDQztBQUNoRTtBQUNBLFNBQVNBLHVCQUF1QkMsR0FBRztJQUMvQixPQUFPQSxJQUFJQyxJQUFJLENBQUNDLEtBQUssS0FBSztBQUM5QixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY29yZS9lcXVhbEJ5UXVlcnkuanM/OWZmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBlcXVhbCBmcm9tIFwiQHdyeS9lcXVhbGl0eVwiO1xuaW1wb3J0IHsgY3JlYXRlRnJhZ21lbnRNYXAsIGdldEZyYWdtZW50RGVmaW5pdGlvbnMsIGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbiwgZ2V0TWFpbkRlZmluaXRpb24sIGlzRmllbGQsIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIHNob3VsZEluY2x1ZGUsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuLy8gUmV0dXJucyB0cnVlIGlmIGFSZXN1bHQgYW5kIGJSZXN1bHQgYXJlIGRlZXBseSBlcXVhbCBhY2NvcmRpbmcgdG8gdGhlIGZpZWxkc1xuLy8gc2VsZWN0ZWQgYnkgdGhlIGdpdmVuIHF1ZXJ5LCBpZ25vcmluZyBhbnkgZmllbGRzIG1hcmtlZCBhcyBAbm9ucmVhY3RpdmUuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeVF1ZXJ5KHF1ZXJ5LCBfYSwgX2IsIHZhcmlhYmxlcykge1xuICAgIHZhciBhRGF0YSA9IF9hLmRhdGEsIGFSZXN0ID0gX19yZXN0KF9hLCBbXCJkYXRhXCJdKTtcbiAgICB2YXIgYkRhdGEgPSBfYi5kYXRhLCBiUmVzdCA9IF9fcmVzdChfYiwgW1wiZGF0YVwiXSk7XG4gICAgcmV0dXJuIChlcXVhbChhUmVzdCwgYlJlc3QpICYmXG4gICAgICAgIGVxdWFsQnlTZWxlY3Rpb25TZXQoZ2V0TWFpbkRlZmluaXRpb24ocXVlcnkpLnNlbGVjdGlvblNldCwgYURhdGEsIGJEYXRhLCB7XG4gICAgICAgICAgICBmcmFnbWVudE1hcDogY3JlYXRlRnJhZ21lbnRNYXAoZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhxdWVyeSkpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGVxdWFsQnlTZWxlY3Rpb25TZXQoc2VsZWN0aW9uU2V0LCBhUmVzdWx0LCBiUmVzdWx0LCBjb250ZXh0KSB7XG4gICAgaWYgKGFSZXN1bHQgPT09IGJSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBzZWVuU2VsZWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAvLyBSZXR1cm5pbmcgdHJ1ZSBmcm9tIHRoaXMgQXJyYXkucHJvdG90eXBlLmV2ZXJ5IGNhbGxiYWNrIGZ1bmN0aW9uIHNraXBzIHRoZVxuICAgIC8vIGN1cnJlbnQgZmllbGQvc3VidHJlZS4gUmV0dXJuaW5nIGZhbHNlIGFib3J0cyB0aGUgZW50aXJlIHRyYXZlcnNhbFxuICAgIC8vIGltbWVkaWF0ZWx5LCBjYXVzaW5nIGVxdWFsQnlTZWxlY3Rpb25TZXQgdG8gcmV0dXJuIGZhbHNlLlxuICAgIHJldHVybiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIEF2b2lkIHJlLXByb2Nlc3NpbmcgdGhlIHNhbWUgc2VsZWN0aW9uIGF0IHRoZSBzYW1lIGxldmVsIG9mIHJlY3Vyc2lvbiwgaW5cbiAgICAgICAgLy8gY2FzZSB0aGUgc2FtZSBmaWVsZCBnZXRzIGluY2x1ZGVkIHZpYSBtdWx0aXBsZSBpbmRpcmVjdCBmcmFnbWVudCBzcHJlYWRzLlxuICAgICAgICBpZiAoc2VlblNlbGVjdGlvbnMuaGFzKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgc2VlblNlbGVjdGlvbnMuYWRkKHNlbGVjdGlvbik7XG4gICAgICAgIC8vIElnbm9yZSBAc2tpcChpZjogdHJ1ZSkgYW5kIEBpbmNsdWRlKGlmOiBmYWxzZSkgZmllbGRzLlxuICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCBjb250ZXh0LnZhcmlhYmxlcykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIG9yIChuYW1lZCkgZnJhZ21lbnQgc3ByZWFkIGhhcyBhIEBub25yZWFjdGl2ZSBkaXJlY3RpdmUgb25cbiAgICAgICAgLy8gaXQsIHdlIGRvbid0IGNhcmUgaWYgaXQncyBkaWZmZXJlbnQsIHNvIHdlIHByZXRlbmQgaXQncyB0aGUgc2FtZS5cbiAgICAgICAgaWYgKHNlbGVjdGlvbkhhc05vbnJlYWN0aXZlRGlyZWN0aXZlKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdEtleSA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBhUmVzdWx0Q2hpbGQgPSBhUmVzdWx0ICYmIGFSZXN1bHRbcmVzdWx0S2V5XTtcbiAgICAgICAgICAgIHZhciBiUmVzdWx0Q2hpbGQgPSBiUmVzdWx0ICYmIGJSZXN1bHRbcmVzdWx0S2V5XTtcbiAgICAgICAgICAgIHZhciBjaGlsZFNlbGVjdGlvblNldCA9IHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQ7XG4gICAgICAgICAgICBpZiAoIWNoaWxkU2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHNjYWxhciB2YWx1ZXMsIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gd2l0aCBkZWVwIGVxdWFsXG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCByZWRvaW5nIHRoZSBtYWluIHJlY3Vyc2l2ZSB3b3JrLlxuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbChhUmVzdWx0Q2hpbGQsIGJSZXN1bHRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYUNoaWxkSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYVJlc3VsdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBiQ2hpbGRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShiUmVzdWx0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKGFDaGlsZElzQXJyYXkgIT09IGJDaGlsZElzQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGFDaGlsZElzQXJyYXkgJiYgYkNoaWxkSXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGFSZXN1bHRDaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGJSZXN1bHRDaGlsZC5sZW5ndGggIT09IGxlbmd0aF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxCeVNlbGVjdGlvblNldChjaGlsZFNlbGVjdGlvblNldCwgYVJlc3VsdENoaWxkW2ldLCBiUmVzdWx0Q2hpbGRbaV0sIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxCeVNlbGVjdGlvblNldChjaGlsZFNlbGVjdGlvblNldCwgYVJlc3VsdENoaWxkLCBiUmVzdWx0Q2hpbGQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbiwgY29udGV4dC5mcmFnbWVudE1hcCk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZnJhZ21lbnQgbWlnaHQgPT09IHNlbGVjdGlvbiBpZiBpdCdzIGFuIGlubGluZSBmcmFnbWVudCwgYnV0XG4gICAgICAgICAgICAgICAgLy8gY291bGQgYmUgIT09IGlmIGl0J3MgYSBuYW1lZCBmcmFnbWVudCAuLi5zcHJlYWQuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkhhc05vbnJlYWN0aXZlRGlyZWN0aXZlKGZyYWdtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsQnlTZWxlY3Rpb25TZXQoZnJhZ21lbnQuc2VsZWN0aW9uU2V0LCBcbiAgICAgICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB3ZSByZXVzZSB0aGUgc2FtZSBhUmVzdWx0IGFuZCBiUmVzdWx0IHZhbHVlcyBoZXJlLFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBmcmFnbWVudCAuLi5zcHJlYWQgZG9lcyBub3Qgc3BlY2lmeSBhIGZpZWxkIG5hbWUsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGZpZWxkcyAod2l0aGluIHRoZSBmcmFnbWVudCdzIHNlbGVjdGlvbiBzZXQpXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byB0aGUgY3VycmVudCByZXN1bHQgdmFsdWUocykuXG4gICAgICAgICAgICAgICAgYVJlc3VsdCwgYlJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkhhc05vbnJlYWN0aXZlRGlyZWN0aXZlKHNlbGVjdGlvbikge1xuICAgIHJldHVybiAoISFzZWxlY3Rpb24uZGlyZWN0aXZlcyAmJiBzZWxlY3Rpb24uZGlyZWN0aXZlcy5zb21lKGRpcmVjdGl2ZUlzTm9ucmVhY3RpdmUpKTtcbn1cbmZ1bmN0aW9uIGRpcmVjdGl2ZUlzTm9ucmVhY3RpdmUoZGlyKSB7XG4gICAgcmV0dXJuIGRpci5uYW1lLnZhbHVlID09PSBcIm5vbnJlYWN0aXZlXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbEJ5UXVlcnkuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsImVxdWFsIiwiY3JlYXRlRnJhZ21lbnRNYXAiLCJnZXRGcmFnbWVudERlZmluaXRpb25zIiwiZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uIiwiZ2V0TWFpbkRlZmluaXRpb24iLCJpc0ZpZWxkIiwicmVzdWx0S2V5TmFtZUZyb21GaWVsZCIsInNob3VsZEluY2x1ZGUiLCJlcXVhbEJ5UXVlcnkiLCJxdWVyeSIsIl9hIiwiX2IiLCJ2YXJpYWJsZXMiLCJhRGF0YSIsImRhdGEiLCJhUmVzdCIsImJEYXRhIiwiYlJlc3QiLCJlcXVhbEJ5U2VsZWN0aW9uU2V0Iiwic2VsZWN0aW9uU2V0IiwiZnJhZ21lbnRNYXAiLCJhUmVzdWx0IiwiYlJlc3VsdCIsImNvbnRleHQiLCJzZWVuU2VsZWN0aW9ucyIsIlNldCIsInNlbGVjdGlvbnMiLCJldmVyeSIsInNlbGVjdGlvbiIsImhhcyIsImFkZCIsInNlbGVjdGlvbkhhc05vbnJlYWN0aXZlRGlyZWN0aXZlIiwicmVzdWx0S2V5IiwiYVJlc3VsdENoaWxkIiwiYlJlc3VsdENoaWxkIiwiY2hpbGRTZWxlY3Rpb25TZXQiLCJhQ2hpbGRJc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiYkNoaWxkSXNBcnJheSIsImxlbmd0aF8xIiwibGVuZ3RoIiwiaSIsImZyYWdtZW50IiwiZGlyZWN0aXZlcyIsInNvbWUiLCJkaXJlY3RpdmVJc05vbnJlYWN0aXZlIiwiZGlyIiwibmFtZSIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js":
/*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/core/networkStatus.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkStatus: function() { return /* binding */ NetworkStatus; },\n/* harmony export */   isNetworkRequestInFlight: function() { return /* binding */ isNetworkRequestInFlight; },\n/* harmony export */   isNetworkRequestSettled: function() { return /* binding */ isNetworkRequestSettled; }\n/* harmony export */ });\n/**\n * The current status of a query’s execution in our system.\n */ var NetworkStatus;\n(function(NetworkStatus) {\n    /**\n     * The query has never been run before and the query is now currently running. A query will still\n     * have this network status even if a partial data result was returned from the cache, but a\n     * query was dispatched anyway.\n     */ NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    /**\n     * If `setVariables` was called and a query was fired because of that then the network status\n     * will be `setVariables` until the result of that query comes back.\n     */ NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    /**\n     * Indicates that `fetchMore` was called on this query and that the query created is currently in\n     * flight.\n     */ NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    /**\n     * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n     * and the refetch request is currently in flight.\n     */ NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    /**\n     * Indicates that a polling query is currently in flight. So for example if you are polling a\n     * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n     * a poll request has been sent but not resolved.\n     */ NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    /**\n     * No request is in flight for this query, and no errors happened. Everything is OK.\n     */ NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    /**\n     * No request is in flight for this query, but one or more errors were detected.\n     */ NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */ function isNetworkRequestInFlight(networkStatus) {\n    return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */ function isNetworkRequestSettled(networkStatus) {\n    return networkStatus === 7 || networkStatus === 8;\n} //# sourceMappingURL=networkStatus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL25ldHdvcmtTdGF0dXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0NBRUMsR0FDTSxJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEI7Ozs7S0FJQyxHQUNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlDOzs7S0FHQyxHQUNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ25EOzs7S0FHQyxHQUNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2hEOzs7S0FHQyxHQUNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlDOzs7O0tBSUMsR0FDREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMzQzs7S0FFQyxHQUNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7QUFDaEQsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qzs7O0NBR0MsR0FDTSxTQUFTQyx5QkFBeUJDLGFBQWE7SUFDbEQsT0FBT0EsZ0JBQWdCQSxnQkFBZ0IsSUFBSTtBQUMvQztBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLHdCQUF3QkQsYUFBYTtJQUNqRCxPQUFPQSxrQkFBa0IsS0FBS0Esa0JBQWtCO0FBQ3BELEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL25ldHdvcmtTdGF0dXMuanM/MDJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHF1ZXJ54oCZcyBleGVjdXRpb24gaW4gb3VyIHN5c3RlbS5cbiAqL1xuZXhwb3J0IHZhciBOZXR3b3JrU3RhdHVzO1xuKGZ1bmN0aW9uIChOZXR3b3JrU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IGhhcyBuZXZlciBiZWVuIHJ1biBiZWZvcmUgYW5kIHRoZSBxdWVyeSBpcyBub3cgY3VycmVudGx5IHJ1bm5pbmcuIEEgcXVlcnkgd2lsbCBzdGlsbFxuICAgICAqIGhhdmUgdGhpcyBuZXR3b3JrIHN0YXR1cyBldmVuIGlmIGEgcGFydGlhbCBkYXRhIHJlc3VsdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgY2FjaGUsIGJ1dCBhXG4gICAgICogcXVlcnkgd2FzIGRpc3BhdGNoZWQgYW55d2F5LlxuICAgICAqL1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcImxvYWRpbmdcIl0gPSAxXSA9IFwibG9hZGluZ1wiO1xuICAgIC8qKlxuICAgICAqIElmIGBzZXRWYXJpYWJsZXNgIHdhcyBjYWxsZWQgYW5kIGEgcXVlcnkgd2FzIGZpcmVkIGJlY2F1c2Ugb2YgdGhhdCB0aGVuIHRoZSBuZXR3b3JrIHN0YXR1c1xuICAgICAqIHdpbGwgYmUgYHNldFZhcmlhYmxlc2AgdW50aWwgdGhlIHJlc3VsdCBvZiB0aGF0IHF1ZXJ5IGNvbWVzIGJhY2suXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wic2V0VmFyaWFibGVzXCJdID0gMl0gPSBcInNldFZhcmlhYmxlc1wiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGBmZXRjaE1vcmVgIHdhcyBjYWxsZWQgb24gdGhpcyBxdWVyeSBhbmQgdGhhdCB0aGUgcXVlcnkgY3JlYXRlZCBpcyBjdXJyZW50bHkgaW5cbiAgICAgKiBmbGlnaHQuXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZmV0Y2hNb3JlXCJdID0gM10gPSBcImZldGNoTW9yZVwiO1xuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gdGhlIGBzZXRWYXJpYWJsZXNgIG5ldHdvcmsgc3RhdHVzLiBJdCBtZWFucyB0aGF0IGByZWZldGNoYCB3YXMgY2FsbGVkIG9uIGEgcXVlcnlcbiAgICAgKiBhbmQgdGhlIHJlZmV0Y2ggcmVxdWVzdCBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgICAqL1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInJlZmV0Y2hcIl0gPSA0XSA9IFwicmVmZXRjaFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgcG9sbGluZyBxdWVyeSBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LiBTbyBmb3IgZXhhbXBsZSBpZiB5b3UgYXJlIHBvbGxpbmcgYVxuICAgICAqIHF1ZXJ5IGV2ZXJ5IDEwIHNlY29uZHMgdGhlbiB0aGUgbmV0d29yayBzdGF0dXMgd2lsbCBzd2l0Y2ggdG8gYHBvbGxgIGV2ZXJ5IDEwIHNlY29uZHMgd2hlbmV2ZXJcbiAgICAgKiBhIHBvbGwgcmVxdWVzdCBoYXMgYmVlbiBzZW50IGJ1dCBub3QgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicG9sbFwiXSA9IDZdID0gXCJwb2xsXCI7XG4gICAgLyoqXG4gICAgICogTm8gcmVxdWVzdCBpcyBpbiBmbGlnaHQgZm9yIHRoaXMgcXVlcnksIGFuZCBubyBlcnJvcnMgaGFwcGVuZWQuIEV2ZXJ5dGhpbmcgaXMgT0suXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVhZHlcIl0gPSA3XSA9IFwicmVhZHlcIjtcbiAgICAvKipcbiAgICAgKiBObyByZXF1ZXN0IGlzIGluIGZsaWdodCBmb3IgdGhpcyBxdWVyeSwgYnV0IG9uZSBvciBtb3JlIGVycm9ycyB3ZXJlIGRldGVjdGVkLlxuICAgICAqL1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcImVycm9yXCJdID0gOF0gPSBcImVycm9yXCI7XG59KShOZXR3b3JrU3RhdHVzIHx8IChOZXR3b3JrU3RhdHVzID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGN1cnJlbnRseSBhIG5ldHdvcmsgcmVxdWVzdCBpbiBmbGlnaHQgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gbmV0d29ya1xuICogc3RhdHVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpIHtcbiAgICByZXR1cm4gbmV0d29ya1N0YXR1cyA/IG5ldHdvcmtTdGF0dXMgPCA3IDogZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbmV0d29yayByZXF1ZXN0IGlzIGluIHJlYWR5IG9yIGVycm9yIHN0YXRlIGFjY29yZGluZyB0byBhIGdpdmVuIG5ldHdvcmtcbiAqIHN0YXR1cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmV0d29ya1JlcXVlc3RTZXR0bGVkKG5ldHdvcmtTdGF0dXMpIHtcbiAgICByZXR1cm4gbmV0d29ya1N0YXR1cyA9PT0gNyB8fCBuZXR3b3JrU3RhdHVzID09PSA4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya1N0YXR1cy5qcy5tYXAiXSwibmFtZXMiOlsiTmV0d29ya1N0YXR1cyIsImlzTmV0d29ya1JlcXVlc3RJbkZsaWdodCIsIm5ldHdvcmtTdGF0dXMiLCJpc05ldHdvcmtSZXF1ZXN0U2V0dGxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/errors/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/errors/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloError: function() { return /* binding */ ApolloError; },\n/* harmony export */   PROTOCOL_ERRORS_SYMBOL: function() { return /* binding */ PROTOCOL_ERRORS_SYMBOL; },\n/* harmony export */   graphQLResultHasProtocolErrors: function() { return /* binding */ graphQLResultHasProtocolErrors; },\n/* harmony export */   isApolloError: function() { return /* binding */ isApolloError; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n\n\n\n// This Symbol allows us to pass transport-specific errors from the link chain\n// into QueryManager/client internals without risking a naming collision within\n// extensions (which implementers can use as they see fit).\nvar PROTOCOL_ERRORS_SYMBOL = Symbol();\nfunction graphQLResultHasProtocolErrors(result) {\n    if (result.extensions) {\n        return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);\n    }\n    return false;\n}\nfunction isApolloError(err) {\n    return err.hasOwnProperty(\"graphQLErrors\");\n}\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nvar generateErrorMessage = function(err) {\n    var errors = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);\n    if (err.networkError) errors.push(err.networkError);\n    return errors// The rest of the code sometimes unsafely types non-Error objects as GraphQLErrors\n    .map(function(err) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.isNonNullObject)(err) && err.message || \"Error message not found.\";\n    }).join(\"\\n\");\n};\nvar ApolloError = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ApolloError, _super);\n    // Constructs an instance of ApolloError given serialized GraphQL errors,\n    // client errors, protocol errors or network errors.\n    // Note that one of these has to be a valid\n    // value or the constructed error will be meaningless.\n    function ApolloError(_a) {\n        var graphQLErrors = _a.graphQLErrors, protocolErrors = _a.protocolErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;\n        var _this = _super.call(this, errorMessage) || this;\n        _this.name = \"ApolloError\";\n        _this.graphQLErrors = graphQLErrors || [];\n        _this.protocolErrors = protocolErrors || [];\n        _this.clientErrors = clientErrors || [];\n        _this.networkError = networkError || null;\n        _this.message = errorMessage || generateErrorMessage(_this);\n        _this.extraInfo = extraInfo;\n        _this.cause = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n            networkError\n        ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {\n            return !!e;\n        }) || null;\n        // We're not using `Object.setPrototypeOf` here as it isn't fully\n        // supported on Android (see issue #3236).\n        _this.__proto__ = ApolloError.prototype;\n        return _this;\n    }\n    return ApolloError;\n}(Error);\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNWO0FBQ2lCO0FBQ3hELDhFQUE4RTtBQUM5RSwrRUFBK0U7QUFDL0UsMkRBQTJEO0FBQ3BELElBQUlHLHlCQUF5QkMsU0FBUztBQUN0QyxTQUFTQywrQkFBK0JDLE1BQU07SUFDakQsSUFBSUEsT0FBT0MsVUFBVSxFQUFFO1FBQ25CLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0gsT0FBT0MsVUFBVSxDQUFDSix1QkFBdUI7SUFDbEU7SUFDQSxPQUFPO0FBQ1g7QUFDTyxTQUFTTyxjQUFjQyxHQUFHO0lBQzdCLE9BQU9BLElBQUlDLGNBQWMsQ0FBQztBQUM5QjtBQUNBLHdEQUF3RDtBQUN4RCxtREFBbUQ7QUFDbkQsd0RBQXdEO0FBQ3hELG9EQUFvRDtBQUNwRCxJQUFJQyx1QkFBdUIsU0FBVUYsR0FBRztJQUNwQyxJQUFJRyxTQUFTYixvREFBYUEsQ0FBQ0Esb0RBQWFBLENBQUNBLG9EQUFhQSxDQUFDLEVBQUUsRUFBRVUsSUFBSUksYUFBYSxFQUFFLE9BQU9KLElBQUlLLFlBQVksRUFBRSxPQUFPTCxJQUFJTSxjQUFjLEVBQUU7SUFDbEksSUFBSU4sSUFBSU8sWUFBWSxFQUNoQkosT0FBT0ssSUFBSSxDQUFDUixJQUFJTyxZQUFZO0lBQ2hDLE9BQVFKLE1BQ0osbUZBQW1GO0tBQ2xGTSxHQUFHLENBQUMsU0FBVVQsR0FBRztRQUNsQixPQUFPLHFFQUFpQkEsUUFBUUEsSUFBSVUsT0FBTyxJQUFLO0lBQ3BELEdBQ0tDLElBQUksQ0FBQztBQUNkO0FBQ0EsSUFBSUMsY0FBYyxXQUFXLEdBQUksU0FBVUMsTUFBTTtJQUM3Q3hCLGdEQUFTQSxDQUFDdUIsYUFBYUM7SUFDdkIseUVBQXlFO0lBQ3pFLG9EQUFvRDtJQUNwRCwyQ0FBMkM7SUFDM0Msc0RBQXNEO0lBQ3RELFNBQVNELFlBQVlFLEVBQUU7UUFDbkIsSUFBSVYsZ0JBQWdCVSxHQUFHVixhQUFhLEVBQUVFLGlCQUFpQlEsR0FBR1IsY0FBYyxFQUFFRCxlQUFlUyxHQUFHVCxZQUFZLEVBQUVFLGVBQWVPLEdBQUdQLFlBQVksRUFBRVEsZUFBZUQsR0FBR0MsWUFBWSxFQUFFQyxZQUFZRixHQUFHRSxTQUFTO1FBQ2xNLElBQUlDLFFBQVFKLE9BQU9LLElBQUksQ0FBQyxJQUFJLEVBQUVILGlCQUFpQixJQUFJO1FBQ25ERSxNQUFNRSxJQUFJLEdBQUc7UUFDYkYsTUFBTWIsYUFBYSxHQUFHQSxpQkFBaUIsRUFBRTtRQUN6Q2EsTUFBTVgsY0FBYyxHQUFHQSxrQkFBa0IsRUFBRTtRQUMzQ1csTUFBTVosWUFBWSxHQUFHQSxnQkFBZ0IsRUFBRTtRQUN2Q1ksTUFBTVYsWUFBWSxHQUFHQSxnQkFBZ0I7UUFDckNVLE1BQU1QLE9BQU8sR0FBR0ssZ0JBQWdCYixxQkFBcUJlO1FBQ3JEQSxNQUFNRCxTQUFTLEdBQUdBO1FBQ2xCQyxNQUFNRyxLQUFLLEdBQ1A5QixvREFBYUEsQ0FBQ0Esb0RBQWFBLENBQUNBLG9EQUFhQSxDQUFDO1lBQ3RDaUI7U0FDSCxFQUFHSCxpQkFBaUIsRUFBRSxFQUFHLE9BQVFFLGtCQUFrQixFQUFFLEVBQUcsT0FBUUQsZ0JBQWdCLEVBQUUsRUFBRyxNQUFNZ0IsSUFBSSxDQUFDLFNBQVVDLENBQUM7WUFBSSxPQUFPLENBQUMsQ0FBQ0E7UUFBRyxNQUFNO1FBQ3RJLGlFQUFpRTtRQUNqRSwwQ0FBMEM7UUFDMUNMLE1BQU1NLFNBQVMsR0FBR1gsWUFBWVksU0FBUztRQUN2QyxPQUFPUDtJQUNYO0lBQ0EsT0FBT0w7QUFDWCxFQUFFYTtBQUNxQixDQUN2QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2Vycm9ycy9pbmRleC5qcz8yOTU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXh0ZW5kcywgX19zcHJlYWRBcnJheSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFwiLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzTm9uTnVsbE9iamVjdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbi8vIFRoaXMgU3ltYm9sIGFsbG93cyB1cyB0byBwYXNzIHRyYW5zcG9ydC1zcGVjaWZpYyBlcnJvcnMgZnJvbSB0aGUgbGluayBjaGFpblxuLy8gaW50byBRdWVyeU1hbmFnZXIvY2xpZW50IGludGVybmFscyB3aXRob3V0IHJpc2tpbmcgYSBuYW1pbmcgY29sbGlzaW9uIHdpdGhpblxuLy8gZXh0ZW5zaW9ucyAod2hpY2ggaW1wbGVtZW50ZXJzIGNhbiB1c2UgYXMgdGhleSBzZWUgZml0KS5cbmV4cG9ydCB2YXIgUFJPVE9DT0xfRVJST1JTX1NZTUJPTCA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdyYXBoUUxSZXN1bHRIYXNQcm90b2NvbEVycm9ycyhyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzdWx0LmV4dGVuc2lvbnNbUFJPVE9DT0xfRVJST1JTX1NZTUJPTF0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcG9sbG9FcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyLmhhc093blByb3BlcnR5KFwiZ3JhcGhRTEVycm9yc1wiKTtcbn1cbi8vIFNldHMgdGhlIGVycm9yIG1lc3NhZ2Ugb24gdGhpcyBlcnJvciBhY2NvcmRpbmcgdG8gdGhlXG4vLyB0aGUgR3JhcGhRTCBhbmQgbmV0d29yayBlcnJvcnMgdGhhdCBhcmUgcHJlc2VudC5cbi8vIElmIHRoZSBlcnJvciBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRocm91Z2ggdGhlXG4vLyBjb25zdHJ1Y3RvciBvciBvdGhlcndpc2UsIHRoaXMgZnVuY3Rpb24gaXMgYSBub3AuXG52YXIgZ2VuZXJhdGVFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVycm9ycyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBlcnIuZ3JhcGhRTEVycm9ycywgdHJ1ZSksIGVyci5jbGllbnRFcnJvcnMsIHRydWUpLCBlcnIucHJvdG9jb2xFcnJvcnMsIHRydWUpO1xuICAgIGlmIChlcnIubmV0d29ya0Vycm9yKVxuICAgICAgICBlcnJvcnMucHVzaChlcnIubmV0d29ya0Vycm9yKTtcbiAgICByZXR1cm4gKGVycm9yc1xuICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgY29kZSBzb21ldGltZXMgdW5zYWZlbHkgdHlwZXMgbm9uLUVycm9yIG9iamVjdHMgYXMgR3JhcGhRTEVycm9yc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIChpc05vbk51bGxPYmplY3QoZXJyKSAmJiBlcnIubWVzc2FnZSkgfHwgXCJFcnJvciBtZXNzYWdlIG5vdCBmb3VuZC5cIjtcbiAgICB9KVxuICAgICAgICAuam9pbihcIlxcblwiKSk7XG59O1xudmFyIEFwb2xsb0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcG9sbG9FcnJvciwgX3N1cGVyKTtcbiAgICAvLyBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEFwb2xsb0Vycm9yIGdpdmVuIHNlcmlhbGl6ZWQgR3JhcGhRTCBlcnJvcnMsXG4gICAgLy8gY2xpZW50IGVycm9ycywgcHJvdG9jb2wgZXJyb3JzIG9yIG5ldHdvcmsgZXJyb3JzLlxuICAgIC8vIE5vdGUgdGhhdCBvbmUgb2YgdGhlc2UgaGFzIHRvIGJlIGEgdmFsaWRcbiAgICAvLyB2YWx1ZSBvciB0aGUgY29uc3RydWN0ZWQgZXJyb3Igd2lsbCBiZSBtZWFuaW5nbGVzcy5cbiAgICBmdW5jdGlvbiBBcG9sbG9FcnJvcihfYSkge1xuICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IF9hLmdyYXBoUUxFcnJvcnMsIHByb3RvY29sRXJyb3JzID0gX2EucHJvdG9jb2xFcnJvcnMsIGNsaWVudEVycm9ycyA9IF9hLmNsaWVudEVycm9ycywgbmV0d29ya0Vycm9yID0gX2EubmV0d29ya0Vycm9yLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIGV4dHJhSW5mbyA9IF9hLmV4dHJhSW5mbztcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3JNZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gXCJBcG9sbG9FcnJvclwiO1xuICAgICAgICBfdGhpcy5ncmFwaFFMRXJyb3JzID0gZ3JhcGhRTEVycm9ycyB8fCBbXTtcbiAgICAgICAgX3RoaXMucHJvdG9jb2xFcnJvcnMgPSBwcm90b2NvbEVycm9ycyB8fCBbXTtcbiAgICAgICAgX3RoaXMuY2xpZW50RXJyb3JzID0gY2xpZW50RXJyb3JzIHx8IFtdO1xuICAgICAgICBfdGhpcy5uZXR3b3JrRXJyb3IgPSBuZXR3b3JrRXJyb3IgfHwgbnVsbDtcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCBnZW5lcmF0ZUVycm9yTWVzc2FnZShfdGhpcyk7XG4gICAgICAgIF90aGlzLmV4dHJhSW5mbyA9IGV4dHJhSW5mbztcbiAgICAgICAgX3RoaXMuY2F1c2UgPVxuICAgICAgICAgICAgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvclxuICAgICAgICAgICAgXSwgKGdyYXBoUUxFcnJvcnMgfHwgW10pLCB0cnVlKSwgKHByb3RvY29sRXJyb3JzIHx8IFtdKSwgdHJ1ZSksIChjbGllbnRFcnJvcnMgfHwgW10pLCB0cnVlKS5maW5kKGZ1bmN0aW9uIChlKSB7IHJldHVybiAhIWU7IH0pIHx8IG51bGw7XG4gICAgICAgIC8vIFdlJ3JlIG5vdCB1c2luZyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBoZXJlIGFzIGl0IGlzbid0IGZ1bGx5XG4gICAgICAgIC8vIHN1cHBvcnRlZCBvbiBBbmRyb2lkIChzZWUgaXNzdWUgIzMyMzYpLlxuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBBcG9sbG9FcnJvci5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFwb2xsb0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgQXBvbGxvRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJfX3NwcmVhZEFycmF5IiwiaXNOb25OdWxsT2JqZWN0IiwiUFJPVE9DT0xfRVJST1JTX1NZTUJPTCIsIlN5bWJvbCIsImdyYXBoUUxSZXN1bHRIYXNQcm90b2NvbEVycm9ycyIsInJlc3VsdCIsImV4dGVuc2lvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0Fwb2xsb0Vycm9yIiwiZXJyIiwiaGFzT3duUHJvcGVydHkiLCJnZW5lcmF0ZUVycm9yTWVzc2FnZSIsImVycm9ycyIsImdyYXBoUUxFcnJvcnMiLCJjbGllbnRFcnJvcnMiLCJwcm90b2NvbEVycm9ycyIsIm5ldHdvcmtFcnJvciIsInB1c2giLCJtYXAiLCJtZXNzYWdlIiwiam9pbiIsIkFwb2xsb0Vycm9yIiwiX3N1cGVyIiwiX2EiLCJlcnJvck1lc3NhZ2UiLCJleHRyYUluZm8iLCJfdGhpcyIsImNhbGwiLCJuYW1lIiwiY2F1c2UiLCJmaW5kIiwiZSIsIl9fcHJvdG9fXyIsInByb3RvdHlwZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/ApolloLink.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloLink: function() { return /* binding */ ApolloLink; }\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/createOperation.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/transformOperation.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/validateOperation.js\");\n\n\n\nfunction passthrough(op, forward) {\n    return forward ? forward(op) : _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n}\nfunction toLink(handler) {\n    return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\nfunction isTerminating(link) {\n    return link.request.length <= 1;\n}\nvar ApolloLink = /** @class */ function() {\n    function ApolloLink(request) {\n        if (request) this.request = request;\n    }\n    ApolloLink.empty = function() {\n        return new ApolloLink(function() {\n            return _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n        });\n    };\n    ApolloLink.from = function(links) {\n        if (links.length === 0) return ApolloLink.empty();\n        return links.map(toLink).reduce(function(x, y) {\n            return x.concat(y);\n        });\n    };\n    ApolloLink.split = function(test, left, right) {\n        var leftLink = toLink(left);\n        var rightLink = toLink(right || new ApolloLink(passthrough));\n        var ret;\n        if (isTerminating(leftLink) && isTerminating(rightLink)) {\n            ret = new ApolloLink(function(operation) {\n                return test(operation) ? leftLink.request(operation) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of() : rightLink.request(operation) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n            });\n        } else {\n            ret = new ApolloLink(function(operation, forward) {\n                return test(operation) ? leftLink.request(operation, forward) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of() : rightLink.request(operation, forward) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n            });\n        }\n        return Object.assign(ret, {\n            left: leftLink,\n            right: rightLink\n        });\n    };\n    ApolloLink.execute = function(link, operation) {\n        return link.request((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.createOperation)(operation.context, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.transformOperation)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.validateOperation)(operation)))) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n    };\n    ApolloLink.concat = function(first, second) {\n        var firstLink = toLink(first);\n        if (isTerminating(firstLink)) {\n            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(36, firstLink);\n            return firstLink;\n        }\n        var nextLink = toLink(second);\n        var ret;\n        if (isTerminating(nextLink)) {\n            ret = new ApolloLink(function(operation) {\n                return firstLink.request(operation, function(op) {\n                    return nextLink.request(op) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n                }) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n            });\n        } else {\n            ret = new ApolloLink(function(operation, forward) {\n                return firstLink.request(operation, function(op) {\n                    return nextLink.request(op, forward) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n                }) || _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.Observable.of();\n            });\n        }\n        return Object.assign(ret, {\n            left: firstLink,\n            right: nextLink\n        });\n    };\n    ApolloLink.prototype.split = function(test, left, right) {\n        return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));\n    };\n    ApolloLink.prototype.concat = function(next) {\n        return ApolloLink.concat(this, next);\n    };\n    ApolloLink.prototype.request = function(operation, forward) {\n        throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(37);\n    };\n    ApolloLink.prototype.onError = function(error, observer) {\n        if (observer && observer.error) {\n            observer.error(error);\n            // Returning false indicates that observer.error does not need to be\n            // called again, since it was already called (on the previous line).\n            // Calling observer.error again would not cause any real problems,\n            // since only the first call matters, but custom onError functions\n            // might have other reasons for wanting to prevent the default\n            // behavior by returning false.\n            return false;\n        }\n        // Throw errors will be passed to observer.error.\n        throw error;\n    };\n    ApolloLink.prototype.setOnError = function(fn) {\n        this.onError = fn;\n        return this;\n    };\n    return ApolloLink;\n}();\n //# sourceMappingURL=ApolloLink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2NvcmUvQXBvbGxvTGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Y7QUFDMUI7QUFDc0M7QUFDNUYsU0FBU00sWUFBWUMsRUFBRSxFQUFFQyxPQUFPO0lBQzVCLE9BQVFBLFVBQVVBLFFBQVFELE1BQU1MLDJEQUFVQSxDQUFDTyxFQUFFO0FBQ2pEO0FBQ0EsU0FBU0MsT0FBT0MsT0FBTztJQUNuQixPQUFPLE9BQU9BLFlBQVksYUFBYSxJQUFJQyxXQUFXRCxXQUFXQTtBQUNyRTtBQUNBLFNBQVNFLGNBQWNDLElBQUk7SUFDdkIsT0FBT0EsS0FBS0MsT0FBTyxDQUFDQyxNQUFNLElBQUk7QUFDbEM7QUFDQSxJQUFJSixhQUFhLFdBQVcsR0FBSTtJQUM1QixTQUFTQSxXQUFXRyxPQUFPO1FBQ3ZCLElBQUlBLFNBQ0EsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ3ZCO0lBQ0FILFdBQVdLLEtBQUssR0FBRztRQUNmLE9BQU8sSUFBSUwsV0FBVztZQUFjLE9BQU9WLDJEQUFVQSxDQUFDTyxFQUFFO1FBQUk7SUFDaEU7SUFDQUcsV0FBV00sSUFBSSxHQUFHLFNBQVVDLEtBQUs7UUFDN0IsSUFBSUEsTUFBTUgsTUFBTSxLQUFLLEdBQ2pCLE9BQU9KLFdBQVdLLEtBQUs7UUFDM0IsT0FBT0UsTUFBTUMsR0FBRyxDQUFDVixRQUFRVyxNQUFNLENBQUMsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1lBQUksT0FBT0QsRUFBRUUsTUFBTSxDQUFDRDtRQUFJO0lBQzFFO0lBQ0FYLFdBQVdhLEtBQUssR0FBRyxTQUFVQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsS0FBSztRQUMxQyxJQUFJQyxXQUFXbkIsT0FBT2lCO1FBQ3RCLElBQUlHLFlBQVlwQixPQUFPa0IsU0FBUyxJQUFJaEIsV0FBV047UUFDL0MsSUFBSXlCO1FBQ0osSUFBSWxCLGNBQWNnQixhQUFhaEIsY0FBY2lC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QWtFO1lBQ2xFLDhEQUE4RDtZQUM5RCwrQkFBK0I7WUFDL0IsT0FBTztRQUNYO1FBQ0EsaURBQWlEO1FBQ2pELE1BQU1BO0lBQ1Y7SUFDQW5DLFdBQVdnQyxTQUFTLENBQUNLLFVBQVUsR0FBRyxTQUFVQyxFQUFFO1FBQzFDLElBQUksQ0FBQ0osT0FBTyxHQUFHSTtRQUNmLE9BQU8sSUFBSTtJQUNmO0lBQ0EsT0FBT3RDO0FBQ1g7QUFDc0IsQ0FDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2NvcmUvQXBvbGxvTGluay5qcz84M2Q5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5ld0ludmFyaWFudEVycm9yLCBpbnZhcmlhbnQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZU9wZXJhdGlvbiwgY3JlYXRlT3BlcmF0aW9uLCB0cmFuc2Zvcm1PcGVyYXRpb24sIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBwYXNzdGhyb3VnaChvcCwgZm9yd2FyZCkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IGZvcndhcmQob3ApIDogT2JzZXJ2YWJsZS5vZigpKTtcbn1cbmZ1bmN0aW9uIHRvTGluayhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgQXBvbGxvTGluayhoYW5kbGVyKSA6IGhhbmRsZXI7XG59XG5mdW5jdGlvbiBpc1Rlcm1pbmF0aW5nKGxpbmspIHtcbiAgICByZXR1cm4gbGluay5yZXF1ZXN0Lmxlbmd0aCA8PSAxO1xufVxudmFyIEFwb2xsb0xpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBvbGxvTGluayhyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9XG4gICAgQXBvbGxvTGluay5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9ic2VydmFibGUub2YoKTsgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLmZyb20gPSBmdW5jdGlvbiAobGlua3MpIHtcbiAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBBcG9sbG9MaW5rLmVtcHR5KCk7XG4gICAgICAgIHJldHVybiBsaW5rcy5tYXAodG9MaW5rKS5yZWR1Y2UoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHguY29uY2F0KHkpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsuc3BsaXQgPSBmdW5jdGlvbiAodGVzdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGxlZnRMaW5rID0gdG9MaW5rKGxlZnQpO1xuICAgICAgICB2YXIgcmlnaHRMaW5rID0gdG9MaW5rKHJpZ2h0IHx8IG5ldyBBcG9sbG9MaW5rKHBhc3N0aHJvdWdoKSk7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChpc1Rlcm1pbmF0aW5nKGxlZnRMaW5rKSAmJiBpc1Rlcm1pbmF0aW5nKHJpZ2h0TGluaykpIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdChvcGVyYXRpb24pID9cbiAgICAgICAgICAgICAgICAgICAgbGVmdExpbmsucmVxdWVzdChvcGVyYXRpb24pIHx8IE9ic2VydmFibGUub2YoKVxuICAgICAgICAgICAgICAgICAgICA6IHJpZ2h0TGluay5yZXF1ZXN0KG9wZXJhdGlvbikgfHwgT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Qob3BlcmF0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGxlZnRMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmb3J3YXJkKSB8fCBPYnNlcnZhYmxlLm9mKClcbiAgICAgICAgICAgICAgICAgICAgOiByaWdodExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpIHx8IE9ic2VydmFibGUub2YoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJldCwgeyBsZWZ0OiBsZWZ0TGluaywgcmlnaHQ6IHJpZ2h0TGluayB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsuZXhlY3V0ZSA9IGZ1bmN0aW9uIChsaW5rLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChsaW5rLnJlcXVlc3QoY3JlYXRlT3BlcmF0aW9uKG9wZXJhdGlvbi5jb250ZXh0LCB0cmFuc2Zvcm1PcGVyYXRpb24odmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSkpKSB8fCBPYnNlcnZhYmxlLm9mKCkpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5jb25jYXQgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgZmlyc3RMaW5rID0gdG9MaW5rKGZpcnN0KTtcbiAgICAgICAgaWYgKGlzVGVybWluYXRpbmcoZmlyc3RMaW5rKSkge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2FybigzNiwgZmlyc3RMaW5rKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdExpbms7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRMaW5rID0gdG9MaW5rKHNlY29uZCk7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChpc1Rlcm1pbmF0aW5nKG5leHRMaW5rKSkge1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFwb2xsb0xpbmsoZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCkgfHwgT2JzZXJ2YWJsZS5vZigpOyB9KSB8fCBPYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZpcnN0TGluay5yZXF1ZXN0KG9wZXJhdGlvbiwgZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0TGluay5yZXF1ZXN0KG9wLCBmb3J3YXJkKSB8fCBPYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICAgICAgfSkgfHwgT2JzZXJ2YWJsZS5vZigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJldCwgeyBsZWZ0OiBmaXJzdExpbmssIHJpZ2h0OiBuZXh0TGluayB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHRlc3QsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChBcG9sbG9MaW5rLnNwbGl0KHRlc3QsIGxlZnQsIHJpZ2h0IHx8IG5ldyBBcG9sbG9MaW5rKHBhc3N0aHJvdWdoKSkpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIEFwb2xsb0xpbmsuY29uY2F0KHRoaXMsIG5leHQpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoMzcpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyICYmIG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAvLyBSZXR1cm5pbmcgZmFsc2UgaW5kaWNhdGVzIHRoYXQgb2JzZXJ2ZXIuZXJyb3IgZG9lcyBub3QgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIGFnYWluLCBzaW5jZSBpdCB3YXMgYWxyZWFkeSBjYWxsZWQgKG9uIHRoZSBwcmV2aW91cyBsaW5lKS5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgb2JzZXJ2ZXIuZXJyb3IgYWdhaW4gd291bGQgbm90IGNhdXNlIGFueSByZWFsIHByb2JsZW1zLFxuICAgICAgICAgICAgLy8gc2luY2Ugb25seSB0aGUgZmlyc3QgY2FsbCBtYXR0ZXJzLCBidXQgY3VzdG9tIG9uRXJyb3IgZnVuY3Rpb25zXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIG90aGVyIHJlYXNvbnMgZm9yIHdhbnRpbmcgdG8gcHJldmVudCB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgYnkgcmV0dXJuaW5nIGZhbHNlLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRocm93IGVycm9ycyB3aWxsIGJlIHBhc3NlZCB0byBvYnNlcnZlci5lcnJvci5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5zZXRPbkVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25FcnJvciA9IGZuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBcG9sbG9MaW5rO1xufSgpKTtcbmV4cG9ydCB7IEFwb2xsb0xpbmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwb2xsb0xpbmsuanMubWFwIl0sIm5hbWVzIjpbIm5ld0ludmFyaWFudEVycm9yIiwiaW52YXJpYW50IiwiT2JzZXJ2YWJsZSIsInZhbGlkYXRlT3BlcmF0aW9uIiwiY3JlYXRlT3BlcmF0aW9uIiwidHJhbnNmb3JtT3BlcmF0aW9uIiwicGFzc3Rocm91Z2giLCJvcCIsImZvcndhcmQiLCJvZiIsInRvTGluayIsImhhbmRsZXIiLCJBcG9sbG9MaW5rIiwiaXNUZXJtaW5hdGluZyIsImxpbmsiLCJyZXF1ZXN0IiwibGVuZ3RoIiwiZW1wdHkiLCJmcm9tIiwibGlua3MiLCJtYXAiLCJyZWR1Y2UiLCJ4IiwieSIsImNvbmNhdCIsInNwbGl0IiwidGVzdCIsImxlZnQiLCJyaWdodCIsImxlZnRMaW5rIiwicmlnaHRMaW5rIiwicmV0Iiwib3BlcmF0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwiZXhlY3V0ZSIsImNvbnRleHQiLCJmaXJzdCIsInNlY29uZCIsImZpcnN0TGluayIsImdsb2JhbFRoaXMiLCJfX0RFVl9fIiwid2FybiIsIm5leHRMaW5rIiwicHJvdG90eXBlIiwibmV4dCIsIm9uRXJyb3IiLCJlcnJvciIsIm9ic2VydmVyIiwic2V0T25FcnJvciIsImZuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/core/execute.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/execute.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   execute: function() { return /* binding */ execute; }\n/* harmony export */ });\n/* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ApolloLink.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js\");\n\nvar execute = _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__.ApolloLink.execute; //# sourceMappingURL=execute.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2NvcmUvZXhlY3V0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2QztBQUN0QyxJQUFJQyxVQUFVRCxzREFBVUEsQ0FBQ0MsT0FBTyxDQUFDLENBQ3hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9jb3JlL2V4ZWN1dGUuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcG9sbG9MaW5rIH0gZnJvbSBcIi4vQXBvbGxvTGluay5qc1wiO1xuZXhwb3J0IHZhciBleGVjdXRlID0gQXBvbGxvTGluay5leGVjdXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhlY3V0ZS5qcy5tYXAiXSwibmFtZXMiOlsiQXBvbGxvTGluayIsImV4ZWN1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/core/execute.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/HttpLink.js":
/*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/HttpLink.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpLink: function() { return /* binding */ HttpLink; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js\");\n/* harmony import */ var _createHttpLink_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createHttpLink.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/createHttpLink.js\");\n\n\n\nvar HttpLink = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(HttpLink, _super);\n    function HttpLink(options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _this = _super.call(this, (0,_createHttpLink_js__WEBPACK_IMPORTED_MODULE_1__.createHttpLink)(options).request) || this;\n        _this.options = options;\n        return _this;\n    }\n    return HttpLink;\n}(_core_index_js__WEBPACK_IMPORTED_MODULE_2__.ApolloLink);\n //# sourceMappingURL=HttpLink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvSHR0cExpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNZO0FBQ087QUFDckQsSUFBSUcsV0FBVyxXQUFXLEdBQUksU0FBVUMsTUFBTTtJQUMxQ0osZ0RBQVNBLENBQUNHLFVBQVVDO0lBQ3BCLFNBQVNELFNBQVNFLE9BQU87UUFDckIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFBRUEsVUFBVSxDQUFDO1FBQUc7UUFDeEMsSUFBSUMsUUFBUUYsT0FBT0csSUFBSSxDQUFDLElBQUksRUFBRUwsa0VBQWNBLENBQUNHLFNBQVNHLE9BQU8sS0FBSyxJQUFJO1FBQ3RFRixNQUFNRCxPQUFPLEdBQUdBO1FBQ2hCLE9BQU9DO0lBQ1g7SUFDQSxPQUFPSDtBQUNYLEVBQUVGLHNEQUFVQTtBQUNRLENBQ3BCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL0h0dHBMaW5rLmpzP2VjNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBBcG9sbG9MaW5rIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCB7IGNyZWF0ZUh0dHBMaW5rIH0gZnJvbSBcIi4vY3JlYXRlSHR0cExpbmsuanNcIjtcbnZhciBIdHRwTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHR0cExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cExpbmsob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjcmVhdGVIdHRwTGluayhvcHRpb25zKS5yZXF1ZXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSHR0cExpbms7XG59KEFwb2xsb0xpbmspKTtcbmV4cG9ydCB7IEh0dHBMaW5rIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdHRwTGluay5qcy5tYXAiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiQXBvbGxvTGluayIsImNyZWF0ZUh0dHBMaW5rIiwiSHR0cExpbmsiLCJfc3VwZXIiLCJvcHRpb25zIiwiX3RoaXMiLCJjYWxsIiwicmVxdWVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/HttpLink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/checkFetcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/checkFetcher.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkFetcher: function() { return /* binding */ checkFetcher; }\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\nvar checkFetcher = function(fetcher) {\n    if (!fetcher && typeof fetch === \"undefined\") {\n        throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(38);\n    }\n}; //# sourceMappingURL=checkFetcher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvY2hlY2tGZXRjaGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFFO0FBQzlELElBQUlDLGVBQWUsU0FBVUMsT0FBTztJQUN2QyxJQUFJLENBQUNBLFdBQVcsT0FBT0MsVUFBVSxhQUFhO1FBQzFDLE1BQU1ILDhFQUFpQkEsQ0FBQztJQUM1QjtBQUNKLEVBQUUsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvaHR0cC9jaGVja0ZldGNoZXIuanM/NDBjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBuZXdJbnZhcmlhbnRFcnJvciB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuZXhwb3J0IHZhciBjaGVja0ZldGNoZXIgPSBmdW5jdGlvbiAoZmV0Y2hlcikge1xuICAgIGlmICghZmV0Y2hlciAmJiB0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoMzgpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja0ZldGNoZXIuanMubWFwIl0sIm5hbWVzIjpbIm5ld0ludmFyaWFudEVycm9yIiwiY2hlY2tGZXRjaGVyIiwiZmV0Y2hlciIsImZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/checkFetcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/createHttpLink.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/createHttpLink.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHttpLink: function() { return /* binding */ createHttpLink; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/core/ApolloLink.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./serializeFetchParameter.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/serializeFetchParameter.js\");\n/* harmony import */ var _selectURI_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selectURI.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/selectURI.js\");\n/* harmony import */ var _parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./parseAndCheckHttpResponse.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js\");\n/* harmony import */ var _checkFetcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./checkFetcher.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/checkFetcher.js\");\n/* harmony import */ var _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectHttpOptionsAndBody.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js\");\n/* harmony import */ var _rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rewriteURIForGET.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/rewriteURIForGET.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/fromError.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/filterOperationVariables.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar backupFetch = (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return fetch;\n});\nvar createHttpLink = function(linkOptions) {\n    if (linkOptions === void 0) {\n        linkOptions = {};\n    }\n    var _a = linkOptions.uri, uri = _a === void 0 ? \"/graphql\" : _a, // use default global fetch if nothing passed in\n    preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_1__.defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(linkOptions, [\n        \"uri\",\n        \"fetch\",\n        \"print\",\n        \"includeExtensions\",\n        \"preserveHeaderCase\",\n        \"useGETForQueries\",\n        \"includeUnusedVariables\"\n    ]);\n    if (globalThis.__DEV__ !== false) {\n        // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n        // defined, so requests won't fail at runtime.\n        (0,_checkFetcher_js__WEBPACK_IMPORTED_MODULE_3__.checkFetcher)(preferredFetch || backupFetch);\n    }\n    var linkConfig = {\n        http: {\n            includeExtensions: includeExtensions,\n            preserveHeaderCase: preserveHeaderCase\n        },\n        options: requestOptions.fetchOptions,\n        credentials: requestOptions.credentials,\n        headers: requestOptions.headers\n    };\n    return new _core_index_js__WEBPACK_IMPORTED_MODULE_4__.ApolloLink(function(operation) {\n        var chosenURI = (0,_selectURI_js__WEBPACK_IMPORTED_MODULE_5__.selectURI)(operation, uri);\n        var context = operation.getContext();\n        // `apollographql-client-*` headers are automatically set if a\n        // `clientAwareness` object is found in the context. These headers are\n        // set first, followed by the rest of the headers pulled from\n        // `context.headers`. If desired, `apollographql-client-*` headers set by\n        // the `clientAwareness` object can be overridden by\n        // `apollographql-client-*` headers set in `context.headers`.\n        var clientAwarenessHeaders = {};\n        if (context.clientAwareness) {\n            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;\n            if (name_1) {\n                clientAwarenessHeaders[\"apollographql-client-name\"] = name_1;\n            }\n            if (version) {\n                clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n            }\n        }\n        var contextHeaders = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, clientAwarenessHeaders), context.headers);\n        var contextConfig = {\n            http: context.http,\n            options: context.fetchOptions,\n            credentials: context.credentials,\n            headers: contextHeaders\n        };\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.hasDirectives)([\n            \"client\"\n        ], operation.query)) {\n            var transformedQuery = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.removeClientSetsFromDocument)(operation.query);\n            if (!transformedQuery) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.fromError)(new Error(\"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"));\n            }\n            operation.query = transformedQuery;\n        }\n        //uses fallback, link, and then context to build options\n        var _b = (0,_selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_1__.selectHttpOptionsAndBodyInternal)(operation, print, _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_1__.fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;\n        if (body.variables && !includeUnusedVariables) {\n            body.variables = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.filterOperationVariables)(body.variables, operation.query);\n        }\n        var controller;\n        if (!options.signal && typeof AbortController !== \"undefined\") {\n            controller = new AbortController();\n            options.signal = controller.signal;\n        }\n        // If requested, set method to GET if there are no mutations.\n        var definitionIsMutation = function(d) {\n            return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n        };\n        var definitionIsSubscription = function(d) {\n            return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n        };\n        var isSubscription = definitionIsSubscription((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.getMainDefinition)(operation.query));\n        // does not match custom directives beginning with @defer\n        var hasDefer = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_6__.hasDirectives)([\n            \"defer\"\n        ], operation.query);\n        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {\n            options.method = \"GET\";\n        }\n        if (hasDefer || isSubscription) {\n            options.headers = options.headers || {};\n            var acceptHeader = \"multipart/mixed;\";\n            // Omit defer-specific headers if the user attempts to defer a selection\n            // set on a subscription and log a warning.\n            if (isSubscription && hasDefer) {\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(39);\n            }\n            if (isSubscription) {\n                acceptHeader += \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n            } else if (hasDefer) {\n                acceptHeader += \"deferSpec=20220824,application/json\";\n            }\n            options.headers.accept = acceptHeader;\n        }\n        if (options.method === \"GET\") {\n            var _c = (0,_rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_11__.rewriteURIForGET)(chosenURI, body), newURI = _c.newURI, parseError = _c.parseError;\n            if (parseError) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.fromError)(parseError);\n            }\n            chosenURI = newURI;\n        } else {\n            try {\n                options.body = (0,_serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_12__.serializeFetchParameter)(body, \"Payload\");\n            } catch (parseError) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.fromError)(parseError);\n            }\n        }\n        return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.Observable(function(observer) {\n            // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n            // fall back to the *current* global window.fetch function (see issue\n            // #7832), or (if all else fails) the backupFetch function we saved when\n            // this module was first evaluated. This last option protects against the\n            // removal of window.fetch, which is unlikely but not impossible.\n            var currentFetch = preferredFetch || (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n                return fetch;\n            }) || backupFetch;\n            var observerNext = observer.next.bind(observer);\n            currentFetch(chosenURI, options).then(function(response) {\n                var _a;\n                operation.setContext({\n                    response: response\n                });\n                var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n                if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n                    return (0,_parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_14__.readMultipartBody)(response, observerNext);\n                } else {\n                    return (0,_parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_14__.parseAndCheckHttpResponse)(operation)(response).then(observerNext);\n                }\n            }).then(function() {\n                controller = undefined;\n                observer.complete();\n            }).catch(function(err) {\n                controller = undefined;\n                (0,_parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_14__.handleError)(err, observer);\n            });\n            return function() {\n                // XXX support canceling this request\n                // https://developers.google.com/web/updates/2017/09/abortable-fetch\n                if (controller) controller.abort();\n            };\n        });\n    });\n}; //# sourceMappingURL=createHttpLink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvY3JlYXRlSHR0cExpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNvQjtBQUNmO0FBQ3VCO0FBQ0U7QUFDNUI7QUFDaUU7QUFDM0Q7QUFDcUU7QUFDN0Q7QUFDZTtBQUMyQjtBQUNuRyxJQUFJcUIsY0FBY0gsa0VBQUtBLENBQUM7SUFBYyxPQUFPSTtBQUFPO0FBQzdDLElBQUlDLGlCQUFpQixTQUFVQyxXQUFXO0lBQzdDLElBQUlBLGdCQUFnQixLQUFLLEdBQUc7UUFBRUEsY0FBYyxDQUFDO0lBQUc7SUFDaEQsSUFBSUMsS0FBS0QsWUFBWUUsR0FBRyxFQUFFQSxNQUFNRCxPQUFPLEtBQUssSUFBSSxhQUFhQSxJQUM3RCxnREFBZ0Q7SUFDaERFLGlCQUFpQkgsWUFBWUYsS0FBSyxFQUFFTSxLQUFLSixZQUFZSyxLQUFLLEVBQUVBLFFBQVFELE9BQU8sS0FBSyxJQUFJZix3RUFBY0EsR0FBR2UsSUFBSUUsb0JBQW9CTixZQUFZTSxpQkFBaUIsRUFBRUMscUJBQXFCUCxZQUFZTyxrQkFBa0IsRUFBRUMsbUJBQW1CUixZQUFZUSxnQkFBZ0IsRUFBRUMsS0FBS1QsWUFBWVUsc0JBQXNCLEVBQUVBLHlCQUF5QkQsT0FBTyxLQUFLLElBQUksUUFBUUEsSUFBSUUsaUJBQWlCbEMsNkNBQU1BLENBQUN1QixhQUFhO1FBQUM7UUFBTztRQUFTO1FBQVM7UUFBcUI7UUFBc0I7UUFBb0I7S0FBeUI7SUFDdmYsSUFBSVksV0FBV0MsT0FBTyxLQUFLLE9BQU87UUFDOUIsNEVBQTRFO1FBQzVFLDhDQUE4QztRQUM5QzFCLDhEQUFZQSxDQUFDZ0Isa0JBQWtCTjtJQUNuQztJQUNBLElBQUlpQixhQUFhO1FBQ2JDLE1BQU07WUFBRVQsbUJBQW1CQTtZQUFtQkMsb0JBQW9CQTtRQUFtQjtRQUNyRlMsU0FBU0wsZUFBZU0sWUFBWTtRQUNwQ0Ms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R0FBRzZELEdBQUcsQ0FBQztnQkFDaEYsSUFBSUQsVUFBVSxRQUFRLHFCQUFxQkUsSUFBSSxDQUFDRixRQUFRO29CQUNwRCxPQUFPNUUsaUZBQWlCQSxDQUFDMEUsVUFBVUo7Z0JBQ3ZDLE9BQ0s7b0JBQ0QsT0FBT3JFLHlGQUF5QkEsQ0FBQ2tDLFdBQVd1QyxVQUFVRCxJQUFJLENBQUNIO2dCQUMvRDtZQUNKLEdBQ0tHLElBQUksQ0FBQztnQkFDTnRCLGFBQWE0QjtnQkFDYlgsU0FBU1ksUUFBUTtZQUNyQixHQUNLQyxLQUFLLENBQUMsU0FBVUMsR0FBRztnQkFDcEIvQixhQUFhNEI7Z0JBQ2JoRiwyRUFBV0EsQ0FBQ21GLEtBQUtkO1lBQ3JCO1lBQ0EsT0FBTztnQkFDSCxxQ0FBcUM7Z0JBQ3JDLG9FQUFvRTtnQkFDcEUsSUFBSWpCLFlBQ0FBLFdBQVdnQyxLQUFLO1lBQ3hCO1FBQ0o7SUFDSjtBQUNKLEVBQUUsQ0FDRiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvaHR0cC9jcmVhdGVIdHRwTGluay5qcz82YzMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQXBvbGxvTGluayB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBoYXNEaXJlY3RpdmVzIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIgfSBmcm9tIFwiLi9zZXJpYWxpemVGZXRjaFBhcmFtZXRlci5qc1wiO1xuaW1wb3J0IHsgc2VsZWN0VVJJIH0gZnJvbSBcIi4vc2VsZWN0VVJJLmpzXCI7XG5pbXBvcnQgeyBoYW5kbGVFcnJvciwgcmVhZE11bHRpcGFydEJvZHksIHBhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2UsIH0gZnJvbSBcIi4vcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgY2hlY2tGZXRjaGVyIH0gZnJvbSBcIi4vY2hlY2tGZXRjaGVyLmpzXCI7XG5pbXBvcnQgeyBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbCwgZGVmYXVsdFByaW50ZXIsIGZhbGxiYWNrSHR0cENvbmZpZywgfSBmcm9tIFwiLi9zZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkuanNcIjtcbmltcG9ydCB7IHJld3JpdGVVUklGb3JHRVQgfSBmcm9tIFwiLi9yZXdyaXRlVVJJRm9yR0VULmpzXCI7XG5pbXBvcnQgeyBmcm9tRXJyb3IsIGZpbHRlck9wZXJhdGlvblZhcmlhYmxlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbWF5YmUsIGdldE1haW5EZWZpbml0aW9uLCByZW1vdmVDbGllbnRTZXRzRnJvbURvY3VtZW50LCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbnZhciBiYWNrdXBGZXRjaCA9IG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoOyB9KTtcbmV4cG9ydCB2YXIgY3JlYXRlSHR0cExpbmsgPSBmdW5jdGlvbiAobGlua09wdGlvbnMpIHtcbiAgICBpZiAobGlua09wdGlvbnMgPT09IHZvaWQgMCkgeyBsaW5rT3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gbGlua09wdGlvbnMudXJpLCB1cmkgPSBfYSA9PT0gdm9pZCAwID8gXCIvZ3JhcGhxbFwiIDogX2EsIFxuICAgIC8vIHVzZSBkZWZhdWx0IGdsb2JhbCBmZXRjaCBpZiBub3RoaW5nIHBhc3NlZCBpblxuICAgIHByZWZlcnJlZEZldGNoID0gbGlua09wdGlvbnMuZmV0Y2gsIF9iID0gbGlua09wdGlvbnMucHJpbnQsIHByaW50ID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRQcmludGVyIDogX2IsIGluY2x1ZGVFeHRlbnNpb25zID0gbGlua09wdGlvbnMuaW5jbHVkZUV4dGVuc2lvbnMsIHByZXNlcnZlSGVhZGVyQ2FzZSA9IGxpbmtPcHRpb25zLnByZXNlcnZlSGVhZGVyQ2FzZSwgdXNlR0VURm9yUXVlcmllcyA9IGxpbmtPcHRpb25zLnVzZUdFVEZvclF1ZXJpZXMsIF9jID0gbGlua09wdGlvbnMuaW5jbHVkZVVudXNlZFZhcmlhYmxlcywgaW5jbHVkZVVudXNlZFZhcmlhYmxlcyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByZXF1ZXN0T3B0aW9ucyA9IF9fcmVzdChsaW5rT3B0aW9ucywgW1widXJpXCIsIFwiZmV0Y2hcIiwgXCJwcmludFwiLCBcImluY2x1ZGVFeHRlbnNpb25zXCIsIFwicHJlc2VydmVIZWFkZXJDYXNlXCIsIFwidXNlR0VURm9yUXVlcmllc1wiLCBcImluY2x1ZGVVbnVzZWRWYXJpYWJsZXNcIl0pO1xuICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgb2YgcHJlZmVycmVkRmV0Y2gsIHdpbmRvdy5mZXRjaCwgb3IgYmFja3VwRmV0Y2ggaXNcbiAgICAgICAgLy8gZGVmaW5lZCwgc28gcmVxdWVzdHMgd29uJ3QgZmFpbCBhdCBydW50aW1lLlxuICAgICAgICBjaGVja0ZldGNoZXIocHJlZmVycmVkRmV0Y2ggfHwgYmFja3VwRmV0Y2gpO1xuICAgIH1cbiAgICB2YXIgbGlua0NvbmZpZyA9IHtcbiAgICAgICAgaHR0cDogeyBpbmNsdWRlRXh0ZW5zaW9uczogaW5jbHVkZUV4dGVuc2lvbnMsIHByZXNlcnZlSGVhZGVyQ2FzZTogcHJlc2VydmVIZWFkZXJDYXNlIH0sXG4gICAgICAgIG9wdGlvbnM6IHJlcXVlc3RPcHRpb25zLmZldGNoT3B0aW9ucyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3RPcHRpb25zLmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGNob3NlblVSSSA9IHNlbGVjdFVSSShvcGVyYXRpb24sIHVyaSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gb3BlcmF0aW9uLmdldENvbnRleHQoKTtcbiAgICAgICAgLy8gYGFwb2xsb2dyYXBocWwtY2xpZW50LSpgIGhlYWRlcnMgYXJlIGF1dG9tYXRpY2FsbHkgc2V0IGlmIGFcbiAgICAgICAgLy8gYGNsaWVudEF3YXJlbmVzc2Agb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBjb250ZXh0LiBUaGVzZSBoZWFkZXJzIGFyZVxuICAgICAgICAvLyBzZXQgZmlyc3QsIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mIHRoZSBoZWFkZXJzIHB1bGxlZCBmcm9tXG4gICAgICAgIC8vIGBjb250ZXh0LmhlYWRlcnNgLiBJZiBkZXNpcmVkLCBgYXBvbGxvZ3JhcGhxbC1jbGllbnQtKmAgaGVhZGVycyBzZXQgYnlcbiAgICAgICAgLy8gdGhlIGBjbGllbnRBd2FyZW5lc3NgIG9iamVjdCBjYW4gYmUgb3ZlcnJpZGRlbiBieVxuICAgICAgICAvLyBgYXBvbGxvZ3JhcGhxbC1jbGllbnQtKmAgaGVhZGVycyBzZXQgaW4gYGNvbnRleHQuaGVhZGVyc2AuXG4gICAgICAgIHZhciBjbGllbnRBd2FyZW5lc3NIZWFkZXJzID0ge307XG4gICAgICAgIGlmIChjb250ZXh0LmNsaWVudEF3YXJlbmVzcykge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udGV4dC5jbGllbnRBd2FyZW5lc3MsIG5hbWVfMSA9IF9hLm5hbWUsIHZlcnNpb24gPSBfYS52ZXJzaW9uO1xuICAgICAgICAgICAgaWYgKG5hbWVfMSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEF3YXJlbmVzc0hlYWRlcnNbXCJhcG9sbG9ncmFwaHFsLWNsaWVudC1uYW1lXCJdID0gbmFtZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBd2FyZW5lc3NIZWFkZXJzW1wiYXBvbGxvZ3JhcGhxbC1jbGllbnQtdmVyc2lvblwiXSA9IHZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHRIZWFkZXJzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNsaWVudEF3YXJlbmVzc0hlYWRlcnMpLCBjb250ZXh0LmhlYWRlcnMpO1xuICAgICAgICB2YXIgY29udGV4dENvbmZpZyA9IHtcbiAgICAgICAgICAgIGh0dHA6IGNvbnRleHQuaHR0cCxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNvbnRleHQuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IGNvbnRleHQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgICBoZWFkZXJzOiBjb250ZXh0SGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMoW1wiY2xpZW50XCJdLCBvcGVyYXRpb24ucXVlcnkpKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRRdWVyeSA9IHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQob3BlcmF0aW9uLnF1ZXJ5KTtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWRRdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IobmV3IEVycm9yKFwiSHR0cExpbms6IFRyeWluZyB0byBzZW5kIGEgY2xpZW50LW9ubHkgcXVlcnkgdG8gdGhlIHNlcnZlci4gVG8gc2VuZCB0byB0aGUgc2VydmVyLCBlbnN1cmUgYSBub24tY2xpZW50IGZpZWxkIGlzIGFkZGVkIHRvIHRoZSBxdWVyeSBvciBzZXQgdGhlIGB0cmFuc2Zvcm1PcHRpb25zLnJlbW92ZUNsaWVudEZpZWxkc2Agb3B0aW9uIHRvIGB0cnVlYC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlcmF0aW9uLnF1ZXJ5ID0gdHJhbnNmb3JtZWRRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICAvL3VzZXMgZmFsbGJhY2ssIGxpbmssIGFuZCB0aGVuIGNvbnRleHQgdG8gYnVpbGQgb3B0aW9uc1xuICAgICAgICB2YXIgX2IgPSBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbChvcGVyYXRpb24sIHByaW50LCBmYWxsYmFja0h0dHBDb25maWcsIGxpbmtDb25maWcsIGNvbnRleHRDb25maWcpLCBvcHRpb25zID0gX2Iub3B0aW9ucywgYm9keSA9IF9iLmJvZHk7XG4gICAgICAgIGlmIChib2R5LnZhcmlhYmxlcyAmJiAhaW5jbHVkZVVudXNlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgYm9keS52YXJpYWJsZXMgPSBmaWx0ZXJPcGVyYXRpb25WYXJpYWJsZXMoYm9keS52YXJpYWJsZXMsIG9wZXJhdGlvbi5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRyb2xsZXI7XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWduYWwgJiYgdHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmVxdWVzdGVkLCBzZXQgbWV0aG9kIHRvIEdFVCBpZiB0aGVyZSBhcmUgbm8gbXV0YXRpb25zLlxuICAgICAgICB2YXIgZGVmaW5pdGlvbklzTXV0YXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCIgJiYgZC5vcGVyYXRpb24gPT09IFwibXV0YXRpb25cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZmluaXRpb25Jc1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIiAmJiBkLm9wZXJhdGlvbiA9PT0gXCJzdWJzY3JpcHRpb25cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzU3Vic2NyaXB0aW9uID0gZGVmaW5pdGlvbklzU3Vic2NyaXB0aW9uKGdldE1haW5EZWZpbml0aW9uKG9wZXJhdGlvbi5xdWVyeSkpO1xuICAgICAgICAvLyBkb2VzIG5vdCBtYXRjaCBjdXN0b20gZGlyZWN0aXZlcyBiZWdpbm5pbmcgd2l0aCBAZGVmZXJcbiAgICAgICAgdmFyIGhhc0RlZmVyID0gaGFzRGlyZWN0aXZlcyhbXCJkZWZlclwiXSwgb3BlcmF0aW9uLnF1ZXJ5KTtcbiAgICAgICAgaWYgKHVzZUdFVEZvclF1ZXJpZXMgJiZcbiAgICAgICAgICAgICFvcGVyYXRpb24ucXVlcnkuZGVmaW5pdGlvbnMuc29tZShkZWZpbml0aW9uSXNNdXRhdGlvbikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmZXIgfHwgaXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBhY2NlcHRIZWFkZXIgPSBcIm11bHRpcGFydC9taXhlZDtcIjtcbiAgICAgICAgICAgIC8vIE9taXQgZGVmZXItc3BlY2lmaWMgaGVhZGVycyBpZiB0aGUgdXNlciBhdHRlbXB0cyB0byBkZWZlciBhIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gc2V0IG9uIGEgc3Vic2NyaXB0aW9uIGFuZCBsb2cgYSB3YXJuaW5nLlxuICAgICAgICAgICAgaWYgKGlzU3Vic2NyaXB0aW9uICYmIGhhc0RlZmVyKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2FybigzOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhY2NlcHRIZWFkZXIgKz1cbiAgICAgICAgICAgICAgICAgICAgXCJib3VuZGFyeT1ncmFwaHFsO3N1YnNjcmlwdGlvblNwZWM9MS4wLGFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0RlZmVyKSB7XG4gICAgICAgICAgICAgICAgYWNjZXB0SGVhZGVyICs9IFwiZGVmZXJTcGVjPTIwMjIwODI0LGFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5hY2NlcHQgPSBhY2NlcHRIZWFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSByZXdyaXRlVVJJRm9yR0VUKGNob3NlblVSSSwgYm9keSksIG5ld1VSSSA9IF9jLm5ld1VSSSwgcGFyc2VFcnJvciA9IF9jLnBhcnNlRXJyb3I7XG4gICAgICAgICAgICBpZiAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IocGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaG9zZW5VUkkgPSBuZXdVUkk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHksIFwiUGF5bG9hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21FcnJvcihwYXJzZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgbGlua09wdGlvbnMuZmV0Y2ggKHByZWZlcnJlZEZldGNoKSBpZiBwcm92aWRlZCwgYW5kIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSAqY3VycmVudCogZ2xvYmFsIHdpbmRvdy5mZXRjaCBmdW5jdGlvbiAoc2VlIGlzc3VlXG4gICAgICAgICAgICAvLyAjNzgzMiksIG9yIChpZiBhbGwgZWxzZSBmYWlscykgdGhlIGJhY2t1cEZldGNoIGZ1bmN0aW9uIHdlIHNhdmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRoaXMgbW9kdWxlIHdhcyBmaXJzdCBldmFsdWF0ZWQuIFRoaXMgbGFzdCBvcHRpb24gcHJvdGVjdHMgYWdhaW5zdCB0aGVcbiAgICAgICAgICAgIC8vIHJlbW92YWwgb2Ygd2luZG93LmZldGNoLCB3aGljaCBpcyB1bmxpa2VseSBidXQgbm90IGltcG9zc2libGUuXG4gICAgICAgICAgICB2YXIgY3VycmVudEZldGNoID0gcHJlZmVycmVkRmV0Y2ggfHwgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2g7IH0pIHx8IGJhY2t1cEZldGNoO1xuICAgICAgICAgICAgdmFyIG9ic2VydmVyTmV4dCA9IG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlcik7XG4gICAgICAgICAgICBjdXJyZW50RmV0Y2goY2hvc2VuVVJJLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uc2V0Q29udGV4dCh7IHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY3R5cGUgPSAoX2EgPSByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjdHlwZSAhPT0gbnVsbCAmJiAvXm11bHRpcGFydFxcL21peGVkL2kudGVzdChjdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRNdWx0aXBhcnRCb2R5KHJlc3BvbnNlLCBvYnNlcnZlck5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2Uob3BlcmF0aW9uKShyZXNwb25zZSkudGhlbihvYnNlcnZlck5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFhYWCBzdXBwb3J0IGNhbmNlbGluZyB0aGlzIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzA5L2Fib3J0YWJsZS1mZXRjaFxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyKVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVIdHRwTGluay5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX3Jlc3QiLCJpbnZhcmlhbnQiLCJBcG9sbG9MaW5rIiwiT2JzZXJ2YWJsZSIsImhhc0RpcmVjdGl2ZXMiLCJzZXJpYWxpemVGZXRjaFBhcmFtZXRlciIsInNlbGVjdFVSSSIsImhhbmRsZUVycm9yIiwicmVhZE11bHRpcGFydEJvZHkiLCJwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlIiwiY2hlY2tGZXRjaGVyIiwic2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5SW50ZXJuYWwiLCJkZWZhdWx0UHJpbnRlciIsImZhbGxiYWNrSHR0cENvbmZpZyIsInJld3JpdGVVUklGb3JHRVQiLCJmcm9tRXJyb3IiLCJmaWx0ZXJPcGVyYXRpb25WYXJpYWJsZXMiLCJtYXliZSIsImdldE1haW5EZWZpbml0aW9uIiwicmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCIsImJhY2t1cEZldGNoIiwiZmV0Y2giLCJjcmVhdGVIdHRwTGluayIsImxpbmtPcHRpb25zIiwiX2EiLCJ1cmkiLCJwcmVmZXJyZWRGZXRjaCIsIl9iIiwicHJpbnQiLCJpbmNsdWRlRXh0ZW5zaW9ucyIsInByZXNlcnZlSGVhZGVyQ2FzZSIsInVzZUdFVEZvclF1ZXJpZXMiLCJfYyIsImluY2x1ZGVVbnVzZWRWYXJpYWJsZXMiLCJyZXF1ZXN0T3B0aW9ucyIsImdsb2JhbFRoaXMiLCJfX0RFVl9fIiwibGlua0NvbmZpZyIsImh0dHAiLCJvcHRpb25zIiwiZmV0Y2hPcHRpb25zIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwib3BlcmF0aW9uIiwiY2hvc2VuVVJJIiwiY29udGV4dCIsImdldENvbnRleHQiLCJjbGllbnRBd2FyZW5lc3NIZWFkZXJzIiwiY2xpZW50QXdhcmVuZXNzIiwibmFtZV8xIiwibmFtZSIsInZlcnNpb24iLCJjb250ZXh0SGVhZGVycyIsImNvbnRleHRDb25maWciLCJxdWVyeSIsInRyYW5zZm9ybWVkUXVlcnkiLCJFcnJvciIsImJvZHkiLCJ2YXJpYWJsZXMiLCJjb250cm9sbGVyIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiZGVmaW5pdGlvbklzTXV0YXRpb24iLCJkIiwia2luZCIsImRlZmluaXRpb25Jc1N1YnNjcmlwdGlvbiIsImlzU3Vic2NyaXB0aW9uIiwiaGFzRGVmZXIiLCJkZWZpbml0aW9ucyIsInNvbWUiLCJtZXRob2QiLCJhY2NlcHRIZWFkZXIiLCJ3YXJuIiwiYWNjZXB0IiwibmV3VVJJIiwicGFyc2VFcnJvciIsIm9ic2VydmVyIiwiY3VycmVudEZldGNoIiwib2JzZXJ2ZXJOZXh0IiwibmV4dCIsImJpbmQiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRDb250ZXh0IiwiY3R5cGUiLCJnZXQiLCJ0ZXN0IiwidW5kZWZpbmVkIiwiY29tcGxldGUiLCJjYXRjaCIsImVyciIsImFib3J0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/createHttpLink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/async.js":
/*!******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/iterators/async.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ asyncIterator; }\n/* harmony export */ });\n/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */ function asyncIterator(source) {\n    var _a;\n    var iterator = source[Symbol.asyncIterator]();\n    return _a = {\n        next: function() {\n            return iterator.next();\n        }\n    }, _a[Symbol.asyncIterator] = function() {\n        return this;\n    }, _a;\n} //# sourceMappingURL=async.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL2FzeW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDYyxTQUFTQSxjQUFjQyxNQUFNO0lBQ3hDLElBQUlDO0lBQ0osSUFBSUMsV0FBV0YsTUFBTSxDQUFDRyxPQUFPSixhQUFhLENBQUM7SUFDM0MsT0FBT0UsS0FBSztRQUNKRyxNQUFNO1lBQ0YsT0FBT0YsU0FBU0UsSUFBSTtRQUN4QjtJQUNKLEdBQ0FILEVBQUUsQ0FBQ0UsT0FBT0osYUFBYSxDQUFDLEdBQUc7UUFDdkIsT0FBTyxJQUFJO0lBQ2YsR0FDQUU7QUFDUixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL2l0ZXJhdG9ycy9hc3luYy5qcz84MzZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT3JpZ2luYWwgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ttYWxha29mZi9yZXNwb25zZS1pdGVyYXRvci9ibG9iL21hc3Rlci9zcmMvaXRlcmF0b3JzL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzeW5jSXRlcmF0b3Ioc291cmNlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBpdGVyYXRvciA9IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICByZXR1cm4gX2EgPSB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9hO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMuanMubWFwIl0sIm5hbWVzIjpbImFzeW5jSXRlcmF0b3IiLCJzb3VyY2UiLCJfYSIsIml0ZXJhdG9yIiwiU3ltYm9sIiwibmV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/async.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/nodeStream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/iterators/nodeStream.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ nodeStreamIterator; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */ \nfunction nodeStreamIterator(stream) {\n    var cleanup = null;\n    var error = null;\n    var done = false;\n    var data = [];\n    var waiting = [];\n    function onData(chunk) {\n        if (error) return;\n        if (waiting.length) {\n            var shiftedArr = waiting.shift();\n            if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n                return shiftedArr[0]({\n                    value: chunk,\n                    done: false\n                });\n            }\n        }\n        data.push(chunk);\n    }\n    function onError(err) {\n        error = err;\n        var all = waiting.slice();\n        all.forEach(function(pair) {\n            pair[1](err);\n        });\n        !cleanup || cleanup();\n    }\n    function onEnd() {\n        done = true;\n        var all = waiting.slice();\n        all.forEach(function(pair) {\n            pair[0]({\n                value: undefined,\n                done: true\n            });\n        });\n        !cleanup || cleanup();\n    }\n    cleanup = function() {\n        cleanup = null;\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"error\", onError);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"finish\", onEnd);\n        stream.removeListener(\"close\", onEnd);\n    };\n    stream.on(\"data\", onData);\n    stream.on(\"error\", onError);\n    stream.on(\"end\", onEnd);\n    stream.on(\"finish\", onEnd);\n    stream.on(\"close\", onEnd);\n    function getNext() {\n        return new Promise(function(resolve, reject) {\n            if (error) return reject(error);\n            if (data.length) return resolve({\n                value: data.shift(),\n                done: false\n            });\n            if (done) return resolve({\n                value: undefined,\n                done: true\n            });\n            waiting.push([\n                resolve,\n                reject\n            ]);\n        });\n    }\n    var iterator = {\n        next: function() {\n            return getNext();\n        }\n    };\n    if (_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n} //# sourceMappingURL=nodeStream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL25vZGVTdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FDdUU7QUFDekQsU0FBU0MsbUJBQW1CQyxNQUFNO0lBQzdDLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxRQUFRO0lBQ1osSUFBSUMsT0FBTztJQUNYLElBQUlDLE9BQU8sRUFBRTtJQUNiLElBQUlDLFVBQVUsRUFBRTtJQUNoQixTQUFTQyxPQUFPQyxLQUFLO1FBQ2pCLElBQUlMLE9BQ0E7UUFDSixJQUFJRyxRQUFRRyxNQUFNLEVBQUU7WUFDaEIsSUFBSUMsYUFBYUosUUFBUUssS0FBSztZQUM5QixJQUFJQyxNQUFNQyxPQUFPLENBQUNILGVBQWVBLFVBQVUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzVDLE9BQU9BLFVBQVUsQ0FBQyxFQUFFLENBQUM7b0JBQUVJLE9BQU9OO29CQUFPSixNQUFNO2dCQUFNO1lBQ3JEO1FBQ0o7UUFDQUMsS0FBS1UsSUFBSSxDQUFDUDtJQUNkO0lBQ0EsU0FBU1EsUUFBUUMsR0FBRztRQUNoQmQsUUFBUWM7UUFDUixJQUFJQyxNQUFNWixRQUFRYSxLQUFLO1FBQ3ZCRCxJQUFJRSxPQUFPLENBQUMsU0FBVUMsSUFBSTtZQUN0QkEsSUFBSSxDQUFDLEVBQUUsQ0FBQ0o7UUFDWjtRQUNBLENBQUNmLFdBQVdBO0lBQ2hCO0lBQ0EsU0FBU29CO1FBQ0xsQixPQUFPO1FBQ1AsSUFBSWMsTUFBTVosUUFBUWEsS0FBSztRQUN2QkQsSUFBSUUsT0FBTyxDQUFDLFNBQVVDLElBQUk7WUFDdEJBLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQUVQLE9BQU9TO2dCQUFXbkIsTUFBTTtZQUFLO1FBQzNDO1FBQ0EsQ0FBQ0YsV0FBV0E7SUFDaEI7SUFDQUEsVUFBVTtRQUNOQSxVQUFVO1FBQ1ZELE9BQU91QixjQUFjLENBQUMsUUFBUWpCO1FBQzlCTixPQUFPdUIsY0FBYyxDQUFDLFNBQVNSO1FBQy9CZixPQUFPdUIsY0FBYyxDQUFDLE9BQU9GO1FBQzdCckIsT0FBT3VCLGNBQWMsQ0FBQyxVQUFVRjtRQUNoQ3JCLE9BQU91QixjQUFjLENBQUMsU0FBU0Y7SUFDbkM7SUFDQXJCLE9BQU93QixFQUFFLENBQUMsUUFBUWxCO0lBQ2xCTixPQUFPd0IsRUFBRSxDQUFDLFNBQVNUO0lBQ25CZixPQUFPd0IsRUFBRSxDQUFDLE9BQU9IO0lBQ2pCckIsT0FBT3dCLEVBQUUsQ0FBQyxVQUFVSDtJQUNwQnJCLE9BQU93QixFQUFFLENBQUMsU0FBU0g7SUFDbkIsU0FBU0k7UUFDTCxPQUFPLElBQUlDLFFBQVEsU0FBVUMsT0FBTyxFQUFFQyxNQUFNO1lBQ3hDLElBQUkxQixPQUNBLE9BQU8wQixPQUFPMUI7WUFDbEIsSUFBSUUsS0FBS0ksTUFBTSxFQUNYLE9BQU9tQixRQUFRO2dCQUFFZCxPQUFPVCxLQUFLTSxLQUFLO2dCQUFJUCxNQUFNO1lBQU07WUFDdEQsSUFBSUEsTUFDQSxPQUFPd0IsUUFBUTtnQkFBRWQsT0FBT1M7Z0JBQVduQixNQUFNO1lBQUs7WUFDbERFLFFBQVFTLElBQUksQ0FBQztnQkFBQ2E7Z0JBQVNDO2FBQU87UUFDbEM7SUFDSjtJQUNBLElBQUlDLFdBQVc7UUFDWEMsTUFBTTtZQUNGLE9BQU9MO1FBQ1g7SUFDSjtJQUNBLElBQUkzQiwwRUFBeUJBLEVBQUU7UUFDM0IrQixRQUFRLENBQUNFLE9BQU9DLGFBQWEsQ0FBQyxHQUFHO1lBQzdCLE9BQU8sSUFBSTtRQUNmO0lBQ0o7SUFDQSxPQUFPSDtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL25vZGVTdHJlYW0uanM/MjcyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9yaWdpbmFsIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rbWFsYWtvZmYvcmVzcG9uc2UtaXRlcmF0b3IvYmxvYi9tYXN0ZXIvc3JjL2l0ZXJhdG9ycy9ub2RlU3RyZWFtLnRzXG4gKi9cbmltcG9ydCB7IGNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2RlU3RyZWFtSXRlcmF0b3Ioc3RyZWFtKSB7XG4gICAgdmFyIGNsZWFudXAgPSBudWxsO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciB3YWl0aW5nID0gW107XG4gICAgZnVuY3Rpb24gb25EYXRhKGNodW5rKSB7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2hpZnRlZEFyciA9IHdhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNoaWZ0ZWRBcnIpICYmIHNoaWZ0ZWRBcnJbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRlZEFyclswXSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIHZhciBhbGwgPSB3YWl0aW5nLnNsaWNlKCk7XG4gICAgICAgIGFsbC5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBwYWlyWzFdKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICAhY2xlYW51cCB8fCBjbGVhbnVwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIGFsbCA9IHdhaXRpbmcuc2xpY2UoKTtcbiAgICAgICAgYWxsLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgIHBhaXJbMF0oeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgIWNsZWFudXAgfHwgY2xlYW51cCgpO1xuICAgIH1cbiAgICBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhbnVwID0gbnVsbDtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsIG9uRW5kKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25FbmQpO1xuICAgIH07XG4gICAgc3RyZWFtLm9uKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgIHN0cmVhbS5vbihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgIHN0cmVhbS5vbihcImVuZFwiLCBvbkVuZCk7XG4gICAgc3RyZWFtLm9uKFwiZmluaXNoXCIsIG9uRW5kKTtcbiAgICBzdHJlYW0ub24oXCJjbG9zZVwiLCBvbkVuZCk7XG4gICAgZnVuY3Rpb24gZ2V0TmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHZhbHVlOiBkYXRhLnNoaWZ0KCksIGRvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2FpdGluZy5wdXNoKFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5leHQoKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sKSB7XG4gICAgICAgIGl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlU3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6WyJjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sIiwibm9kZVN0cmVhbUl0ZXJhdG9yIiwic3RyZWFtIiwiY2xlYW51cCIsImVycm9yIiwiZG9uZSIsImRhdGEiLCJ3YWl0aW5nIiwib25EYXRhIiwiY2h1bmsiLCJsZW5ndGgiLCJzaGlmdGVkQXJyIiwic2hpZnQiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWx1ZSIsInB1c2giLCJvbkVycm9yIiwiZXJyIiwiYWxsIiwic2xpY2UiLCJmb3JFYWNoIiwicGFpciIsIm9uRW5kIiwidW5kZWZpbmVkIiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsImdldE5leHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIml0ZXJhdG9yIiwibmV4dCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/nodeStream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/promise.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/iterators/promise.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ promiseIterator; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */ \nfunction promiseIterator(promise) {\n    var resolved = false;\n    var iterator = {\n        next: function() {\n            if (resolved) return Promise.resolve({\n                value: undefined,\n                done: true\n            });\n            resolved = true;\n            return new Promise(function(resolve, reject) {\n                promise.then(function(value) {\n                    resolve({\n                        value: value,\n                        done: false\n                    });\n                }).catch(reject);\n            });\n        }\n    };\n    if (_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n} //# sourceMappingURL=promise.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL3Byb21pc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FDdUU7QUFDekQsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzNDLElBQUlDLFdBQVc7SUFDZixJQUFJQyxXQUFXO1FBQ1hDLE1BQU07WUFDRixJQUFJRixVQUNBLE9BQU9HLFFBQVFDLE9BQU8sQ0FBQztnQkFDbkJDLE9BQU9DO2dCQUNQQyxNQUFNO1lBQ1Y7WUFDSlAsV0FBVztZQUNYLE9BQU8sSUFBSUcsUUFBUSxTQUFVQyxPQUFPLEVBQUVJLE1BQU07Z0JBQ3hDVCxRQUNLVSxJQUFJLENBQUMsU0FBVUosS0FBSztvQkFDckJELFFBQVE7d0JBQUVDLE9BQU9BO3dCQUFPRSxNQUFNO29CQUFNO2dCQUN4QyxHQUNLRyxLQUFLLENBQUNGO1lBQ2Y7UUFDSjtJQUNKO0lBQ0EsSUFBSVgsMEVBQXlCQSxFQUFFO1FBQzNCSSxRQUFRLENBQUNVLE9BQU9DLGFBQWEsQ0FBQyxHQUFHO1lBQzdCLE9BQU8sSUFBSTtRQUNmO0lBQ0o7SUFDQSxPQUFPWDtBQUNYLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL3Byb21pc2UuanM/MDk3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9yaWdpbmFsIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rbWFsYWtvZmYvcmVzcG9uc2UtaXRlcmF0b3IvYmxvYi9tYXN0ZXIvc3JjL2l0ZXJhdG9ycy9wcm9taXNlLnRzXG4gKi9cbmltcG9ydCB7IGNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9taXNlSXRlcmF0b3IocHJvbWlzZSkge1xuICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHZhbHVlLCBkb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wpIHtcbiAgICAgICAgaXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbImNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wiLCJwcm9taXNlSXRlcmF0b3IiLCJwcm9taXNlIiwicmVzb2x2ZWQiLCJpdGVyYXRvciIsIm5leHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInZhbHVlIiwidW5kZWZpbmVkIiwiZG9uZSIsInJlamVjdCIsInRoZW4iLCJjYXRjaCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/promise.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/reader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/iterators/reader.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ readerIterator; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */ \nfunction readerIterator(reader) {\n    var iterator = {\n        next: function() {\n            return reader.read();\n        }\n    };\n    if (_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n} //# sourceMappingURL=reader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvaXRlcmF0b3JzL3JlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUN1RTtBQUN6RCxTQUFTQyxlQUFlQyxNQUFNO0lBQ3pDLElBQUlDLFdBQVc7UUFDWEMsTUFBTTtZQUNGLE9BQU9GLE9BQU9HLElBQUk7UUFDdEI7SUFDSjtJQUNBLElBQUlMLDBFQUF5QkEsRUFBRTtRQUMzQkcsUUFBUSxDQUFDRyxPQUFPQyxhQUFhLENBQUMsR0FBRztZQUM3QixPQUFPLElBQUk7UUFDZjtJQUNKO0lBQ0EsT0FBT0o7QUFDWCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL2l0ZXJhdG9ycy9yZWFkZXIuanM/OGUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9yaWdpbmFsIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rbWFsYWtvZmYvcmVzcG9uc2UtaXRlcmF0b3IvYmxvYi9tYXN0ZXIvc3JjL2l0ZXJhdG9ycy9yZWFkZXIudHNcbiAqL1xuaW1wb3J0IHsgY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCB9IGZyb20gXCIuLi8uLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWRlckl0ZXJhdG9yKHJlYWRlcikge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCkge1xuICAgICAgICBpdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sIiwicmVhZGVySXRlcmF0b3IiLCJyZWFkZXIiLCJpdGVyYXRvciIsIm5leHQiLCJyZWFkIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/reader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleError: function() { return /* binding */ handleError; },\n/* harmony export */   parseAndCheckHttpResponse: function() { return /* binding */ parseAndCheckHttpResponse; },\n/* harmony export */   parseHeaders: function() { return /* binding */ parseHeaders; },\n/* harmony export */   parseJsonBody: function() { return /* binding */ parseJsonBody; },\n/* harmony export */   readMultipartBody: function() { return /* binding */ readMultipartBody; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _responseIterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./responseIterator.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/responseIterator.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/utils/throwServerError.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\");\n/* harmony import */ var _utilities_common_incrementalResult_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/common/incrementalResult.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js\");\n\n\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction readMultipartBody(response, nextValue) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function() {\n        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n        var _b, _c;\n        var _d;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    if (TextDecoder === undefined) {\n                        throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n                    }\n                    decoder = new TextDecoder(\"utf-8\");\n                    contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get(\"content-type\");\n                    delimiter = \"boundary=\";\n                    boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n                    boundary = \"\\r\\n--\".concat(boundaryVal);\n                    buffer = \"\";\n                    iterator = (0,_responseIterator_js__WEBPACK_IMPORTED_MODULE_1__.responseIterator)(response);\n                    running = true;\n                    _e.label = 1;\n                case 1:\n                    if (!running) return [\n                        3 /*break*/ ,\n                        3\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        iterator.next()\n                    ];\n                case 2:\n                    _a = _e.sent(), value = _a.value, done = _a.done;\n                    chunk = typeof value === \"string\" ? value : decoder.decode(value);\n                    searchFrom = buffer.length - boundary.length + 1;\n                    running = !done;\n                    buffer += chunk;\n                    bi = buffer.indexOf(boundary, searchFrom);\n                    while(bi > -1){\n                        message = void 0;\n                        _b = [\n                            buffer.slice(0, bi),\n                            buffer.slice(bi + boundary.length)\n                        ], message = _b[0], buffer = _b[1];\n                        i = message.indexOf(\"\\r\\n\\r\\n\");\n                        headers = parseHeaders(message.slice(0, i));\n                        contentType_1 = headers[\"content-type\"];\n                        if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n                            throw new Error(\"Unsupported patch content type: application/json is required.\");\n                        }\n                        body = message.slice(i);\n                        if (body) {\n                            result = parseJsonBody(response, body);\n                            if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                                if ((0,_utilities_common_incrementalResult_js__WEBPACK_IMPORTED_MODULE_2__.isApolloPayloadResult)(result)) {\n                                    next = {};\n                                    if (\"payload\" in result) {\n                                        if (Object.keys(result).length === 1 && result.payload === null) {\n                                            return [\n                                                2 /*return*/ \n                                            ];\n                                        }\n                                        next = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, result.payload);\n                                    }\n                                    if (\"errors\" in result) {\n                                        next = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, next), {\n                                            extensions: (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, \"extensions\" in next ? next.extensions : null), (_c = {}, _c[_errors_index_js__WEBPACK_IMPORTED_MODULE_3__.PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))\n                                        });\n                                    }\n                                    nextValue(next);\n                                } else {\n                                    // for the last chunk with only `hasNext: false`\n                                    // we don't need to call observer.next as there is no data/errors\n                                    nextValue(result);\n                                }\n                            } else if (// If the chunk contains only a \"hasNext: false\", we can call\n                            // observer.complete() immediately.\n                            Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                                return [\n                                    2 /*return*/ \n                                ];\n                            }\n                        }\n                        bi = buffer.indexOf(boundary);\n                    }\n                    return [\n                        3 /*break*/ ,\n                        1\n                    ];\n                case 3:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n}\nfunction parseHeaders(headerText) {\n    var headersInit = {};\n    headerText.split(\"\\n\").forEach(function(line) {\n        var i = line.indexOf(\":\");\n        if (i > -1) {\n            // normalize headers to lowercase\n            var name_1 = line.slice(0, i).trim().toLowerCase();\n            var value = line.slice(i + 1).trim();\n            headersInit[name_1] = value;\n        }\n    });\n    return headersInit;\n}\nfunction parseJsonBody(response, bodyText) {\n    if (response.status >= 300) {\n        // Network error\n        var getResult = function() {\n            try {\n                return JSON.parse(bodyText);\n            } catch (err) {\n                return bodyText;\n            }\n        };\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.throwServerError)(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n    }\n    try {\n        return JSON.parse(bodyText);\n    } catch (err) {\n        var parseError = err;\n        parseError.name = \"ServerParseError\";\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        throw parseError;\n    }\n}\nfunction handleError(err, observer) {\n    // if it is a network error, BUT there is graphql result info fire\n    // the next observer before calling error this gives apollo-client\n    // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n    // pass to UI this should only happen if we *also* have data as\n    // part of the response key per the spec\n    if (err.result && err.result.errors && err.result.data) {\n        // if we don't call next, the UI can only show networkError\n        // because AC didn't get any graphqlErrors this is graphql\n        // execution result info (i.e errors and possibly data) this is\n        // because there is no formal spec how errors should translate to\n        // http status codes. So an auth error (401) could have both data\n        // from a public field, errors from a private field, and a status\n        // of 401\n        // {\n        //  user { // this will have errors\n        //    firstName\n        //  }\n        //  products { // this is public so will have data\n        //    cost\n        //  }\n        // }\n        //\n        // the result of above *could* look like this:\n        // {\n        //   data: { products: [{ cost: \"$10\" }] },\n        //   errors: [{\n        //      message: 'your session has timed out',\n        //      path: []\n        //   }]\n        // }\n        // status code of above would be a 401\n        // in the UI you want to show data where you can, errors as data where you can\n        // and use correct http status codes\n        observer.next(err.result);\n    }\n    observer.error(err);\n}\nfunction parseAndCheckHttpResponse(operations) {\n    return function(response) {\n        return response.text().then(function(bodyText) {\n            return parseJsonBody(response, bodyText);\n        }).then(function(result) {\n            if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n                // Data error\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.throwServerError)(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function(op) {\n                    return op.operationName;\n                }) : operations.operationName, \"'.\"));\n            }\n            return result;\n        });\n    };\n} //# sourceMappingURL=parseAndCheckHttpResponse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0E7QUFDSjtBQUNVO0FBQ3FCO0FBQ3BGLElBQUlPLGlCQUFpQkMsT0FBT0MsU0FBUyxDQUFDRixjQUFjO0FBQzdDLFNBQVNHLGtCQUFrQkMsUUFBUSxFQUFFQyxTQUFTO0lBQ2pELE9BQU9YLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLElBQUlZLFNBQVNDLGFBQWFDLFdBQVdDLGFBQWFDLFVBQVVDLFFBQVFDLFVBQVVDLFNBQVNDLElBQUlDLE9BQU9DLE1BQU1DLE9BQU9DLFlBQVlDLElBQUlDLFNBQVNDLEdBQUdDLFNBQVNDLGVBQWVDLE1BQU1DLFFBQVFDO1FBQ2pMLElBQUlDLElBQUlDO1FBQ1IsSUFBSUM7UUFDSixPQUFPbEMsa0RBQVdBLENBQUMsSUFBSSxFQUFFLFNBQVVtQyxFQUFFO1lBQ2pDLE9BQVFBLEdBQUdDLEtBQUs7Z0JBQ1osS0FBSztvQkFDRCxJQUFJQyxnQkFBZ0JDLFdBQVc7d0JBQzNCLE1BQU0sSUFBSUMsTUFBTTtvQkFDcEI7b0JBQ0E1QixVQUFVLElBQUkwQixZQUFZO29CQUMxQnpCLGNBQWMsQ0FBQ3NCLEtBQUt6QixTQUFTa0IsT0FBTyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR00sR0FBRyxDQUFDO29CQUNsRjNCLFlBQVk7b0JBQ1pDLGNBQWMsQ0FBQ0YsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZNkIsUUFBUSxDQUFDNUIsVUFBUyxJQUNuR0QsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZOEIsU0FBUyxDQUFDLENBQUM5QixnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtB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VXdEO1FBQVcsR0FDckVnQixJQUFJLENBQUMsU0FBVW5ELE1BQU07WUFDdEIsSUFBSSxDQUFDb0QsTUFBTUMsT0FBTyxDQUFDckQsV0FDZixDQUFDekIsZUFBZStFLElBQUksQ0FBQ3RELFFBQVEsV0FDN0IsQ0FBQ3pCLGVBQWUrRSxJQUFJLENBQUN0RCxRQUFRLFdBQVc7Z0JBQ3hDLGFBQWE7Z0JBQ2I1QixpRUFBZ0JBLENBQUNPLFVBQVVxQixRQUFRLDBDQUEwQ2lCLE1BQU0sQ0FBQ21DLE1BQU1DLE9BQU8sQ0FBQ0osY0FDOUZBLFdBQVdNLEdBQUcsQ0FBQyxTQUFVQyxFQUFFO29CQUFJLE9BQU9BLEdBQUdDLGFBQWE7Z0JBQUUsS0FDdERSLFdBQVdRLGFBQWEsRUFBRTtZQUNwQztZQUNBLE9BQU96RDtRQUNYO0lBQ0o7QUFDSixFQUNBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL3BhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2UuanM/MzYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcmVzcG9uc2VJdGVyYXRvciB9IGZyb20gXCIuL3Jlc3BvbnNlSXRlcmF0b3IuanNcIjtcbmltcG9ydCB7IHRocm93U2VydmVyRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBST1RPQ09MX0VSUk9SU19TWU1CT0wgfSBmcm9tIFwiLi4vLi4vZXJyb3JzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc0Fwb2xsb1BheWxvYWRSZXN1bHQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2NvbW1vbi9pbmNyZW1lbnRhbFJlc3VsdC5qc1wiO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiByZWFkTXVsdGlwYXJ0Qm9keShyZXNwb25zZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVjb2RlciwgY29udGVudFR5cGUsIGRlbGltaXRlciwgYm91bmRhcnlWYWwsIGJvdW5kYXJ5LCBidWZmZXIsIGl0ZXJhdG9yLCBydW5uaW5nLCBfYSwgdmFsdWUsIGRvbmUsIGNodW5rLCBzZWFyY2hGcm9tLCBiaSwgbWVzc2FnZSwgaSwgaGVhZGVycywgY29udGVudFR5cGVfMSwgYm9keSwgcmVzdWx0LCBuZXh0O1xuICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICB2YXIgX2Q7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0RGVjb2RlciBtdXN0IGJlIGRlZmluZWQgaW4gdGhlIGVudmlyb25tZW50OiBwbGVhc2UgaW1wb3J0IGEgcG9seWZpbGwuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSAoX2QgPSByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBcImJvdW5kYXJ5PVwiO1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVZhbCA9IChjb250ZW50VHlwZSA9PT0gbnVsbCB8fCBjb250ZW50VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFR5cGUuaW5jbHVkZXMoZGVsaW1pdGVyKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLnN1YnN0cmluZygoY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgKyBkZWxpbWl0ZXIubGVuZ3RoKS5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKS5yZXBsYWNlKC9cXDsoLiopL2dtLCBcIlwiKS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gXCJcXHJcXG4tLVwiLmNvbmNhdChib3VuZGFyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gcmVzcG9uc2VJdGVyYXRvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmcpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBpdGVyYXRvci5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfZS5zZW50KCksIHZhbHVlID0gX2EudmFsdWUsIGRvbmUgPSBfYS5kb25lO1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogZGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hGcm9tID0gYnVmZmVyLmxlbmd0aCAtIGJvdW5kYXJ5Lmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSAhZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICBiaSA9IGJ1ZmZlci5pbmRleE9mKGJvdW5kYXJ5LCBzZWFyY2hGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuc2xpY2UoMCwgYmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zbGljZShiaSArIGJvdW5kYXJ5Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBtZXNzYWdlID0gX2JbMF0sIGJ1ZmZlciA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1lc3NhZ2UuaW5kZXhPZihcIlxcclxcblxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMobWVzc2FnZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZV8xID0gaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZV8xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVfMS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhdGNoIGNvbnRlbnQgdHlwZTogYXBwbGljYXRpb24vanNvbiBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbWVzc2FnZS5zbGljZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VKc29uQm9keShyZXNwb25zZSwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID4gMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFcIiBpbiByZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmNyZW1lbnRhbFwiIGluIHJlc3VsdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yc1wiIGluIHJlc3VsdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBheWxvYWRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXBvbGxvUGF5bG9hZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJwYXlsb2FkXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAxICYmIHJlc3VsdC5wYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IF9fYXNzaWduKHt9LCByZXN1bHQucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlcnJvcnNcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG5leHQpLCB7IGV4dGVuc2lvbnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoXCJleHRlbnNpb25zXCIgaW4gbmV4dCA/IG5leHQuZXh0ZW5zaW9ucyA6IG51bGwpKSwgKF9jID0ge30sIF9jW1BST1RPQ09MX0VSUk9SU19TWU1CT0xdID0gcmVzdWx0LmVycm9ycywgX2MpKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWYWx1ZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgbGFzdCBjaHVuayB3aXRoIG9ubHkgYGhhc05leHQ6IGZhbHNlYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIG9ic2VydmVyLm5leHQgYXMgdGhlcmUgaXMgbm8gZGF0YS9lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaHVuayBjb250YWlucyBvbmx5IGEgXCJoYXNOZXh0OiBmYWxzZVwiLCB3ZSBjYW4gY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ic2VydmVyLmNvbXBsZXRlKCkgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoYXNOZXh0XCIgaW4gcmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXN1bHQuaGFzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmkgPSBidWZmZXIuaW5kZXhPZihib3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJUZXh0KSB7XG4gICAgdmFyIGhlYWRlcnNJbml0ID0ge307XG4gICAgaGVhZGVyVGV4dC5zcGxpdChcIlxcblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBpID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGhlYWRlcnMgdG8gbG93ZXJjYXNlXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gbGluZS5zbGljZSgwLCBpKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpbmUuc2xpY2UoaSArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIGhlYWRlcnNJbml0W25hbWVfMV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzSW5pdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUpzb25Cb2R5KHJlc3BvbnNlLCBib2R5VGV4dCkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgIC8vIE5ldHdvcmsgZXJyb3JcbiAgICAgICAgdmFyIGdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBib2R5VGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhyb3dTZXJ2ZXJFcnJvcihyZXNwb25zZSwgZ2V0UmVzdWx0KCksIFwiUmVzcG9uc2Ugbm90IHN1Y2Nlc3NmdWw6IFJlY2VpdmVkIHN0YXR1cyBjb2RlIFwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keVRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHZhciBwYXJzZUVycm9yID0gZXJyO1xuICAgICAgICBwYXJzZUVycm9yLm5hbWUgPSBcIlNlcnZlclBhcnNlRXJyb3JcIjtcbiAgICAgICAgcGFyc2VFcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBwYXJzZUVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIHBhcnNlRXJyb3IuYm9keVRleHQgPSBib2R5VGV4dDtcbiAgICAgICAgdGhyb3cgcGFyc2VFcnJvcjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBvYnNlcnZlcikge1xuICAgIC8vIGlmIGl0IGlzIGEgbmV0d29yayBlcnJvciwgQlVUIHRoZXJlIGlzIGdyYXBocWwgcmVzdWx0IGluZm8gZmlyZVxuICAgIC8vIHRoZSBuZXh0IG9ic2VydmVyIGJlZm9yZSBjYWxsaW5nIGVycm9yIHRoaXMgZ2l2ZXMgYXBvbGxvLWNsaWVudFxuICAgIC8vIChhbmQgcmVhY3QtYXBvbGxvKSB0aGUgYGdyYXBocWxFcnJvcnNgIGFuZCBgbmV0d29ya0Vycm9yc2AgdG9cbiAgICAvLyBwYXNzIHRvIFVJIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHdlICphbHNvKiBoYXZlIGRhdGEgYXNcbiAgICAvLyBwYXJ0IG9mIHRoZSByZXNwb25zZSBrZXkgcGVyIHRoZSBzcGVjXG4gICAgaWYgKGVyci5yZXN1bHQgJiYgZXJyLnJlc3VsdC5lcnJvcnMgJiYgZXJyLnJlc3VsdC5kYXRhKSB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGNhbGwgbmV4dCwgdGhlIFVJIGNhbiBvbmx5IHNob3cgbmV0d29ya0Vycm9yXG4gICAgICAgIC8vIGJlY2F1c2UgQUMgZGlkbid0IGdldCBhbnkgZ3JhcGhxbEVycm9ycyB0aGlzIGlzIGdyYXBocWxcbiAgICAgICAgLy8gZXhlY3V0aW9uIHJlc3VsdCBpbmZvIChpLmUgZXJyb3JzIGFuZCBwb3NzaWJseSBkYXRhKSB0aGlzIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gZm9ybWFsIHNwZWMgaG93IGVycm9ycyBzaG91bGQgdHJhbnNsYXRlIHRvXG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGNvZGVzLiBTbyBhbiBhdXRoIGVycm9yICg0MDEpIGNvdWxkIGhhdmUgYm90aCBkYXRhXG4gICAgICAgIC8vIGZyb20gYSBwdWJsaWMgZmllbGQsIGVycm9ycyBmcm9tIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIGEgc3RhdHVzXG4gICAgICAgIC8vIG9mIDQwMVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICB1c2VyIHsgLy8gdGhpcyB3aWxsIGhhdmUgZXJyb3JzXG4gICAgICAgIC8vICAgIGZpcnN0TmFtZVxuICAgICAgICAvLyAgfVxuICAgICAgICAvLyAgcHJvZHVjdHMgeyAvLyB0aGlzIGlzIHB1YmxpYyBzbyB3aWxsIGhhdmUgZGF0YVxuICAgICAgICAvLyAgICBjb3N0XG4gICAgICAgIC8vICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhlIHJlc3VsdCBvZiBhYm92ZSAqY291bGQqIGxvb2sgbGlrZSB0aGlzOlxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgZGF0YTogeyBwcm9kdWN0czogW3sgY29zdDogXCIkMTBcIiB9XSB9LFxuICAgICAgICAvLyAgIGVycm9yczogW3tcbiAgICAgICAgLy8gICAgICBtZXNzYWdlOiAneW91ciBzZXNzaW9uIGhhcyB0aW1lZCBvdXQnLFxuICAgICAgICAvLyAgICAgIHBhdGg6IFtdXG4gICAgICAgIC8vICAgfV1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBzdGF0dXMgY29kZSBvZiBhYm92ZSB3b3VsZCBiZSBhIDQwMVxuICAgICAgICAvLyBpbiB0aGUgVUkgeW91IHdhbnQgdG8gc2hvdyBkYXRhIHdoZXJlIHlvdSBjYW4sIGVycm9ycyBhcyBkYXRhIHdoZXJlIHlvdSBjYW5cbiAgICAgICAgLy8gYW5kIHVzZSBjb3JyZWN0IGh0dHAgc3RhdHVzIGNvZGVzXG4gICAgICAgIG9ic2VydmVyLm5leHQoZXJyLnJlc3VsdCk7XG4gICAgfVxuICAgIG9ic2VydmVyLmVycm9yKGVycik7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZShvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgICAgIC50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5VGV4dCkgeyByZXR1cm4gcGFyc2VKc29uQm9keShyZXNwb25zZSwgYm9keVRleHQpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIFwiZGF0YVwiKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgXCJlcnJvcnNcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3dTZXJ2ZXJFcnJvcihyZXNwb25zZSwgcmVzdWx0LCBcIlNlcnZlciByZXNwb25zZSB3YXMgbWlzc2luZyBmb3IgcXVlcnkgJ1wiLmNvbmNhdChBcnJheS5pc0FycmF5KG9wZXJhdGlvbnMpID9cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5vcGVyYXRpb25OYW1lOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbnMub3BlcmF0aW9uTmFtZSwgXCInLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX2F3YWl0ZXIiLCJfX2dlbmVyYXRvciIsInJlc3BvbnNlSXRlcmF0b3IiLCJ0aHJvd1NlcnZlckVycm9yIiwiUFJPVE9DT0xfRVJST1JTX1NZTUJPTCIsImlzQXBvbGxvUGF5bG9hZFJlc3VsdCIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwicmVhZE11bHRpcGFydEJvZHkiLCJyZXNwb25zZSIsIm5leHRWYWx1ZSIsImRlY29kZXIiLCJjb250ZW50VHlwZSIsImRlbGltaXRlciIsImJvdW5kYXJ5VmFsIiwiYm91bmRhcnkiLCJidWZmZXIiLCJpdGVyYXRvciIsInJ1bm5pbmciLCJfYSIsInZhbHVlIiwiZG9uZSIsImNodW5rIiwic2VhcmNoRnJvbSIsImJpIiwibWVzc2FnZSIsImkiLCJoZWFkZXJzIiwiY29udGVudFR5cGVfMSIsImJvZHkiLCJyZXN1bHQiLCJuZXh0IiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJsYWJlbCIsIlRleHREZWNvZGVyIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJnZXQiLCJpbmNsdWRlcyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsZW5ndGgiLCJyZXBsYWNlIiwidHJpbSIsImNvbmNhdCIsInNlbnQiLCJkZWNvZGUiLCJzbGljZSIsInBhcnNlSGVhZGVycyIsInRvTG93ZXJDYXNlIiwicGFyc2VKc29uQm9keSIsImtleXMiLCJwYXlsb2FkIiwiZXh0ZW5zaW9ucyIsImVycm9ycyIsImhhc05leHQiLCJoZWFkZXJUZXh0IiwiaGVhZGVyc0luaXQiLCJzcGxpdCIsImZvckVhY2giLCJsaW5lIiwibmFtZV8xIiwiYm9keVRleHQiLCJzdGF0dXMiLCJnZXRSZXN1bHQiLCJKU09OIiwicGFyc2UiLCJlcnIiLCJwYXJzZUVycm9yIiwibmFtZSIsInN0YXR1c0NvZGUiLCJoYW5kbGVFcnJvciIsIm9ic2VydmVyIiwiZGF0YSIsImVycm9yIiwicGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSIsIm9wZXJhdGlvbnMiLCJ0ZXh0IiwidGhlbiIsIkFycmF5IiwiaXNBcnJheSIsImNhbGwiLCJtYXAiLCJvcCIsIm9wZXJhdGlvbk5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/responseIterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/responseIterator.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   responseIterator: function() { return /* binding */ responseIterator; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _iterators_async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterators/async.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/async.js\");\n/* harmony import */ var _iterators_nodeStream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iterators/nodeStream.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/nodeStream.js\");\n/* harmony import */ var _iterators_promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./iterators/promise.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/promise.js\");\n/* harmony import */ var _iterators_reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iterators/reader.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/iterators/reader.js\");\n/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */ \n\n\n\n\nfunction isNodeResponse(value) {\n    return !!value.body;\n}\nfunction isReadableStream(value) {\n    return !!value.getReader;\n}\nfunction isAsyncIterableIterator(value) {\n    return !!(_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);\n}\nfunction isStreamableBlob(value) {\n    return !!value.stream;\n}\nfunction isBlob(value) {\n    return !!value.arrayBuffer;\n}\nfunction isNodeReadableStream(value) {\n    return !!value.pipe;\n}\nfunction responseIterator(response) {\n    var body = response;\n    if (isNodeResponse(response)) body = response.body;\n    if (isAsyncIterableIterator(body)) return (0,_iterators_async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body);\n    if (isReadableStream(body)) return (0,_iterators_reader_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(body.getReader());\n    // this errors without casting to ReadableStream<T>\n    // because Blob.stream() returns a NodeJS ReadableStream\n    if (isStreamableBlob(body)) {\n        return (0,_iterators_reader_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(body.stream().getReader());\n    }\n    if (isBlob(body)) return (0,_iterators_promise_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(body.arrayBuffer());\n    if (isNodeReadableStream(body)) return (0,_iterators_nodeStream_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(body);\n    throw new Error(\"Unknown body type for responseIterator. Please pass a streamable response.\");\n} //# sourceMappingURL=responseIterator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvcmVzcG9uc2VJdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDb0U7QUFDcEI7QUFDVTtBQUNOO0FBQ0Y7QUFDbkQsU0FBU0ssZUFBZUMsS0FBSztJQUN6QixPQUFPLENBQUMsQ0FBQ0EsTUFBTUMsSUFBSTtBQUN2QjtBQUNBLFNBQVNDLGlCQUFpQkYsS0FBSztJQUMzQixPQUFPLENBQUMsQ0FBQ0EsTUFBTUcsU0FBUztBQUM1QjtBQUNBLFNBQVNDLHdCQUF3QkosS0FBSztJQUNsQyxPQUFPLENBQUMsQ0FBRU4sQ0FBQUEsMEVBQXlCQSxJQUMvQk0sS0FBSyxDQUFDSyxPQUFPVixhQUFhLENBQUM7QUFDbkM7QUFDQSxTQUFTVyxpQkFBaUJOLEtBQUs7SUFDM0IsT0FBTyxDQUFDLENBQUNBLE1BQU1PLE1BQU07QUFDekI7QUFDQSxTQUFTQyxPQUFPUixLQUFLO0lBQ2pCLE9BQU8sQ0FBQyxDQUFDQSxNQUFNUyxXQUFXO0FBQzlCO0FBQ0EsU0FBU0MscUJBQXFCVixLQUFLO0lBQy9CLE9BQU8sQ0FBQyxDQUFDQSxNQUFNVyxJQUFJO0FBQ3ZCO0FBQ08sU0FBU0MsaUJBQWlCQyxRQUFRO0lBQ3JDLElBQUlaLE9BQU9ZO0lBQ1gsSUFBSWQsZUFBZWMsV0FDZlosT0FBT1ksU0FBU1osSUFBSTtJQUN4QixJQUFJRyx3QkFBd0JILE9BQ3hCLE9BQU9OLCtEQUFhQSxDQUFDTTtJQUN6QixJQUFJQyxpQkFBaUJELE9BQ2pCLE9BQU9ILGdFQUFjQSxDQUFDRyxLQUFLRSxTQUFTO0lBQ3hDLG1EQUFtRDtJQUNuRCx3REFBd0Q7SUFDeEQsSUFBSUcsaUJBQWlCTCxPQUFPO1FBQ3hCLE9BQU9ILGdFQUFjQSxDQUFDRyxLQUFLTSxNQUFNLEdBQUdKLFNBQVM7SUFDakQ7SUFDQSxJQUFJSyxPQUFPUCxPQUNQLE9BQU9KLGlFQUFlQSxDQUFDSSxLQUFLUSxXQUFXO0lBQzNDLElBQUlDLHFCQUFxQlQsT0FDckIsT0FBT0wsb0VBQWtCQSxDQUFDSztJQUM5QixNQUFNLElBQUlhLE1BQU07QUFDcEIsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvaHR0cC9yZXNwb25zZUl0ZXJhdG9yLmpzPzdmMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcmlnaW5hbCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20va21hbGFrb2ZmL3Jlc3BvbnNlLWl0ZXJhdG9yL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuICovXG5pbXBvcnQgeyBjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IGFzeW5jSXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3JzL2FzeW5jLmpzXCI7XG5pbXBvcnQgbm9kZVN0cmVhbUl0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9ycy9ub2RlU3RyZWFtLmpzXCI7XG5pbXBvcnQgcHJvbWlzZUl0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9ycy9wcm9taXNlLmpzXCI7XG5pbXBvcnQgcmVhZGVySXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3JzL3JlYWRlci5qc1wiO1xuZnVuY3Rpb24gaXNOb2RlUmVzcG9uc2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZS5ib2R5O1xufVxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLmdldFJlYWRlcjtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKGNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wgJiZcbiAgICAgICAgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcbn1cbmZ1bmN0aW9uIGlzU3RyZWFtYWJsZUJsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZS5zdHJlYW07XG59XG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZS5hcnJheUJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGlzTm9kZVJlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUucGlwZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNwb25zZUl0ZXJhdG9yKHJlc3BvbnNlKSB7XG4gICAgdmFyIGJvZHkgPSByZXNwb25zZTtcbiAgICBpZiAoaXNOb2RlUmVzcG9uc2UocmVzcG9uc2UpKVxuICAgICAgICBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICBpZiAoaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IoYm9keSkpXG4gICAgICAgIHJldHVybiBhc3luY0l0ZXJhdG9yKGJvZHkpO1xuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtKGJvZHkpKVxuICAgICAgICByZXR1cm4gcmVhZGVySXRlcmF0b3IoYm9keS5nZXRSZWFkZXIoKSk7XG4gICAgLy8gdGhpcyBlcnJvcnMgd2l0aG91dCBjYXN0aW5nIHRvIFJlYWRhYmxlU3RyZWFtPFQ+XG4gICAgLy8gYmVjYXVzZSBCbG9iLnN0cmVhbSgpIHJldHVybnMgYSBOb2RlSlMgUmVhZGFibGVTdHJlYW1cbiAgICBpZiAoaXNTdHJlYW1hYmxlQmxvYihib2R5KSkge1xuICAgICAgICByZXR1cm4gcmVhZGVySXRlcmF0b3IoYm9keS5zdHJlYW0oKS5nZXRSZWFkZXIoKSk7XG4gICAgfVxuICAgIGlmIChpc0Jsb2IoYm9keSkpXG4gICAgICAgIHJldHVybiBwcm9taXNlSXRlcmF0b3IoYm9keS5hcnJheUJ1ZmZlcigpKTtcbiAgICBpZiAoaXNOb2RlUmVhZGFibGVTdHJlYW0oYm9keSkpXG4gICAgICAgIHJldHVybiBub2RlU3RyZWFtSXRlcmF0b3IoYm9keSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBib2R5IHR5cGUgZm9yIHJlc3BvbnNlSXRlcmF0b3IuIFBsZWFzZSBwYXNzIGEgc3RyZWFtYWJsZSByZXNwb25zZS5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNwb25zZUl0ZXJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsIm5vZGVTdHJlYW1JdGVyYXRvciIsInByb21pc2VJdGVyYXRvciIsInJlYWRlckl0ZXJhdG9yIiwiaXNOb2RlUmVzcG9uc2UiLCJ2YWx1ZSIsImJvZHkiLCJpc1JlYWRhYmxlU3RyZWFtIiwiZ2V0UmVhZGVyIiwiaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IiLCJTeW1ib2wiLCJpc1N0cmVhbWFibGVCbG9iIiwic3RyZWFtIiwiaXNCbG9iIiwiYXJyYXlCdWZmZXIiLCJpc05vZGVSZWFkYWJsZVN0cmVhbSIsInBpcGUiLCJyZXNwb25zZUl0ZXJhdG9yIiwicmVzcG9uc2UiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/responseIterator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/rewriteURIForGET.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/rewriteURIForGET.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rewriteURIForGET: function() { return /* binding */ rewriteURIForGET; }\n/* harmony export */ });\n/* harmony import */ var _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./serializeFetchParameter.js */ \"(app-pages-browser)/./node_modules/@apollo/client/link/http/serializeFetchParameter.js\");\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI, body) {\n    // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n    // the extra level of JSON serialization!\n    var queryParams = [];\n    var addQueryParam = function(key, value) {\n        queryParams.push(\"\".concat(key, \"=\").concat(encodeURIComponent(value)));\n    };\n    if (\"query\" in body) {\n        addQueryParam(\"query\", body.query);\n    }\n    if (body.operationName) {\n        addQueryParam(\"operationName\", body.operationName);\n    }\n    if (body.variables) {\n        var serializedVariables = void 0;\n        try {\n            serializedVariables = (0,_serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__.serializeFetchParameter)(body.variables, \"Variables map\");\n        } catch (parseError) {\n            return {\n                parseError: parseError\n            };\n        }\n        addQueryParam(\"variables\", serializedVariables);\n    }\n    if (body.extensions) {\n        var serializedExtensions = void 0;\n        try {\n            serializedExtensions = (0,_serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__.serializeFetchParameter)(body.extensions, \"Extensions map\");\n        } catch (parseError) {\n            return {\n                parseError: parseError\n            };\n        }\n        addQueryParam(\"extensions\", serializedExtensions);\n    }\n    // Reconstruct the URI with added query params.\n    // XXX This assumes that the URI is well-formed and that it doesn't\n    //     already contain any of these query params. We could instead use the\n    //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n    //     don't support URLSearchParams. Note that some browsers (and\n    //     versions of whatwg-url) support URL but not URLSearchParams!\n    var fragment = \"\", preFragment = chosenURI;\n    var fragmentStart = chosenURI.indexOf(\"#\");\n    if (fragmentStart !== -1) {\n        fragment = chosenURI.substr(fragmentStart);\n        preFragment = chosenURI.substr(0, fragmentStart);\n    }\n    var queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n    var newURI = preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n    return {\n        newURI: newURI\n    };\n} //# sourceMappingURL=rewriteURIForGET.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvcmV3cml0ZVVSSUZvckdFVC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RTtBQUN2RSw0RUFBNEU7QUFDNUUsZUFBZTtBQUNSLFNBQVNDLGlCQUFpQkMsU0FBUyxFQUFFQyxJQUFJO0lBQzVDLHlFQUF5RTtJQUN6RSx5Q0FBeUM7SUFDekMsSUFBSUMsY0FBYyxFQUFFO0lBQ3BCLElBQUlDLGdCQUFnQixTQUFVQyxHQUFHLEVBQUVDLEtBQUs7UUFDcENILFlBQVlJLElBQUksQ0FBQyxHQUFHQyxNQUFNLENBQUNILEtBQUssS0FBS0csTUFBTSxDQUFDQyxtQkFBbUJIO0lBQ25FO0lBQ0EsSUFBSSxXQUFXSixNQUFNO1FBQ2pCRSxjQUFjLFNBQVNGLEtBQUtRLEtBQUs7SUFDckM7SUFDQSxJQUFJUixLQUFLUyxhQUFhLEVBQUU7UUFDcEJQLGNBQWMsaUJBQWlCRixLQUFLUyxhQUFhO0lBQ3JEO0lBQ0EsSUFBSVQsS0FBS1UsU0FBUyxFQUFFO1FBQ2hCLElBQUlDLHNCQUFzQixLQUFLO1FBQy9CLElBQUk7WUFDQUEsc0JBQXNCZCxvRkFBdUJBLENBQUNHLEtBQUtVLFNBQVMsRUFBRTtRQUNsRSxFQUNBLE9BQU9FLFlBQVk7WUFDZixPQUFPO2dCQUFFQSxZQUFZQTtZQUFXO1FBQ3BDO1FBQ0FWLGNBQWMsYUFBYVM7SUFDL0I7SUFDQSxJQUFJWCxLQUFLYSxVQUFVLEVBQUU7UUFDakIsSUFBSUMsdUJBQXVCLEtBQUs7UUFDaEMsSUFBSTtZQUNBQSx1QkFBdUJqQixvRkFBdUJBLENBQUNHLEtBQUthLFVBQVUsRUFBRTtRQUNwRSxFQUNBLE9BQU9ELFlBQVk7WUFDZixPQUFPO2dCQUFFQSxZQUFZQTtZQUFXO1FBQ3BDO1FBQ0FWLGNBQWMsY0FBY1k7SUFDaEM7SUFDQSwrQ0FBK0M7SUFDL0MsbUVBQW1FO0lBQ25FLDBFQUEwRTtJQUMxRSx5RUFBeUU7SUFDekUsa0VBQWtFO0lBQ2xFLG1FQUFtRTtJQUNuRSxJQUFJQyxXQUFXLElBQUlDLGNBQWNqQjtJQUNqQyxJQUFJa0IsZ0JBQWdCbEIsVUFBVW1CLE9BQU8sQ0FBQztJQUN0QyxJQUFJRCxrQkFBa0IsQ0FBQyxHQUFHO1FBQ3RCRixXQUFXaEIsVUFBVW9CLE1BQU0sQ0FBQ0Y7UUFDNUJELGNBQWNqQixVQUFVb0IsTUFBTSxDQUFDLEdBQUdGO0lBQ3RDO0lBQ0EsSUFBSUcsb0JBQW9CSixZQUFZRSxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTTtJQUNoRSxJQUFJRyxTQUFTTCxjQUFjSSxvQkFBb0JuQixZQUFZcUIsSUFBSSxDQUFDLE9BQU9QO0lBQ3ZFLE9BQU87UUFBRU0sUUFBUUE7SUFBTztBQUM1QixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL3Jld3JpdGVVUklGb3JHRVQuanM/NjU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciB9IGZyb20gXCIuL3NlcmlhbGl6ZUZldGNoUGFyYW1ldGVyLmpzXCI7XG4vLyBGb3IgR0VUIG9wZXJhdGlvbnMsIHJldHVybnMgdGhlIGdpdmVuIFVSSSByZXdyaXR0ZW4gd2l0aCBwYXJhbWV0ZXJzLCBvciBhXG4vLyBwYXJzZSBlcnJvci5cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlVVJJRm9yR0VUKGNob3NlblVSSSwgYm9keSkge1xuICAgIC8vIEltcGxlbWVudCB0aGUgc3RhbmRhcmQgSFRUUCBHRVQgc2VyaWFsaXphdGlvbiwgcGx1cyAnZXh0ZW5zaW9ucycuIE5vdGVcbiAgICAvLyB0aGUgZXh0cmEgbGV2ZWwgb2YgSlNPTiBzZXJpYWxpemF0aW9uIVxuICAgIHZhciBxdWVyeVBhcmFtcyA9IFtdO1xuICAgIHZhciBhZGRRdWVyeVBhcmFtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMucHVzaChcIlwiLmNvbmNhdChrZXksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkpO1xuICAgIH07XG4gICAgaWYgKFwicXVlcnlcIiBpbiBib2R5KSB7XG4gICAgICAgIGFkZFF1ZXJ5UGFyYW0oXCJxdWVyeVwiLCBib2R5LnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGJvZHkub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBhZGRRdWVyeVBhcmFtKFwib3BlcmF0aW9uTmFtZVwiLCBib2R5Lm9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBpZiAoYm9keS52YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRWYXJpYWJsZXMgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkVmFyaWFibGVzID0gc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIoYm9keS52YXJpYWJsZXMsIFwiVmFyaWFibGVzIG1hcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VFcnJvcjogcGFyc2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGFkZFF1ZXJ5UGFyYW0oXCJ2YXJpYWJsZXNcIiwgc2VyaWFsaXplZFZhcmlhYmxlcyk7XG4gICAgfVxuICAgIGlmIChib2R5LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRFeHRlbnNpb25zID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZEV4dGVuc2lvbnMgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LmV4dGVuc2lvbnMsIFwiRXh0ZW5zaW9ucyBtYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhcnNlRXJyb3I6IHBhcnNlRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBhZGRRdWVyeVBhcmFtKFwiZXh0ZW5zaW9uc1wiLCBzZXJpYWxpemVkRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8vIFJlY29uc3RydWN0IHRoZSBVUkkgd2l0aCBhZGRlZCBxdWVyeSBwYXJhbXMuXG4gICAgLy8gWFhYIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBVUkkgaXMgd2VsbC1mb3JtZWQgYW5kIHRoYXQgaXQgZG9lc24ndFxuICAgIC8vICAgICBhbHJlYWR5IGNvbnRhaW4gYW55IG9mIHRoZXNlIHF1ZXJ5IHBhcmFtcy4gV2UgY291bGQgaW5zdGVhZCB1c2UgdGhlXG4gICAgLy8gICAgIFVSTCBBUEkgYW5kIHRha2UgYSBwb2x5ZmlsbCAod2hhdHdnLXVybEA2KSBmb3Igb2xkZXIgYnJvd3NlcnMgdGhhdFxuICAgIC8vICAgICBkb24ndCBzdXBwb3J0IFVSTFNlYXJjaFBhcmFtcy4gTm90ZSB0aGF0IHNvbWUgYnJvd3NlcnMgKGFuZFxuICAgIC8vICAgICB2ZXJzaW9ucyBvZiB3aGF0d2ctdXJsKSBzdXBwb3J0IFVSTCBidXQgbm90IFVSTFNlYXJjaFBhcmFtcyFcbiAgICB2YXIgZnJhZ21lbnQgPSBcIlwiLCBwcmVGcmFnbWVudCA9IGNob3NlblVSSTtcbiAgICB2YXIgZnJhZ21lbnRTdGFydCA9IGNob3NlblVSSS5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoZnJhZ21lbnRTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgZnJhZ21lbnQgPSBjaG9zZW5VUkkuc3Vic3RyKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICBwcmVGcmFnbWVudCA9IGNob3NlblVSSS5zdWJzdHIoMCwgZnJhZ21lbnRTdGFydCk7XG4gICAgfVxuICAgIHZhciBxdWVyeVBhcmFtc1ByZWZpeCA9IHByZUZyYWdtZW50LmluZGV4T2YoXCI/XCIpID09PSAtMSA/IFwiP1wiIDogXCImXCI7XG4gICAgdmFyIG5ld1VSSSA9IHByZUZyYWdtZW50ICsgcXVlcnlQYXJhbXNQcmVmaXggKyBxdWVyeVBhcmFtcy5qb2luKFwiJlwiKSArIGZyYWdtZW50O1xuICAgIHJldHVybiB7IG5ld1VSSTogbmV3VVJJIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXdyaXRlVVJJRm9yR0VULmpzLm1hcCJdLCJuYW1lcyI6WyJzZXJpYWxpemVGZXRjaFBhcmFtZXRlciIsInJld3JpdGVVUklGb3JHRVQiLCJjaG9zZW5VUkkiLCJib2R5IiwicXVlcnlQYXJhbXMiLCJhZGRRdWVyeVBhcmFtIiwia2V5IiwidmFsdWUiLCJwdXNoIiwiY29uY2F0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicXVlcnkiLCJvcGVyYXRpb25OYW1lIiwidmFyaWFibGVzIiwic2VyaWFsaXplZFZhcmlhYmxlcyIsInBhcnNlRXJyb3IiLCJleHRlbnNpb25zIiwic2VyaWFsaXplZEV4dGVuc2lvbnMiLCJmcmFnbWVudCIsInByZUZyYWdtZW50IiwiZnJhZ21lbnRTdGFydCIsImluZGV4T2YiLCJzdWJzdHIiLCJxdWVyeVBhcmFtc1ByZWZpeCIsIm5ld1VSSSIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/rewriteURIForGET.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultPrinter: function() { return /* binding */ defaultPrinter; },\n/* harmony export */   fallbackHttpConfig: function() { return /* binding */ fallbackHttpConfig; },\n/* harmony export */   selectHttpOptionsAndBody: function() { return /* binding */ selectHttpOptionsAndBody; },\n/* harmony export */   selectHttpOptionsAndBodyInternal: function() { return /* binding */ selectHttpOptionsAndBodyInternal; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/print.js\");\n\n\nvar defaultHttpOptions = {\n    includeQuery: true,\n    includeExtensions: false,\n    preserveHeaderCase: false\n};\nvar defaultHeaders = {\n    // headers are case insensitive (https://stackoverflow.com/a/5259004)\n    accept: \"*/*\",\n    // The content-type header describes the type of the body of the request, and\n    // so it typically only is sent with requests that actually have bodies. One\n    // could imagine that Apollo Client would remove this header when constructing\n    // a GET request (which has no body), but we historically have not done that.\n    // This means that browsers will preflight all Apollo Client requests (even\n    // GET requests). Apollo Server's CSRF prevention feature (introduced in\n    // AS3.7) takes advantage of this fact and does not block requests with this\n    // header. If you want to drop this header from GET requests, then you should\n    // probably replace it with a `apollo-require-preflight` header, or servers\n    // with CSRF prevention enabled might block your GET request. See\n    // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n    // for more details.\n    \"content-type\": \"application/json\"\n};\nvar defaultOptions = {\n    method: \"POST\"\n};\nvar fallbackHttpConfig = {\n    http: defaultHttpOptions,\n    headers: defaultHeaders,\n    options: defaultOptions\n};\nvar defaultPrinter = function(ast, printer) {\n    return printer(ast);\n};\nfunction selectHttpOptionsAndBody(operation, fallbackConfig) {\n    var configs = [];\n    for(var _i = 2; _i < arguments.length; _i++){\n        configs[_i - 2] = arguments[_i];\n    }\n    configs.unshift(fallbackConfig);\n    return selectHttpOptionsAndBodyInternal.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([\n        operation,\n        defaultPrinter\n    ], configs, false));\n}\nfunction selectHttpOptionsAndBodyInternal(operation, printer) {\n    var configs = [];\n    for(var _i = 2; _i < arguments.length; _i++){\n        configs[_i - 2] = arguments[_i];\n    }\n    var options = {};\n    var http = {};\n    configs.forEach(function(config) {\n        options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, options), config.options), {\n            headers: (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, options.headers), config.headers)\n        });\n        if (config.credentials) {\n            options.credentials = config.credentials;\n        }\n        http = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, http), config.http);\n    });\n    if (options.headers) {\n        options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);\n    }\n    //The body depends on the http options\n    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;\n    var body = {\n        operationName: operationName,\n        variables: variables\n    };\n    if (http.includeExtensions) body.extensions = extensions;\n    // not sending the query (i.e persisted queries)\n    if (http.includeQuery) body.query = printer(query, _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.print);\n    return {\n        options: options,\n        body: body\n    };\n}\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(headers, preserveHeaderCase) {\n    // If we're not preserving the case, just remove duplicates w/ normalization.\n    if (!preserveHeaderCase) {\n        var normalizedHeaders_1 = {};\n        Object.keys(Object(headers)).forEach(function(name) {\n            normalizedHeaders_1[name.toLowerCase()] = headers[name];\n        });\n        return normalizedHeaders_1;\n    }\n    // If we are preserving the case, remove duplicates w/ normalization,\n    // preserving the original name.\n    // This allows for non-http-spec-compliant servers that expect intentionally\n    // capitalized header names (See #6741).\n    var headerData = {};\n    Object.keys(Object(headers)).forEach(function(name) {\n        headerData[name.toLowerCase()] = {\n            originalName: name,\n            value: headers[name]\n        };\n    });\n    var normalizedHeaders = {};\n    Object.keys(headerData).forEach(function(name) {\n        normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n    });\n    return normalizedHeaders;\n} //# sourceMappingURL=selectHttpOptionsAndBody.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnRDtBQUNDO0FBQ2pELElBQUlHLHFCQUFxQjtJQUNyQkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLG9CQUFvQjtBQUN4QjtBQUNBLElBQUlDLGlCQUFpQjtJQUNqQixxRUFBcUU7SUFDckVDLFFBQVE7SUFDUiw2RUFBNkU7SUFDN0UsNEVBQTRFO0lBQzVFLDhFQUE4RTtJQUM5RSw2RUFBNkU7SUFDN0UsMkVBQTJFO0lBQzNFLHdFQUF3RTtJQUN4RSw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLDJFQUEyRTtJQUMzRSxpRUFBaUU7SUFDakUsNkdBQTZHO0lBQzdHLG9CQUFvQjtJQUNwQixnQkFBZ0I7QUFDcEI7QUFDQSxJQUFJQyxpQkFBaUI7SUFDakJDLFFBQVE7QUFDWjtBQUNPLElBQUlDLHFCQUFxQjtJQUM1QkMsTUFBTVQ7SUFDTlUsU0FBU047SUFDVE8sU0FBU0w7QUFDYixFQUFFO0FBQ0ssSUFBSU0saUJBQWlCLFNBQVVDLEdBQUcsRUFBRUMsT0FBTztJQUFJLE9BQU9BLFFBQVFEO0FBQU0sRUFBRTtBQUN0RSxTQUFTRSx5QkFBeUJDLFNBQVMsRUFBRUMsY0FBYztJQUM5RCxJQUFJQyxVQUFVLEVBQUU7SUFDaEIsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtDLFVBQVVDLE1BQU0sRUFBRUYsS0FBTTtRQUMxQ0QsT0FBTyxDQUFDQyxLQUFLLEVBQUUsR0FBR0MsU0FBUyxDQUFDRCxHQUFHO0lBQ25DO0lBQ0FELFFBQVFJLE9BQU8sQ0FBQ0w7SUFDaEIsT0FBT00saUNBQWlDQyxLQUFLLENBQUMsS0FBSyxHQUFHMUIsb0RBQWFBLENBQUM7UUFBQ2tCO1FBQ2pFSjtLQUFlLEVBQUVNLFNBQVM7QUFDbEM7QUFDTyxTQUFTSyxpQ0FBaUNQLFNBQVMsRUFBRUYsT0FBTztJQUMvRCxJQUFJSSxVQUFVLEVBQUU7SUFDaEIsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtDLFVBQVVDLE1BQU0sRUFBRUYsS0FBTTtRQUMxQ0QsT0FBTyxDQUFDQyxLQUFLLEVBQUUsR0FBR0MsU0FBUyxDQUFDRCxHQUFHO0lBQ25DO0lBQ0EsSUFBSVIsVUFBVSxDQUFDO0lBQ2YsSUFBSUYsT0FBTyxDQUFDO0lBQ1pTLFFBQVFPLE9BQU8sQ0FBQyxTQUFVQyxNQUFNO1FBQzVCZixVQUFVZCwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR2MsVUFBVWUsT0FBT2YsT0FBTyxHQUFHO1lBQUVELFNBQVNiLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdjLFFBQVFELE9BQU8sR0FBR2dCLE9BQU9oQixPQUFPO1FBQUU7UUFDdkksSUFBSWdCLE9BQU9DLFdBQVcsRUFBRTtZQUNwQmhCLFFBQVFnQixXQUFXLEdBQUdELE9BQU9DLFdBQVc7UUFDNUM7UUFDQWxCLE9BQU9aLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdZLE9BQU9pQixPQUFPakIsSUFBSTtJQUNuRDtJQUNBLElBQUlFLFFBQVFELE9BQU8sRUFBRTtRQUNqQkMsUUFBUUQsT0FBTyxHQUFHa0IsdUJBQXVCakIsUUFBUUQsT0FBTyxFQUFFRCxLQUFLTixrQkFBa0I7SUFDckY7SUFDQSxzQ0FBc0M7SUFDdEMsSUFBSTBCLGdCQUFnQmIsVUFBVWEsYUFBYSxFQUFFQyxhQUFhZCxVQUFVYyxVQUFVLEVBQUVDLFlBQVlmLFVBQVVlLFNBQVMsRUFBRUMsUUFBUWhCLFVBQVVnQixLQUFLO0lBQ3hJLElBQUlDLE9BQU87UUFBRUosZUFBZUE7UUFBZUUsV0FBV0E7SUFBVTtJQUNoRSxJQUFJdEIsS0FBS1AsaUJBQWlCLEVBQ3RCK0IsS0FBS0gsVUFBVSxHQUFHQTtJQUN0QixnREFBZ0Q7SUFDaEQsSUFBSXJCLEtBQUtSLFlBQVksRUFDakJnQyxLQUFLRCxLQUFLLEdBQUdsQixRQUFRa0IsT0FBT2pDLHNEQUFLQTtJQUNyQyxPQUFPO1FBQ0hZLFNBQVNBO1FBQ1RzQixNQUFNQTtJQUNWO0FBQ0o7QUFDQSxpRkFBaUY7QUFDakYsMEVBQTBFO0FBQzFFLHdDQUF3QztBQUN4QyxTQUFTTCx1QkFBdUJsQixPQUFPLEVBQUVQLGtCQUFrQjtJQUN2RCw2RUFBNkU7SUFDN0UsSUFBSSxDQUFDQSxvQkFBb0I7UUFDckIsSUFBSStCLHNCQUFzQixDQUFDO1FBQzNCQyxPQUFPQyxJQUFJLENBQUNELE9BQU96QixVQUFVZSxPQUFPLENBQUMsU0FBVVksSUFBSTtZQUMvQ0gsbUJBQW1CLENBQUNHLEtBQUtDLFdBQVcsR0FBRyxHQUFHNUIsT0FBTyxDQUFDMkIsS0FBSztRQUMzRDtRQUNBLE9BQU9IO0lBQ1g7SUFDQSxxRUFBcUU7SUFDckUsZ0NBQWdDO0lBQ2hDLDRFQUE0RTtJQUM1RSx3Q0FBd0M7SUFDeEMsSUFBSUssYUFBYSxDQUFDO0lBQ2xCSixPQUFPQyxJQUFJLENBQUNELE9BQU96QixVQUFVZSxPQUFPLENBQUMsU0FBVVksSUFBSTtRQUMvQ0UsVUFBVSxDQUFDRixLQUFLQyxXQUFXLEdBQUcsR0FBRztZQUM3QkUsY0FBY0g7WUFDZEksT0FBTy9CLE9BQU8sQ0FBQzJCLEtBQUs7UUFDeEI7SUFDSjtJQUNBLElBQUlLLG9CQUFvQixDQUFDO0lBQ3pCUCxPQUFPQyxJQUFJLENBQUNHLFlBQVlkLE9BQU8sQ0FBQyxTQUFVWSxJQUFJO1FBQzFDSyxpQkFBaUIsQ0FBQ0gsVUFBVSxDQUFDRixLQUFLLENBQUNHLFlBQVksQ0FBQyxHQUFHRCxVQUFVLENBQUNGLEtBQUssQ0FBQ0ksS0FBSztJQUM3RTtJQUNBLE9BQU9DO0FBQ1gsRUFDQSxvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvaHR0cC9zZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkuanM/MDMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcHJpbnQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG52YXIgZGVmYXVsdEh0dHBPcHRpb25zID0ge1xuICAgIGluY2x1ZGVRdWVyeTogdHJ1ZSxcbiAgICBpbmNsdWRlRXh0ZW5zaW9uczogZmFsc2UsXG4gICAgcHJlc2VydmVIZWFkZXJDYXNlOiBmYWxzZSxcbn07XG52YXIgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgLy8gaGVhZGVycyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNTkwMDQpXG4gICAgYWNjZXB0OiBcIiovKlwiLFxuICAgIC8vIFRoZSBjb250ZW50LXR5cGUgaGVhZGVyIGRlc2NyaWJlcyB0aGUgdHlwZSBvZiB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdCwgYW5kXG4gICAgLy8gc28gaXQgdHlwaWNhbGx5IG9ubHkgaXMgc2VudCB3aXRoIHJlcXVlc3RzIHRoYXQgYWN0dWFsbHkgaGF2ZSBib2RpZXMuIE9uZVxuICAgIC8vIGNvdWxkIGltYWdpbmUgdGhhdCBBcG9sbG8gQ2xpZW50IHdvdWxkIHJlbW92ZSB0aGlzIGhlYWRlciB3aGVuIGNvbnN0cnVjdGluZ1xuICAgIC8vIGEgR0VUIHJlcXVlc3QgKHdoaWNoIGhhcyBubyBib2R5KSwgYnV0IHdlIGhpc3RvcmljYWxseSBoYXZlIG5vdCBkb25lIHRoYXQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IGJyb3dzZXJzIHdpbGwgcHJlZmxpZ2h0IGFsbCBBcG9sbG8gQ2xpZW50IHJlcXVlc3RzIChldmVuXG4gICAgLy8gR0VUIHJlcXVlc3RzKS4gQXBvbGxvIFNlcnZlcidzIENTUkYgcHJldmVudGlvbiBmZWF0dXJlIChpbnRyb2R1Y2VkIGluXG4gICAgLy8gQVMzLjcpIHRha2VzIGFkdmFudGFnZSBvZiB0aGlzIGZhY3QgYW5kIGRvZXMgbm90IGJsb2NrIHJlcXVlc3RzIHdpdGggdGhpc1xuICAgIC8vIGhlYWRlci4gSWYgeW91IHdhbnQgdG8gZHJvcCB0aGlzIGhlYWRlciBmcm9tIEdFVCByZXF1ZXN0cywgdGhlbiB5b3Ugc2hvdWxkXG4gICAgLy8gcHJvYmFibHkgcmVwbGFjZSBpdCB3aXRoIGEgYGFwb2xsby1yZXF1aXJlLXByZWZsaWdodGAgaGVhZGVyLCBvciBzZXJ2ZXJzXG4gICAgLy8gd2l0aCBDU1JGIHByZXZlbnRpb24gZW5hYmxlZCBtaWdodCBibG9jayB5b3VyIEdFVCByZXF1ZXN0LiBTZWVcbiAgICAvLyBodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL2Fwb2xsby1zZXJ2ZXIvc2VjdXJpdHkvY29ycy8jcHJldmVudGluZy1jcm9zcy1zaXRlLXJlcXVlc3QtZm9yZ2VyeS1jc3JmXG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbn07XG5leHBvcnQgdmFyIGZhbGxiYWNrSHR0cENvbmZpZyA9IHtcbiAgICBodHRwOiBkZWZhdWx0SHR0cE9wdGlvbnMsXG4gICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMsXG4gICAgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG59O1xuZXhwb3J0IHZhciBkZWZhdWx0UHJpbnRlciA9IGZ1bmN0aW9uIChhc3QsIHByaW50ZXIpIHsgcmV0dXJuIHByaW50ZXIoYXN0KTsgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkob3BlcmF0aW9uLCBmYWxsYmFja0NvbmZpZykge1xuICAgIHZhciBjb25maWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY29uZmlnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY29uZmlncy51bnNoaWZ0KGZhbGxiYWNrQ29uZmlnKTtcbiAgICByZXR1cm4gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5SW50ZXJuYWwuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtvcGVyYXRpb24sXG4gICAgICAgIGRlZmF1bHRQcmludGVyXSwgY29uZmlncywgZmFsc2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbChvcGVyYXRpb24sIHByaW50ZXIpIHtcbiAgICB2YXIgY29uZmlncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNvbmZpZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIGh0dHAgPSB7fTtcbiAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCBjb25maWcub3B0aW9ucyksIHsgaGVhZGVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycyksIGNvbmZpZy5oZWFkZXJzKSB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IGNvbmZpZy5jcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICBodHRwID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGh0dHApLCBjb25maWcuaHR0cCk7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSByZW1vdmVEdXBsaWNhdGVIZWFkZXJzKG9wdGlvbnMuaGVhZGVycywgaHR0cC5wcmVzZXJ2ZUhlYWRlckNhc2UpO1xuICAgIH1cbiAgICAvL1RoZSBib2R5IGRlcGVuZHMgb24gdGhlIGh0dHAgb3B0aW9uc1xuICAgIHZhciBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUsIGV4dGVuc2lvbnMgPSBvcGVyYXRpb24uZXh0ZW5zaW9ucywgdmFyaWFibGVzID0gb3BlcmF0aW9uLnZhcmlhYmxlcywgcXVlcnkgPSBvcGVyYXRpb24ucXVlcnk7XG4gICAgdmFyIGJvZHkgPSB7IG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbk5hbWUsIHZhcmlhYmxlczogdmFyaWFibGVzIH07XG4gICAgaWYgKGh0dHAuaW5jbHVkZUV4dGVuc2lvbnMpXG4gICAgICAgIGJvZHkuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgLy8gbm90IHNlbmRpbmcgdGhlIHF1ZXJ5IChpLmUgcGVyc2lzdGVkIHF1ZXJpZXMpXG4gICAgaWYgKGh0dHAuaW5jbHVkZVF1ZXJ5KVxuICAgICAgICBib2R5LnF1ZXJ5ID0gcHJpbnRlcihxdWVyeSwgcHJpbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgfTtcbn1cbi8vIFJlbW92ZSBwb3RlbnRpYWwgZHVwbGljYXRlIGhlYWRlciBuYW1lcywgcHJlc2VydmluZyBsYXN0IChieSBpbnNlcnRpb24gb3JkZXIpLlxuLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgdW5pbnRlbnRpb25hbGx5IGR1cGxpY2F0aW5nIGEgaGVhZGVyIGluc3RlYWQgb2Zcbi8vIG92ZXJ3cml0aW5nIGl0IChTZWUgIzg0NDcgYW5kICM4NDQ5KS5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZUhlYWRlcnMoaGVhZGVycywgcHJlc2VydmVIZWFkZXJDYXNlKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IHByZXNlcnZpbmcgdGhlIGNhc2UsIGp1c3QgcmVtb3ZlIGR1cGxpY2F0ZXMgdy8gbm9ybWFsaXphdGlvbi5cbiAgICBpZiAoIXByZXNlcnZlSGVhZGVyQ2FzZSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZEhlYWRlcnNfMSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhPYmplY3QoaGVhZGVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzXzFbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEhlYWRlcnNfMTtcbiAgICB9XG4gICAgLy8gSWYgd2UgYXJlIHByZXNlcnZpbmcgdGhlIGNhc2UsIHJlbW92ZSBkdXBsaWNhdGVzIHcvIG5vcm1hbGl6YXRpb24sXG4gICAgLy8gcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAvLyBUaGlzIGFsbG93cyBmb3Igbm9uLWh0dHAtc3BlYy1jb21wbGlhbnQgc2VydmVycyB0aGF0IGV4cGVjdCBpbnRlbnRpb25hbGx5XG4gICAgLy8gY2FwaXRhbGl6ZWQgaGVhZGVyIG5hbWVzIChTZWUgIzY3NDEpLlxuICAgIHZhciBoZWFkZXJEYXRhID0ge307XG4gICAgT2JqZWN0LmtleXMoT2JqZWN0KGhlYWRlcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGhlYWRlckRhdGFbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzW25hbWVdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBub3JtYWxpemVkSGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGhlYWRlckRhdGEpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyRGF0YVtuYW1lXS5vcmlnaW5hbE5hbWVdID0gaGVhZGVyRGF0YVtuYW1lXS52YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9ybWFsaXplZEhlYWRlcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiX19zcHJlYWRBcnJheSIsInByaW50IiwiZGVmYXVsdEh0dHBPcHRpb25zIiwiaW5jbHVkZVF1ZXJ5IiwiaW5jbHVkZUV4dGVuc2lvbnMiLCJwcmVzZXJ2ZUhlYWRlckNhc2UiLCJkZWZhdWx0SGVhZGVycyIsImFjY2VwdCIsImRlZmF1bHRPcHRpb25zIiwibWV0aG9kIiwiZmFsbGJhY2tIdHRwQ29uZmlnIiwiaHR0cCIsImhlYWRlcnMiLCJvcHRpb25zIiwiZGVmYXVsdFByaW50ZXIiLCJhc3QiLCJwcmludGVyIiwic2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5Iiwib3BlcmF0aW9uIiwiZmFsbGJhY2tDb25maWciLCJjb25maWdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bnNoaWZ0Iiwic2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5SW50ZXJuYWwiLCJhcHBseSIsImZvckVhY2giLCJjb25maWciLCJjcmVkZW50aWFscyIsInJlbW92ZUR1cGxpY2F0ZUhlYWRlcnMiLCJvcGVyYXRpb25OYW1lIiwiZXh0ZW5zaW9ucyIsInZhcmlhYmxlcyIsInF1ZXJ5IiwiYm9keSIsIm5vcm1hbGl6ZWRIZWFkZXJzXzEiLCJPYmplY3QiLCJrZXlzIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaGVhZGVyRGF0YSIsIm9yaWdpbmFsTmFtZSIsInZhbHVlIiwibm9ybWFsaXplZEhlYWRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/selectURI.js":
/*!************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/selectURI.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   selectURI: function() { return /* binding */ selectURI; }\n/* harmony export */ });\nvar selectURI = function(operation, fallbackURI) {\n    var context = operation.getContext();\n    var contextURI = context.uri;\n    if (contextURI) {\n        return contextURI;\n    } else if (typeof fallbackURI === \"function\") {\n        return fallbackURI(operation);\n    } else {\n        return fallbackURI || \"/graphql\";\n    }\n}; //# sourceMappingURL=selectURI.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvc2VsZWN0VVJJLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFJQSxZQUFZLFNBQVVDLFNBQVMsRUFBRUMsV0FBVztJQUNuRCxJQUFJQyxVQUFVRixVQUFVRyxVQUFVO0lBQ2xDLElBQUlDLGFBQWFGLFFBQVFHLEdBQUc7SUFDNUIsSUFBSUQsWUFBWTtRQUNaLE9BQU9BO0lBQ1gsT0FDSyxJQUFJLE9BQU9ILGdCQUFnQixZQUFZO1FBQ3hDLE9BQU9BLFlBQVlEO0lBQ3ZCLE9BQ0s7UUFDRCxPQUFPQyxlQUFlO0lBQzFCO0FBQ0osRUFBRSxDQUNGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL3NlbGVjdFVSSS5qcz9mMGZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgc2VsZWN0VVJJID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgZmFsbGJhY2tVUkkpIHtcbiAgICB2YXIgY29udGV4dCA9IG9wZXJhdGlvbi5nZXRDb250ZXh0KCk7XG4gICAgdmFyIGNvbnRleHRVUkkgPSBjb250ZXh0LnVyaTtcbiAgICBpZiAoY29udGV4dFVSSSkge1xuICAgICAgICByZXR1cm4gY29udGV4dFVSSTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrVVJJID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVVJJKG9wZXJhdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tVUkkgfHwgXCIvZ3JhcGhxbFwiO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RVUkkuanMubWFwIl0sIm5hbWVzIjpbInNlbGVjdFVSSSIsIm9wZXJhdGlvbiIsImZhbGxiYWNrVVJJIiwiY29udGV4dCIsImdldENvbnRleHQiLCJjb250ZXh0VVJJIiwidXJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/selectURI.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/http/serializeFetchParameter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/serializeFetchParameter.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serializeFetchParameter: function() { return /* binding */ serializeFetchParameter; }\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\nvar serializeFetchParameter = function(p, label) {\n    var serialized;\n    try {\n        serialized = JSON.stringify(p);\n    } catch (e) {\n        var parseError = (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(40, label, e.message);\n        parseError.parseError = e;\n        throw parseError;\n    }\n    return serialized;\n}; //# sourceMappingURL=serializeFetchParameter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUU7QUFDOUQsSUFBSUMsMEJBQTBCLFNBQVVDLENBQUMsRUFBRUMsS0FBSztJQUNuRCxJQUFJQztJQUNKLElBQUk7UUFDQUEsYUFBYUMsS0FBS0MsU0FBUyxDQUFDSjtJQUNoQyxFQUNBLE9BQU9LLEdBQUc7UUFDTixJQUFJQyxhQUFhUiw4RUFBaUJBLENBQUMsSUFBSUcsT0FBT0ksRUFBRUUsT0FBTztRQUN2REQsV0FBV0EsVUFBVSxHQUFHRDtRQUN4QixNQUFNQztJQUNWO0lBQ0EsT0FBT0o7QUFDWCxFQUFFLENBQ0YsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL2h0dHAvc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIuanM/YmQ2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBuZXdJbnZhcmlhbnRFcnJvciB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuZXhwb3J0IHZhciBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciA9IGZ1bmN0aW9uIChwLCBsYWJlbCkge1xuICAgIHZhciBzZXJpYWxpemVkO1xuICAgIHRyeSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBuZXdJbnZhcmlhbnRFcnJvcig0MCwgbGFiZWwsIGUubWVzc2FnZSk7XG4gICAgICAgIHBhcnNlRXJyb3IucGFyc2VFcnJvciA9IGU7XG4gICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJuZXdJbnZhcmlhbnRFcnJvciIsInNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyIiwicCIsImxhYmVsIiwic2VyaWFsaXplZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwicGFyc2VFcnJvciIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/http/serializeFetchParameter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/createOperation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/createOperation.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOperation: function() { return /* binding */ createOperation; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n\nfunction createOperation(starting, operation) {\n    var context = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, starting);\n    var setContext = function(next) {\n        if (typeof next === \"function\") {\n            context = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, context), next(context));\n        } else {\n            context = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, context), next);\n        }\n    };\n    var getContext = function() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, context);\n    };\n    Object.defineProperty(operation, \"setContext\", {\n        enumerable: false,\n        value: setContext\n    });\n    Object.defineProperty(operation, \"getContext\", {\n        enumerable: false,\n        value: getContext\n    });\n    return operation;\n} //# sourceMappingURL=createOperation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL2NyZWF0ZU9wZXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUMxQixTQUFTQyxnQkFBZ0JDLFFBQVEsRUFBRUMsU0FBUztJQUMvQyxJQUFJQyxVQUFVSiwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdFO0lBQzNCLElBQUlHLGFBQWEsU0FBVUMsSUFBSTtRQUMzQixJQUFJLE9BQU9BLFNBQVMsWUFBWTtZQUM1QkYsVUFBVUosK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR0ksVUFBVUUsS0FBS0Y7UUFDbkQsT0FDSztZQUNEQSxVQUFVSiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHSSxVQUFVRTtRQUM5QztJQUNKO0lBQ0EsSUFBSUMsYUFBYTtRQUFjLE9BQVFQLCtDQUFRQSxDQUFDLENBQUMsR0FBR0k7SUFBVztJQUMvREksT0FBT0MsY0FBYyxDQUFDTixXQUFXLGNBQWM7UUFDM0NPLFlBQVk7UUFDWkMsT0FBT047SUFDWDtJQUNBRyxPQUFPQyxjQUFjLENBQUNOLFdBQVcsY0FBYztRQUMzQ08sWUFBWTtRQUNaQyxPQUFPSjtJQUNYO0lBQ0EsT0FBT0o7QUFDWCxFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay91dGlscy9jcmVhdGVPcGVyYXRpb24uanM/NTMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvbihzdGFydGluZywgb3BlcmF0aW9uKSB7XG4gICAgdmFyIGNvbnRleHQgPSBfX2Fzc2lnbih7fSwgc3RhcnRpbmcpO1xuICAgIHZhciBzZXRDb250ZXh0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIG5leHQoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb250ZXh0KSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBjb250ZXh0KSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wZXJhdGlvbiwgXCJzZXRDb250ZXh0XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZXRDb250ZXh0LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcGVyYXRpb24sIFwiZ2V0Q29udGV4dFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogZ2V0Q29udGV4dCxcbiAgICB9KTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlT3BlcmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsImNyZWF0ZU9wZXJhdGlvbiIsInN0YXJ0aW5nIiwib3BlcmF0aW9uIiwiY29udGV4dCIsInNldENvbnRleHQiLCJuZXh0IiwiZ2V0Q29udGV4dCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/createOperation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/filterOperationVariables.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/filterOperationVariables.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterOperationVariables: function() { return /* binding */ filterOperationVariables; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n\n\nfunction filterOperationVariables(variables, query) {\n    var result = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, variables);\n    var unusedNames = new Set(Object.keys(variables));\n    (0,graphql__WEBPACK_IMPORTED_MODULE_1__.visit)(query, {\n        Variable: function(node, _key, parent) {\n            // A variable type definition at the top level of a query is not\n            // enough to silence server-side errors about the variable being\n            // unused, so variable definitions do not count as usage.\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            if (parent && parent.kind !== \"VariableDefinition\") {\n                unusedNames.delete(node.name.value);\n            }\n        }\n    });\n    unusedNames.forEach(function(name) {\n        delete result[name];\n    });\n    return result;\n} //# sourceMappingURL=filterOperationVariables.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL2ZpbHRlck9wZXJhdGlvblZhcmlhYmxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDRDtBQUN6QixTQUFTRSx5QkFBeUJDLFNBQVMsRUFBRUMsS0FBSztJQUNyRCxJQUFJQyxTQUFTTCwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdHO0lBQzFCLElBQUlHLGNBQWMsSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDTjtJQUN0Q0YsOENBQUtBLENBQUNHLE9BQU87UUFDVE0sVUFBVSxTQUFVQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsTUFBTTtZQUNsQyxnRUFBZ0U7WUFDaEUsZ0VBQWdFO1lBQ2hFLHlEQUF5RDtZQUN6RCx5REFBeUQ7WUFDekQsSUFBSUEsVUFDQUEsT0FBT0MsSUFBSSxLQUFLLHNCQUFzQjtnQkFDdENSLFlBQVlTLE1BQU0sQ0FBQ0osS0FBS0ssSUFBSSxDQUFDQyxLQUFLO1lBQ3RDO1FBQ0o7SUFDSjtJQUNBWCxZQUFZWSxPQUFPLENBQUMsU0FBVUYsSUFBSTtRQUM5QixPQUFPWCxNQUFNLENBQUNXLEtBQUs7SUFDdkI7SUFDQSxPQUFPWDtBQUNYLEVBQ0Esb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL2ZpbHRlck9wZXJhdGlvblZhcmlhYmxlcy5qcz84YWNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gXCJncmFwaHFsXCI7XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyT3BlcmF0aW9uVmFyaWFibGVzKHZhcmlhYmxlcywgcXVlcnkpIHtcbiAgICB2YXIgcmVzdWx0ID0gX19hc3NpZ24oe30sIHZhcmlhYmxlcyk7XG4gICAgdmFyIHVudXNlZE5hbWVzID0gbmV3IFNldChPYmplY3Qua2V5cyh2YXJpYWJsZXMpKTtcbiAgICB2aXNpdChxdWVyeSwge1xuICAgICAgICBWYXJpYWJsZTogZnVuY3Rpb24gKG5vZGUsIF9rZXksIHBhcmVudCkge1xuICAgICAgICAgICAgLy8gQSB2YXJpYWJsZSB0eXBlIGRlZmluaXRpb24gYXQgdGhlIHRvcCBsZXZlbCBvZiBhIHF1ZXJ5IGlzIG5vdFxuICAgICAgICAgICAgLy8gZW5vdWdoIHRvIHNpbGVuY2Ugc2VydmVyLXNpZGUgZXJyb3JzIGFib3V0IHRoZSB2YXJpYWJsZSBiZWluZ1xuICAgICAgICAgICAgLy8gdW51c2VkLCBzbyB2YXJpYWJsZSBkZWZpbml0aW9ucyBkbyBub3QgY291bnQgYXMgdXNhZ2UuXG4gICAgICAgICAgICAvLyBodHRwczovL3NwZWMuZ3JhcGhxbC5vcmcvZHJhZnQvI3NlYy1BbGwtVmFyaWFibGVzLVVzZWRcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQua2luZCAhPT0gXCJWYXJpYWJsZURlZmluaXRpb25cIikge1xuICAgICAgICAgICAgICAgIHVudXNlZE5hbWVzLmRlbGV0ZShub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHVudXNlZE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtuYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyT3BlcmF0aW9uVmFyaWFibGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsInZpc2l0IiwiZmlsdGVyT3BlcmF0aW9uVmFyaWFibGVzIiwidmFyaWFibGVzIiwicXVlcnkiLCJyZXN1bHQiLCJ1bnVzZWROYW1lcyIsIlNldCIsIk9iamVjdCIsImtleXMiLCJWYXJpYWJsZSIsIm5vZGUiLCJfa2V5IiwicGFyZW50Iiwia2luZCIsImRlbGV0ZSIsIm5hbWUiLCJ2YWx1ZSIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/filterOperationVariables.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/fromError.js":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/fromError.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromError: function() { return /* binding */ fromError; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n\nfunction fromError(errorValue) {\n    return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.Observable(function(observer) {\n        observer.error(errorValue);\n    });\n} //# sourceMappingURL=fromError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL2Zyb21FcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzRDtBQUMvQyxTQUFTQyxVQUFVQyxVQUFVO0lBQ2hDLE9BQU8sSUFBSUYsMkRBQVVBLENBQUMsU0FBVUcsUUFBUTtRQUNwQ0EsU0FBU0MsS0FBSyxDQUFDRjtJQUNuQjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL2Zyb21FcnJvci5qcz84ZTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZnJvbUVycm9yKGVycm9yVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yVmFsdWUpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlIiwiZnJvbUVycm9yIiwiZXJyb3JWYWx1ZSIsIm9ic2VydmVyIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/fromError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/throwServerError.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/throwServerError.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   throwServerError: function() { return /* binding */ throwServerError; }\n/* harmony export */ });\nvar throwServerError = function(response, result, message) {\n    var error = new Error(message);\n    error.name = \"ServerError\";\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n}; //# sourceMappingURL=throwServerError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL3Rocm93U2VydmVyRXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUlBLG1CQUFtQixTQUFVQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUM3RCxJQUFJQyxRQUFRLElBQUlDLE1BQU1GO0lBQ3RCQyxNQUFNRSxJQUFJLEdBQUc7SUFDYkYsTUFBTUgsUUFBUSxHQUFHQTtJQUNqQkcsTUFBTUcsVUFBVSxHQUFHTixTQUFTTyxNQUFNO0lBQ2xDSixNQUFNRixNQUFNLEdBQUdBO0lBQ2YsTUFBTUU7QUFDVixFQUFFLENBQ0YsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL3Rocm93U2VydmVyRXJyb3IuanM/NDllZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIHRocm93U2VydmVyRXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3VsdCwgbWVzc2FnZSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5uYW1lID0gXCJTZXJ2ZXJFcnJvclwiO1xuICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgZXJyb3Iuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBlcnJvci5yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3dTZXJ2ZXJFcnJvci5qcy5tYXAiXSwibmFtZXMiOlsidGhyb3dTZXJ2ZXJFcnJvciIsInJlc3BvbnNlIiwicmVzdWx0IiwibWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJuYW1lIiwic3RhdHVzQ29kZSIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/throwServerError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/transformOperation.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/transformOperation.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transformOperation: function() { return /* binding */ transformOperation; }\n/* harmony export */ });\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n\nfunction transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query\n    };\n    // Best guess at an operation name\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName = typeof transformedOperation.query !== \"string\" ? (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_0__.getOperationName)(transformedOperation.query) || undefined : \"\";\n    }\n    return transformedOperation;\n} //# sourceMappingURL=transformOperation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL3RyYW5zZm9ybU9wZXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0RDtBQUNyRCxTQUFTQyxtQkFBbUJDLFNBQVM7SUFDeEMsSUFBSUMsdUJBQXVCO1FBQ3ZCQyxXQUFXRixVQUFVRSxTQUFTLElBQUksQ0FBQztRQUNuQ0MsWUFBWUgsVUFBVUcsVUFBVSxJQUFJLENBQUM7UUFDckNDLGVBQWVKLFVBQVVJLGFBQWE7UUFDdENDLE9BQU9MLFVBQVVLLEtBQUs7SUFDMUI7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSSxDQUFDSixxQkFBcUJHLGFBQWEsRUFBRTtRQUNyQ0gscUJBQXFCRyxhQUFhLEdBQzlCLE9BQU9ILHFCQUFxQkksS0FBSyxLQUFLLFdBQ2xDUCxxRUFBZ0JBLENBQUNHLHFCQUFxQkksS0FBSyxLQUFLQyxZQUM5QztJQUNkO0lBQ0EsT0FBT0w7QUFDWCxFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay91dGlscy90cmFuc2Zvcm1PcGVyYXRpb24uanM/ZWExMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRPcGVyYXRpb25OYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICB2YXIgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgICAgIHZhcmlhYmxlczogb3BlcmF0aW9uLnZhcmlhYmxlcyB8fCB7fSxcbiAgICAgICAgZXh0ZW5zaW9uczogb3BlcmF0aW9uLmV4dGVuc2lvbnMgfHwge30sXG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5vcGVyYXRpb25OYW1lLFxuICAgICAgICBxdWVyeTogb3BlcmF0aW9uLnF1ZXJ5LFxuICAgIH07XG4gICAgLy8gQmVzdCBndWVzcyBhdCBhbiBvcGVyYXRpb24gbmFtZVxuICAgIGlmICghdHJhbnNmb3JtZWRPcGVyYXRpb24ub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vcGVyYXRpb25OYW1lID1cbiAgICAgICAgICAgIHR5cGVvZiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5xdWVyeSAhPT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgZ2V0T3BlcmF0aW9uTmFtZSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5xdWVyeSkgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtZWRPcGVyYXRpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1PcGVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbImdldE9wZXJhdGlvbk5hbWUiLCJ0cmFuc2Zvcm1PcGVyYXRpb24iLCJvcGVyYXRpb24iLCJ0cmFuc2Zvcm1lZE9wZXJhdGlvbiIsInZhcmlhYmxlcyIsImV4dGVuc2lvbnMiLCJvcGVyYXRpb25OYW1lIiwicXVlcnkiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/transformOperation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/link/utils/validateOperation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/validateOperation.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateOperation: function() { return /* binding */ validateOperation; }\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\nfunction validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        \"query\",\n        \"operationName\",\n        \"variables\",\n        \"extensions\",\n        \"context\"\n    ];\n    for(var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++){\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(44, key);\n        }\n    }\n    return operation;\n} //# sourceMappingURL=validateOperation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9saW5rL3V0aWxzL3ZhbGlkYXRlT3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFFO0FBQzlELFNBQVNDLGtCQUFrQkMsU0FBUztJQUN2QyxJQUFJQyxtQkFBbUI7UUFDbkI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsSUFBSyxJQUFJQyxLQUFLLEdBQUdDLEtBQUtDLE9BQU9DLElBQUksQ0FBQ0wsWUFBWUUsS0FBS0MsR0FBR0csTUFBTSxFQUFFSixLQUFNO1FBQ2hFLElBQUlLLE1BQU1KLEVBQUUsQ0FBQ0QsR0FBRztRQUNoQixJQUFJRCxpQkFBaUJPLE9BQU8sQ0FBQ0QsT0FBTyxHQUFHO1lBQ25DLE1BQU1ULDhFQUFpQkEsQ0FBQyxJQUFJUztRQUNoQztJQUNKO0lBQ0EsT0FBT1A7QUFDWCxFQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay91dGlscy92YWxpZGF0ZU9wZXJhdGlvbi5qcz8wZjA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9nbG9iYWxzL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIE9QRVJBVElPTl9GSUVMRFMgPSBbXG4gICAgICAgIFwicXVlcnlcIixcbiAgICAgICAgXCJvcGVyYXRpb25OYW1lXCIsXG4gICAgICAgIFwidmFyaWFibGVzXCIsXG4gICAgICAgIFwiZXh0ZW5zaW9uc1wiLFxuICAgICAgICBcImNvbnRleHRcIixcbiAgICBdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24pOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICBpZiAoT1BFUkFUSU9OX0ZJRUxEUy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXdJbnZhcmlhbnRFcnJvcig0NCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGVPcGVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIm5ld0ludmFyaWFudEVycm9yIiwidmFsaWRhdGVPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJPUEVSQVRJT05fRklFTERTIiwiX2kiLCJfYSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJrZXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/link/utils/validateOperation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloContext.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/react/context/ApolloContext.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var rehackt__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getApolloContext: function() { return /* binding */ getApolloContext; },\n/* harmony export */   resetApolloContext: function() { return /* binding */ resetApolloContext; }\n/* harmony export */ });\n/* harmony import */ var rehackt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rehackt */ \"(app-pages-browser)/./node_modules/rehackt/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\n\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nvar contextKey = _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.canUseSymbol ? Symbol.for(\"__APOLLO_CONTEXT__\") : \"__APOLLO_CONTEXT__\";\nfunction getApolloContext() {\n    (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_1__.invariant)(\"createContext\" in /*#__PURE__*/ (rehackt__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (rehackt__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(rehackt__WEBPACK_IMPORTED_MODULE_0__, 2))), 46);\n    var context = rehackt__WEBPACK_IMPORTED_MODULE_0__.createContext[contextKey];\n    if (!context) {\n        Object.defineProperty(rehackt__WEBPACK_IMPORTED_MODULE_0__.createContext, contextKey, {\n            value: context = rehackt__WEBPACK_IMPORTED_MODULE_0__.createContext({}),\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n        context.displayName = \"ApolloContext\";\n    }\n    return context;\n}\n/**\n * @deprecated This function has no \"resetting\" effect since Apollo Client 3.4.12,\n * and will be removed in the next major version of Apollo Client.\n * If you want to get the Apollo Context, use `getApolloContext` instead.\n */ var resetApolloContext = getApolloContext; //# sourceMappingURL=ApolloContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9jb250ZXh0L0Fwb2xsb0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ3VCO0FBQ0s7QUFDN0Qsd0VBQXdFO0FBQ3hFLDBFQUEwRTtBQUMxRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLElBQUlHLGFBQWFGLDZEQUFZQSxHQUFHRyxPQUFPQyxHQUFHLENBQUMsd0JBQXdCO0FBQzVELFNBQVNDO0lBQ1pKLHNFQUFTQSxDQUFDLGtOQUF3QkYsRUFBRTtJQUNwQyxJQUFJTyxVQUFVUCxrREFBbUIsQ0FBQ0csV0FBVztJQUM3QyxJQUFJLENBQUNJLFNBQVM7UUFDVkUsT0FBT0MsY0FBYyxDQUFDVixrREFBbUIsRUFBRUcsWUFBWTtZQUNuRFEsT0FBUUosVUFBVVAsa0RBQW1CLENBQUMsQ0FBQztZQUN2Q1ksWUFBWTtZQUNaQyxVQUFVO1lBQ1ZDLGNBQWM7UUFDbEI7UUFDQVAsUUFBUVEsV0FBVyxHQUFHO0lBQzFCO0lBQ0EsT0FBT1I7QUFDWDtBQUNBOzs7O0NBSUMsR0FDTSxJQUFJUyxxQkFBcUJWLGlCQUFpQixDQUNqRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3JlYWN0L2NvbnRleHQvQXBvbGxvQ29udGV4dC5qcz9mYzg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWhhY2t0XCI7XG5pbXBvcnQgeyBjYW5Vc2VTeW1ib2wgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbi8vIFRvIG1ha2Ugc3VyZSBBcG9sbG8gQ2xpZW50IGRvZXNuJ3QgY3JlYXRlIG1vcmUgdGhhbiBvbmUgUmVhY3QgY29udGV4dFxuLy8gKHdoaWNoIGNhbiBsZWFkIHRvIHByb2JsZW1zIGxpa2UgaGF2aW5nIGFuIEFwb2xsbyBDbGllbnQgaW5zdGFuY2UgYWRkZWRcbi8vIGluIG9uZSBjb250ZXh0LCB0aGVuIGF0dGVtcHRpbmcgdG8gcmV0cmlldmUgaXQgZnJvbSBhbm90aGVyIGRpZmZlcmVudFxuLy8gY29udGV4dCksIGEgc2luZ2xlIEFwb2xsbyBjb250ZXh0IGlzIGNyZWF0ZWQgYW5kIHRyYWNrZWQgaW4gZ2xvYmFsIHN0YXRlLlxudmFyIGNvbnRleHRLZXkgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKFwiX19BUE9MTE9fQ09OVEVYVF9fXCIpIDogXCJfX0FQT0xMT19DT05URVhUX19cIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcG9sbG9Db250ZXh0KCkge1xuICAgIGludmFyaWFudChcImNyZWF0ZUNvbnRleHRcIiBpbiBSZWFjdCwgNDYpO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dFtjb250ZXh0S2V5XTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0LmNyZWF0ZUNvbnRleHQsIGNvbnRleHRLZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiAoY29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pKSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXBvbGxvQ29udGV4dFwiO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgbm8gXCJyZXNldHRpbmdcIiBlZmZlY3Qgc2luY2UgQXBvbGxvIENsaWVudCAzLjQuMTIsXG4gKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgQXBvbGxvIENsaWVudC5cbiAqIElmIHlvdSB3YW50IHRvIGdldCB0aGUgQXBvbGxvIENvbnRleHQsIHVzZSBgZ2V0QXBvbGxvQ29udGV4dGAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHZhciByZXNldEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBvbGxvQ29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJjYW5Vc2VTeW1ib2wiLCJpbnZhcmlhbnQiLCJjb250ZXh0S2V5IiwiU3ltYm9sIiwiZm9yIiwiZ2V0QXBvbGxvQ29udGV4dCIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImRpc3BsYXlOYW1lIiwicmVzZXRBcG9sbG9Db250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloProvider.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/react/context/ApolloProvider.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloProvider: function() { return /* binding */ ApolloProvider; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var rehackt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rehackt */ \"(app-pages-browser)/./node_modules/rehackt/index.js\");\n/* harmony import */ var _ApolloContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ApolloContext.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloContext.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nvar ApolloProvider = function(_a) {\n    _s();\n    var client = _a.client, children = _a.children;\n    var ApolloContext = (0,_ApolloContext_js__WEBPACK_IMPORTED_MODULE_2__.getApolloContext)();\n    var parentContext = rehackt__WEBPACK_IMPORTED_MODULE_1__.useContext(ApolloContext);\n    var context = rehackt__WEBPACK_IMPORTED_MODULE_1__.useMemo(function() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, parentContext), {\n            client: client || parentContext.client\n        });\n    }, [\n        parentContext,\n        client\n    ]);\n    (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.client, 47);\n    return rehackt__WEBPACK_IMPORTED_MODULE_1__.createElement(ApolloContext.Provider, {\n        value: context\n    }, children);\n}; //# sourceMappingURL=ApolloProvider.js.map\n_s(ApolloProvider, \"ck7GEjiLIKXtOy41mdYuYYszi2A=\");\n_c = ApolloProvider;\nvar _c;\n$RefreshReg$(_c, \"ApolloProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9jb250ZXh0L0Fwb2xsb1Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUM0QjtBQUM1QjtBQUNxQjtBQUMvQyxJQUFJSSxpQkFBaUIsU0FBVUMsRUFBRTs7SUFDcEMsSUFBSUMsU0FBU0QsR0FBR0MsTUFBTSxFQUFFQyxXQUFXRixHQUFHRSxRQUFRO0lBQzlDLElBQUlDLGdCQUFnQkwsbUVBQWdCQTtJQUNwQyxJQUFJTSxnQkFBZ0JQLCtDQUFnQixDQUFDTTtJQUNyQyxJQUFJRyxVQUFVVCw0Q0FBYSxDQUFDO1FBQ3hCLE9BQU9GLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdTLGdCQUFnQjtZQUFFSCxRQUFRQSxVQUFVRyxjQUFjSCxNQUFNO1FBQUM7SUFDMUYsR0FBRztRQUFDRztRQUFlSDtLQUFPO0lBQzFCTCxzRUFBU0EsQ0FBQ1UsUUFBUUwsTUFBTSxFQUFFO0lBQzFCLE9BQVFKLGtEQUFtQixDQUFDTSxjQUFjTSxRQUFRLEVBQUU7UUFBRUMsT0FBT0o7SUFBUSxHQUFHSjtBQUM1RSxFQUFFLENBQ0YsMENBQTBDO0dBVi9CSDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvY29udGV4dC9BcG9sbG9Qcm92aWRlci5qcz9lOTJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWhhY2t0XCI7XG5pbXBvcnQgeyBnZXRBcG9sbG9Db250ZXh0IH0gZnJvbSBcIi4vQXBvbGxvQ29udGV4dC5qc1wiO1xuZXhwb3J0IHZhciBBcG9sbG9Qcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEFwb2xsb0NvbnRleHQpO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCksIHsgY2xpZW50OiBjbGllbnQgfHwgcGFyZW50Q29udGV4dC5jbGllbnQgfSk7XG4gICAgfSwgW3BhcmVudENvbnRleHQsIGNsaWVudF0pO1xuICAgIGludmFyaWFudChjb250ZXh0LmNsaWVudCwgNDcpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChBcG9sbG9Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBvbGxvUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiaW52YXJpYW50IiwiUmVhY3QiLCJnZXRBcG9sbG9Db250ZXh0IiwiQXBvbGxvUHJvdmlkZXIiLCJfYSIsImNsaWVudCIsImNoaWxkcmVuIiwiQXBvbGxvQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJ1c2VDb250ZXh0IiwiY29udGV4dCIsInVzZU1lbW8iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/caching/caches.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoCleanedStrongCache: function() { return /* binding */ AutoCleanedStrongCache; },\n/* harmony export */   AutoCleanedWeakCache: function() { return /* binding */ AutoCleanedWeakCache; }\n/* harmony export */ });\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/weak.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/strong.js\");\n\nvar scheduledCleanup = new WeakSet();\nfunction schedule(cache) {\n    if (cache.size <= (cache.max || -1)) {\n        return;\n    }\n    if (!scheduledCleanup.has(cache)) {\n        scheduledCleanup.add(cache);\n        setTimeout(function() {\n            cache.clean();\n            scheduledCleanup.delete(cache);\n        }, 100);\n    }\n}\n/**\n * @internal\n * A version of WeakCache that will auto-schedule a cleanup of the cache when\n * a new item is added and the cache reached maximum size.\n * Throttled to once per 100ms.\n *\n * @privateRemarks\n * Should be used throughout the rest of the codebase instead of WeakCache,\n * with the notable exception of usage in `wrap` from `optimism` - that one\n * already handles cleanup and should remain a `WeakCache`.\n */ var AutoCleanedWeakCache = function(max, dispose) {\n    /*\n    Some builds of `WeakCache` are function prototypes, some are classes.\n    This library still builds with an ES5 target, so we can't extend the\n    real classes.\n    Instead, we have to use this workaround until we switch to a newer build\n    target.\n    */ var cache = new _wry_caches__WEBPACK_IMPORTED_MODULE_0__.WeakCache(max, dispose);\n    cache.set = function(key, value) {\n        var ret = _wry_caches__WEBPACK_IMPORTED_MODULE_0__.WeakCache.prototype.set.call(this, key, value);\n        schedule(this);\n        return ret;\n    };\n    return cache;\n};\n_c = AutoCleanedWeakCache;\n/**\n * @internal\n * A version of StrongCache that will auto-schedule a cleanup of the cache when\n * a new item is added and the cache reached maximum size.\n * Throttled to once per 100ms.\n *\n * @privateRemarks\n * Should be used throughout the rest of the codebase instead of StrongCache,\n * with the notable exception of usage in `wrap` from `optimism` - that one\n * already handles cleanup and should remain a `StrongCache`.\n */ var AutoCleanedStrongCache = function(max, dispose) {\n    /*\n    Some builds of `StrongCache` are function prototypes, some are classes.\n    This library still builds with an ES5 target, so we can't extend the\n    real classes.\n    Instead, we have to use this workaround until we switch to a newer build\n    target.\n    */ var cache = new _wry_caches__WEBPACK_IMPORTED_MODULE_1__.StrongCache(max, dispose);\n    cache.set = function(key, value) {\n        var ret = _wry_caches__WEBPACK_IMPORTED_MODULE_1__.StrongCache.prototype.set.call(this, key, value);\n        schedule(this);\n        return ret;\n    };\n    return cache;\n}; //# sourceMappingURL=caches.js.map\n_c1 = AutoCleanedStrongCache;\nvar _c, _c1;\n$RefreshReg$(_c, \"AutoCleanedWeakCache\");\n$RefreshReg$(_c1, \"AutoCleanedStrongCache\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY2FjaGluZy9jYWNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRDtBQUNyRCxJQUFJRSxtQkFBbUIsSUFBSUM7QUFDM0IsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixJQUFJQSxNQUFNQyxJQUFJLElBQUtELENBQUFBLE1BQU1FLEdBQUcsSUFBSSxDQUFDLElBQUk7UUFDakM7SUFDSjtJQUNBLElBQUksQ0FBQ0wsaUJBQWlCTSxHQUFHLENBQUNILFFBQVE7UUFDOUJILGlCQUFpQk8sR0FBRyxDQUFDSjtRQUNyQkssV0FBVztZQUNQTCxNQUFNTSxLQUFLO1lBQ1hULGlCQUFpQlUsTUFBTSxDQUFDUDtRQUM1QixHQUFHO0lBQ1A7QUFDSjtBQUNBOzs7Ozs7Ozs7O0NBVUMsR0FDTSxJQUFJUSx1QkFBdUIsU0FBVU4sR0FBRyxFQUFFTyxPQUFPO0lBQ3BEOzs7Ozs7SUFNQSxHQUNBLElBQUlULFFBQVEsSUFBSUwsa0RBQVNBLENBQUNPLEtBQUtPO0lBQy9CVCxNQUFNVSxHQUFHLEdBQUcsU0FBVUMsR0FBRyxFQUFFQyxLQUFLO1FBQzVCLElBQUlDLE1BQU1sQixrREFBU0EsQ0FBQ21CLFNBQVMsQ0FBQ0osR0FBRyxDQUFDSyxJQUFJLENBQUMsSUFBSSxFQUFFSixLQUFLQztRQUNsRGIsU0FBUyxJQUFJO1FBQ2IsT0FBT2M7SUFDWDtJQUNBLE9BQU9iO0FBQ1gsRUFBRTtLQWZTUTtBQWdCWDs7Ozs7Ozs7OztDQVVDLEdBQ00sSUFBSVEseUJBQXlCLFNBQVVkLEdBQUcsRUFBRU8sT0FBTztJQUN0RDs7Ozs7O0lBTUEsR0FDQSxJQUFJVCxRQUFRLElBQUlKLG9EQUFXQSxDQUFDTSxLQUFLTztJQUNqQ1QsTUFBTVUsR0FBRyxHQUFHLFNBQVVDLEdBQUcsRUFBRUMsS0FBSztRQUM1QixJQUFJQyxNQUFNakIsb0RBQVdBLENBQUNrQixTQUFTLENBQUNKLEdBQUcsQ0FBQ0ssSUFBSSxDQUFDLElBQUksRUFBRUosS0FBS0M7UUFDcERiLFNBQVMsSUFBSTtRQUNiLE9BQU9jO0lBQ1g7SUFDQSxPQUFPYjtBQUNYLEVBQUUsQ0FDRixrQ0FBa0M7TUFoQnZCZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9jYWNoaW5nL2NhY2hlcy5qcz8yMTNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlYWtDYWNoZSwgU3Ryb25nQ2FjaGUgfSBmcm9tIFwiQHdyeS9jYWNoZXNcIjtcbnZhciBzY2hlZHVsZWRDbGVhbnVwID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIHNjaGVkdWxlKGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPD0gKGNhY2hlLm1heCB8fCAtMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNjaGVkdWxlZENsZWFudXAuaGFzKGNhY2hlKSkge1xuICAgICAgICBzY2hlZHVsZWRDbGVhbnVwLmFkZChjYWNoZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FjaGUuY2xlYW4oKTtcbiAgICAgICAgICAgIHNjaGVkdWxlZENsZWFudXAuZGVsZXRlKGNhY2hlKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSB2ZXJzaW9uIG9mIFdlYWtDYWNoZSB0aGF0IHdpbGwgYXV0by1zY2hlZHVsZSBhIGNsZWFudXAgb2YgdGhlIGNhY2hlIHdoZW5cbiAqIGEgbmV3IGl0ZW0gaXMgYWRkZWQgYW5kIHRoZSBjYWNoZSByZWFjaGVkIG1heGltdW0gc2l6ZS5cbiAqIFRocm90dGxlZCB0byBvbmNlIHBlciAxMDBtcy5cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFNob3VsZCBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIHJlc3Qgb2YgdGhlIGNvZGViYXNlIGluc3RlYWQgb2YgV2Vha0NhY2hlLFxuICogd2l0aCB0aGUgbm90YWJsZSBleGNlcHRpb24gb2YgdXNhZ2UgaW4gYHdyYXBgIGZyb20gYG9wdGltaXNtYCAtIHRoYXQgb25lXG4gKiBhbHJlYWR5IGhhbmRsZXMgY2xlYW51cCBhbmQgc2hvdWxkIHJlbWFpbiBhIGBXZWFrQ2FjaGVgLlxuICovXG5leHBvcnQgdmFyIEF1dG9DbGVhbmVkV2Vha0NhY2hlID0gZnVuY3Rpb24gKG1heCwgZGlzcG9zZSkge1xuICAgIC8qXG4gICAgU29tZSBidWlsZHMgb2YgYFdlYWtDYWNoZWAgYXJlIGZ1bmN0aW9uIHByb3RvdHlwZXMsIHNvbWUgYXJlIGNsYXNzZXMuXG4gICAgVGhpcyBsaWJyYXJ5IHN0aWxsIGJ1aWxkcyB3aXRoIGFuIEVTNSB0YXJnZXQsIHNvIHdlIGNhbid0IGV4dGVuZCB0aGVcbiAgICByZWFsIGNsYXNzZXMuXG4gICAgSW5zdGVhZCwgd2UgaGF2ZSB0byB1c2UgdGhpcyB3b3JrYXJvdW5kIHVudGlsIHdlIHN3aXRjaCB0byBhIG5ld2VyIGJ1aWxkXG4gICAgdGFyZ2V0LlxuICAgICovXG4gICAgdmFyIGNhY2hlID0gbmV3IFdlYWtDYWNoZShtYXgsIGRpc3Bvc2UpO1xuICAgIGNhY2hlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXQgPSBXZWFrQ2FjaGUucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBzY2hlZHVsZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHJldHVybiBjYWNoZTtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSB2ZXJzaW9uIG9mIFN0cm9uZ0NhY2hlIHRoYXQgd2lsbCBhdXRvLXNjaGVkdWxlIGEgY2xlYW51cCBvZiB0aGUgY2FjaGUgd2hlblxuICogYSBuZXcgaXRlbSBpcyBhZGRlZCBhbmQgdGhlIGNhY2hlIHJlYWNoZWQgbWF4aW11bSBzaXplLlxuICogVGhyb3R0bGVkIHRvIG9uY2UgcGVyIDEwMG1zLlxuICpcbiAqIEBwcml2YXRlUmVtYXJrc1xuICogU2hvdWxkIGJlIHVzZWQgdGhyb3VnaG91dCB0aGUgcmVzdCBvZiB0aGUgY29kZWJhc2UgaW5zdGVhZCBvZiBTdHJvbmdDYWNoZSxcbiAqIHdpdGggdGhlIG5vdGFibGUgZXhjZXB0aW9uIG9mIHVzYWdlIGluIGB3cmFwYCBmcm9tIGBvcHRpbWlzbWAgLSB0aGF0IG9uZVxuICogYWxyZWFkeSBoYW5kbGVzIGNsZWFudXAgYW5kIHNob3VsZCByZW1haW4gYSBgU3Ryb25nQ2FjaGVgLlxuICovXG5leHBvcnQgdmFyIEF1dG9DbGVhbmVkU3Ryb25nQ2FjaGUgPSBmdW5jdGlvbiAobWF4LCBkaXNwb3NlKSB7XG4gICAgLypcbiAgICBTb21lIGJ1aWxkcyBvZiBgU3Ryb25nQ2FjaGVgIGFyZSBmdW5jdGlvbiBwcm90b3R5cGVzLCBzb21lIGFyZSBjbGFzc2VzLlxuICAgIFRoaXMgbGlicmFyeSBzdGlsbCBidWlsZHMgd2l0aCBhbiBFUzUgdGFyZ2V0LCBzbyB3ZSBjYW4ndCBleHRlbmQgdGhlXG4gICAgcmVhbCBjbGFzc2VzLlxuICAgIEluc3RlYWQsIHdlIGhhdmUgdG8gdXNlIHRoaXMgd29ya2Fyb3VuZCB1bnRpbCB3ZSBzd2l0Y2ggdG8gYSBuZXdlciBidWlsZFxuICAgIHRhcmdldC5cbiAgICAqL1xuICAgIHZhciBjYWNoZSA9IG5ldyBTdHJvbmdDYWNoZShtYXgsIGRpc3Bvc2UpO1xuICAgIGNhY2hlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXQgPSBTdHJvbmdDYWNoZS5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHNjaGVkdWxlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgcmV0dXJuIGNhY2hlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlcy5qcy5tYXAiXSwibmFtZXMiOlsiV2Vha0NhY2hlIiwiU3Ryb25nQ2FjaGUiLCJzY2hlZHVsZWRDbGVhbnVwIiwiV2Vha1NldCIsInNjaGVkdWxlIiwiY2FjaGUiLCJzaXplIiwibWF4IiwiaGFzIiwiYWRkIiwic2V0VGltZW91dCIsImNsZWFuIiwiZGVsZXRlIiwiQXV0b0NsZWFuZWRXZWFrQ2FjaGUiLCJkaXNwb3NlIiwic2V0Iiwia2V5IiwidmFsdWUiLCJyZXQiLCJwcm90b3R5cGUiLCJjYWxsIiwiQXV0b0NsZWFuZWRTdHJvbmdDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getApolloCacheMemoryInternals: function() { return /* binding */ getApolloCacheMemoryInternals; },\n/* harmony export */   getApolloClientMemoryInternals: function() { return /* binding */ getApolloClientMemoryInternals; },\n/* harmony export */   getInMemoryCacheMemoryInternals: function() { return /* binding */ getInMemoryCacheMemoryInternals; },\n/* harmony export */   registerGlobalCache: function() { return /* binding */ registerGlobalCache; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _sizes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n\n\nvar globalCaches = {};\nfunction registerGlobalCache(name, getSize) {\n    globalCaches[name] = getSize;\n}\n/**\n * For internal purposes only - please call `ApolloClient.getMemoryInternals` instead\n * @internal\n */ var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : undefined;\n/**\n * For internal purposes only - please call `ApolloClient.getMemoryInternals` instead\n * @internal\n */ var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : undefined;\n/**\n * For internal purposes only - please call `ApolloClient.getMemoryInternals` instead\n * @internal\n */ var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : undefined;\nfunction getCurrentCacheSizes() {\n    // `defaultCacheSizes` is a `const enum` that will be inlined during build, so we have to reconstruct it's shape here\n    var defaults = {\n        parser: 1000 /* defaultCacheSizes[\"parser\"] */ ,\n        canonicalStringify: 1000 /* defaultCacheSizes[\"canonicalStringify\"] */ ,\n        print: 2000 /* defaultCacheSizes[\"print\"] */ ,\n        \"documentTransform.cache\": 2000 /* defaultCacheSizes[\"documentTransform.cache\"] */ ,\n        \"queryManager.getDocumentInfo\": 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */ ,\n        \"PersistedQueryLink.persistedQueryHashes\": 2000 /* defaultCacheSizes[\"PersistedQueryLink.persistedQueryHashes\"] */ ,\n        \"fragmentRegistry.transform\": 2000 /* defaultCacheSizes[\"fragmentRegistry.transform\"] */ ,\n        \"fragmentRegistry.lookup\": 1000 /* defaultCacheSizes[\"fragmentRegistry.lookup\"] */ ,\n        \"fragmentRegistry.findFragmentSpreads\": 4000 /* defaultCacheSizes[\"fragmentRegistry.findFragmentSpreads\"] */ ,\n        \"cache.fragmentQueryDocuments\": 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */ ,\n        \"removeTypenameFromVariables.getVariableDefinitions\": 2000 /* defaultCacheSizes[\"removeTypenameFromVariables.getVariableDefinitions\"] */ ,\n        \"inMemoryCache.maybeBroadcastWatch\": 5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */ ,\n        \"inMemoryCache.executeSelectionSet\": 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */ ,\n        \"inMemoryCache.executeSubSelectedArray\": 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */ \n    };\n    return Object.fromEntries(Object.entries(defaults).map(function(_a) {\n        var k = _a[0], v = _a[1];\n        return [\n            k,\n            _sizes_js__WEBPACK_IMPORTED_MODULE_0__.cacheSizes[k] || v\n        ];\n    }));\n}\nfunction _getApolloClientMemoryInternals() {\n    var _a, _b, _c, _d, _e;\n    if (!(globalThis.__DEV__ !== false)) throw new Error(\"only supported in development mode\");\n    return {\n        limits: getCurrentCacheSizes(),\n        sizes: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n            print: (_a = globalCaches.print) === null || _a === void 0 ? void 0 : _a.call(globalCaches),\n            parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches),\n            canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches),\n            links: linkInfo(this.link),\n            queryManager: {\n                getDocumentInfo: this[\"queryManager\"][\"transformCache\"].size,\n                documentTransforms: transformInfo(this[\"queryManager\"].documentTransform)\n            }\n        }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))\n    };\n}\nfunction _getApolloCacheMemoryInternals() {\n    return {\n        cache: {\n            fragmentQueryDocuments: getWrapperInformation(this[\"getFragmentDoc\"])\n        }\n    };\n}\nfunction _getInMemoryCacheMemoryInternals() {\n    var fragments = this.config.fragments;\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, _getApolloCacheMemoryInternals.apply(this)), {\n        addTypenameDocumentTransform: transformInfo(this[\"addTypenameTransform\"]),\n        inMemoryCache: {\n            executeSelectionSet: getWrapperInformation(this[\"storeReader\"][\"executeSelectionSet\"]),\n            executeSubSelectedArray: getWrapperInformation(this[\"storeReader\"][\"executeSubSelectedArray\"]),\n            maybeBroadcastWatch: getWrapperInformation(this[\"maybeBroadcastWatch\"])\n        },\n        fragmentRegistry: {\n            findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),\n            lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),\n            transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)\n        }\n    });\n}\nfunction isWrapper(f) {\n    return !!f && \"dirtyKey\" in f;\n}\nfunction getWrapperInformation(f) {\n    return isWrapper(f) ? f.size : undefined;\n}\nfunction isDefined(value) {\n    return value != null;\n}\nfunction transformInfo(transform) {\n    return recurseTransformInfo(transform).map(function(cache) {\n        return {\n            cache: cache\n        };\n    });\n}\nfunction recurseTransformInfo(transform) {\n    return transform ? (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n        getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform[\"performWork\"])\n    ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform[\"left\"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform[\"right\"]), true).filter(isDefined) : [];\n}\nfunction linkInfo(link) {\n    var _a;\n    return link ? (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n        (_a = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a === void 0 ? void 0 : _a.call(link)\n    ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];\n} //# sourceMappingURL=getMemoryInternals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY2FjaGluZy9nZXRNZW1vcnlJbnRlcm5hbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdEO0FBQ1I7QUFDeEMsSUFBSUcsZUFBZSxDQUFDO0FBQ2IsU0FBU0Msb0JBQW9CQyxJQUFJLEVBQUVDLE9BQU87SUFDN0NILFlBQVksQ0FBQ0UsS0FBSyxHQUFHQztBQUN6QjtBQUNBOzs7Q0FHQyxHQUNNLElBQUlDLGlDQUFpQ0MsV0FBV0MsT0FBTyxLQUFLLFFBQy9EQyxrQ0FDRUMsVUFBVTtBQUNoQjs7O0NBR0MsR0FDTSxJQUFJQyxrQ0FBa0NKLFdBQVdDLE9BQU8sS0FBSyxRQUNoRUksbUNBQ0VGLFVBQVU7QUFDaEI7OztDQUdDLEdBQ00sSUFBSUcsZ0NBQWdDTixXQUFXQyxPQUFPLEtBQUssUUFDOURNLGlDQUNFSixVQUFVO0FBQ2hCLFNBQVNLO0lBQ0wscUhBQXFIO0lBQ3JILElBQUlDLFdBQVc7UUFDWEMsUUFBUSxLQUFLLCtCQUErQjtRQUM1Q0Msb0JBQW9CLEtBQUssMkNBQTJDO1FBQ3BFQyxPQUFPLEtBQUssOEJBQThCO1FBQzFDLDJCQUEyQixLQUFLLGdEQUFnRDtRQUNoRixnQ0FBZ0MsS0FBSyxxREFBcUQ7UUFDMUYsMkNBQTJDLEtBQUssZ0VBQWdFO1FBQ2hILDhCQUE4QixLQUFLLG1EQUFtRDtRQUN0RiwyQkFBMkIsS0FBSyxnREFBZ0Q7UUFDaEYsd0NBQXdDLEtBQUssNkRBQTZEO1FBQzFHLGdDQUFnQyxLQUFLLHFEQUFxRDtRQUMxRixzREFBc0QsS0FBSywyRUFBMkU7UUFDdEkscUNBQXFDLEtBQUssMERBQTBEO1FBQ3BHLHFDQUFxQyxNQUFNLDBEQUEwRDtRQUNyRyx5Q0FBeUMsTUFBTSw4REFBOEQ7SUFDakg7SUFDQSxPQUFPQyxPQUFPQyxXQUFXLENBQUNELE9BQU9FLE9BQU8sQ0FBQ04sVUFBVU8sR0FBRyxDQUFDLFNBQVVDLEVB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b0IscUJBQXFCTCxTQUFTO0lBQ25DLE9BQU9BLFlBQ0gzRCxvREFBYUEsQ0FBQ0Esb0RBQWFBLENBQUM7UUFDeEIrQyxzQkFBc0JZLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTLENBQUMsY0FBYztLQUN2RyxFQUFFSyxxQkFBcUJMLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTLENBQUMsT0FBTyxHQUFHLE9BQU9LLHFCQUFxQkwsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMsQ0FBQyxRQUFRLEdBQUcsTUFBTU0sTUFBTSxDQUFDSCxhQUNwTixFQUFFO0FBQ1o7QUFDQSxTQUFTMUIsU0FBU0MsSUFBSTtJQUNsQixJQUFJYjtJQUNKLE9BQU9hLE9BQ0hyQyxvREFBYUEsQ0FBQ0Esb0RBQWFBLENBQUM7UUFDdkJ3QixDQUFBQSxLQUFLYSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS1Esa0JBQWtCLE1BQU0sUUFBUXJCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1UsSUFBSSxDQUFDRztLQUMzSCxFQUFFRCxTQUFTQyxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzZCLElBQUksR0FBRyxPQUFPOUIsU0FBU0MsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUs4QixLQUFLLEdBQUcsTUFBTUYsTUFBTSxDQUFDSCxhQUN4SixFQUFFO0FBQ1osRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9jYWNoaW5nL2dldE1lbW9yeUludGVybmFscy5qcz8zMDI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjYWNoZVNpemVzIH0gZnJvbSBcIi4vc2l6ZXMuanNcIjtcbnZhciBnbG9iYWxDYWNoZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlckdsb2JhbENhY2hlKG5hbWUsIGdldFNpemUpIHtcbiAgICBnbG9iYWxDYWNoZXNbbmFtZV0gPSBnZXRTaXplO1xufVxuLyoqXG4gKiBGb3IgaW50ZXJuYWwgcHVycG9zZXMgb25seSAtIHBsZWFzZSBjYWxsIGBBcG9sbG9DbGllbnQuZ2V0TWVtb3J5SW50ZXJuYWxzYCBpbnN0ZWFkXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBnZXRBcG9sbG9DbGllbnRNZW1vcnlJbnRlcm5hbHMgPSBnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlID9cbiAgICBfZ2V0QXBvbGxvQ2xpZW50TWVtb3J5SW50ZXJuYWxzXG4gICAgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEZvciBpbnRlcm5hbCBwdXJwb3NlcyBvbmx5IC0gcGxlYXNlIGNhbGwgYEFwb2xsb0NsaWVudC5nZXRNZW1vcnlJbnRlcm5hbHNgIGluc3RlYWRcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdmFyIGdldEluTWVtb3J5Q2FjaGVNZW1vcnlJbnRlcm5hbHMgPSBnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlID9cbiAgICBfZ2V0SW5NZW1vcnlDYWNoZU1lbW9yeUludGVybmFsc1xuICAgIDogdW5kZWZpbmVkO1xuLyoqXG4gKiBGb3IgaW50ZXJuYWwgcHVycG9zZXMgb25seSAtIHBsZWFzZSBjYWxsIGBBcG9sbG9DbGllbnQuZ2V0TWVtb3J5SW50ZXJuYWxzYCBpbnN0ZWFkXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBnZXRBcG9sbG9DYWNoZU1lbW9yeUludGVybmFscyA9IGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgP1xuICAgIF9nZXRBcG9sbG9DYWNoZU1lbW9yeUludGVybmFsc1xuICAgIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0Q3VycmVudENhY2hlU2l6ZXMoKSB7XG4gICAgLy8gYGRlZmF1bHRDYWNoZVNpemVzYCBpcyBhIGBjb25zdCBlbnVtYCB0aGF0IHdpbGwgYmUgaW5saW5lZCBkdXJpbmcgYnVpbGQsIHNvIHdlIGhhdmUgdG8gcmVjb25zdHJ1Y3QgaXQncyBzaGFwZSBoZXJlXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBwYXJzZXI6IDEwMDAgLyogZGVmYXVsdENhY2hlU2l6ZXNbXCJwYXJzZXJcIl0gKi8sXG4gICAgICAgIGNhbm9uaWNhbFN0cmluZ2lmeTogMTAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImNhbm9uaWNhbFN0cmluZ2lmeVwiXSAqLyxcbiAgICAgICAgcHJpbnQ6IDIwMDAgLyogZGVmYXVsdENhY2hlU2l6ZXNbXCJwcmludFwiXSAqLyxcbiAgICAgICAgXCJkb2N1bWVudFRyYW5zZm9ybS5jYWNoZVwiOiAyMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiZG9jdW1lbnRUcmFuc2Zvcm0uY2FjaGVcIl0gKi8sXG4gICAgICAgIFwicXVlcnlNYW5hZ2VyLmdldERvY3VtZW50SW5mb1wiOiAyMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wicXVlcnlNYW5hZ2VyLmdldERvY3VtZW50SW5mb1wiXSAqLyxcbiAgICAgICAgXCJQZXJzaXN0ZWRRdWVyeUxpbmsucGVyc2lzdGVkUXVlcnlIYXNoZXNcIjogMjAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcIlBlcnNpc3RlZFF1ZXJ5TGluay5wZXJzaXN0ZWRRdWVyeUhhc2hlc1wiXSAqLyxcbiAgICAgICAgXCJmcmFnbWVudFJlZ2lzdHJ5LnRyYW5zZm9ybVwiOiAyMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiZnJhZ21lbnRSZWdpc3RyeS50cmFuc2Zvcm1cIl0gKi8sXG4gICAgICAgIFwiZnJhZ21lbnRSZWdpc3RyeS5sb29rdXBcIjogMTAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImZyYWdtZW50UmVnaXN0cnkubG9va3VwXCJdICovLFxuICAgICAgICBcImZyYWdtZW50UmVnaXN0cnkuZmluZEZyYWdtZW50U3ByZWFkc1wiOiA0MDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiZnJhZ21lbnRSZWdpc3RyeS5maW5kRnJhZ21lbnRTcHJlYWRzXCJdICovLFxuICAgICAgICBcImNhY2hlLmZyYWdtZW50UXVlcnlEb2N1bWVudHNcIjogMTAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImNhY2hlLmZyYWdtZW50UXVlcnlEb2N1bWVudHNcIl0gKi8sXG4gICAgICAgIFwicmVtb3ZlVHlwZW5hbWVGcm9tVmFyaWFibGVzLmdldFZhcmlhYmxlRGVmaW5pdGlvbnNcIjogMjAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcInJlbW92ZVR5cGVuYW1lRnJvbVZhcmlhYmxlcy5nZXRWYXJpYWJsZURlZmluaXRpb25zXCJdICovLFxuICAgICAgICBcImluTWVtb3J5Q2FjaGUubWF5YmVCcm9hZGNhc3RXYXRjaFwiOiA1MDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiaW5NZW1vcnlDYWNoZS5tYXliZUJyb2FkY2FzdFdhdGNoXCJdICovLFxuICAgICAgICBcImluTWVtb3J5Q2FjaGUuZXhlY3V0ZVNlbGVjdGlvblNldFwiOiA1MDAwMCAvKiBkZWZhdWx0Q2FjaGVTaXplc1tcImluTWVtb3J5Q2FjaGUuZXhlY3V0ZVNlbGVjdGlvblNldFwiXSAqLyxcbiAgICAgICAgXCJpbk1lbW9yeUNhY2hlLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5XCI6IDEwMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzW1wiaW5NZW1vcnlDYWNoZS5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheVwiXSAqLyxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGVmYXVsdHMpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGsgPSBfYVswXSwgdiA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGNhY2hlU2l6ZXNba10gfHwgdixcbiAgICAgICAgXTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBfZ2V0QXBvbGxvQ2xpZW50TWVtb3J5SW50ZXJuYWxzKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgaWYgKCEoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGltaXRzOiBnZXRDdXJyZW50Q2FjaGVTaXplcygpLFxuICAgICAgICBzaXplczogX19hc3NpZ24oeyBwcmludDogKF9hID0gZ2xvYmFsQ2FjaGVzLnByaW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChnbG9iYWxDYWNoZXMpLCBwYXJzZXI6IChfYiA9IGdsb2JhbENhY2hlcy5wYXJzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGdsb2JhbENhY2hlcyksIGNhbm9uaWNhbFN0cmluZ2lmeTogKF9jID0gZ2xvYmFsQ2FjaGVzLmNhbm9uaWNhbFN0cmluZ2lmeSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoZ2xvYmFsQ2FjaGVzKSwgbGlua3M6IGxpbmtJbmZvKHRoaXMubGluayksIHF1ZXJ5TWFuYWdlcjoge1xuICAgICAgICAgICAgICAgIGdldERvY3VtZW50SW5mbzogdGhpc1tcInF1ZXJ5TWFuYWdlclwiXVtcInRyYW5zZm9ybUNhY2hlXCJdLnNpemUsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRUcmFuc2Zvcm1zOiB0cmFuc2Zvcm1JbmZvKHRoaXNbXCJxdWVyeU1hbmFnZXJcIl0uZG9jdW1lbnRUcmFuc2Zvcm0pLFxuICAgICAgICAgICAgfSB9LCAoX2UgPSAoX2QgPSB0aGlzLmNhY2hlKS5nZXRNZW1vcnlJbnRlcm5hbHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9nZXRBcG9sbG9DYWNoZU1lbW9yeUludGVybmFscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgZnJhZ21lbnRRdWVyeURvY3VtZW50czogZ2V0V3JhcHBlckluZm9ybWF0aW9uKHRoaXNbXCJnZXRGcmFnbWVudERvY1wiXSksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9nZXRJbk1lbW9yeUNhY2hlTWVtb3J5SW50ZXJuYWxzKCkge1xuICAgIHZhciBmcmFnbWVudHMgPSB0aGlzLmNvbmZpZy5mcmFnbWVudHM7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBfZ2V0QXBvbGxvQ2FjaGVNZW1vcnlJbnRlcm5hbHMuYXBwbHkodGhpcykpLCB7IGFkZFR5cGVuYW1lRG9jdW1lbnRUcmFuc2Zvcm06IHRyYW5zZm9ybUluZm8odGhpc1tcImFkZFR5cGVuYW1lVHJhbnNmb3JtXCJdKSwgaW5NZW1vcnlDYWNoZToge1xuICAgICAgICAgICAgZXhlY3V0ZVNlbGVjdGlvblNldDogZ2V0V3JhcHBlckluZm9ybWF0aW9uKHRoaXNbXCJzdG9yZVJlYWRlclwiXVtcImV4ZWN1dGVTZWxlY3Rpb25TZXRcIl0pLFxuICAgICAgICAgICAgZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXk6IGdldFdyYXBwZXJJbmZvcm1hdGlvbih0aGlzW1wic3RvcmVSZWFkZXJcIl1bXCJleGVjdXRlU3ViU2VsZWN0ZWRBcnJheVwiXSksXG4gICAgICAgICAgICBtYXliZUJyb2FkY2FzdFdhdGNoOiBnZXRXcmFwcGVySW5mb3JtYXRpb24odGhpc1tcIm1heWJlQnJvYWRjYXN0V2F0Y2hcIl0pLFxuICAgICAgICB9LCBmcmFnbWVudFJlZ2lzdHJ5OiB7XG4gICAgICAgICAgICBmaW5kRnJhZ21lbnRTcHJlYWRzOiBnZXRXcmFwcGVySW5mb3JtYXRpb24oZnJhZ21lbnRzID09PSBudWxsIHx8IGZyYWdtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJhZ21lbnRzLmZpbmRGcmFnbWVudFNwcmVhZHMpLFxuICAgICAgICAgICAgbG9va3VwOiBnZXRXcmFwcGVySW5mb3JtYXRpb24oZnJhZ21lbnRzID09PSBudWxsIHx8IGZyYWdtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJhZ21lbnRzLmxvb2t1cCksXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGdldFdyYXBwZXJJbmZvcm1hdGlvbihmcmFnbWVudHMgPT09IG51bGwgfHwgZnJhZ21lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcmFnbWVudHMudHJhbnNmb3JtKSxcbiAgICAgICAgfSB9KTtcbn1cbmZ1bmN0aW9uIGlzV3JhcHBlcihmKSB7XG4gICAgcmV0dXJuICEhZiAmJiBcImRpcnR5S2V5XCIgaW4gZjtcbn1cbmZ1bmN0aW9uIGdldFdyYXBwZXJJbmZvcm1hdGlvbihmKSB7XG4gICAgcmV0dXJuIGlzV3JhcHBlcihmKSA/IGYuc2l6ZSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSW5mbyh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gcmVjdXJzZVRyYW5zZm9ybUluZm8odHJhbnNmb3JtKS5tYXAoZnVuY3Rpb24gKGNhY2hlKSB7IHJldHVybiAoeyBjYWNoZTogY2FjaGUgfSk7IH0pO1xufVxuZnVuY3Rpb24gcmVjdXJzZVRyYW5zZm9ybUluZm8odHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA/XG4gICAgICAgIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICBnZXRXcmFwcGVySW5mb3JtYXRpb24odHJhbnNmb3JtID09PSBudWxsIHx8IHRyYW5zZm9ybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtW1wicGVyZm9ybVdvcmtcIl0pXG4gICAgICAgIF0sIHJlY3Vyc2VUcmFuc2Zvcm1JbmZvKHRyYW5zZm9ybSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVtcImxlZnRcIl0pLCB0cnVlKSwgcmVjdXJzZVRyYW5zZm9ybUluZm8odHJhbnNmb3JtID09PSBudWxsIHx8IHRyYW5zZm9ybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtW1wicmlnaHRcIl0pLCB0cnVlKS5maWx0ZXIoaXNEZWZpbmVkKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gbGlua0luZm8obGluaykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbGluayA/XG4gICAgICAgIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAoX2EgPSBsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsuZ2V0TWVtb3J5SW50ZXJuYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaW5rKVxuICAgICAgICBdLCBsaW5rSW5mbyhsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsubGVmdCksIHRydWUpLCBsaW5rSW5mbyhsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsucmlnaHQpLCB0cnVlKS5maWx0ZXIoaXNEZWZpbmVkKVxuICAgICAgICA6IFtdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TWVtb3J5SW50ZXJuYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fc3ByZWFkQXJyYXkiLCJjYWNoZVNpemVzIiwiZ2xvYmFsQ2FjaGVzIiwicmVnaXN0ZXJHbG9iYWxDYWNoZSIsIm5hbWUiLCJnZXRTaXplIiwiZ2V0QXBvbGxvQ2xpZW50TWVtb3J5SW50ZXJuYWxzIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJfZ2V0QXBvbGxvQ2xpZW50TWVtb3J5SW50ZXJuYWxzIiwidW5kZWZpbmVkIiwiZ2V0SW5NZW1vcnlDYWNoZU1lbW9yeUludGVybmFscyIsIl9nZXRJbk1lbW9yeUNhY2hlTWVtb3J5SW50ZXJuYWxzIiwiZ2V0QXBvbGxvQ2FjaGVNZW1vcnlJbnRlcm5hbHMiLCJfZ2V0QXBvbGxvQ2FjaGVNZW1vcnlJbnRlcm5hbHMiLCJnZXRDdXJyZW50Q2FjaGVTaXplcyIsImRlZmF1bHRzIiwicGFyc2VyIiwiY2Fub25pY2FsU3RyaW5naWZ5IiwicHJpbnQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJfYSIsImsiLCJ2IiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJFcnJvciIsImxpbWl0cyIsInNpemVzIiwiY2FsbCIsImxpbmtzIiwibGlua0luZm8iLCJsaW5rIiwicXVlcnlNYW5hZ2VyIiwiZ2V0RG9jdW1lbnRJbmZvIiwic2l6ZSIsImRvY3VtZW50VHJhbnNmb3JtcyIsInRyYW5zZm9ybUluZm8iLCJkb2N1bWVudFRyYW5zZm9ybSIsImNhY2hlIiwiZ2V0TWVtb3J5SW50ZXJuYWxzIiwiZnJhZ21lbnRRdWVyeURvY3VtZW50cyIsImdldFdyYXBwZXJJbmZvcm1hdGlvbiIsImZyYWdtZW50cyIsImNvbmZpZyIsImFwcGx5IiwiYWRkVHlwZW5hbWVEb2N1bWVudFRyYW5zZm9ybSIsImluTWVtb3J5Q2FjaGUiLCJleGVjdXRlU2VsZWN0aW9uU2V0IiwiZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkiLCJtYXliZUJyb2FkY2FzdFdhdGNoIiwiZnJhZ21lbnRSZWdpc3RyeSIsImZpbmRGcmFnbWVudFNwcmVhZHMiLCJsb29rdXAiLCJ0cmFuc2Zvcm0iLCJpc1dyYXBwZXIiLCJmIiwiaXNEZWZpbmVkIiwidmFsdWUiLCJyZWN1cnNlVHJhbnNmb3JtSW5mbyIsImZpbHRlciIsImxlZnQiLCJyaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/caching/sizes.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheSizes: function() { return /* binding */ cacheSizes; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\n\nvar cacheSizeSymbol = Symbol.for(\"apollo.cacheSize\");\n/**\n *\n * The global cache size configuration for Apollo Client.\n *\n * @remarks\n *\n * You can directly modify this object, but any modification will\n * only have an effect on caches that are created after the modification.\n *\n * So for global caches, such as `parser`, `canonicalStringify` and `print`,\n * you might need to call `.reset` on them, which will essentially re-create them.\n *\n * Alternatively, you can set `globalThis[Symbol.for(\"apollo.cacheSize\")]` before\n * you load the Apollo Client package:\n *\n * @example\n * ```ts\n * globalThis[Symbol.for(\"apollo.cacheSize\")] = {\n *   parser: 100\n * } satisfies Partial<CacheSizes> // the `satisfies` is optional if using TypeScript\n * ```\n */ var cacheSizes = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.global[cacheSizeSymbol]); //# sourceMappingURL=sizes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY2FjaGluZy9zaXplcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDWTtBQUM3QyxJQUFJRSxrQkFBa0JDLE9BQU9DLEdBQUcsQ0FBQztBQUNqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sSUFBSUMsYUFBYUwsK0NBQVFBLENBQUMsQ0FBQyxHQUFHQyxxREFBTSxDQUFDQyxnQkFBZ0IsRUFBRSxDQUM5RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9jYWNoaW5nL3NpemVzLmpzPzMzNWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gXCIuLi9nbG9iYWxzL2luZGV4LmpzXCI7XG52YXIgY2FjaGVTaXplU3ltYm9sID0gU3ltYm9sLmZvcihcImFwb2xsby5jYWNoZVNpemVcIik7XG4vKipcbiAqXG4gKiBUaGUgZ2xvYmFsIGNhY2hlIHNpemUgY29uZmlndXJhdGlvbiBmb3IgQXBvbGxvIENsaWVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFlvdSBjYW4gZGlyZWN0bHkgbW9kaWZ5IHRoaXMgb2JqZWN0LCBidXQgYW55IG1vZGlmaWNhdGlvbiB3aWxsXG4gKiBvbmx5IGhhdmUgYW4gZWZmZWN0IG9uIGNhY2hlcyB0aGF0IGFyZSBjcmVhdGVkIGFmdGVyIHRoZSBtb2RpZmljYXRpb24uXG4gKlxuICogU28gZm9yIGdsb2JhbCBjYWNoZXMsIHN1Y2ggYXMgYHBhcnNlcmAsIGBjYW5vbmljYWxTdHJpbmdpZnlgIGFuZCBgcHJpbnRgLFxuICogeW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgLnJlc2V0YCBvbiB0aGVtLCB3aGljaCB3aWxsIGVzc2VudGlhbGx5IHJlLWNyZWF0ZSB0aGVtLlxuICpcbiAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gc2V0IGBnbG9iYWxUaGlzW1N5bWJvbC5mb3IoXCJhcG9sbG8uY2FjaGVTaXplXCIpXWAgYmVmb3JlXG4gKiB5b3UgbG9hZCB0aGUgQXBvbGxvIENsaWVudCBwYWNrYWdlOlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogZ2xvYmFsVGhpc1tTeW1ib2wuZm9yKFwiYXBvbGxvLmNhY2hlU2l6ZVwiKV0gPSB7XG4gKiAgIHBhcnNlcjogMTAwXG4gKiB9IHNhdGlzZmllcyBQYXJ0aWFsPENhY2hlU2l6ZXM+IC8vIHRoZSBgc2F0aXNmaWVzYCBpcyBvcHRpb25hbCBpZiB1c2luZyBUeXBlU2NyaXB0XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHZhciBjYWNoZVNpemVzID0gX19hc3NpZ24oe30sIGdsb2JhbFtjYWNoZVNpemVTeW1ib2xdKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemVzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsImdsb2JhbCIsImNhY2hlU2l6ZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsImNhY2hlU2l6ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/arrays.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: function() { return /* binding */ isArray; },\n/* harmony export */   isNonEmptyArray: function() { return /* binding */ isNonEmptyArray; }\n/* harmony export */ });\n// A version of Array.isArray that works better with readonly arrays.\nvar isArray = Array.isArray;\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n} //# sourceMappingURL=arrays.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2FycmF5cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFFQUFxRTtBQUM5RCxJQUFJQSxVQUFVQyxNQUFNRCxPQUFPLENBQUM7QUFDNUIsU0FBU0UsZ0JBQWdCQyxLQUFLO0lBQ2pDLE9BQU9GLE1BQU1ELE9BQU8sQ0FBQ0csVUFBVUEsTUFBTUMsTUFBTSxHQUFHO0FBQ2xELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2FycmF5cy5qcz80ZGZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgdmVyc2lvbiBvZiBBcnJheS5pc0FycmF5IHRoYXQgd29ya3MgYmV0dGVyIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuZXhwb3J0IHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5cy5qcy5tYXAiXSwibmFtZXMiOlsiaXNBcnJheSIsIkFycmF5IiwiaXNOb25FbXB0eUFycmF5IiwidmFsdWUiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/canUse.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canUseAsyncIteratorSymbol: function() { return /* binding */ canUseAsyncIteratorSymbol; },\n/* harmony export */   canUseDOM: function() { return /* binding */ canUseDOM; },\n/* harmony export */   canUseLayoutEffect: function() { return /* binding */ canUseLayoutEffect; },\n/* harmony export */   canUseSymbol: function() { return /* binding */ canUseSymbol; },\n/* harmony export */   canUseWeakMap: function() { return /* binding */ canUseWeakMap; },\n/* harmony export */   canUseWeakSet: function() { return /* binding */ canUseWeakSet; }\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\nvar isReactNative = (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return navigator.product;\n}) == \"ReactNative\";\nvar canUseWeakMap = typeof WeakMap === \"function\" && !(isReactNative && !global.HermesInternal);\nvar canUseWeakSet = typeof WeakSet === \"function\";\nvar canUseSymbol = typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\nvar canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\nvar canUseDOM = typeof (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return window.document.createElement;\n}) === \"function\";\nvar usingJSDOM = // Following advice found in this comment from @domenic (maintainer of jsdom):\n// https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n//\n// Since we control the version of Jest and jsdom used when running Apollo\n// Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n// at the end of the user agent string, I believe this case is all we need to\n// check. Testing for \"Node.js\" was recommended for backwards compatibility\n// with older version of jsdom, but we don't have that problem.\n(0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return navigator.userAgent.indexOf(\"jsdom\") >= 0;\n}) || false;\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nvar canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM; //# sourceMappingURL=canUse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2NhblVzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRDO0FBQzVDLElBQUlDLGdCQUFnQkQsd0RBQUtBLENBQUM7SUFBYyxPQUFPRSxVQUFVQyxPQUFPO0FBQUUsTUFBTTtBQUNqRSxJQUFJQyxnQkFBZ0IsT0FBT0MsWUFBWSxjQUMxQyxDQUFFSixDQUFBQSxpQkFBaUIsQ0FBQ0ssT0FBT0MsY0FBYyxFQUFFO0FBQ3hDLElBQUlDLGdCQUFnQixPQUFPQyxZQUFZLFdBQVc7QUFDbEQsSUFBSUMsZUFBZSxPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsR0FBRyxLQUFLLFdBQVc7QUFDcEYsSUFBSUMsNEJBQTRCSCxnQkFBZ0JDLE9BQU9HLGFBQWEsQ0FBQztBQUNyRSxJQUFJQyxZQUFZLE9BQU9mLHdEQUFLQSxDQUFDO0lBQWMsT0FBT2dCLE9BQU9DLFFBQVEsQ0FBQ0MsYUFBYTtBQUFFLE9BQU8sV0FBVztBQUMxRyxJQUFJQyxhQUNKLDhFQUE4RTtBQUM5RSxvRUFBb0U7QUFDcEUsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLDJFQUEyRTtBQUMzRSwrREFBK0Q7QUFDL0RuQix3REFBS0EsQ0FBQztJQUFjLE9BQU9FLFVBQVVrQixTQUFTLENBQUNDLE9BQU8sQ0FBQyxZQUFZO0FBQUcsTUFBTTtBQUM1RSxzRUFBc0U7QUFDdEUsK0VBQStFO0FBQy9FLHdFQUF3RTtBQUN4RSwwRUFBMEU7QUFDMUUsZ0ZBQWdGO0FBQ2hGLGlFQUFpRTtBQUMxRCxJQUFJQyxxQkFBcUIsQ0FBQ1AsYUFBYWQsYUFBWSxLQUFNLENBQUNrQixXQUFXLENBQzVFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2NvbW1vbi9jYW5Vc2UuanM/MGY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXliZSB9IGZyb20gXCIuLi9nbG9iYWxzL2luZGV4LmpzXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0OyB9KSA9PSBcIlJlYWN0TmF0aXZlXCI7XG5leHBvcnQgdmFyIGNhblVzZVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgIShpc1JlYWN0TmF0aXZlICYmICFnbG9iYWwuSGVybWVzSW50ZXJuYWwpO1xuZXhwb3J0IHZhciBjYW5Vc2VXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCB2YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnQgdmFyIGNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wgPSBjYW5Vc2VTeW1ib2wgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG5leHBvcnQgdmFyIGNhblVzZURPTSA9IHR5cGVvZiBtYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudDsgfSkgPT09IFwiZnVuY3Rpb25cIjtcbnZhciB1c2luZ0pTRE9NID0gXG4vLyBGb2xsb3dpbmcgYWR2aWNlIGZvdW5kIGluIHRoaXMgY29tbWVudCBmcm9tIEBkb21lbmljIChtYWludGFpbmVyIG9mIGpzZG9tKTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2RvbS9qc2RvbS9pc3N1ZXMvMTUzNyNpc3N1ZWNvbW1lbnQtMjI5NDA1MzI3XG4vL1xuLy8gU2luY2Ugd2UgY29udHJvbCB0aGUgdmVyc2lvbiBvZiBKZXN0IGFuZCBqc2RvbSB1c2VkIHdoZW4gcnVubmluZyBBcG9sbG9cbi8vIENsaWVudCB0ZXN0cywgYW5kIHRoYXQgdmVyc2lvbiBpcyByZWNlbnQgZW5vdWdodCB0byBpbmNsdWRlIFwiIGpzZG9tL3gueS56XCJcbi8vIGF0IHRoZSBlbmQgb2YgdGhlIHVzZXIgYWdlbnQgc3RyaW5nLCBJIGJlbGlldmUgdGhpcyBjYXNlIGlzIGFsbCB3ZSBuZWVkIHRvXG4vLyBjaGVjay4gVGVzdGluZyBmb3IgXCJOb2RlLmpzXCIgd2FzIHJlY29tbWVuZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuLy8gd2l0aCBvbGRlciB2ZXJzaW9uIG9mIGpzZG9tLCBidXQgd2UgZG9uJ3QgaGF2ZSB0aGF0IHByb2JsZW0uXG5tYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJqc2RvbVwiKSA+PSAwOyB9KSB8fCBmYWxzZTtcbi8vIE91ciB0ZXN0cyBzaG91bGQgYWxsIGNvbnRpbnVlIHRvIHBhc3MgaWYgd2UgcmVtb3ZlIHRoaXMgIXVzaW5nSlNET01cbi8vIGNvbmRpdGlvbiwgdGhlcmVieSBhbGxvd2luZyB1c2VMYXlvdXRFZmZlY3Qgd2hlbiB1c2luZyBqc2RvbS4gVW5mb3J0dW5hdGVseSxcbi8vIGlmIHdlIGFsbG93IHVzZUxheW91dEVmZmVjdCwgdGhlbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBnZW5lcmF0ZXMgbWFueVxuLy8gd2FybmluZ3MgYWJvdXQgdXNlTGF5b3V0RWZmZWN0IGRvaW5nIG5vdGhpbmcgb24gdGhlIHNlcnZlci4gV2hpbGUgdGhlc2Vcbi8vIHdhcm5pbmdzIGFyZSBoYXJtbGVzcywgdGhpcyAhdXNpbmdKU0RPTSBjb25kaXRpb24gc2VlbXMgdG8gYmUgdGhlIGJlc3Qgd2F5IHRvXG4vLyBwcmV2ZW50IHRoZW0gKGkuZS4gc2tpcHBpbmcgdXNlTGF5b3V0RWZmZWN0IHdoZW4gdXNpbmcganNkb20pLlxuZXhwb3J0IHZhciBjYW5Vc2VMYXlvdXRFZmZlY3QgPSAoY2FuVXNlRE9NIHx8IGlzUmVhY3ROYXRpdmUpICYmICF1c2luZ0pTRE9NO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXNlLmpzLm1hcCJdLCJuYW1lcyI6WyJtYXliZSIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiY2FuVXNlV2Vha01hcCIsIldlYWtNYXAiLCJnbG9iYWwiLCJIZXJtZXNJbnRlcm5hbCIsImNhblVzZVdlYWtTZXQiLCJXZWFrU2V0IiwiY2FuVXNlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1c2luZ0pTRE9NIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImNhblVzZUxheW91dEVmZmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/canonicalStringify.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalStringify: function() { return /* binding */ canonicalStringify; }\n/* harmony export */ });\n/* harmony import */ var _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js\");\n/* harmony import */ var _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n\n\n/**\n * Like JSON.stringify, but with object keys always sorted in the same order.\n *\n * To achieve performant sorting, this function uses a Map from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little bit more memory for every\n * object encountered that has different (more, less, a different order of) keys\n * than in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem, so we provide\n * canonicalStringify.reset() as a way of clearing the cache.\n * */ var canonicalStringify = Object.assign(function canonicalStringify(value) {\n    return JSON.stringify(value, stableObjectReplacer);\n}, {\n    reset: function() {\n        // Clearing the sortingMap will reclaim all cached memory, without\n        // affecting the logical results of canonicalStringify, but potentially\n        // sacrificing performance until the cache is refilled.\n        sortingMap = new _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_0__.AutoCleanedStrongCache(_utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_1__.cacheSizes.canonicalStringify || 1000 /* defaultCacheSizes.canonicalStringify */ );\n    }\n});\nif (globalThis.__DEV__ !== false) {\n    (0,_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_2__.registerGlobalCache)(\"canonicalStringify\", function() {\n        return sortingMap.size;\n    });\n}\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nvar sortingMap;\ncanonicalStringify.reset();\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key, value) {\n    if (value && typeof value === \"object\") {\n        var proto = Object.getPrototypeOf(value);\n        // We don't want to mess with objects that are not \"plain\" objects, which\n        // means their prototype is either Object.prototype or null. This check also\n        // prevents needlessly rearranging the indices of arrays.\n        if (proto === Object.prototype || proto === null) {\n            var keys = Object.keys(value);\n            // If keys is already sorted, let JSON.stringify serialize the original\n            // value instead of creating a new object with keys in the same order.\n            if (keys.every(everyKeyInOrder)) return value;\n            var unsortedKey = JSON.stringify(keys);\n            var sortedKeys = sortingMap.get(unsortedKey);\n            if (!sortedKeys) {\n                keys.sort();\n                var sortedKey = JSON.stringify(keys);\n                // Checking for sortedKey in the sortingMap allows us to share the same\n                // sorted array reference for all permutations of the same set of keys.\n                sortedKeys = sortingMap.get(sortedKey) || keys;\n                sortingMap.set(unsortedKey, sortedKeys);\n                sortingMap.set(sortedKey, sortedKeys);\n            }\n            var sortedObject_1 = Object.create(proto);\n            // Reassigning the keys in sorted order will cause JSON.stringify to\n            // serialize them in sorted order.\n            sortedKeys.forEach(function(key) {\n                sortedObject_1[key] = value[key];\n            });\n            return sortedObject_1;\n        }\n    }\n    return value;\n}\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(key, i, keys) {\n    return i === 0 || keys[i - 1] <= key;\n} //# sourceMappingURL=canonicalStringify.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Nhbm9uaWNhbFN0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVGO0FBQ2hCO0FBQ3ZFOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHLEdBQ0ksSUFBSUcscUJBQXFCQyxPQUFPQyxNQUFNLENBQUMsU0FBU0YsbUJBQW1CRyxLQUFLO0lBQzNFLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0YsT0FBT0c7QUFDakMsR0FBRztJQUNDQyxPQUFPO1FBQ0gsa0VBQWtFO1FBQ2xFLHVFQUF1RTtRQUN2RSx1REFBdUQ7UUFDdkRDLGFBQWEsSUFBSVgsK0VBQXNCQSxDQUFDQyxtRUFBVUEsQ0FBQ0Usa0JBQWtCLElBQUksS0FBSyx3Q0FBd0M7SUFDMUg7QUFDSixHQUFHO0FBQ0gsSUFBSVMsV0FBV0MsT0FBTyxLQUFLLE9BQU87SUFDOUJYLG1GQUFtQkEsQ0FBQyxzQkFBc0I7UUFBYyxPQUFPUyxXQUFXRyxJQUFJO0lBQUU7QUFDcEY7QUFDQSw4RUFBOEU7QUFDOUUsc0NBQXNDO0FBQ3RDLElBQUlIO0FBQ0pSLG1CQUFtQk8sS0FBSztBQUN4Qix5RUFBeUU7QUFDekUsNEVBQTRFO0FBQzVFLHdFQUF3RTtBQUN4RSw4RUFBOEU7QUFDOUUscUVBQXFFO0FBQ3JFLHlIQUF5SDtBQUN6SCxTQUFTRCxxQkFBcUJNLEdBQUcsRUFBRVQsS0FBSztJQUNwQyxJQUFJQSxTQUFTLE9BQU9BLFVBQVUsVUFBVTtRQUNwQyxJQUFJVSxRQUFRWixPQUFPYSxjQUFjLENBQUNYO1FBQ2xDLHlFQUF5RTtRQUN6RSw0RUFBNEU7UUFDNUUseURBQXlEO1FBQ3pELElBQUlVLFVBQVVaLE9BQU9jLFNBQVMsSUFBSUYsVUFBVSxNQUFNO1lBQzlDLElBQUlHLE9BQU9mLE9BQU9lLElBQUksQ0FBQ2I7WUFDdkIsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSxJQUFJYSxLQUFLQyxLQUFLLENBQUNDLGtCQUNYLE9BQU9mO1lBQ1gsSUFBSWdCLGNBQWNmLEtBQUtDLFNBQVMsQ0FBQ1c7WUFDakMsSUFBSUksYUFBYVosV0FBV2EsR0FBRyxDQUFDRjtZQUNoQyxJQUFJLENBQUNDLFlBQVk7Z0JBQ2JKLEtBQUtNLElBQUk7Z0JBQ1QsSUFBSUMsWUFBWW5CLEtBQUtDLFNBQVMsQ0FBQ1c7Z0JBQy9CLHVFQUF1RTtnQkFDdkUsdUVBQXVFO2dCQUN2RUksYUFBYVosV0FBV2EsR0FBRyxDQUFDRSxjQUFjUDtnQkFDMUNSLFdBQVdnQixHQUFHLENBQUNMLGFBQWFDO2dCQUM1QlosV0FBV2dCLEdBQUcsQ0FBQ0QsV0FBV0g7WUFDOUI7WUFDQSxJQUFJSyxpQkFBaUJ4QixPQUFPeUIsTUFBTSxDQUFDYjtZQUNuQyxvRUFBb0U7WUFDcEUsa0NBQWtDO1lBQ2xDTyxXQUFXTyxPQUFPLENBQUMsU0FBVWYsR0FBRztnQkFDNUJhLGNBQWMsQ0FBQ2IsSUFBSSxHQUFHVCxLQUFLLENBQUNTLElBQUk7WUFDcEM7WUFDQSxPQUFPYTtRQUNYO0lBQ0o7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLCtFQUErRTtBQUMvRSxzRUFBc0U7QUFDdEUsOEVBQThFO0FBQzlFLDBDQUEwQztBQUMxQyxTQUFTZSxnQkFBZ0JOLEdBQUcsRUFBRWdCLENBQUMsRUFBRVosSUFBSTtJQUNqQyxPQUFPWSxNQUFNLEtBQUtaLElBQUksQ0FBQ1ksSUFBSSxFQUFFLElBQUloQjtBQUNyQyxFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2NvbW1vbi9jYW5vbmljYWxTdHJpbmdpZnkuanM/NjRkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdXRvQ2xlYW5lZFN0cm9uZ0NhY2hlLCBjYWNoZVNpemVzLCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvY2FjaGluZy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVnaXN0ZXJHbG9iYWxDYWNoZSB9IGZyb20gXCIuLi9jYWNoaW5nL2dldE1lbW9yeUludGVybmFscy5qc1wiO1xuLyoqXG4gKiBMaWtlIEpTT04uc3RyaW5naWZ5LCBidXQgd2l0aCBvYmplY3Qga2V5cyBhbHdheXMgc29ydGVkIGluIHRoZSBzYW1lIG9yZGVyLlxuICpcbiAqIFRvIGFjaGlldmUgcGVyZm9ybWFudCBzb3J0aW5nLCB0aGlzIGZ1bmN0aW9uIHVzZXMgYSBNYXAgZnJvbSBKU09OLXNlcmlhbGl6ZWRcbiAqIGFycmF5cyBvZiBrZXlzIChpbiBhbnkgb3JkZXIpIHRvIHNvcnRlZCBhcnJheXMgb2YgdGhlIHNhbWUga2V5cywgd2l0aCBhXG4gKiBzaW5nbGUgc29ydGVkIGFycmF5IHJlZmVyZW5jZSBzaGFyZWQgYnkgYWxsIHBlcm11dGF0aW9ucyBvZiB0aGUga2V5cy5cbiAqXG4gKiBBcyBhIGRyYXdiYWNrLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGEgbGl0dGxlIGJpdCBtb3JlIG1lbW9yeSBmb3IgZXZlcnlcbiAqIG9iamVjdCBlbmNvdW50ZXJlZCB0aGF0IGhhcyBkaWZmZXJlbnQgKG1vcmUsIGxlc3MsIGEgZGlmZmVyZW50IG9yZGVyIG9mKSBrZXlzXG4gKiB0aGFuIGluIHRoZSBwYXN0LlxuICpcbiAqIEluIGEgdHlwaWNhbCBhcHBsaWNhdGlvbiwgdGhpcyBleHRyYSBtZW1vcnkgdXNhZ2Ugc2hvdWxkIG5vdCBwbGF5IGFcbiAqIHNpZ25pZmljYW50IHJvbGUsIGFzIGBjYW5vbmljYWxTdHJpbmdpZnlgIHdpbGwgYmUgY2FsbGVkIGZvciBvbmx5IGEgbGltaXRlZFxuICogbnVtYmVyIG9mIG9iamVjdCBzaGFwZXMsIGFuZCB0aGUgY2FjaGUgd2lsbCBub3QgZ3JvdyBiZXlvbmQgYSBjZXJ0YWluIHBvaW50LlxuICogQnV0IGluIHNvbWUgZWRnZSBjYXNlcywgdGhpcyBjb3VsZCBiZSBhIHByb2JsZW0sIHNvIHdlIHByb3ZpZGVcbiAqIGNhbm9uaWNhbFN0cmluZ2lmeS5yZXNldCgpIGFzIGEgd2F5IG9mIGNsZWFyaW5nIHRoZSBjYWNoZS5cbiAqICovXG5leHBvcnQgdmFyIGNhbm9uaWNhbFN0cmluZ2lmeSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gY2Fub25pY2FsU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBzdGFibGVPYmplY3RSZXBsYWNlcik7XG59LCB7XG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2xlYXJpbmcgdGhlIHNvcnRpbmdNYXAgd2lsbCByZWNsYWltIGFsbCBjYWNoZWQgbWVtb3J5LCB3aXRob3V0XG4gICAgICAgIC8vIGFmZmVjdGluZyB0aGUgbG9naWNhbCByZXN1bHRzIG9mIGNhbm9uaWNhbFN0cmluZ2lmeSwgYnV0IHBvdGVudGlhbGx5XG4gICAgICAgIC8vIHNhY3JpZmljaW5nIHBlcmZvcm1hbmNlIHVudGlsIHRoZSBjYWNoZSBpcyByZWZpbGxlZC5cbiAgICAgICAgc29ydGluZ01hcCA9IG5ldyBBdXRvQ2xlYW5lZFN0cm9uZ0NhY2hlKGNhY2hlU2l6ZXMuY2Fub25pY2FsU3RyaW5naWZ5IHx8IDEwMDAgLyogZGVmYXVsdENhY2hlU2l6ZXMuY2Fub25pY2FsU3RyaW5naWZ5ICovKTtcbiAgICB9LFxufSk7XG5pZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgIHJlZ2lzdGVyR2xvYmFsQ2FjaGUoXCJjYW5vbmljYWxTdHJpbmdpZnlcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ydGluZ01hcC5zaXplOyB9KTtcbn1cbi8vIFZhbHVlcyBhcmUgSlNPTi1zZXJpYWxpemVkIGFycmF5cyBvZiBvYmplY3Qga2V5cyAoaW4gYW55IG9yZGVyKSwgYW5kIHZhbHVlc1xuLy8gYXJlIHNvcnRlZCBhcnJheXMgb2YgdGhlIHNhbWUga2V5cy5cbnZhciBzb3J0aW5nTWFwO1xuY2Fub25pY2FsU3RyaW5naWZ5LnJlc2V0KCk7XG4vLyBUaGUgSlNPTi5zdHJpbmdpZnkgZnVuY3Rpb24gdGFrZXMgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IGNhbGxlZCBhXG4vLyByZXBsYWNlciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgaW4gdGhlXG4vLyBvYmplY3QgYmVpbmcgc3RyaW5naWZpZWQsIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGVcbi8vIG9yaWdpbmFsIHZhbHVlLiBJZiB0aGUgcmVwbGFjZXIgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyB2YWx1ZSwgdGhhdCB2YWx1ZSBpc1xuLy8gc3RyaW5naWZpZWQgYXMgSlNPTiBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSN0aGVfcmVwbGFjZXJfcGFyYW1ldGVyXG5mdW5jdGlvbiBzdGFibGVPYmplY3RSZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG1lc3Mgd2l0aCBvYmplY3RzIHRoYXQgYXJlIG5vdCBcInBsYWluXCIgb2JqZWN0cywgd2hpY2hcbiAgICAgICAgLy8gbWVhbnMgdGhlaXIgcHJvdG90eXBlIGlzIGVpdGhlciBPYmplY3QucHJvdG90eXBlIG9yIG51bGwuIFRoaXMgY2hlY2sgYWxzb1xuICAgICAgICAvLyBwcmV2ZW50cyBuZWVkbGVzc2x5IHJlYXJyYW5naW5nIHRoZSBpbmRpY2VzIG9mIGFycmF5cy5cbiAgICAgICAgaWYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIElmIGtleXMgaXMgYWxyZWFkeSBzb3J0ZWQsIGxldCBKU09OLnN0cmluZ2lmeSBzZXJpYWxpemUgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyB2YWx1ZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aXRoIGtleXMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICBpZiAoa2V5cy5ldmVyeShldmVyeUtleUluT3JkZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHZhciB1bnNvcnRlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleXMpO1xuICAgICAgICAgICAgdmFyIHNvcnRlZEtleXMgPSBzb3J0aW5nTWFwLmdldCh1bnNvcnRlZEtleSk7XG4gICAgICAgICAgICBpZiAoIXNvcnRlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydGVkS2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5cyk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIHNvcnRlZEtleSBpbiB0aGUgc29ydGluZ01hcCBhbGxvd3MgdXMgdG8gc2hhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyBzb3J0ZWQgYXJyYXkgcmVmZXJlbmNlIGZvciBhbGwgcGVybXV0YXRpb25zIG9mIHRoZSBzYW1lIHNldCBvZiBrZXlzLlxuICAgICAgICAgICAgICAgIHNvcnRlZEtleXMgPSBzb3J0aW5nTWFwLmdldChzb3J0ZWRLZXkpIHx8IGtleXM7XG4gICAgICAgICAgICAgICAgc29ydGluZ01hcC5zZXQodW5zb3J0ZWRLZXksIHNvcnRlZEtleXMpO1xuICAgICAgICAgICAgICAgIHNvcnRpbmdNYXAuc2V0KHNvcnRlZEtleSwgc29ydGVkS2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29ydGVkT2JqZWN0XzEgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgIC8vIFJlYXNzaWduaW5nIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlciB3aWxsIGNhdXNlIEpTT04uc3RyaW5naWZ5IHRvXG4gICAgICAgICAgICAvLyBzZXJpYWxpemUgdGhlbSBpbiBzb3J0ZWQgb3JkZXIuXG4gICAgICAgICAgICBzb3J0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHNvcnRlZE9iamVjdF8xW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkT2JqZWN0XzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gU2luY2UgZXZlcnl0aGluZyB0aGF0IGhhcHBlbnMgaW4gc3RhYmxlT2JqZWN0UmVwbGFjZXIgYmVuZWZpdHMgZnJvbSBiZWluZyBhc1xuLy8gZWZmaWNpZW50IGFzIHBvc3NpYmxlLCB3ZSB1c2UgYSBzdGF0aWMgZnVuY3Rpb24gYXMgdGhlIGNhbGxiYWNrIGZvclxuLy8ga2V5cy5ldmVyeSBpbiBvcmRlciB0byB0ZXN0IGlmIHRoZSBwcm92aWRlZCBrZXlzIGFyZSBhbHJlYWR5IHNvcnRlZCB3aXRob3V0XG4vLyBhbGxvY2F0aW5nIGV4dHJhIG1lbW9yeSBmb3IgYSBjYWxsYmFjay5cbmZ1bmN0aW9uIGV2ZXJ5S2V5SW5PcmRlcihrZXksIGksIGtleXMpIHtcbiAgICByZXR1cm4gaSA9PT0gMCB8fCBrZXlzW2kgLSAxXSA8PSBrZXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5vbmljYWxTdHJpbmdpZnkuanMubWFwIl0sIm5hbWVzIjpbIkF1dG9DbGVhbmVkU3Ryb25nQ2FjaGUiLCJjYWNoZVNpemVzIiwicmVnaXN0ZXJHbG9iYWxDYWNoZSIsImNhbm9uaWNhbFN0cmluZ2lmeSIsIk9iamVjdCIsImFzc2lnbiIsInZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YWJsZU9iamVjdFJlcGxhY2VyIiwicmVzZXQiLCJzb3J0aW5nTWFwIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJzaXplIiwia2V5IiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImtleXMiLCJldmVyeSIsImV2ZXJ5S2V5SW5PcmRlciIsInVuc29ydGVkS2V5Iiwic29ydGVkS2V5cyIsImdldCIsInNvcnQiLCJzb3J0ZWRLZXkiLCJzZXQiLCJzb3J0ZWRPYmplY3RfMSIsImNyZWF0ZSIsImZvckVhY2giLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/cloneDeep.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneDeep: function() { return /* binding */ cloneDeep; }\n/* harmony export */ });\nvar toString = Object.prototype.toString;\n/**\n * Deeply clones a value to create a new instance.\n */ function cloneDeep(value) {\n    return cloneDeepHelper(value);\n}\nfunction cloneDeepHelper(val, seen) {\n    switch(toString.call(val)){\n        case \"[object Array]\":\n            {\n                seen = seen || new Map();\n                if (seen.has(val)) return seen.get(val);\n                var copy_1 = val.slice(0);\n                seen.set(val, copy_1);\n                copy_1.forEach(function(child, i) {\n                    copy_1[i] = cloneDeepHelper(child, seen);\n                });\n                return copy_1;\n            }\n        case \"[object Object]\":\n            {\n                seen = seen || new Map();\n                if (seen.has(val)) return seen.get(val);\n                // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n                // possible in all JS environments, so we will assume they exist/work.\n                var copy_2 = Object.create(Object.getPrototypeOf(val));\n                seen.set(val, copy_2);\n                Object.keys(val).forEach(function(key) {\n                    copy_2[key] = cloneDeepHelper(val[key], seen);\n                });\n                return copy_2;\n            }\n        default:\n            return val;\n    }\n} //# sourceMappingURL=cloneDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Nsb25lRGVlcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsV0FBV0MsT0FBT0MsU0FBUyxDQUFDRixRQUFRO0FBQ3hDOztDQUVDLEdBQ00sU0FBU0csVUFBVUMsS0FBSztJQUMzQixPQUFPQyxnQkFBZ0JEO0FBQzNCO0FBQ0EsU0FBU0MsZ0JBQWdCQyxHQUFHLEVBQUVDLElBQUk7SUFDOUIsT0FBUVAsU0FBU1EsSUFBSSxDQUFDRjtRQUNsQixLQUFLO1lBQWtCO2dCQUNuQkMsT0FBT0EsUUFBUSxJQUFJRTtnQkFDbkIsSUFBSUYsS0FBS0csR0FBRyxDQUFDSixNQUNULE9BQU9DLEtBQUtJLEdBQUcsQ0FBQ0w7Z0JBQ3BCLElBQUlNLFNBQVNOLElBQUlPLEtBQUssQ0FBQztnQkFDdkJOLEtBQUtPLEdBQUcsQ0FBQ1IsS0FBS007Z0JBQ2RBLE9BQU9HLE9BQU8sQ0FBQyxTQUFVQyxLQUFLLEVBQUVDLENBQUM7b0JBQzdCTCxNQUFNLENBQUNLLEVBQUUsR0FBR1osZ0JBQWdCVyxPQUFPVDtnQkFDdkM7Z0JBQ0EsT0FBT0s7WUFDWDtRQUNBLEtBQUs7WUFBbUI7Z0JBQ3BCTCxPQUFPQSxRQUFRLElBQUlFO2dCQUNuQixJQUFJRixLQUFLRyxHQUFHLENBQUNKLE1BQ1QsT0FBT0MsS0FBS0ksR0FBRyxDQUFDTDtnQkFDcEIseUVBQXlFO2dCQUN6RSxzRUFBc0U7Z0JBQ3RFLElBQUlZLFNBQVNqQixPQUFPa0IsTUFBTSxDQUFDbEIsT0FBT21CLGNBQWMsQ0FBQ2Q7Z0JBQ2pEQyxLQUFLTyxHQUFHLENBQUNSLEtBQUtZO2dCQUNkakIsT0FBT29CLElBQUksQ0FBQ2YsS0FBS1MsT0FBTyxDQUFDLFNBQVVPLEdBQUc7b0JBQ2xDSixNQUFNLENBQUNJLElBQUksR0FBR2pCLGdCQUFnQkMsR0FBRyxDQUFDZ0IsSUFBSSxFQUFFZjtnQkFDNUM7Z0JBQ0EsT0FBT1c7WUFDWDtRQUNBO1lBQ0ksT0FBT1o7SUFDZjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Nsb25lRGVlcC5qcz84ODQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vKipcbiAqIERlZXBseSBjbG9uZXMgYSB2YWx1ZSB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwSGVscGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcEhlbHBlcih2YWwsIHNlZW4pIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjoge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uZ2V0KHZhbCk7XG4gICAgICAgICAgICB2YXIgY29weV8xID0gdmFsLnNsaWNlKDApO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzEpO1xuICAgICAgICAgICAgY29weV8xLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICAgICAgY29weV8xW2ldID0gY2xvbmVEZWVwSGVscGVyKGNoaWxkLCBzZWVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlfMTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6IHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgLy8gSGlnaCBmaWRlbGl0eSBwb2x5ZmlsbHMgb2YgT2JqZWN0LmNyZWF0ZSBhbmQgT2JqZWN0LmdldFByb3RvdHlwZU9mIGFyZVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaW4gYWxsIEpTIGVudmlyb25tZW50cywgc28gd2Ugd2lsbCBhc3N1bWUgdGhleSBleGlzdC93b3JrLlxuICAgICAgICAgICAgdmFyIGNvcHlfMiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkpO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzJba2V5XSA9IGNsb25lRGVlcEhlbHBlcih2YWxba2V5XSwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVEZWVwLmpzLm1hcCJdLCJuYW1lcyI6WyJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImNsb25lRGVlcCIsInZhbHVlIiwiY2xvbmVEZWVwSGVscGVyIiwidmFsIiwic2VlbiIsImNhbGwiLCJNYXAiLCJoYXMiLCJnZXQiLCJjb3B5XzEiLCJzbGljZSIsInNldCIsImZvckVhY2giLCJjaGlsZCIsImkiLCJjb3B5XzIiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImtleXMiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/compact.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compact: function() { return /* binding */ compact; }\n/* harmony export */ });\n/**\n * Merges the provided objects shallowly and removes\n * all properties with an `undefined` value\n */ function compact() {\n    var objects = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        objects[_i] = arguments[_i];\n    }\n    var result = Object.create(null);\n    objects.forEach(function(obj) {\n        if (!obj) return;\n        Object.keys(obj).forEach(function(key) {\n            var value = obj[key];\n            if (value !== void 0) {\n                result[key] = value;\n            }\n        });\n    });\n    return result;\n} //# sourceMappingURL=compact.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2NvbXBhY3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUNNLFNBQVNBO0lBQ1osSUFBSUMsVUFBVSxFQUFFO0lBQ2hCLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLQyxVQUFVQyxNQUFNLEVBQUVGLEtBQU07UUFDMUNELE9BQU8sQ0FBQ0MsR0FBRyxHQUFHQyxTQUFTLENBQUNELEdBQUc7SUFDL0I7SUFDQSxJQUFJRyxTQUFTQyxPQUFPQyxNQUFNLENBQUM7SUFDM0JOLFFBQVFPLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1FBQ3pCLElBQUksQ0FBQ0EsS0FDRDtRQUNKSCxPQUFPSSxJQUFJLENBQUNELEtBQUtELE9BQU8sQ0FBQyxTQUFVRyxHQUFHO1lBQ2xDLElBQUlDLFFBQVFILEdBQUcsQ0FBQ0UsSUFBSTtZQUNwQixJQUFJQyxVQUFVLEtBQUssR0FBRztnQkFDbEJQLE1BQU0sQ0FBQ00sSUFBSSxHQUFHQztZQUNsQjtRQUNKO0lBQ0o7SUFDQSxPQUFPUDtBQUNYLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2NvbXBhY3QuanM/NmU2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1lcmdlcyB0aGUgcHJvdmlkZWQgb2JqZWN0cyBzaGFsbG93bHkgYW5kIHJlbW92ZXNcbiAqIGFsbCBwcm9wZXJ0aWVzIHdpdGggYW4gYHVuZGVmaW5lZGAgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QoKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJjb21wYWN0Iiwib2JqZWN0cyIsIl9pIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicmVzdWx0IiwiT2JqZWN0IiwiY3JlYXRlIiwiZm9yRWFjaCIsIm9iaiIsImtleXMiLCJrZXkiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/errorHandling.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/errorHandling.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getGraphQLErrorsFromResult: function() { return /* binding */ getGraphQLErrorsFromResult; },\n/* harmony export */   graphQLResultHasError: function() { return /* binding */ graphQLResultHasError; }\n/* harmony export */ });\n/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrays.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _incrementalResult_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./incrementalResult.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js\");\n\n\nfunction graphQLResultHasError(result) {\n    var errors = getGraphQLErrorsFromResult(result);\n    return (0,_arrays_js__WEBPACK_IMPORTED_MODULE_0__.isNonEmptyArray)(errors);\n}\nfunction getGraphQLErrorsFromResult(result) {\n    var graphQLErrors = (0,_arrays_js__WEBPACK_IMPORTED_MODULE_0__.isNonEmptyArray)(result.errors) ? result.errors.slice(0) : [];\n    if ((0,_incrementalResult_js__WEBPACK_IMPORTED_MODULE_1__.isExecutionPatchIncrementalResult)(result) && (0,_arrays_js__WEBPACK_IMPORTED_MODULE_0__.isNonEmptyArray)(result.incremental)) {\n        result.incremental.forEach(function(incrementalResult) {\n            if (incrementalResult.errors) {\n                graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);\n            }\n        });\n    }\n    return graphQLErrors;\n} //# sourceMappingURL=errorHandling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Vycm9ySGFuZGxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUM2QjtBQUNwRSxTQUFTRSxzQkFBc0JDLE1BQU07SUFDeEMsSUFBSUMsU0FBU0MsMkJBQTJCRjtJQUN4QyxPQUFPSCwyREFBZUEsQ0FBQ0k7QUFDM0I7QUFDTyxTQUFTQywyQkFBMkJGLE1BQU07SUFDN0MsSUFBSUcsZ0JBQWdCTiwyREFBZUEsQ0FBQ0csT0FBT0MsTUFBTSxJQUFJRCxPQUFPQyxNQUFNLENBQUNHLEtBQUssQ0FBQyxLQUFLLEVBQUU7SUFDaEYsSUFBSU4sd0ZBQWlDQSxDQUFDRSxXQUNsQ0gsMkRBQWVBLENBQUNHLE9BQU9LLFdBQVcsR0FBRztRQUNyQ0wsT0FBT0ssV0FBVyxDQUFDQyxPQUFPLENBQUMsU0FBVUMsaUJBQWlCO1lBQ2xELElBQUlBLGtCQUFrQk4sTUFBTSxFQUFFO2dCQUMxQkUsY0FBY0ssSUFBSSxDQUFDQyxLQUFLLENBQUNOLGVBQWVJLGtCQUFrQk4sTUFBTTtZQUNwRTtRQUNKO0lBQ0o7SUFDQSxPQUFPRTtBQUNYLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Vycm9ySGFuZGxpbmcuanM/N2VmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vbkVtcHR5QXJyYXkgfSBmcm9tIFwiLi9hcnJheXMuanNcIjtcbmltcG9ydCB7IGlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdCB9IGZyb20gXCIuL2luY3JlbWVudGFsUmVzdWx0LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCkge1xuICAgIHZhciBlcnJvcnMgPSBnZXRHcmFwaFFMRXJyb3JzRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgIHJldHVybiBpc05vbkVtcHR5QXJyYXkoZXJyb3JzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmFwaFFMRXJyb3JzRnJvbVJlc3VsdChyZXN1bHQpIHtcbiAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IGlzTm9uRW1wdHlBcnJheShyZXN1bHQuZXJyb3JzKSA/IHJlc3VsdC5lcnJvcnMuc2xpY2UoMCkgOiBbXTtcbiAgICBpZiAoaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0KHJlc3VsdCkgJiZcbiAgICAgICAgaXNOb25FbXB0eUFycmF5KHJlc3VsdC5pbmNyZW1lbnRhbCkpIHtcbiAgICAgICAgcmVzdWx0LmluY3JlbWVudGFsLmZvckVhY2goZnVuY3Rpb24gKGluY3JlbWVudGFsUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50YWxSZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9ycy5wdXNoLmFwcGx5KGdyYXBoUUxFcnJvcnMsIGluY3JlbWVudGFsUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhRTEVycm9ycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ySGFuZGxpbmcuanMubWFwIl0sIm5hbWVzIjpbImlzTm9uRW1wdHlBcnJheSIsImlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdCIsImdyYXBoUUxSZXN1bHRIYXNFcnJvciIsInJlc3VsdCIsImVycm9ycyIsImdldEdyYXBoUUxFcnJvcnNGcm9tUmVzdWx0IiwiZ3JhcGhRTEVycm9ycyIsInNsaWNlIiwiaW5jcmVtZW50YWwiLCJmb3JFYWNoIiwiaW5jcmVtZW50YWxSZXN1bHQiLCJwdXNoIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/errorHandling.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/incrementalResult.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isApolloPayloadResult: function() { return /* binding */ isApolloPayloadResult; },\n/* harmony export */   isExecutionPatchIncrementalResult: function() { return /* binding */ isExecutionPatchIncrementalResult; },\n/* harmony export */   isExecutionPatchInitialResult: function() { return /* binding */ isExecutionPatchInitialResult; },\n/* harmony export */   isExecutionPatchResult: function() { return /* binding */ isExecutionPatchResult; },\n/* harmony export */   mergeIncrementalData: function() { return /* binding */ mergeIncrementalData; }\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arrays.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _mergeDeep_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeep.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\");\n\n\n\nfunction isExecutionPatchIncrementalResult(value) {\n    return \"incremental\" in value;\n}\nfunction isExecutionPatchInitialResult(value) {\n    return \"hasNext\" in value && \"data\" in value;\n}\nfunction isExecutionPatchResult(value) {\n    return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);\n}\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nfunction isApolloPayloadResult(value) {\n    return (0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(value) && \"payload\" in value;\n}\nfunction mergeIncrementalData(prevResult, result) {\n    var mergedData = prevResult;\n    var merger = new _mergeDeep_js__WEBPACK_IMPORTED_MODULE_1__.DeepMerger();\n    if (isExecutionPatchIncrementalResult(result) && (0,_arrays_js__WEBPACK_IMPORTED_MODULE_2__.isNonEmptyArray)(result.incremental)) {\n        result.incremental.forEach(function(_a) {\n            var data = _a.data, path = _a.path;\n            for(var i = path.length - 1; i >= 0; --i){\n                var key = path[i];\n                var isNumericKey = !isNaN(+key);\n                var parent_1 = isNumericKey ? [] : {};\n                parent_1[key] = data;\n                data = parent_1;\n            }\n            mergedData = merger.merge(mergedData, data);\n        });\n    }\n    return mergedData;\n} //# sourceMappingURL=incrementalResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2luY3JlbWVudGFsUmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ0Q7QUFDRjtBQUNyQyxTQUFTRyxrQ0FBa0NDLEtBQUs7SUFDbkQsT0FBTyxpQkFBaUJBO0FBQzVCO0FBQ08sU0FBU0MsOEJBQThCRCxLQUFLO0lBQy9DLE9BQU8sYUFBYUEsU0FBUyxVQUFVQTtBQUMzQztBQUNPLFNBQVNFLHVCQUF1QkYsS0FBSztJQUN4QyxPQUFRRCxrQ0FBa0NDLFVBQ3RDQyw4QkFBOEJEO0FBQ3RDO0FBQ0EsMEVBQTBFO0FBQzFFLDJFQUEyRTtBQUMzRSxpQ0FBaUM7QUFDMUIsU0FBU0csc0JBQXNCSCxLQUFLO0lBQ3ZDLE9BQU9KLDREQUFlQSxDQUFDSSxVQUFVLGFBQWFBO0FBQ2xEO0FBQ08sU0FBU0kscUJBQXFCQyxVQUFVLEVBQUVDLE1BQU07SUFDbkQsSUFBSUMsYUFBYUY7SUFDakIsSUFBSUcsU0FBUyxJQUFJVixxREFBVUE7SUFDM0IsSUFBSUMsa0NBQWtDTyxXQUNsQ1QsMkRBQWVBLENBQUNTLE9BQU9HLFdBQVcsR0FBRztRQUNyQ0gsT0FBT0csV0FBVyxDQUFDQyxPQUFPLENBQUMsU0FBVUMsRUFBRTtZQUNuQyxJQUFJQyxPQUFPRCxHQUFHQyxJQUFJLEVBQUVDLE9BQU9GLEdBQUdFLElBQUk7WUFDbEMsSUFBSyxJQUFJQyxJQUFJRCxLQUFLRSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7Z0JBQ3ZDLElBQUlFLE1BQU1ILElBQUksQ0FBQ0MsRUFBRTtnQkFDakIsSUFBSUcsZUFBZSxDQUFDQyxNQUFNLENBQUNGO2dCQUMzQixJQUFJRyxXQUFXRixlQUFlLEVBQUUsR0FBRyxDQUFDO2dCQUNwQ0UsUUFBUSxDQUFDSCxJQUFJLEdBQUdKO2dCQUNoQkEsT0FBT087WUFDWDtZQUNBWixhQUFhQyxPQUFPWSxLQUFLLENBQUNiLFlBQVlLO1FBQzFDO0lBQ0o7SUFDQSxPQUFPTDtBQUNYLEVBQ0EsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2luY3JlbWVudGFsUmVzdWx0LmpzPzJiODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb25OdWxsT2JqZWN0IH0gZnJvbSBcIi4vb2JqZWN0cy5qc1wiO1xuaW1wb3J0IHsgaXNOb25FbXB0eUFycmF5IH0gZnJvbSBcIi4vYXJyYXlzLmpzXCI7XG5pbXBvcnQgeyBEZWVwTWVyZ2VyIH0gZnJvbSBcIi4vbWVyZ2VEZWVwLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiaW5jcmVtZW50YWxcIiBpbiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0V4ZWN1dGlvblBhdGNoSW5pdGlhbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiBcImhhc05leHRcIiBpbiB2YWx1ZSAmJiBcImRhdGFcIiBpbiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0V4ZWN1dGlvblBhdGNoUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0V4ZWN1dGlvblBhdGNoSW5jcmVtZW50YWxSZXN1bHQodmFsdWUpIHx8XG4gICAgICAgIGlzRXhlY3V0aW9uUGF0Y2hJbml0aWFsUmVzdWx0KHZhbHVlKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgYW4gQXBvbGxvIHBheWxvYWQgcmVzdWx0IGJlZm9yZSBpdCBpcyB0cmFuc2Zvcm1lZFxuLy8gaW50byBhIEZldGNoUmVzdWx0IHZpYSBIdHRwTGluazsgaXQgY2Fubm90IGRldGVjdCBhbiBBcG9sbG9QYXlsb2FkUmVzdWx0XG4vLyBvbmNlIGl0IGxlYXZlcyB0aGUgbGluayBjaGFpbi5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fwb2xsb1BheWxvYWRSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJiBcInBheWxvYWRcIiBpbiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUluY3JlbWVudGFsRGF0YShwcmV2UmVzdWx0LCByZXN1bHQpIHtcbiAgICB2YXIgbWVyZ2VkRGF0YSA9IHByZXZSZXN1bHQ7XG4gICAgdmFyIG1lcmdlciA9IG5ldyBEZWVwTWVyZ2VyKCk7XG4gICAgaWYgKGlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdChyZXN1bHQpICYmXG4gICAgICAgIGlzTm9uRW1wdHlBcnJheShyZXN1bHQuaW5jcmVtZW50YWwpKSB7XG4gICAgICAgIHJlc3VsdC5pbmNyZW1lbnRhbC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBwYXRoID0gX2EucGF0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlzTnVtZXJpY0tleSA9ICFpc05hTigra2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBpc051bWVyaWNLZXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgIHBhcmVudF8xW2tleV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZERhdGEgPSBtZXJnZXIubWVyZ2UobWVyZ2VkRGF0YSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkRGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsUmVzdWx0LmpzLm1hcCJdLCJuYW1lcyI6WyJpc05vbk51bGxPYmplY3QiLCJpc05vbkVtcHR5QXJyYXkiLCJEZWVwTWVyZ2VyIiwiaXNFeGVjdXRpb25QYXRjaEluY3JlbWVudGFsUmVzdWx0IiwidmFsdWUiLCJpc0V4ZWN1dGlvblBhdGNoSW5pdGlhbFJlc3VsdCIsImlzRXhlY3V0aW9uUGF0Y2hSZXN1bHQiLCJpc0Fwb2xsb1BheWxvYWRSZXN1bHQiLCJtZXJnZUluY3JlbWVudGFsRGF0YSIsInByZXZSZXN1bHQiLCJyZXN1bHQiLCJtZXJnZWREYXRhIiwibWVyZ2VyIiwiaW5jcmVtZW50YWwiLCJmb3JFYWNoIiwiX2EiLCJkYXRhIiwicGF0aCIsImkiLCJsZW5ndGgiLCJrZXkiLCJpc051bWVyaWNLZXkiLCJpc05hTiIsInBhcmVudF8xIiwibWVyZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/incrementalResult.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/makeUniqueId.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/makeUniqueId.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeUniqueId: function() { return /* binding */ makeUniqueId; }\n/* harmony export */ });\nvar prefixCounts = new Map();\n// These IDs won't be globally unique, but they will be unique within this\n// process, thanks to the counter, and unguessable thanks to the random suffix.\nfunction makeUniqueId(prefix) {\n    var count = prefixCounts.get(prefix) || 1;\n    prefixCounts.set(prefix, count + 1);\n    return \"\".concat(prefix, \":\").concat(count, \":\").concat(Math.random().toString(36).slice(2));\n} //# sourceMappingURL=makeUniqueId.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21ha2VVbmlxdWVJZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsZUFBZSxJQUFJQztBQUN2QiwwRUFBMEU7QUFDMUUsK0VBQStFO0FBQ3hFLFNBQVNDLGFBQWFDLE1BQU07SUFDL0IsSUFBSUMsUUFBUUosYUFBYUssR0FBRyxDQUFDRixXQUFXO0lBQ3hDSCxhQUFhTSxHQUFHLENBQUNILFFBQVFDLFFBQVE7SUFDakMsT0FBTyxHQUFHRyxNQUFNLENBQUNKLFFBQVEsS0FBS0ksTUFBTSxDQUFDSCxPQUFPLEtBQUtHLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDO0FBQzdGLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21ha2VVbmlxdWVJZC5qcz8yOWFhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwcmVmaXhDb3VudHMgPSBuZXcgTWFwKCk7XG4vLyBUaGVzZSBJRHMgd29uJ3QgYmUgZ2xvYmFsbHkgdW5pcXVlLCBidXQgdGhleSB3aWxsIGJlIHVuaXF1ZSB3aXRoaW4gdGhpc1xuLy8gcHJvY2VzcywgdGhhbmtzIHRvIHRoZSBjb3VudGVyLCBhbmQgdW5ndWVzc2FibGUgdGhhbmtzIHRvIHRoZSByYW5kb20gc3VmZml4LlxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VVbmlxdWVJZChwcmVmaXgpIHtcbiAgICB2YXIgY291bnQgPSBwcmVmaXhDb3VudHMuZ2V0KHByZWZpeCkgfHwgMTtcbiAgICBwcmVmaXhDb3VudHMuc2V0KHByZWZpeCwgY291bnQgKyAxKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4LCBcIjpcIikuY29uY2F0KGNvdW50LCBcIjpcIikuY29uY2F0KE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VVbmlxdWVJZC5qcy5tYXAiXSwibmFtZXMiOlsicHJlZml4Q291bnRzIiwiTWFwIiwibWFrZVVuaXF1ZUlkIiwicHJlZml4IiwiY291bnQiLCJnZXQiLCJzZXQiLCJjb25jYXQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/makeUniqueId.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeDeepFreeze: function() { return /* binding */ maybeDeepFreeze; }\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n\nfunction deepFreeze(value) {\n    var workSet = new Set([\n        value\n    ]);\n    workSet.forEach(function(obj) {\n        if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(obj) && shallowFreeze(obj) === obj) {\n            Object.getOwnPropertyNames(obj).forEach(function(name) {\n                if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(obj[name])) workSet.add(obj[name]);\n            });\n        }\n    });\n    return value;\n}\nfunction shallowFreeze(obj) {\n    if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {\n        try {\n            Object.freeze(obj);\n        } catch (e) {\n            // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n            // they all throw a TypeError when you try, so we re-throw any exceptions\n            // that are not TypeErrors, since that would be unexpected.\n            if (e instanceof TypeError) return null;\n            throw e;\n        }\n    }\n    return obj;\n}\nfunction maybeDeepFreeze(obj) {\n    if (globalThis.__DEV__ !== false) {\n        deepFreeze(obj);\n    }\n    return obj;\n} //# sourceMappingURL=maybeDeepFreeze.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21heWJlRGVlcEZyZWV6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUMvQyxTQUFTQyxXQUFXQyxLQUFLO0lBQ3JCLElBQUlDLFVBQVUsSUFBSUMsSUFBSTtRQUFDRjtLQUFNO0lBQzdCQyxRQUFRRSxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUN6QixJQUFJTiw0REFBZUEsQ0FBQ00sUUFBUUMsY0FBY0QsU0FBU0EsS0FBSztZQUNwREUsT0FBT0MsbUJBQW1CLENBQUNILEtBQUtELE9BQU8sQ0FBQyxTQUFVSyxJQUFJO2dCQUNsRCxJQUFJViw0REFBZUEsQ0FBQ00sR0FBRyxDQUFDSSxLQUFLLEdBQ3pCUCxRQUFRUSxHQUFHLENBQUNMLEdBQUcsQ0FBQ0ksS0FBSztZQUM3QjtRQUNKO0lBQ0o7SUFDQSxPQUFPUjtBQUNYO0FBQ0EsU0FBU0ssY0FBY0QsR0FBRztJQUN0QixJQUFJTSxXQUFXQyxPQUFPLEtBQUssU0FBUyxDQUFDTCxPQUFPTSxRQUFRLENBQUNSLE1BQU07UUFDdkQsSUFBSTtZQUNBRSxPQUFPTyxNQUFNLENBQUNUO1FBQ2xCLEVBQ0EsT0FBT1UsR0FBRztZQUNOLHdFQUF3RTtZQUN4RSx5RUFBeUU7WUFDekUsMkRBQTJEO1lBQzNELElBQUlBLGFBQWFDLFdBQ2IsT0FBTztZQUNYLE1BQU1EO1FBQ1Y7SUFDSjtJQUNBLE9BQU9WO0FBQ1g7QUFDTyxTQUFTWSxnQkFBZ0JaLEdBQUc7SUFDL0IsSUFBSU0sV0FBV0MsT0FBTyxLQUFLLE9BQU87UUFDOUJaLFdBQVdLO0lBQ2Y7SUFDQSxPQUFPQTtBQUNYLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21heWJlRGVlcEZyZWV6ZS5qcz80NWQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9uTnVsbE9iamVjdCB9IGZyb20gXCIuL29iamVjdHMuanNcIjtcbmZ1bmN0aW9uIGRlZXBGcmVlemUodmFsdWUpIHtcbiAgICB2YXIgd29ya1NldCA9IG5ldyBTZXQoW3ZhbHVlXSk7XG4gICAgd29ya1NldC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChvYmopICYmIHNoYWxsb3dGcmVlemUob2JqKSA9PT0gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KG9ialtuYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgIHdvcmtTZXQuYWRkKG9ialtuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dGcmVlemUob2JqKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgIU9iamVjdC5pc0Zyb3plbihvYmopKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgdHlwZXMgbGlrZSBVaW50OEFycmF5IGFuZCBOb2RlLmpzJ3MgQnVmZmVyIGNhbm5vdCBiZSBmcm96ZW4sIGJ1dFxuICAgICAgICAgICAgLy8gdGhleSBhbGwgdGhyb3cgYSBUeXBlRXJyb3Igd2hlbiB5b3UgdHJ5LCBzbyB3ZSByZS10aHJvdyBhbnkgZXhjZXB0aW9uc1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IFR5cGVFcnJvcnMsIHNpbmNlIHRoYXQgd291bGQgYmUgdW5leHBlY3RlZC5cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlRGVlcEZyZWV6ZShvYmopIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICBkZWVwRnJlZXplKG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXliZURlZXBGcmVlemUuanMubWFwIl0sIm5hbWVzIjpbImlzTm9uTnVsbE9iamVjdCIsImRlZXBGcmVlemUiLCJ2YWx1ZSIsIndvcmtTZXQiLCJTZXQiLCJmb3JFYWNoIiwib2JqIiwic2hhbGxvd0ZyZWV6ZSIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJuYW1lIiwiYWRkIiwiZ2xvYmFsVGhpcyIsIl9fREVWX18iLCJpc0Zyb3plbiIsImZyZWV6ZSIsImUiLCJUeXBlRXJyb3IiLCJtYXliZURlZXBGcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/mergeDeep.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeepMerger: function() { return /* binding */ DeepMerger; },\n/* harmony export */   mergeDeep: function() { return /* binding */ mergeDeep; },\n/* harmony export */   mergeDeepArray: function() { return /* binding */ mergeDeepArray; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction mergeDeep() {\n    var sources = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nfunction mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var merger = new DeepMerger();\n        for(var i = 1; i < count; ++i){\n            target = merger.merge(target, sources[i]);\n        }\n    }\n    return target;\n}\nvar defaultReconciler = function(target, source, property) {\n    return this.merge(target[property], source[property]);\n};\nvar DeepMerger = /** @class */ function() {\n    function DeepMerger(reconciler) {\n        if (reconciler === void 0) {\n            reconciler = defaultReconciler;\n        }\n        this.reconciler = reconciler;\n        this.isObject = _objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject;\n        this.pastCopies = new Set();\n    }\n    DeepMerger.prototype.merge = function(target, source) {\n        var _this = this;\n        var context = [];\n        for(var _i = 2; _i < arguments.length; _i++){\n            context[_i - 2] = arguments[_i];\n        }\n        if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(source) && (0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(target)) {\n            Object.keys(source).forEach(function(sourceKey) {\n                if (hasOwnProperty.call(target, sourceKey)) {\n                    var targetValue = target[sourceKey];\n                    if (source[sourceKey] !== targetValue) {\n                        var result = _this.reconciler.apply(_this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n                            target,\n                            source,\n                            sourceKey\n                        ], context, false));\n                        // A well-implemented reconciler may return targetValue to indicate\n                        // the merge changed nothing about the structure of the target.\n                        if (result !== targetValue) {\n                            target = _this.shallowCopyForMerge(target);\n                            target[sourceKey] = result;\n                        }\n                    }\n                } else {\n                    // If there is no collision, the target can safely share memory with\n                    // the source, and the recursion can terminate here.\n                    target = _this.shallowCopyForMerge(target);\n                    target[sourceKey] = source[sourceKey];\n                }\n            });\n            return target;\n        }\n        // If source (or target) is not an object, let source replace target.\n        return source;\n    };\n    DeepMerger.prototype.shallowCopyForMerge = function(value) {\n        if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(value)) {\n            if (!this.pastCopies.has(value)) {\n                if (Array.isArray(value)) {\n                    value = value.slice(0);\n                } else {\n                    value = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n                        __proto__: Object.getPrototypeOf(value)\n                    }, value);\n                }\n                this.pastCopies.add(value);\n            }\n        }\n        return value;\n    };\n    return DeepMerger;\n}();\n //# sourceMappingURL=mergeDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21lcmdlRGVlcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRDtBQUNEO0FBQy9DLElBQUlHLGlCQUFpQkMsT0FBT0MsU0FBUyxDQUFDRixjQUFjO0FBQzdDLFNBQVNHO0lBQ1osSUFBSUMsVUFBVSxFQUFFO0lBQ2hCLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLQyxVQUFVQyxNQUFNLEVBQUVGLEtBQU07UUFDMUNELE9BQU8sQ0FBQ0MsR0FBRyxHQUFHQyxTQUFTLENBQUNELEdBQUc7SUFDL0I7SUFDQSxPQUFPRyxlQUFlSjtBQUMxQjtBQUNBLGlFQUFpRTtBQUNqRSx1RUFBdUU7QUFDdkUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSxtRUFBbUU7QUFDbkUsMkJBQTJCO0FBQ3BCLFNBQVNJLGVBQWVKLE9BQU87SUFDbEMsSUFBSUssU0FBU0wsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO0lBQzVCLElBQUlNLFFBQVFOLFFBQVFHLE1BQU07SUFDMUIsSUFBSUcsUUFBUSxHQUFHO1FBQ1gsSUFBSUMsU0FBUyxJQUFJQztRQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBTyxFQUFFRyxFQUFHO1lBQzVCSixTQUFTRSxPQUFPRyxLQUFLLENBQUNMLFFBQVFMLE9BQU8sQ0FBQ1MsRUFBRTtRQUM1QztJQUNKO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLElBQUlNLG9CQUFvQixTQUFVTixNQUFNLEVBQUVPLE1BQU0sRUFBRUMsUUFBUTtJQUN0RCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDTCxNQUFNLENBQUNRLFNBQVMsRUFBRUQsTUFBTSxDQUFDQyxTQUFTO0FBQ3hEO0FBQ0EsSUFBSUwsYUFBYSxXQUFXLEdBQUk7SUFDNUIsU0FBU0EsV0FBV00sVUFBVTtRQUMxQixJQUFJQSxlQUFlLEtBQUssR0FBRztZQUFFQSxhQUFhSDtRQUFtQjtRQUM3RCxJQUFJLENBQUNHLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdwQix3REFBZUE7UUFDL0IsSUFBSSxDQUFDcUIsVUFBVSxHQUFHLElBQUlDO0lBQzFCO0lBQ0FULFdBQVdWLFNBQVMsQ0FBQ1ksS0FBSyxHQUFHLFNBQVVMLE1BQU0sRUFBRU8sTUFBTTtRQUNqRCxJQUFJTSxRQUFRLElBQUk7UUFDaEIsSUFBSUMsVUFBVSxFQUFFO1FBQ2hCLElBQUssSUFBSWxCLEtBQUssR0FBR0EsS0FBS0MsVUFBVUMsTUFBTSxFQUFFRixLQUFNO1lBQzFDa0IsT0FBTyxDQUFDbEIsS0FBSyxFQUFFLEdBQUdDLFNBQVMsQ0FBQ0QsR0FBRztRQUNuQztRQUNBLElBQUlOLDREQUFlQSxDQUFDaUIsV0FBV2pCLDREQUFlQSxDQUFDVSxTQUFTO1lBQ3BEUixPQUFPdUIsSUFBSSxDQUFDUixRQUFRUyxPQUFPLENBQUMsU0FBVUMsU0FBUztnQkFDM0MsSUFBSTFCLGVBQWUyQixJQUFJLENBQUNsQixRQUFRaUIsWUFBWTtvQkFDeEMsSUFBSUUsY0FBY25CLE1BQU0sQ0FBQ2lCLFVBQVU7b0JBQ25DLElBQUlWLE1BQU0sQ0FBQ1UsVUFBVSxLQUFLRSxhQUFhO3dCQUNuQyxJQUFJQyxTQUFTUCxNQUFNSixVQUFVLENBQUNZLEtBQUssQ0FBQ1IsT0FBT3hCLG9EQUFhQSxDQUFDOzRCQUFDVzs0QkFDdERPOzRCQUNBVTt5QkFBVSxFQUFFSCxTQUFTO3dCQUN6QixtRUFBbUU7d0JBQ25FLCtEQUErRDt3QkFDL0QsSUFBSU0sV0FBV0QsYUFBYTs0QkFDeEJuQixTQUFTYSxNQUFNUyxtQkFBbUIsQ0FBQ3RCOzRCQUNuQ0EsTUFBTSxDQUFDaUIsVUFBVSxHQUFHRzt3QkFDeEI7b0JBQ0o7Z0JBQ0osT0FDSztvQkFDRCxvRUFBb0U7b0JBQ3BFLG9EQUFvRDtvQkFDcERwQixTQUFTYSxNQUFNUyxtQkFBbUIsQ0FBQ3RCO29CQUNuQ0EsTUFBTSxDQUFDaUIsVUFBVSxHQUFHVixNQUFNLENBQUNVLFVBQVU7Z0JBQ3pDO1lBQ0o7WUFDQSxPQUFPakI7UUFDWDtRQUNBLHFFQUFxRTtRQUNyRSxPQUFPTztJQUNYO0lBQ0FKLFdBQVdWLFNBQVMsQ0FBQzZCLG1CQUFtQixHQUFHLFNBQVVDLEtBQUs7UUFDdEQsSUFBSWpDLDREQUFlQSxDQUFDaUMsUUFBUTtZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDWixVQUFVLENBQUNhLEdBQUcsQ0FBQ0QsUUFBUTtnQkFDN0IsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO29CQUN0QkEsUUFBUUEsTUFBTUksS0FBSyxDQUFDO2dCQUN4QixPQUNLO29CQUNESixRQUFRbkMsK0NBQVFBLENBQUM7d0JBQUV3QyxXQUFXcEMsT0FBT3FDLGNBQWMsQ0FBQ047b0JBQU8sR0FBR0E7Z0JBQ2xFO2dCQUNBLElBQUksQ0FBQ1osVUFBVSxDQUFDbUIsR0FBRyxDQUFDUDtZQUN4QjtRQUNKO1FBQ0EsT0FBT0E7SUFDWDtJQUNBLE9BQU9wQjtBQUNYO0FBQ3NCLENBQ3RCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2NvbW1vbi9tZXJnZURlZXAuanM/YmRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNOb25OdWxsT2JqZWN0IH0gZnJvbSBcIi4vb2JqZWN0cy5qc1wiO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBtZXJnZURlZXBBcnJheShzb3VyY2VzKTtcbn1cbi8vIEluIGFsbW9zdCBhbnkgc2l0dWF0aW9uIHdoZXJlIHlvdSBjb3VsZCBzdWNjZWVkIGluIGdldHRpbmcgdGhlXG4vLyBUeXBlU2NyaXB0IGNvbXBpbGVyIHRvIGluZmVyIGEgdHVwbGUgdHlwZSBmb3IgdGhlIHNvdXJjZXMgYXJyYXksIHlvdVxuLy8gY291bGQganVzdCB1c2UgbWVyZ2VEZWVwIGluc3RlYWQgb2YgbWVyZ2VEZWVwQXJyYXksIHNvIGluc3RlYWQgb2Zcbi8vIHRyeWluZyB0byBjb252ZXJ0IFRbXSB0byBhbiBpbnRlcnNlY3Rpb24gdHlwZSB3ZSBqdXN0IGluZmVyIHRoZSBhcnJheVxuLy8gZWxlbWVudCB0eXBlLCB3aGljaCB3b3JrcyBwZXJmZWN0bHkgd2hlbiB0aGUgc291cmNlcyBhcnJheSBoYXMgYVxuLy8gY29uc2lzdGVudCBlbGVtZW50IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWVwQXJyYXkoc291cmNlcykge1xuICAgIHZhciB0YXJnZXQgPSBzb3VyY2VzWzBdIHx8IHt9O1xuICAgIHZhciBjb3VudCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgdmFyIG1lcmdlciA9IG5ldyBEZWVwTWVyZ2VyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWVyZ2VyLm1lcmdlKHRhcmdldCwgc291cmNlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciBkZWZhdWx0UmVjb25jaWxlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXJnZSh0YXJnZXRbcHJvcGVydHldLCBzb3VyY2VbcHJvcGVydHldKTtcbn07XG52YXIgRGVlcE1lcmdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWVwTWVyZ2VyKHJlY29uY2lsZXIpIHtcbiAgICAgICAgaWYgKHJlY29uY2lsZXIgPT09IHZvaWQgMCkgeyByZWNvbmNpbGVyID0gZGVmYXVsdFJlY29uY2lsZXI7IH1cbiAgICAgICAgdGhpcy5yZWNvbmNpbGVyID0gcmVjb25jaWxlcjtcbiAgICAgICAgdGhpcy5pc09iamVjdCA9IGlzTm9uTnVsbE9iamVjdDtcbiAgICAgICAgdGhpcy5wYXN0Q29waWVzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBEZWVwTWVyZ2VyLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGV4dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29udGV4dFtfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KHNvdXJjZSkgJiYgaXNOb25OdWxsT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBzb3VyY2VLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRhcmdldFtzb3VyY2VLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW3NvdXJjZUtleV0gIT09IHRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucmVjb25jaWxlci5hcHBseShfdGhpcywgX19zcHJlYWRBcnJheShbdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VLZXldLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB3ZWxsLWltcGxlbWVudGVkIHJlY29uY2lsZXIgbWF5IHJldHVybiB0YXJnZXRWYWx1ZSB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lcmdlIGNoYW5nZWQgbm90aGluZyBhYm91dCB0aGUgc3RydWN0dXJlIG9mIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0YXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IF90aGlzLnNoYWxsb3dDb3B5Rm9yTWVyZ2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlS2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY29sbGlzaW9uLCB0aGUgdGFyZ2V0IGNhbiBzYWZlbHkgc2hhcmUgbWVtb3J5IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNvdXJjZSwgYW5kIHRoZSByZWN1cnNpb24gY2FuIHRlcm1pbmF0ZSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy5zaGFsbG93Q29weUZvck1lcmdlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VLZXldID0gc291cmNlW3NvdXJjZUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNvdXJjZSAob3IgdGFyZ2V0KSBpcyBub3QgYW4gb2JqZWN0LCBsZXQgc291cmNlIHJlcGxhY2UgdGFyZ2V0LlxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH07XG4gICAgRGVlcE1lcmdlci5wcm90b3R5cGUuc2hhbGxvd0NvcHlGb3JNZXJnZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhc3RDb3BpZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfX2Fzc2lnbih7IF9fcHJvdG9fXzogT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSB9LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFzdENvcGllcy5hZGQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBEZWVwTWVyZ2VyO1xufSgpKTtcbmV4cG9ydCB7IERlZXBNZXJnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlRGVlcC5qcy5tYXAiXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX3NwcmVhZEFycmF5IiwiaXNOb25OdWxsT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJtZXJnZURlZXAiLCJzb3VyY2VzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtZXJnZURlZXBBcnJheSIsInRhcmdldCIsImNvdW50IiwibWVyZ2VyIiwiRGVlcE1lcmdlciIsImkiLCJtZXJnZSIsImRlZmF1bHRSZWNvbmNpbGVyIiwic291cmNlIiwicHJvcGVydHkiLCJyZWNvbmNpbGVyIiwiaXNPYmplY3QiLCJwYXN0Q29waWVzIiwiU2V0IiwiX3RoaXMiLCJjb250ZXh0Iiwia2V5cyIsImZvckVhY2giLCJzb3VyY2VLZXkiLCJjYWxsIiwidGFyZ2V0VmFsdWUiLCJyZXN1bHQiLCJhcHBseSIsInNoYWxsb3dDb3B5Rm9yTWVyZ2UiLCJ2YWx1ZSIsImhhcyIsIkFycmF5IiwiaXNBcnJheSIsInNsaWNlIiwiX19wcm90b19fIiwiZ2V0UHJvdG90eXBlT2YiLCJhZGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeDeep.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeOptions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/mergeOptions.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeOptions: function() { return /* binding */ mergeOptions; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _compact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compact.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n\n\nfunction mergeOptions(defaults, options) {\n    return (0,_compact_js__WEBPACK_IMPORTED_MODULE_0__.compact)(defaults, options, options.variables && {\n        variables: (0,_compact_js__WEBPACK_IMPORTED_MODULE_0__.compact)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, defaults && defaults.variables), options.variables))\n    });\n} //# sourceMappingURL=mergeOptions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21lcmdlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDTTtBQUNoQyxTQUFTRSxhQUFhQyxRQUFRLEVBQUVDLE9BQU87SUFDMUMsT0FBT0gsb0RBQU9BLENBQUNFLFVBQVVDLFNBQVNBLFFBQVFDLFNBQVMsSUFBSTtRQUNuREEsV0FBV0osb0RBQU9BLENBQUNELCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUlHLFlBQVlBLFNBQVNFLFNBQVMsR0FBSUQsUUFBUUMsU0FBUztJQUNqRztBQUNKLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21lcmdlT3B0aW9ucy5qcz8wMmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjb21wYWN0IH0gZnJvbSBcIi4vY29tcGFjdC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21wYWN0KGRlZmF1bHRzLCBvcHRpb25zLCBvcHRpb25zLnZhcmlhYmxlcyAmJiB7XG4gICAgICAgIHZhcmlhYmxlczogY29tcGFjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKGRlZmF1bHRzICYmIGRlZmF1bHRzLnZhcmlhYmxlcykpLCBvcHRpb25zLnZhcmlhYmxlcykpLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VPcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsImNvbXBhY3QiLCJtZXJnZU9wdGlvbnMiLCJkZWZhdWx0cyIsIm9wdGlvbnMiLCJ2YXJpYWJsZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeOptions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/objects.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNonNullObject: function() { return /* binding */ isNonNullObject; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; }\n/* harmony export */ });\nfunction isNonNullObject(obj) {\n    return obj !== null && typeof obj === \"object\";\n}\nfunction isPlainObject(obj) {\n    return obj !== null && typeof obj === \"object\" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);\n} //# sourceMappingURL=objects.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL29iamVjdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxnQkFBZ0JDLEdBQUc7SUFDL0IsT0FBT0EsUUFBUSxRQUFRLE9BQU9BLFFBQVE7QUFDMUM7QUFDTyxTQUFTQyxjQUFjRCxHQUFHO0lBQzdCLE9BQVFBLFFBQVEsUUFDWixPQUFPQSxRQUFRLFlBQ2RFLENBQUFBLE9BQU9DLGNBQWMsQ0FBQ0gsU0FBU0UsT0FBT0UsU0FBUyxJQUM1Q0YsT0FBT0MsY0FBYyxDQUFDSCxTQUFTLElBQUc7QUFDOUMsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9jb21tb24vb2JqZWN0cy5qcz8yMTU4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc05vbk51bGxPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIChvYmogIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3RzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc05vbk51bGxPYmplY3QiLCJvYmoiLCJpc1BsYWluT2JqZWN0IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/stringifyForDisplay.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/stringifyForDisplay.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringifyForDisplay: function() { return /* binding */ stringifyForDisplay; }\n/* harmony export */ });\n/* harmony import */ var _makeUniqueId_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./makeUniqueId.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/makeUniqueId.js\");\n\nfunction stringifyForDisplay(value, space) {\n    if (space === void 0) {\n        space = 0;\n    }\n    var undefId = (0,_makeUniqueId_js__WEBPACK_IMPORTED_MODULE_0__.makeUniqueId)(\"stringifyForDisplay\");\n    return JSON.stringify(value, function(key, value) {\n        return value === void 0 ? undefId : value;\n    }, space).split(JSON.stringify(undefId)).join(\"<undefined>\");\n} //# sourceMappingURL=stringifyForDisplay.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL3N0cmluZ2lmeUZvckRpc3BsYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDMUMsU0FBU0Msb0JBQW9CQyxLQUFLLEVBQUVDLEtBQUs7SUFDNUMsSUFBSUEsVUFBVSxLQUFLLEdBQUc7UUFBRUEsUUFBUTtJQUFHO0lBQ25DLElBQUlDLFVBQVVKLDhEQUFZQSxDQUFDO0lBQzNCLE9BQU9LLEtBQUtDLFNBQVMsQ0FBQ0osT0FBTyxTQUFVSyxHQUFHLEVBQUVMLEtBQUs7UUFDN0MsT0FBT0EsVUFBVSxLQUFLLElBQUlFLFVBQVVGO0lBQ3hDLEdBQUdDLE9BQ0VLLEtBQUssQ0FBQ0gsS0FBS0MsU0FBUyxDQUFDRixVQUNyQkssSUFBSSxDQUFDO0FBQ2QsRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9jb21tb24vc3RyaW5naWZ5Rm9yRGlzcGxheS5qcz8yMmM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VVbmlxdWVJZCB9IGZyb20gXCIuL21ha2VVbmlxdWVJZC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeUZvckRpc3BsYXkodmFsdWUsIHNwYWNlKSB7XG4gICAgaWYgKHNwYWNlID09PSB2b2lkIDApIHsgc3BhY2UgPSAwOyB9XG4gICAgdmFyIHVuZGVmSWQgPSBtYWtlVW5pcXVlSWQoXCJzdHJpbmdpZnlGb3JEaXNwbGF5XCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB1bmRlZklkIDogdmFsdWU7XG4gICAgfSwgc3BhY2UpXG4gICAgICAgIC5zcGxpdChKU09OLnN0cmluZ2lmeSh1bmRlZklkKSlcbiAgICAgICAgLmpvaW4oXCI8dW5kZWZpbmVkPlwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ2lmeUZvckRpc3BsYXkuanMubWFwIl0sIm5hbWVzIjpbIm1ha2VVbmlxdWVJZCIsInN0cmluZ2lmeUZvckRpc3BsYXkiLCJ2YWx1ZSIsInNwYWNlIiwidW5kZWZJZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJzcGxpdCIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/stringifyForDisplay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/global.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/global.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _maybe_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maybe.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/maybe.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,_maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return globalThis;\n}) || (0,_maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return window;\n}) || (0,_maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return self;\n}) || (0,_maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return global;\n}) || // We don't expect the Function constructor ever to be invoked at runtime, as\n// long as at least one of globalThis, window, self, or global is defined, so\n// we are under no obligation to make it easy for static analysis tools to\n// detect syntactic usage of the Function constructor. If you think you can\n// improve your static analysis to detect this obfuscation, think again. This\n// is an arms race you cannot win, at least not in JavaScript.\n(0,_maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe)(function() {\n    return _maybe_js__WEBPACK_IMPORTED_MODULE_0__.maybe.constructor(\"return this\")();\n})); //# sourceMappingURL=global.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ2xvYmFscy9nbG9iYWwuanMiLCJtYXBwaW5ncyI6Ijs7QUFBbUM7QUFDbkMsK0RBQWdCQSxnREFBS0EsQ0FBQztJQUFjLE9BQU9DO0FBQVksTUFDbkRELGdEQUFLQSxDQUFDO0lBQWMsT0FBT0U7QUFBUSxNQUNuQ0YsZ0RBQUtBLENBQUM7SUFBYyxPQUFPRztBQUFNLE1BQ2pDSCxnREFBS0EsQ0FBQztJQUFjLE9BQU9JO0FBQVEsTUFBTSw2RUFBNkU7QUFDMUgsNkVBQTZFO0FBQzdFLDBFQUEwRTtBQUMxRSwyRUFBMkU7QUFDM0UsNkVBQTZFO0FBQzdFLDhEQUE4RDtBQUM5REosZ0RBQUtBLENBQUM7SUFDRixPQUFPQSw0Q0FBS0EsQ0FBQ0ssV0FBVyxDQUFDO0FBQzdCLEVBQUUsRUFBRSxDQUNKLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dsb2JhbHMvZ2xvYmFsLmpzPzg0ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWF5YmUgfSBmcm9tIFwiLi9tYXliZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgKG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbFRoaXM7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93OyB9KSB8fFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGY7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFsOyB9KSB8fCAvLyBXZSBkb24ndCBleHBlY3QgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGV2ZXIgdG8gYmUgaW52b2tlZCBhdCBydW50aW1lLCBhc1xuLy8gbG9uZyBhcyBhdCBsZWFzdCBvbmUgb2YgZ2xvYmFsVGhpcywgd2luZG93LCBzZWxmLCBvciBnbG9iYWwgaXMgZGVmaW5lZCwgc29cbi8vIHdlIGFyZSB1bmRlciBubyBvYmxpZ2F0aW9uIHRvIG1ha2UgaXQgZWFzeSBmb3Igc3RhdGljIGFuYWx5c2lzIHRvb2xzIHRvXG4vLyBkZXRlY3Qgc3ludGFjdGljIHVzYWdlIG9mIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3Rvci4gSWYgeW91IHRoaW5rIHlvdSBjYW5cbi8vIGltcHJvdmUgeW91ciBzdGF0aWMgYW5hbHlzaXMgdG8gZGV0ZWN0IHRoaXMgb2JmdXNjYXRpb24sIHRoaW5rIGFnYWluLiBUaGlzXG4vLyBpcyBhbiBhcm1zIHJhY2UgeW91IGNhbm5vdCB3aW4sIGF0IGxlYXN0IG5vdCBpbiBKYXZhU2NyaXB0LlxubWF5YmUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXliZS5jb25zdHJ1Y3RvcihcInJldHVybiB0aGlzXCIpKCk7XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWwuanMubWFwIl0sIm5hbWVzIjpbIm1heWJlIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsInNlbGYiLCJnbG9iYWwiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/global.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEV: function() { return /* binding */ DEV; },\n/* harmony export */   InvariantError: function() { return /* reexport safe */ _invariantWrappers_js__WEBPACK_IMPORTED_MODULE_0__.InvariantError; },\n/* harmony export */   __DEV__: function() { return /* binding */ DEV; },\n/* harmony export */   global: function() { return /* reexport safe */ _global_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   invariant: function() { return /* reexport safe */ _invariantWrappers_js__WEBPACK_IMPORTED_MODULE_0__.invariant; },\n/* harmony export */   maybe: function() { return /* reexport safe */ _maybe_js__WEBPACK_IMPORTED_MODULE_1__.maybe; },\n/* harmony export */   newInvariantError: function() { return /* reexport safe */ _invariantWrappers_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError; }\n/* harmony export */ });\n/* harmony import */ var _invariantWrappers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invariantWrappers.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/invariantWrappers.js\");\n/* harmony import */ var _maybe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maybe.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/maybe.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/global.js\");\n\n\n\n\n/**\n * @deprecated we do not use this internally anymore,\n * it is just exported for backwards compatibility\n */ // this file is extempt from automatic `__DEV__` replacement\n// so we have to write it out here\n// @ts-ignore\nvar DEV = globalThis.__DEV__ !== false;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ3BEO0FBQ2E7QUFDUTtBQUN4RDs7O0NBR0MsR0FDRCw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDLGFBQWE7QUFDTixJQUFJTSxNQUFNQyxXQUFXQyxPQUFPLEtBQUssTUFBTTtBQUNwQixDQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9nbG9iYWxzL2luZGV4LmpzP2QzODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW52YXJpYW50LCBuZXdJbnZhcmlhbnRFcnJvciwgSW52YXJpYW50RXJyb3IsIH0gZnJvbSBcIi4vaW52YXJpYW50V3JhcHBlcnMuanNcIjtcbmV4cG9ydCB7IG1heWJlIH0gZnJvbSBcIi4vbWF5YmUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2xvYmFsIH0gZnJvbSBcIi4vZ2xvYmFsLmpzXCI7XG5leHBvcnQgeyBpbnZhcmlhbnQsIG5ld0ludmFyaWFudEVycm9yLCBJbnZhcmlhbnRFcnJvciB9O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB3ZSBkbyBub3QgdXNlIHRoaXMgaW50ZXJuYWxseSBhbnltb3JlLFxuICogaXQgaXMganVzdCBleHBvcnRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuLy8gdGhpcyBmaWxlIGlzIGV4dGVtcHQgZnJvbSBhdXRvbWF0aWMgYF9fREVWX19gIHJlcGxhY2VtZW50XG4vLyBzbyB3ZSBoYXZlIHRvIHdyaXRlIGl0IG91dCBoZXJlXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgdmFyIERFViA9IGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2U7XG5leHBvcnQgeyBERVYgYXMgX19ERVZfXyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImludmFyaWFudCIsIm5ld0ludmFyaWFudEVycm9yIiwiSW52YXJpYW50RXJyb3IiLCJtYXliZSIsImRlZmF1bHQiLCJnbG9iYWwiLCJERVYiLCJnbG9iYWxUaGlzIiwiX19ERVZfXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/invariantWrappers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/invariantWrappers.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloErrorMessageHandler: function() { return /* binding */ ApolloErrorMessageHandler; },\n/* harmony export */   InvariantError: function() { return /* reexport safe */ ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError; },\n/* harmony export */   invariant: function() { return /* binding */ invariant; },\n/* harmony export */   newInvariantError: function() { return /* binding */ newInvariantError; }\n/* harmony export */ });\n/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-invariant */ \"(app-pages-browser)/./node_modules/ts-invariant/lib/invariant.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../version.js */ \"(app-pages-browser)/./node_modules/@apollo/client/version.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/global.js\");\n/* harmony import */ var _common_stringifyForDisplay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/stringifyForDisplay.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/stringifyForDisplay.js\");\n\n\n\n\nfunction wrap(fn) {\n    return function(message) {\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        if (typeof message === \"number\") {\n            var arg0 = message;\n            message = getHandledErrorMsg(arg0);\n            if (!message) {\n                message = getFallbackErrorMsg(arg0, args);\n                args = [];\n            }\n        }\n        fn.apply(void 0, [\n            message\n        ].concat(args));\n    };\n}\nvar invariant = Object.assign(function invariant(condition, message) {\n    var args = [];\n    for(var _i = 2; _i < arguments.length; _i++){\n        args[_i - 2] = arguments[_i];\n    }\n    if (!condition) {\n        (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));\n    }\n}, {\n    debug: wrap(ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant.debug),\n    log: wrap(ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant.log),\n    warn: wrap(ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant.warn),\n    error: wrap(ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant.error)\n});\n/**\n * Returns an InvariantError.\n *\n * `message` can only be a string, a concatenation of strings, or a ternary statement\n * that results in a string. This will be enforced on build, where the message will\n * be replaced with a message number.\n * String substitutions with %s are supported and will also return\n * pretty-stringified objects.\n * Excess `optionalParams` will be swallowed.\n */ function newInvariantError(message) {\n    var optionalParams = [];\n    for(var _i = 1; _i < arguments.length; _i++){\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    return new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));\n}\nvar ApolloErrorMessageHandler = Symbol.for(\"ApolloErrorMessageHandler_\" + _version_js__WEBPACK_IMPORTED_MODULE_2__.version);\nfunction stringify(arg) {\n    if (typeof arg == \"string\") {\n        return arg;\n    }\n    try {\n        return (0,_common_stringifyForDisplay_js__WEBPACK_IMPORTED_MODULE_3__.stringifyForDisplay)(arg, 2).slice(0, 1000);\n    } catch (_a) {\n        return \"<non-serializable>\";\n    }\n}\nfunction getHandledErrorMsg(message, messageArgs) {\n    if (messageArgs === void 0) {\n        messageArgs = [];\n    }\n    if (!message) return;\n    return _global_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][ApolloErrorMessageHandler] && _global_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][ApolloErrorMessageHandler](message, messageArgs.map(stringify));\n}\nfunction getFallbackErrorMsg(message, messageArgs) {\n    if (messageArgs === void 0) {\n        messageArgs = [];\n    }\n    if (!message) return;\n    return \"An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#\".concat(encodeURIComponent(JSON.stringify({\n        version: _version_js__WEBPACK_IMPORTED_MODULE_2__.version,\n        message: message,\n        args: messageArgs.map(stringify)\n    })));\n}\n //# sourceMappingURL=invariantWrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ2xvYmFscy9pbnZhcmlhbnRXcmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RTtBQUNuQztBQUNWO0FBQ3NDO0FBQ3ZFLFNBQVNNLEtBQUtDLEVBQUU7SUFDWixPQUFPLFNBQVVDLE9BQU87UUFDcEIsSUFBSUMsT0FBTyxFQUFFO1FBQ2IsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtDLFVBQVVDLE1BQU0sRUFBRUYsS0FBTTtZQUMxQ0QsSUFBSSxDQUFDQyxLQUFLLEVBQUUsR0FBR0MsU0FBUyxDQUFDRCxHQUFHO1FBQ2hDO1FBQ0EsSUFBSSxPQUFPRixZQUFZLFVBQVU7WUFDN0IsSUFBSUssT0FBT0w7WUFDWEEsVUFBVU0sbUJBQW1CRDtZQUM3QixJQUFJLENBQUNMLFNBQVM7Z0JBQ1ZBLFVBQVVPLG9CQUFvQkYsTUFBTUo7Z0JBQ3BDQSxPQUFPLEVBQUU7WUFDYjtRQUNKO1FBQ0FGLEdBQUdTLEtBQUssQ0FBQyxLQUFLLEdBQUc7WUFBQ1I7U0FBUSxDQUFDUyxNQUFNLENBQUNSO0lBQ3RDO0FBQ0o7QUFDQSxJQUFJVCxZQUFZa0IsT0FBT0MsTUFBTSxDQUFDLFNBQVNuQixVQUFVb0IsU0FBUyxFQUFFWixPQUFPO0lBQy9ELElBQUlDLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLQyxVQUFVQyxNQUFNLEVBQUVGLEtBQU07UUFDMUNELElBQUksQ0FBQ0MsS0FBSyxFQUFFLEdBQUdDLFNBQVMsQ0FBQ0QsR0FBRztJQUNoQztJQUNBLElBQUksQ0FBQ1UsV0FBVztRQUNabkIsdURBQWlCQSxDQUFDbUIsV0FBV04sbUJBQW1CTixTQUFTQyxTQUFTTSxvQkFBb0JQLFNBQVNDO0lBQ25HO0FBQ0osR0FBRztJQUNDWSxPQUFPZixLQUFLTCxtREFBaUJBLENBQUNvQixLQUFLO0lBQ25DQyxLQUFLaEIsS0FBS0wsbURBQWlCQSxDQUFDcUIsR0FBRztJQUMvQkMsTUFBTWpCLEtBQUtMLG1EQUFpQkEsQ0FBQ3NCLElBQUk7SUFDakNDLE9BQU9sQixLQUFLTCxtREFBaUJBLENBQUN1QixLQUFLO0FBQ3ZDO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0Msa0JBQWtCakIsT0FBTztJQUM5QixJQUFJa0IsaUJBQWlCLEVBQUU7SUFDdkIsSUFBSyxJQUFJaEIsS0FBSyxHQUFHQSxLQUFLQyxVQUFVQyxNQUFNLEVBQUVGLEtBQU07UUFDMUNnQixjQUFjLENBQUNoQixLQUFLLEVBQUUsR0FBR0MsU0FBUyxDQUFDRCxHQUFHO0lBQzFDO0lBQ0EsT0FBTyxJQUFJUix3REFBY0EsQ0FBQ1ksbUJBQW1CTixTQUFTa0IsbUJBQ2xEWCxvQkFBb0JQLFNBQVNrQjtBQUNyQztBQUNBLElBQUlDLDRCQUE0QkMsT0FBT0MsR0FBRyxDQUFDLCtCQUErQjFCLGdEQUFPQTtBQUNqRixTQUFTMkIsVUFBVUMsR0FBRztJQUNsQixJQUFJLE9BQU9BLE9BQU8sVUFBVTtRQUN4QixPQUFPQTtJQUNYO0lBQ0EsSUFBSTtRQUNBLE9BQU8xQixtRkFBbUJBLENBQUMwQixLQUFLLEdBQUdDLEtBQUssQ0FBQyxHQUFHO0lBQ2hELEVBQ0EsT0FBT0MsSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU25CLG1CQUFtQk4sT0FBTyxFQUFFMEIsV0FBVztJQUM1QyxJQUFJQSxnQkFBZ0IsS0FBSyxHQUFHO1FBQUVBLGNBQWMsRUFBRTtJQUFFO0lBQ2hELElBQUksQ0FBQzFCLFNBQ0Q7SUFDSixPQUFRSixrREFBTSxDQUFDdUIsMEJBQTBCLElBQ3JDdkIsa0RBQU0sQ0FBQ3VCLDBCQUEwQixDQUFDbkIsU0FBUzBCLFlBQVlDLEdBQUcsQ0FBQ0w7QUFDbkU7QUFDQSxTQUFTZixvQkFBb0JQLE9BQU8sRUFBRTBCLFdBQVc7SUFDN0MsSUFBSUEsZ0JBQWdCLEtBQUssR0FBRztRQUFFQSxjQUFjLEVBQUU7SUFBRTtJQUNoRCxJQUFJLENBQUMxQixTQUNEO0lBQ0osT0FBTywrRkFBK0ZTLE1BQU0sQ0FBQ21CLG1CQUFtQkMsS0FBS1AsU0FBUyxDQUFDO1FBQzNJM0IsU0FBU0EsZ0RBQU9BO1FBQ2hCSyxTQUFTQTtRQUNUQyxNQUFNeUIsWUFBWUMsR0FBRyxDQUFDTDtJQUMxQjtBQUNKO0FBQ29GLENBQ3BGLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dsb2JhbHMvaW52YXJpYW50V3JhcHBlcnMuanM/YzczZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnZhcmlhbnQgYXMgb3JpZ2luYWxJbnZhcmlhbnQsIEludmFyaWFudEVycm9yIH0gZnJvbSBcInRzLWludmFyaWFudFwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi92ZXJzaW9uLmpzXCI7XG5pbXBvcnQgZ2xvYmFsIGZyb20gXCIuL2dsb2JhbC5qc1wiO1xuaW1wb3J0IHsgc3RyaW5naWZ5Rm9yRGlzcGxheSB9IGZyb20gXCIuLi9jb21tb24vc3RyaW5naWZ5Rm9yRGlzcGxheS5qc1wiO1xuZnVuY3Rpb24gd3JhcChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhciBhcmcwID0gbWVzc2FnZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBnZXRIYW5kbGVkRXJyb3JNc2coYXJnMCk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZ2V0RmFsbGJhY2tFcnJvck1zZyhhcmcwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm4uYXBwbHkodm9pZCAwLCBbbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xufVxudmFyIGludmFyaWFudCA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgb3JpZ2luYWxJbnZhcmlhbnQoY29uZGl0aW9uLCBnZXRIYW5kbGVkRXJyb3JNc2cobWVzc2FnZSwgYXJncykgfHwgZ2V0RmFsbGJhY2tFcnJvck1zZyhtZXNzYWdlLCBhcmdzKSk7XG4gICAgfVxufSwge1xuICAgIGRlYnVnOiB3cmFwKG9yaWdpbmFsSW52YXJpYW50LmRlYnVnKSxcbiAgICBsb2c6IHdyYXAob3JpZ2luYWxJbnZhcmlhbnQubG9nKSxcbiAgICB3YXJuOiB3cmFwKG9yaWdpbmFsSW52YXJpYW50Lndhcm4pLFxuICAgIGVycm9yOiB3cmFwKG9yaWdpbmFsSW52YXJpYW50LmVycm9yKSxcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIGFuIEludmFyaWFudEVycm9yLlxuICpcbiAqIGBtZXNzYWdlYCBjYW4gb25seSBiZSBhIHN0cmluZywgYSBjb25jYXRlbmF0aW9uIG9mIHN0cmluZ3MsIG9yIGEgdGVybmFyeSBzdGF0ZW1lbnRcbiAqIHRoYXQgcmVzdWx0cyBpbiBhIHN0cmluZy4gVGhpcyB3aWxsIGJlIGVuZm9yY2VkIG9uIGJ1aWxkLCB3aGVyZSB0aGUgbWVzc2FnZSB3aWxsXG4gKiBiZSByZXBsYWNlZCB3aXRoIGEgbWVzc2FnZSBudW1iZXIuXG4gKiBTdHJpbmcgc3Vic3RpdHV0aW9ucyB3aXRoICVzIGFyZSBzdXBwb3J0ZWQgYW5kIHdpbGwgYWxzbyByZXR1cm5cbiAqIHByZXR0eS1zdHJpbmdpZmllZCBvYmplY3RzLlxuICogRXhjZXNzIGBvcHRpb25hbFBhcmFtc2Agd2lsbCBiZSBzd2FsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIG5ld0ludmFyaWFudEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnZhcmlhbnRFcnJvcihnZXRIYW5kbGVkRXJyb3JNc2cobWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpIHx8XG4gICAgICAgIGdldEZhbGxiYWNrRXJyb3JNc2cobWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpKTtcbn1cbnZhciBBcG9sbG9FcnJvck1lc3NhZ2VIYW5kbGVyID0gU3ltYm9sLmZvcihcIkFwb2xsb0Vycm9yTWVzc2FnZUhhbmRsZXJfXCIgKyB2ZXJzaW9uKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeShhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlGb3JEaXNwbGF5KGFyZywgMikuc2xpY2UoMCwgMTAwMCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gXCI8bm9uLXNlcmlhbGl6YWJsZT5cIjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVkRXJyb3JNc2cobWVzc2FnZSwgbWVzc2FnZUFyZ3MpIHtcbiAgICBpZiAobWVzc2FnZUFyZ3MgPT09IHZvaWQgMCkgeyBtZXNzYWdlQXJncyA9IFtdOyB9XG4gICAgaWYgKCFtZXNzYWdlKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChnbG9iYWxbQXBvbGxvRXJyb3JNZXNzYWdlSGFuZGxlcl0gJiZcbiAgICAgICAgZ2xvYmFsW0Fwb2xsb0Vycm9yTWVzc2FnZUhhbmRsZXJdKG1lc3NhZ2UsIG1lc3NhZ2VBcmdzLm1hcChzdHJpbmdpZnkpKSk7XG59XG5mdW5jdGlvbiBnZXRGYWxsYmFja0Vycm9yTXNnKG1lc3NhZ2UsIG1lc3NhZ2VBcmdzKSB7XG4gICAgaWYgKG1lc3NhZ2VBcmdzID09PSB2b2lkIDApIHsgbWVzc2FnZUFyZ3MgPSBbXTsgfVxuICAgIGlmICghbWVzc2FnZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBcIkFuIGVycm9yIG9jY3VycmVkISBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZ1bGwgZXJyb3IgdGV4dCBhdCBodHRwczovL2dvLmFwb2xsby5kZXYvYy9lcnIjXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGFyZ3M6IG1lc3NhZ2VBcmdzLm1hcChzdHJpbmdpZnkpLFxuICAgIH0pKSk7XG59XG5leHBvcnQgeyBpbnZhcmlhbnQsIEludmFyaWFudEVycm9yLCBuZXdJbnZhcmlhbnRFcnJvciwgQXBvbGxvRXJyb3JNZXNzYWdlSGFuZGxlciwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFyaWFudFdyYXBwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJpbnZhcmlhbnQiLCJvcmlnaW5hbEludmFyaWFudCIsIkludmFyaWFudEVycm9yIiwidmVyc2lvbiIsImdsb2JhbCIsInN0cmluZ2lmeUZvckRpc3BsYXkiLCJ3cmFwIiwiZm4iLCJtZXNzYWdlIiwiYXJncyIsIl9pIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJnMCIsImdldEhhbmRsZWRFcnJvck1zZyIsImdldEZhbGxiYWNrRXJyb3JNc2ciLCJhcHBseSIsImNvbmNhdCIsIk9iamVjdCIsImFzc2lnbiIsImNvbmRpdGlvbiIsImRlYnVnIiwibG9nIiwid2FybiIsImVycm9yIiwibmV3SW52YXJpYW50RXJyb3IiLCJvcHRpb25hbFBhcmFtcyIsIkFwb2xsb0Vycm9yTWVzc2FnZUhhbmRsZXIiLCJTeW1ib2wiLCJmb3IiLCJzdHJpbmdpZnkiLCJhcmciLCJzbGljZSIsIl9hIiwibWVzc2FnZUFyZ3MiLCJtYXAiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/invariantWrappers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/maybe.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/maybe.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybe: function() { return /* binding */ maybe; }\n/* harmony export */ });\nfunction maybe(thunk) {\n    try {\n        return thunk();\n    } catch (_a) {}\n} //# sourceMappingURL=maybe.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ2xvYmFscy9tYXliZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0EsTUFBTUMsS0FBSztJQUN2QixJQUFJO1FBQ0EsT0FBT0E7SUFDWCxFQUNBLE9BQU9DLElBQUksQ0FBRTtBQUNqQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dsb2JhbHMvbWF5YmUuanM/MTVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbWF5YmUodGh1bmspIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGh1bmsoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heWJlLmpzLm1hcCJdLCJuYW1lcyI6WyJtYXliZSIsInRodW5rIiwiX2EiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/maybe.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/DocumentTransform.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/DocumentTransform.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocumentTransform: function() { return /* binding */ DocumentTransform; }\n/* harmony export */ });\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _common_canUse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/canUse.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n/* harmony import */ var _getFromAST_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getFromAST.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/weak.js\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n/* harmony import */ var _caching_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n\n\n\n\n\n\n\nfunction identity(document) {\n    return document;\n}\nvar DocumentTransform = /** @class */ function() {\n    function DocumentTransform(transform, options) {\n        if (options === void 0) {\n            options = Object.create(null);\n        }\n        this.resultCache = _common_canUse_js__WEBPACK_IMPORTED_MODULE_3__.canUseWeakSet ? new WeakSet() : new Set();\n        this.transform = transform;\n        if (options.getCacheKey) {\n            // Override default `getCacheKey` function, which returns [document].\n            this.getCacheKey = options.getCacheKey;\n        }\n        this.cached = options.cache !== false;\n        this.resetCache();\n    }\n    // This default implementation of getCacheKey can be overridden by providing\n    // options.getCacheKey to the DocumentTransform constructor. In general, a\n    // getCacheKey function may either return an array of keys (often including\n    // the document) to be used as a cache key, or undefined to indicate the\n    // transform for this document should not be cached.\n    DocumentTransform.prototype.getCacheKey = function(document) {\n        return [\n            document\n        ];\n    };\n    DocumentTransform.identity = function() {\n        // No need to cache this transform since it just returns the document\n        // unchanged. This should save a bit of memory that would otherwise be\n        // needed to populate the `documentCache` of this transform.\n        return new DocumentTransform(identity, {\n            cache: false\n        });\n    };\n    DocumentTransform.split = function(predicate, left, right) {\n        if (right === void 0) {\n            right = DocumentTransform.identity();\n        }\n        return Object.assign(new DocumentTransform(function(document) {\n            var documentTransform = predicate(document) ? left : right;\n            return documentTransform.transformDocument(document);\n        }, // Reasonably assume both `left` and `right` transforms handle their own caching\n        {\n            cache: false\n        }), {\n            left: left,\n            right: right\n        });\n    };\n    /**\n     * Resets the internal cache of this transform, if it has one.\n     */ DocumentTransform.prototype.resetCache = function() {\n        var _this = this;\n        if (this.cached) {\n            var stableCacheKeys_1 = new _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie(_common_canUse_js__WEBPACK_IMPORTED_MODULE_3__.canUseWeakMap);\n            this.performWork = (0,optimism__WEBPACK_IMPORTED_MODULE_2__.wrap)(DocumentTransform.prototype.performWork.bind(this), {\n                makeCacheKey: function(document) {\n                    var cacheKeys = _this.getCacheKey(document);\n                    if (cacheKeys) {\n                        (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_1__.invariant)(Array.isArray(cacheKeys), 69);\n                        return stableCacheKeys_1.lookupArray(cacheKeys);\n                    }\n                },\n                max: _caching_index_js__WEBPACK_IMPORTED_MODULE_4__.cacheSizes[\"documentTransform.cache\"],\n                cache: _wry_caches__WEBPACK_IMPORTED_MODULE_5__.WeakCache\n            });\n        }\n    };\n    DocumentTransform.prototype.performWork = function(document) {\n        (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_6__.checkDocument)(document);\n        return this.transform(document);\n    };\n    DocumentTransform.prototype.transformDocument = function(document) {\n        // If a user passes an already transformed result back to this function,\n        // immediately return it.\n        if (this.resultCache.has(document)) {\n            return document;\n        }\n        var transformedDocument = this.performWork(document);\n        this.resultCache.add(transformedDocument);\n        return transformedDocument;\n    };\n    DocumentTransform.prototype.concat = function(otherTransform) {\n        var _this = this;\n        return Object.assign(new DocumentTransform(function(document) {\n            return otherTransform.transformDocument(_this.transformDocument(document));\n        }, // Reasonably assume both transforms handle their own caching\n        {\n            cache: false\n        }), {\n            left: this,\n            right: otherTransform\n        });\n    };\n    return DocumentTransform;\n}();\n //# sourceMappingURL=DocumentTransform.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9Eb2N1bWVudFRyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpQztBQUNrQztBQUNuQjtBQUNBO0FBQ1I7QUFDUjtBQUNpQjtBQUNqRCxTQUFTUSxTQUFTQyxRQUFRO0lBQ3RCLE9BQU9BO0FBQ1g7QUFDQSxJQUFJQyxvQkFBb0IsV0FBVyxHQUFJO0lBQ25DLFNBQVNBLGtCQUFrQkMsU0FBUyxFQUFFQyxPQUFPO1FBQ3pDLElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQUVBLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQztRQUFPO1FBQ3pELElBQUksQ0FBQ0MsV0FBVyxHQUFHYiw0REFBYUEsR0FBRyxJQUFJYyxZQUFZLElBQUlDO1FBQ3ZELElBQUksQ0FBQ04sU0FBUyxHQUFHQTtRQUNqQixJQUFJQyxRQUFRTSxXQUFXLEVBQUU7WUFDckIscUVBQXFFO1lBQ3JFLElBQUksQ0FBQ0EsV0FBVyxHQUFHTixRQUFRTSxXQUFXO1FBQzFDO1FBQ0EsSUFBSSxDQUFDQyxNQUFNLEdBQUdQLFFBQVFRLEtBQUssS0FBSztRQUNoQyxJQUFJLENBQUNDLFVBQVU7SUFDbkI7SUFDQSw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLDJFQUEyRTtJQUMzRSx3RUFBd0U7SUFDeEUsb0RBQW9EO0lBQ3BEWCxrQkFBa0JZLFNBQVMsQ0FBQ0osV0FBVyxHQUFHLFNBQVVULFFBQVE7UUFDeEQsT0FBTztZQUFDQTtTQUFTO0lBQ3JCO0lBQ0FDLGtCQUFrQkYsUUFBUSxHQUFHO1FBQ3pCLHFFQUFxRTtRQUNyRSxzRUFBc0U7UUFDdEUsNERBQTREO1FBQzVELE9BQU8sSUFBSUUsa0JBQWtCRixVQUFVO1lBQUVZLE9BQU87UUFBTTtJQUMxRDtJQUNBVixrQkFBa0JhLEtBQUssR0FBRyxTQUFVQyxTQUFTLEVBQUVDLElBQUksRUFBRUMsS0FBSztRQUN0RCxJQUFJQSxVQUFVLEtBQUssR0FBRztZQUFFQSxRQUFRaEIsa0JBQWtCRixRQUFRO1FBQUk7UUFDOUQsT0FBT0ssT0FBT2MsTUFBTSxDQUFDLElBQUlqQixrQkFBa0IsU0FBVUQsUUFBUTtZQUN6RCxJQUFJbUIsb0JBQW9CSixVQUFVZixZQUFZZ0IsT0FBT0M7WUFDckQsT0FBT0Usa0JBQWtCQyxpQkFBaUIsQ0FBQ3BCO1FBQy9DLEdBQ0EsZ0ZBQWdGO1FBQ2hGO1lBQUVXLE9BQU87UUFBTSxJQUFJO1lBQUVLLE1BQU1BO1lBQU1DLE9BQU9BO1FBQU07SUFDbEQ7SUFDQTs7S0FFQyxHQUNEaEIsa0JBQWtCWSxTQUFTLENBQUNELFVBQVUsR0FBRztRQUNyQyxJQUFJUyxRQUFRLElBQUk7UUFDaEIsSUFBSSxJQUFJLENBQUNYLE1BQU0sRUFBRTtZQUNiLElBQUlZLG9CQUFvQixJQUFJL0IsMkNBQUlBLENBQUNDLDREQUFhQTtZQUM5QyxJQUFJLENBQUMrQixXQUFXLEdBQUcxQiw4Q0FBSUEsQ0FBQ0ksa0JBQWtCWSxTQUFTLENBQUNVLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDLElBQUksR0FBRztnQkFDeEVDLGNBQWMsU0FBVXpCLFFBQVE7b0JBQzVCLElBQUkwQixZQUFZTCxNQUFNWixXQUFXLENBQUNUO29CQUNsQyxJQUFJMEIsV0FBVzt3QkFDWC9CLDREQUFTQSxDQUFDZ0MsTUFBTUMsT0FBTyxDQUFDRixZQUFZO3dCQUNwQyxPQUFPSixrQkFBa0JPLFdBQVcsQ0FBQ0g7b0JBQ3pDO2dCQUNKO2dCQUNBSSxLQUFLaEMseURBQVUsQ0FBQywwQkFBMEI7Z0JBQzFDYSxPQUFRZixrREFBU0E7WUFDckI7UUFDSjtJQUNKO0lBQ0FLLGtCQUFrQlksU0FBUyxDQUFDVSxXQUFXLEdBQUcsU0FBVXZCLFFBQVE7UUFDeEROLDZEQUFhQSxDQUFDTTtRQUNkLE9BQU8sSUFBSSxDQUFDRSxTQUFTLENBQUNGO0lBQzFCO0lBQ0FDLGtCQUFrQlksU0FBUyxDQUFDTyxpQkFBaUIsR0FBRyxTQUFVcEIsUUFBUTtRQUM5RCx3RUFBd0U7UUFDeEUseUJBQXlCO1FBQ3pCLElBQUksSUFBSSxDQUFDTSxXQUFXLENBQUN5QixHQUFHLENBQUMvQixXQUFXO1lBQ2hDLE9BQU9BO1FBQ1g7UUFDQSxJQUFJZ0Msc0JBQXNCLElBQUksQ0FBQ1QsV0FBVyxDQUFDdkI7UUFDM0MsSUFBSSxDQUFDTSxXQUFXLENBQUMyQixHQUFHLENBQUNEO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQS9CLGtCQUFrQlksU0FBUyxDQUFDcUIsTUFBTSxHQUFHLFNBQVVDLGNBQWM7UUFDekQsSUFBSWQsUUFBUSxJQUFJO1FBQ2hCLE9BQU9qQixPQUFPYyxNQUFNLENBQUMsSUFBSWpCLGtCQUFrQixTQUFVRCxRQUFRO1lBQ3pELE9BQU9tQyxlQUFlZixpQkFBaUIsQ0FBQ0MsTUFBTUQsaUJBQWlCLENBQUNwQjtRQUNwRSxHQUNBLDZEQUE2RDtRQUM3RDtZQUFFVyxPQUFPO1FBQU0sSUFBSTtZQUNmSyxNQUFNLElBQUk7WUFDVkMsT0FBT2tCO1FBQ1g7SUFDSjtJQUNBLE9BQU9sQztBQUNYO0FBQzZCLENBQzdCLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dyYXBocWwvRG9jdW1lbnRUcmFuc2Zvcm0uanM/YzRkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmllIH0gZnJvbSBcIkB3cnkvdHJpZVwiO1xuaW1wb3J0IHsgY2FuVXNlV2Vha01hcCwgY2FuVXNlV2Vha1NldCB9IGZyb20gXCIuLi9jb21tb24vY2FuVXNlLmpzXCI7XG5pbXBvcnQgeyBjaGVja0RvY3VtZW50IH0gZnJvbSBcIi4vZ2V0RnJvbUFTVC5qc1wiO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFdlYWtDYWNoZSB9IGZyb20gXCJAd3J5L2NhY2hlc1wiO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gXCJvcHRpbWlzbVwiO1xuaW1wb3J0IHsgY2FjaGVTaXplcyB9IGZyb20gXCIuLi9jYWNoaW5nL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBpZGVudGl0eShkb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbn1cbnZhciBEb2N1bWVudFRyYW5zZm9ybSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N1bWVudFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICB0aGlzLnJlc3VsdENhY2hlID0gY2FuVXNlV2Vha1NldCA/IG5ldyBXZWFrU2V0KCkgOiBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICBpZiAob3B0aW9ucy5nZXRDYWNoZUtleSkge1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBgZ2V0Q2FjaGVLZXlgIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIFtkb2N1bWVudF0uXG4gICAgICAgICAgICB0aGlzLmdldENhY2hlS2V5ID0gb3B0aW9ucy5nZXRDYWNoZUtleTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZCA9IG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGdldENhY2hlS2V5IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZ1xuICAgIC8vIG9wdGlvbnMuZ2V0Q2FjaGVLZXkgdG8gdGhlIERvY3VtZW50VHJhbnNmb3JtIGNvbnN0cnVjdG9yLiBJbiBnZW5lcmFsLCBhXG4gICAgLy8gZ2V0Q2FjaGVLZXkgZnVuY3Rpb24gbWF5IGVpdGhlciByZXR1cm4gYW4gYXJyYXkgb2Yga2V5cyAob2Z0ZW4gaW5jbHVkaW5nXG4gICAgLy8gdGhlIGRvY3VtZW50KSB0byBiZSB1c2VkIGFzIGEgY2FjaGUga2V5LCBvciB1bmRlZmluZWQgdG8gaW5kaWNhdGUgdGhlXG4gICAgLy8gdHJhbnNmb3JtIGZvciB0aGlzIGRvY3VtZW50IHNob3VsZCBub3QgYmUgY2FjaGVkLlxuICAgIERvY3VtZW50VHJhbnNmb3JtLnByb3RvdHlwZS5nZXRDYWNoZUtleSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW2RvY3VtZW50XTtcbiAgICB9O1xuICAgIERvY3VtZW50VHJhbnNmb3JtLmlkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNhY2hlIHRoaXMgdHJhbnNmb3JtIHNpbmNlIGl0IGp1c3QgcmV0dXJucyB0aGUgZG9jdW1lbnRcbiAgICAgICAgLy8gdW5jaGFuZ2VkLiBUaGlzIHNob3VsZCBzYXZlIGEgYml0IG9mIG1lbW9yeSB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZVxuICAgICAgICAvLyBuZWVkZWQgdG8gcG9wdWxhdGUgdGhlIGBkb2N1bWVudENhY2hlYCBvZiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFRyYW5zZm9ybShpZGVudGl0eSwgeyBjYWNoZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBEb2N1bWVudFRyYW5zZm9ybS5zcGxpdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gRG9jdW1lbnRUcmFuc2Zvcm0uaWRlbnRpdHkoKTsgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRG9jdW1lbnRUcmFuc2Zvcm0oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRUcmFuc2Zvcm0gPSBwcmVkaWNhdGUoZG9jdW1lbnQpID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50VHJhbnNmb3JtLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIFJlYXNvbmFibHkgYXNzdW1lIGJvdGggYGxlZnRgIGFuZCBgcmlnaHRgIHRyYW5zZm9ybXMgaGFuZGxlIHRoZWlyIG93biBjYWNoaW5nXG4gICAgICAgIHsgY2FjaGU6IGZhbHNlIH0pLCB7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgY2FjaGUgb2YgdGhpcyB0cmFuc2Zvcm0sIGlmIGl0IGhhcyBvbmUuXG4gICAgICovXG4gICAgRG9jdW1lbnRUcmFuc2Zvcm0ucHJvdG90eXBlLnJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZCkge1xuICAgICAgICAgICAgdmFyIHN0YWJsZUNhY2hlS2V5c18xID0gbmV3IFRyaWUoY2FuVXNlV2Vha01hcCk7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1Xb3JrID0gd3JhcChEb2N1bWVudFRyYW5zZm9ybS5wcm90b3R5cGUucGVyZm9ybVdvcmsuYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleXMgPSBfdGhpcy5nZXRDYWNoZUtleShkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudChBcnJheS5pc0FycmF5KGNhY2hlS2V5cyksIDY5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFibGVDYWNoZUtleXNfMS5sb29rdXBBcnJheShjYWNoZUtleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXg6IGNhY2hlU2l6ZXNbXCJkb2N1bWVudFRyYW5zZm9ybS5jYWNoZVwiXSxcbiAgICAgICAgICAgICAgICBjYWNoZTogKFdlYWtDYWNoZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnRUcmFuc2Zvcm0ucHJvdG90eXBlLnBlcmZvcm1Xb3JrID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oZG9jdW1lbnQpO1xuICAgIH07XG4gICAgRG9jdW1lbnRUcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIC8vIElmIGEgdXNlciBwYXNzZXMgYW4gYWxyZWFkeSB0cmFuc2Zvcm1lZCByZXN1bHQgYmFjayB0byB0aGlzIGZ1bmN0aW9uLFxuICAgICAgICAvLyBpbW1lZGlhdGVseSByZXR1cm4gaXQuXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdENhY2hlLmhhcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtZWREb2N1bWVudCA9IHRoaXMucGVyZm9ybVdvcmsoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnJlc3VsdENhY2hlLmFkZCh0cmFuc2Zvcm1lZERvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkRG9jdW1lbnQ7XG4gICAgfTtcbiAgICBEb2N1bWVudFRyYW5zZm9ybS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyVHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBEb2N1bWVudFRyYW5zZm9ybShmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlclRyYW5zZm9ybS50cmFuc2Zvcm1Eb2N1bWVudChfdGhpcy50cmFuc2Zvcm1Eb2N1bWVudChkb2N1bWVudCkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gUmVhc29uYWJseSBhc3N1bWUgYm90aCB0cmFuc2Zvcm1zIGhhbmRsZSB0aGVpciBvd24gY2FjaGluZ1xuICAgICAgICB7IGNhY2hlOiBmYWxzZSB9KSwge1xuICAgICAgICAgICAgbGVmdDogdGhpcyxcbiAgICAgICAgICAgIHJpZ2h0OiBvdGhlclRyYW5zZm9ybSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnRUcmFuc2Zvcm07XG59KCkpO1xuZXhwb3J0IHsgRG9jdW1lbnRUcmFuc2Zvcm0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvY3VtZW50VHJhbnNmb3JtLmpzLm1hcCJdLCJuYW1lcyI6WyJUcmllIiwiY2FuVXNlV2Vha01hcCIsImNhblVzZVdlYWtTZXQiLCJjaGVja0RvY3VtZW50IiwiaW52YXJpYW50IiwiV2Vha0NhY2hlIiwid3JhcCIsImNhY2hlU2l6ZXMiLCJpZGVudGl0eSIsImRvY3VtZW50IiwiRG9jdW1lbnRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJvcHRpb25zIiwiT2JqZWN0IiwiY3JlYXRlIiwicmVzdWx0Q2FjaGUiLCJXZWFrU2V0IiwiU2V0IiwiZ2V0Q2FjaGVLZXkiLCJjYWNoZWQiLCJjYWNoZSIsInJlc2V0Q2FjaGUiLCJwcm90b3R5cGUiLCJzcGxpdCIsInByZWRpY2F0ZSIsImxlZnQiLCJyaWdodCIsImFzc2lnbiIsImRvY3VtZW50VHJhbnNmb3JtIiwidHJhbnNmb3JtRG9jdW1lbnQiLCJfdGhpcyIsInN0YWJsZUNhY2hlS2V5c18xIiwicGVyZm9ybVdvcmsiLCJiaW5kIiwibWFrZUNhY2hlS2V5IiwiY2FjaGVLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwibG9va3VwQXJyYXkiLCJtYXgiLCJoYXMiLCJ0cmFuc2Zvcm1lZERvY3VtZW50IiwiYWRkIiwiY29uY2F0Iiwib3RoZXJUcmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/DocumentTransform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/directives.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDirectiveNames: function() { return /* binding */ getDirectiveNames; },\n/* harmony export */   getInclusionDirectives: function() { return /* binding */ getInclusionDirectives; },\n/* harmony export */   hasAllDirectives: function() { return /* binding */ hasAllDirectives; },\n/* harmony export */   hasAnyDirectives: function() { return /* binding */ hasAnyDirectives; },\n/* harmony export */   hasClientExports: function() { return /* binding */ hasClientExports; },\n/* harmony export */   hasDirectives: function() { return /* binding */ hasDirectives; },\n/* harmony export */   shouldInclude: function() { return /* binding */ shouldInclude; }\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n\n\nfunction shouldInclude(_a, variables) {\n    var directives = _a.directives;\n    if (!directives || !directives.length) {\n        return true;\n    }\n    return getInclusionDirectives(directives).every(function(_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === \"Variable\") {\n            evaledValue = variables && variables[ifArgument.value.name.value];\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(evaledValue !== void 0, 70, directive.name.value);\n        } else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    });\n}\nfunction getDirectiveNames(root) {\n    var names = [];\n    (0,graphql__WEBPACK_IMPORTED_MODULE_1__.visit)(root, {\n        Directive: function(node) {\n            names.push(node.name.value);\n        }\n    });\n    return names;\n}\nvar hasAnyDirectives = function(names, root) {\n    return hasDirectives(names, root, false);\n};\nvar hasAllDirectives = function(names, root) {\n    return hasDirectives(names, root, true);\n};\nfunction hasDirectives(names, root, all) {\n    var nameSet = new Set(names);\n    var uniqueCount = nameSet.size;\n    (0,graphql__WEBPACK_IMPORTED_MODULE_1__.visit)(root, {\n        Directive: function(node) {\n            if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n                return graphql__WEBPACK_IMPORTED_MODULE_1__.BREAK;\n            }\n        }\n    });\n    // If we found all the names, nameSet will be empty. If we only care about\n    // finding some of them, the < condition is sufficient.\n    return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\nfunction hasClientExports(document) {\n    return document && hasDirectives([\n        \"client\",\n        \"export\"\n    ], document, true);\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === \"skip\" || value === \"include\";\n}\nfunction getInclusionDirectives(directives) {\n    var result = [];\n    if (directives && directives.length) {\n        directives.forEach(function(directive) {\n            if (!isInclusionDirective(directive)) return;\n            var directiveArguments = directive.arguments;\n            var directiveName = directive.name.value;\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(directiveArguments && directiveArguments.length === 1, 71, directiveName);\n            var ifArgument = directiveArguments[0];\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifArgument.name && ifArgument.name.value === \"if\", 72, directiveName);\n            var ifValue = ifArgument.value;\n            // means it has to be a variable value if this is a valid @skip or @include directive\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifValue && (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"), 73, directiveName);\n            result.push({\n                directive: directive,\n                ifArgument: ifArgument\n            });\n        });\n    }\n    return result;\n} //# sourceMappingURL=directives.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9kaXJlY3RpdmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNUO0FBQ2hDLFNBQVNHLGNBQWNDLEVBQUUsRUFBRUMsU0FBUztJQUN2QyxJQUFJQyxhQUFhRixHQUFHRSxVQUFVO0lBQzlCLElBQUksQ0FBQ0EsY0FBYyxDQUFDQSxXQUFXQyxNQUFNLEVBQUU7UUFDbkMsT0FBTztJQUNYO0lBQ0EsT0FBT0MsdUJBQXVCRixZQUFZRyxLQUFLLENBQUMsU0FBVUwsRUFBRTtRQUN4RCxJQUFJTSxZQUFZTixHQUFHTSxTQUFTLEVBQUVDLGFBQWFQLEdBQUdPLFVBQVU7UUFDeEQsSUFBSUMsY0FBYztRQUNsQixJQUFJRCxXQUFXRSxLQUFLLENBQUNDLElBQUksS0FBSyxZQUFZO1lBQ3RDRixjQUNJUCxhQUFhQSxTQUFTLENBQUNNLFdBQVdFLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRixLQUFLLENBQUM7WUFDdkRiLDREQUFTQSxDQUFDWSxnQkFBZ0IsS0FBSyxHQUFHLElBQUlGLFVBQVVLLElBQUksQ0FBQ0YsS0FBSztRQUM5RCxPQUNLO1lBQ0RELGNBQWNELFdBQVdFLEtBQUssQ0FBQ0EsS0FBSztRQUN4QztRQUNBLE9BQU9ILFVBQVVLLElBQUksQ0FBQ0YsS0FBSyxLQUFLLFNBQVMsQ0FBQ0QsY0FBY0E7SUFDNUQ7QUFDSjtBQUNPLFNBQVNJLGtCQUFrQkMsSUFBSTtJQUNsQyxJQUFJQyxRQUFRLEVBQUU7SUFDZGpCLDhDQUFLQSxDQUFDZ0IsTUFBTTtRQUNSRSxXQUFXLFNBQVVDLElBQUk7WUFDckJGLE1BQU1HLElBQUksQ0FBQ0QsS0FBS0wsSUFBSSxDQUFDRixLQUFLO1FBQzlCO0lBQ0o7SUFDQSxPQUFPSztBQUNYO0FBQ08sSUFBSUksbUJBQW1CLFNBQVVKLEtBQUssRUFBRUQsSUFBSTtJQUMvQyxPQUFPTSxjQUFjTCxPQUFPRCxNQUFNO0FBQ3RDLEVBQUU7QUFDSyxJQUFJTyxtQkFBbUIsU0FBVU4sS0FBSyxFQUFFRCxJQUFJO0lBQy9DLE9BQU9NLGNBQWNMLE9BQU9ELE1BQU07QUFDdEMsRUFBRTtBQUNLLFNBQVNNLGNBQWNMLEtBQUssRUFBRUQsSUFBSSxFQUFFUSxHQUFHO0lBQzFDLElBQUlDLFVBQVUsSUFBSUMsSUFBSVQ7SUFDdEIsSUFBSVUsY0FBY0YsUUFBUUcsSUFBSTtJQUM5QjVCLDhDQUFLQSxDQUFDZ0IsTUFBTTtRQUNSRSxXQUFXLFNBQVVDLElBQUk7WUFDckIsSUFBSU0sUUFBUUksTUFBTSxDQUFDVixLQUFLTCxJQUFJLENBQUNGLEtBQUssS0FBTSxFQUFDWSxPQUFPLENBQUNDLFFBQVFHLElBQUksR0FBRztnQkFDNUQsT0FBTzNCLDBDQUFLQTtZQUNoQjtRQUNKO0lBQ0o7SUFDQSwwRUFBMEU7SUFDMUUsdURBQXVEO0lBQ3ZELE9BQU91QixNQUFNLENBQUNDLFFBQVFHLElBQUksR0FBR0gsUUFBUUcsSUFBSSxHQUFHRDtBQUNoRDtBQUNPLFNBQVNHLGlCQUFpQkMsUUFBUTtJQUNyQyxPQUFPQSxZQUFZVCxjQUFjO1FBQUM7UUFBVTtLQUFTLEVBQUVTLFVBQVU7QUFDckU7QUFDQSxTQUFTQyxxQkFBcUI3QixFQUFFO0lBQzVCLElBQUlTLFFBQVFULEdBQUdXLElBQUksQ0FBQ0YsS0FBSztJQUN6QixPQUFPQSxVQUFVLFVBQVVBLFVBQVU7QUFDekM7QUFDTyxTQUFTTCx1QkFBdUJGLFVBQVU7SUFDN0MsSUFBSTRCLFNBQVMsRUFBRTtJQUNmLElBQUk1QixjQUFjQSxXQUFXQyxNQUFNLEVBQUU7UUFDakNELFdBQVc2QixPQUFPLENBQUMsU0FBVXpCLFNBQVM7WUFDbEMsSUFBSSxDQUFDdUIscUJBQXFCdkIsWUFDdEI7WUFDSixJQUFJMEIscUJBQXFCMUIsVUFBVTJCLFNBQVM7WUFDNUMsSUFBSUMsZ0JBQWdCNUIsVUFBVUssSUFBSSxDQUFDRixLQUFLO1lBQ3hDYiw0REFBU0EsQ0FBQ29DLHNCQUFzQkEsbUJBQW1CN0IsTUFBTSxLQUFLLEdBQUcsSUFBSStCO1lBQ3JFLElBQUkzQixhQUFheUIsa0JBQWtCLENBQUMsRUFBRTtZQUN0Q3BDLDREQUFTQSxDQUFDVyxXQUFXSSxJQUFJLElBQUlKLFdBQVdJLElBQUksQ0FBQ0YsS0FBSyxLQUFLLE1BQU0sSUFBSXlCO1lBQ2pFLElBQUlDLFVBQVU1QixXQUFXRSxLQUFLO1lBQzlCLHFGQUFxRjtZQUNyRmIsNERBQVNBLENBQUN1QyxXQUNMQSxDQUFBQSxRQUFRekIsSUFBSSxLQUFLLGNBQWN5QixRQUFRekIsSUFBSSxLQUFLLGNBQWEsR0FBSSxJQUFJd0I7WUFDMUVKLE9BQU9iLElBQUksQ0FBQztnQkFBRVgsV0FBV0E7Z0JBQVdDLFlBQVlBO1lBQVc7UUFDL0Q7SUFDSjtJQUNBLE9BQU91QjtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9kaXJlY3RpdmVzLmpzP2UwMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZpc2l0LCBCUkVBSyB9IGZyb20gXCJncmFwaHFsXCI7XG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSW5jbHVkZShfYSwgdmFyaWFibGVzKSB7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBfYS5kaXJlY3RpdmVzO1xuICAgIGlmICghZGlyZWN0aXZlcyB8fCAhZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBnZXRJbmNsdXNpb25EaXJlY3RpdmVzKGRpcmVjdGl2ZXMpLmV2ZXJ5KGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGlyZWN0aXZlID0gX2EuZGlyZWN0aXZlLCBpZkFyZ3VtZW50ID0gX2EuaWZBcmd1bWVudDtcbiAgICAgICAgdmFyIGV2YWxlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmIChpZkFyZ3VtZW50LnZhbHVlLmtpbmQgPT09IFwiVmFyaWFibGVcIikge1xuICAgICAgICAgICAgZXZhbGVkVmFsdWUgPVxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyAmJiB2YXJpYWJsZXNbaWZBcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgIGludmFyaWFudChldmFsZWRWYWx1ZSAhPT0gdm9pZCAwLCA3MCwgZGlyZWN0aXZlLm5hbWUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZhbGVkVmFsdWUgPSBpZkFyZ3VtZW50LnZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gXCJza2lwXCIgPyAhZXZhbGVkVmFsdWUgOiBldmFsZWRWYWx1ZTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXJlY3RpdmVOYW1lcyhyb290KSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgdmlzaXQocm9vdCwge1xuICAgICAgICBEaXJlY3RpdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKG5vZGUubmFtZS52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZXhwb3J0IHZhciBoYXNBbnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gKG5hbWVzLCByb290KSB7XG4gICAgcmV0dXJuIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QsIGZhbHNlKTtcbn07XG5leHBvcnQgdmFyIGhhc0FsbERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAobmFtZXMsIHJvb3QpIHtcbiAgICByZXR1cm4gaGFzRGlyZWN0aXZlcyhuYW1lcywgcm9vdCwgdHJ1ZSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QsIGFsbCkge1xuICAgIHZhciBuYW1lU2V0ID0gbmV3IFNldChuYW1lcyk7XG4gICAgdmFyIHVuaXF1ZUNvdW50ID0gbmFtZVNldC5zaXplO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgRGlyZWN0aXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5hbWVTZXQuZGVsZXRlKG5vZGUubmFtZS52YWx1ZSkgJiYgKCFhbGwgfHwgIW5hbWVTZXQuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gSWYgd2UgZm91bmQgYWxsIHRoZSBuYW1lcywgbmFtZVNldCB3aWxsIGJlIGVtcHR5LiBJZiB3ZSBvbmx5IGNhcmUgYWJvdXRcbiAgICAvLyBmaW5kaW5nIHNvbWUgb2YgdGhlbSwgdGhlIDwgY29uZGl0aW9uIGlzIHN1ZmZpY2llbnQuXG4gICAgcmV0dXJuIGFsbCA/ICFuYW1lU2V0LnNpemUgOiBuYW1lU2V0LnNpemUgPCB1bmlxdWVDb3VudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGllbnRFeHBvcnRzKGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50ICYmIGhhc0RpcmVjdGl2ZXMoW1wiY2xpZW50XCIsIFwiZXhwb3J0XCJdLCBkb2N1bWVudCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBpc0luY2x1c2lvbkRpcmVjdGl2ZShfYSkge1xuICAgIHZhciB2YWx1ZSA9IF9hLm5hbWUudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlID09PSBcInNraXBcIiB8fCB2YWx1ZSA9PT0gXCJpbmNsdWRlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhkaXJlY3RpdmVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzSW5jbHVzaW9uRGlyZWN0aXZlKGRpcmVjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUFyZ3VtZW50cyA9IGRpcmVjdGl2ZS5hcmd1bWVudHM7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgaW52YXJpYW50KGRpcmVjdGl2ZUFyZ3VtZW50cyAmJiBkaXJlY3RpdmVBcmd1bWVudHMubGVuZ3RoID09PSAxLCA3MSwgZGlyZWN0aXZlTmFtZSk7XG4gICAgICAgICAgICB2YXIgaWZBcmd1bWVudCA9IGRpcmVjdGl2ZUFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGludmFyaWFudChpZkFyZ3VtZW50Lm5hbWUgJiYgaWZBcmd1bWVudC5uYW1lLnZhbHVlID09PSBcImlmXCIsIDcyLCBkaXJlY3RpdmVOYW1lKTtcbiAgICAgICAgICAgIHZhciBpZlZhbHVlID0gaWZBcmd1bWVudC52YWx1ZTtcbiAgICAgICAgICAgIC8vIG1lYW5zIGl0IGhhcyB0byBiZSBhIHZhcmlhYmxlIHZhbHVlIGlmIHRoaXMgaXMgYSB2YWxpZCBAc2tpcCBvciBAaW5jbHVkZSBkaXJlY3RpdmVcbiAgICAgICAgICAgIGludmFyaWFudChpZlZhbHVlICYmXG4gICAgICAgICAgICAgICAgKGlmVmFsdWUua2luZCA9PT0gXCJWYXJpYWJsZVwiIHx8IGlmVmFsdWUua2luZCA9PT0gXCJCb29sZWFuVmFsdWVcIiksIDczLCBkaXJlY3RpdmVOYW1lKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZGlyZWN0aXZlOiBkaXJlY3RpdmUsIGlmQXJndW1lbnQ6IGlmQXJndW1lbnQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlcy5qcy5tYXAiXSwibmFtZXMiOlsiaW52YXJpYW50IiwidmlzaXQiLCJCUkVBSyIsInNob3VsZEluY2x1ZGUiLCJfYSIsInZhcmlhYmxlcyIsImRpcmVjdGl2ZXMiLCJsZW5ndGgiLCJnZXRJbmNsdXNpb25EaXJlY3RpdmVzIiwiZXZlcnkiLCJkaXJlY3RpdmUiLCJpZkFyZ3VtZW50IiwiZXZhbGVkVmFsdWUiLCJ2YWx1ZSIsImtpbmQiLCJuYW1lIiwiZ2V0RGlyZWN0aXZlTmFtZXMiLCJyb290IiwibmFtZXMiLCJEaXJlY3RpdmUiLCJub2RlIiwicHVzaCIsImhhc0FueURpcmVjdGl2ZXMiLCJoYXNEaXJlY3RpdmVzIiwiaGFzQWxsRGlyZWN0aXZlcyIsImFsbCIsIm5hbWVTZXQiLCJTZXQiLCJ1bmlxdWVDb3VudCIsInNpemUiLCJkZWxldGUiLCJoYXNDbGllbnRFeHBvcnRzIiwiZG9jdW1lbnQiLCJpc0luY2x1c2lvbkRpcmVjdGl2ZSIsInJlc3VsdCIsImZvckVhY2giLCJkaXJlY3RpdmVBcmd1bWVudHMiLCJhcmd1bWVudHMiLCJkaXJlY3RpdmVOYW1lIiwiaWZWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/fragments.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFragmentMap: function() { return /* binding */ createFragmentMap; },\n/* harmony export */   getFragmentFromSelection: function() { return /* binding */ getFragmentFromSelection; },\n/* harmony export */   getFragmentQueryDocument: function() { return /* binding */ getFragmentQueryDocument; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */ function getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    // Build an array of all our fragment definitions that will be used for\n    // validations. We also do some validations on the other definitions in the\n    // document while building this list.\n    var fragments = [];\n    document.definitions.forEach(function(definition) {\n        // Throw an error if we encounter an operation definition because we will\n        // define our own operation definition later on.\n        if (definition.kind === \"OperationDefinition\") {\n            throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(74, definition.operation, definition.name ? \" named '\".concat(definition.name.value, \"'\") : \"\");\n        }\n        // Add our definition to the fragments array if it is a fragment\n        // definition.\n        if (definition.kind === \"FragmentDefinition\") {\n            fragments.push(definition);\n        }\n    });\n    // If the user did not give us a fragment name then let us try to get a\n    // name from a single fragment in the definition.\n    if (typeof actualFragmentName === \"undefined\") {\n        (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragments.length === 1, 75, fragments.length);\n        actualFragmentName = fragments[0].name.value;\n    }\n    // Generate a query document with an operation that simply spreads the\n    // fragment inside of it.\n    var query = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, document), {\n        definitions: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n            {\n                kind: \"OperationDefinition\",\n                // OperationTypeNode is an enum\n                operation: \"query\",\n                selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                        {\n                            kind: \"FragmentSpread\",\n                            name: {\n                                kind: \"Name\",\n                                value: actualFragmentName\n                            }\n                        }\n                    ]\n                }\n            }\n        ], document.definitions, true)\n    });\n    return query;\n}\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) {\n        fragments = [];\n    }\n    var symTable = {};\n    fragments.forEach(function(fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nfunction getFragmentFromSelection(selection, fragmentMap) {\n    switch(selection.kind){\n        case \"InlineFragment\":\n            return selection;\n        case \"FragmentSpread\":\n            {\n                var fragmentName = selection.name.value;\n                if (typeof fragmentMap === \"function\") {\n                    return fragmentMap(fragmentName);\n                }\n                var fragment = fragmentMap && fragmentMap[fragmentName];\n                (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragment, 76, fragmentName);\n                return fragment || null;\n            }\n        default:\n            return null;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDbUI7QUFDbkU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNJLHlCQUF5QkMsUUFBUSxFQUFFQyxZQUFZO0lBQzNELElBQUlDLHFCQUFxQkQ7SUFDekIsdUVBQXVFO0lBQ3ZFLDJFQUEyRTtJQUMzRSxxQ0FBcUM7SUFDckMsSUFBSUUsWUFBWSxFQUFFO0lBQ2xCSCxTQUFTSSxXQUFXLENBQUNDLE9BQU8sQ0FBQyxTQUFVQyxVQUFVO1FBQzdDLHlFQUF5RTtRQUN6RSxnREFBZ0Q7UUFDaEQsSUFBSUEsV0FBV0MsSUFBSSxLQUFLLHVCQUF1QjtZQUMzQyxNQUFNVCxvRUFBaUJBLENBQ25CLElBQ0FRLFdBQVdFLFNBQVMsRUFDcEJGLFdBQVdHLElBQUksR0FBRyxXQUFXQyxNQUFNLENBQUNKLFdBQVdHLElBQUksQ0FBQ0UsS0FBSyxFQUFFLE9BQU87UUFFMUU7UUFDQSxnRUFBZ0U7UUFDaEUsY0FBYztRQUNkLElBQUlMLFdBQVdDLElBQUksS0FBSyxzQkFBc0I7WUFDMUNKLFVBQVVTLElBQUksQ0FBQ047UUFDbkI7SUFDSjtJQUNBLHVFQUF1RTtJQUN2RSxpREFBaUQ7SUFDakQsSUFBSSxPQUFPSix1QkFBdUIsYUFBYTtRQUMzQ0wsNERBQVNBLENBQUNNLFVBQVVVLE1BQU0sS0FBSyxHQUFHLElBQUlWLFVBQVVVLE1BQU07UUFDdERYLHFCQUFxQkMsU0FBUyxDQUFDLEVBQUUsQ0FBQ00sSUFBSSxDQUFDRSxLQUFLO0lBQ2hEO0lBQ0Esc0VBQXNFO0lBQ3RFLHlCQUF5QjtJQUN6QixJQUFJRyxRQUFRbkIsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR0ssV0FBVztRQUFFSSxhQUFhUixvREFBYUEsQ0FBQztZQUNsRTtnQkFDSVcsTUFBTTtnQkFDTiwrQkFBK0I7Z0JBQy9CQyxXQUFXO2dCQUNYTyxjQUFjO29CQUNWUixNQUFNO29CQUNOUyxZQUFZO3dCQUNSOzRCQUNJVCxNQUFNOzRCQUNORSxNQUFNO2dDQUNGRixNQUFNO2dDQUNOSSxPQUFPVDs0QkFDWDt3QkFDSjtxQkFDSDtnQkFDTDtZQUNKO1NBQ0gsRUFBRUYsU0FBU0ksV0FBVyxFQUFFO0lBQU07SUFDbkMsT0FBT1U7QUFDWDtBQUNBLDBGQUEwRjtBQUMxRixpRUFBaUU7QUFDMUQsU0FBU0csa0JBQWtCZCxTQUFTO0lBQ3ZDLElBQUlBLGNBQWMsS0FBSyxHQUFHO1FBQUVBLFlBQVksRUFBRTtJQUFFO0lBQzVDLElBQUllLFdBQVcsQ0FBQztJQUNoQmYsVUFBVUUsT0FBTyxDQUFDLFNBQVVjLFFBQVE7UUFDaENELFFBQVEsQ0FBQ0MsU0FBU1YsSUFBSSxDQUFDRSxLQUFLLENBQUMsR0FBR1E7SUFDcEM7SUFDQSxPQUFPRDtBQUNYO0FBQ08sU0FBU0UseUJBQXlCQyxTQUFTLEVBQUVDLFdBQVc7SUFDM0QsT0FBUUQsVUFBVWQsSUFBSTtRQUNsQixLQUFLO1lBQ0QsT0FBT2M7UUFDWCxLQUFLO1lBQWtCO2dCQUNuQixJQUFJcEIsZUFBZW9CLFVBQVVaLElBQUksQ0FBQ0UsS0FBSztnQkFDdkMsSUFBSSxPQUFPVyxnQkFBZ0IsWUFBWTtvQkFDbkMsT0FBT0EsWUFBWXJCO2dCQUN2QjtnQkFDQSxJQUFJa0IsV0FBV0csZUFBZUEsV0FBVyxDQUFDckIsYUFBYTtnQkFDdkRKLDREQUFTQSxDQUFDc0IsVUFBVSxJQUFJbEI7Z0JBQ3hCLE9BQU9rQixZQUFZO1lBQ3ZCO1FBQ0E7WUFDSSxPQUFPO0lBQ2Y7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dyYXBocWwvZnJhZ21lbnRzLmpzP2E0NTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vZ2xvYmFscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnkgZG9jdW1lbnQgd2hpY2ggYWRkcyBhIHNpbmdsZSBxdWVyeSBvcGVyYXRpb24gdGhhdCBvbmx5XG4gKiBzcHJlYWRzIHRoZSB0YXJnZXQgZnJhZ21lbnQgaW5zaWRlIG9mIGl0LlxuICpcbiAqIFNvIGZvciBleGFtcGxlIGEgZG9jdW1lbnQgb2Y6XG4gKlxuICogYGBgZ3JhcGhxbFxuICogZnJhZ21lbnQgZm9vIG9uIEZvbyB7IGEgYiBjIH1cbiAqIGBgYFxuICpcbiAqIFR1cm5zIGludG86XG4gKlxuICogYGBgZ3JhcGhxbFxuICogeyAuLi5mb28gfVxuICpcbiAqIGZyYWdtZW50IGZvbyBvbiBGb28geyBhIGIgYyB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgdGFyZ2V0IGZyYWdtZW50IHdpbGwgZWl0aGVyIGJlIHRoZSBvbmx5IGZyYWdtZW50IGluIHRoZSBkb2N1bWVudCwgb3IgYVxuICogZnJhZ21lbnQgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBgZnJhZ21lbnROYW1lYC4gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZVxuICogZnJhZ21lbnQsIGJ1dCBhIGBmcmFnbWVudE5hbWVgIHdhcyBub3QgZGVmaW5lZCB0aGVuIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50KGRvY3VtZW50LCBmcmFnbWVudE5hbWUpIHtcbiAgICB2YXIgYWN0dWFsRnJhZ21lbnROYW1lID0gZnJhZ21lbnROYW1lO1xuICAgIC8vIEJ1aWxkIGFuIGFycmF5IG9mIGFsbCBvdXIgZnJhZ21lbnQgZGVmaW5pdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yXG4gICAgLy8gdmFsaWRhdGlvbnMuIFdlIGFsc28gZG8gc29tZSB2YWxpZGF0aW9ucyBvbiB0aGUgb3RoZXIgZGVmaW5pdGlvbnMgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQgd2hpbGUgYnVpbGRpbmcgdGhpcyBsaXN0LlxuICAgIHZhciBmcmFnbWVudHMgPSBbXTtcbiAgICBkb2N1bWVudC5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHdlIGVuY291bnRlciBhbiBvcGVyYXRpb24gZGVmaW5pdGlvbiBiZWNhdXNlIHdlIHdpbGxcbiAgICAgICAgLy8gZGVmaW5lIG91ciBvd24gb3BlcmF0aW9uIGRlZmluaXRpb24gbGF0ZXIgb24uXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXdJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgICAgICA3NCxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLm9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPyBcIiBuYW1lZCAnXCIuY29uY2F0KGRlZmluaXRpb24ubmFtZS52YWx1ZSwgXCInXCIpIDogXCJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgb3VyIGRlZmluaXRpb24gdG8gdGhlIGZyYWdtZW50cyBhcnJheSBpZiBpdCBpcyBhIGZyYWdtZW50XG4gICAgICAgIC8vIGRlZmluaXRpb24uXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09IFwiRnJhZ21lbnREZWZpbml0aW9uXCIpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIHVzZXIgZGlkIG5vdCBnaXZlIHVzIGEgZnJhZ21lbnQgbmFtZSB0aGVuIGxldCB1cyB0cnkgdG8gZ2V0IGFcbiAgICAvLyBuYW1lIGZyb20gYSBzaW5nbGUgZnJhZ21lbnQgaW4gdGhlIGRlZmluaXRpb24uXG4gICAgaWYgKHR5cGVvZiBhY3R1YWxGcmFnbWVudE5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW52YXJpYW50KGZyYWdtZW50cy5sZW5ndGggPT09IDEsIDc1LCBmcmFnbWVudHMubGVuZ3RoKTtcbiAgICAgICAgYWN0dWFsRnJhZ21lbnROYW1lID0gZnJhZ21lbnRzWzBdLm5hbWUudmFsdWU7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgcXVlcnkgZG9jdW1lbnQgd2l0aCBhbiBvcGVyYXRpb24gdGhhdCBzaW1wbHkgc3ByZWFkcyB0aGVcbiAgICAvLyBmcmFnbWVudCBpbnNpZGUgb2YgaXQuXG4gICAgdmFyIHF1ZXJ5ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvY3VtZW50KSwgeyBkZWZpbml0aW9uczogX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2luZDogXCJPcGVyYXRpb25EZWZpbml0aW9uXCIsXG4gICAgICAgICAgICAgICAgLy8gT3BlcmF0aW9uVHlwZU5vZGUgaXMgYW4gZW51bVxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDoge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBcIlNlbGVjdGlvblNldFwiLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJGcmFnbWVudFNwcmVhZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJOYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhY3R1YWxGcmFnbWVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSwgZG9jdW1lbnQuZGVmaW5pdGlvbnMsIHRydWUpIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGxpc3Qgb2YgZnJhZ21lbnQgZGVmaW5pdGlvbnMgYW5kIG1ha2VzIGEgaGFzaCBvdXQgb2YgdGhlbVxuLy8gdGhhdCBtYXBzIHRoZSBuYW1lIG9mIHRoZSBmcmFnbWVudCB0byB0aGUgZnJhZ21lbnQgZGVmaW5pdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpIHtcbiAgICBpZiAoZnJhZ21lbnRzID09PSB2b2lkIDApIHsgZnJhZ21lbnRzID0gW107IH1cbiAgICB2YXIgc3ltVGFibGUgPSB7fTtcbiAgICBmcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgc3ltVGFibGVbZnJhZ21lbnQubmFtZS52YWx1ZV0gPSBmcmFnbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gc3ltVGFibGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbiwgZnJhZ21lbnRNYXApIHtcbiAgICBzd2l0Y2ggKHNlbGVjdGlvbi5raW5kKSB7XG4gICAgICAgIGNhc2UgXCJJbmxpbmVGcmFnbWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICAgICAgY2FzZSBcIkZyYWdtZW50U3ByZWFkXCI6IHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudE5hbWUgPSBzZWxlY3Rpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRNYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudE1hcChmcmFnbWVudE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZnJhZ21lbnRNYXAgJiYgZnJhZ21lbnRNYXBbZnJhZ21lbnROYW1lXTtcbiAgICAgICAgICAgIGludmFyaWFudChmcmFnbWVudCwgNzYsIGZyYWdtZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fc3ByZWFkQXJyYXkiLCJpbnZhcmlhbnQiLCJuZXdJbnZhcmlhbnRFcnJvciIsImdldEZyYWdtZW50UXVlcnlEb2N1bWVudCIsImRvY3VtZW50IiwiZnJhZ21lbnROYW1lIiwiYWN0dWFsRnJhZ21lbnROYW1lIiwiZnJhZ21lbnRzIiwiZGVmaW5pdGlvbnMiLCJmb3JFYWNoIiwiZGVmaW5pdGlvbiIsImtpbmQiLCJvcGVyYXRpb24iLCJuYW1lIiwiY29uY2F0IiwidmFsdWUiLCJwdXNoIiwibGVuZ3RoIiwicXVlcnkiLCJzZWxlY3Rpb25TZXQiLCJzZWxlY3Rpb25zIiwiY3JlYXRlRnJhZ21lbnRNYXAiLCJzeW1UYWJsZSIsImZyYWdtZW50IiwiZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZnJhZ21lbnRNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/getFromAST.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDocument: function() { return /* binding */ checkDocument; },\n/* harmony export */   getDefaultValues: function() { return /* binding */ getDefaultValues; },\n/* harmony export */   getFragmentDefinition: function() { return /* binding */ getFragmentDefinition; },\n/* harmony export */   getFragmentDefinitions: function() { return /* binding */ getFragmentDefinitions; },\n/* harmony export */   getMainDefinition: function() { return /* binding */ getMainDefinition; },\n/* harmony export */   getOperationDefinition: function() { return /* binding */ getOperationDefinition; },\n/* harmony export */   getOperationName: function() { return /* binding */ getOperationName; },\n/* harmony export */   getQueryDefinition: function() { return /* binding */ getQueryDefinition; }\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _storeUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeUtils.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n\n\n// Checks the document for errors and throws an exception if there is an error.\nfunction checkDocument(doc) {\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc && doc.kind === \"Document\", 77);\n    var operations = doc.definitions.filter(function(d) {\n        return d.kind !== \"FragmentDefinition\";\n    }).map(function(definition) {\n        if (definition.kind !== \"OperationDefinition\") {\n            throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(78, definition.kind);\n        }\n        return definition;\n    });\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(operations.length <= 1, 79, operations.length);\n    return doc;\n}\nfunction getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function(definition) {\n        return definition.kind === \"OperationDefinition\";\n    })[0];\n}\nfunction getOperationName(doc) {\n    return doc.definitions.filter(function(definition) {\n        return definition.kind === \"OperationDefinition\" && !!definition.name;\n    }).map(function(x) {\n        return x.name.value;\n    })[0] || null;\n}\n// Returns the FragmentDefinitions from a particular document as an array\nfunction getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function(definition) {\n        return definition.kind === \"FragmentDefinition\";\n    });\n}\nfunction getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(queryDef && queryDef.operation === \"query\", 80);\n    return queryDef;\n}\nfunction getFragmentDefinition(doc) {\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.kind === \"Document\", 81);\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.definitions.length <= 1, 82);\n    var fragmentDef = doc.definitions[0];\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragmentDef.kind === \"FragmentDefinition\", 83);\n    return fragmentDef;\n}\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */ function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for(var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++){\n        var definition = _a[_i];\n        if (definition.kind === \"OperationDefinition\") {\n            var operation = definition.operation;\n            if (operation === \"query\" || operation === \"mutation\" || operation === \"subscription\") {\n                return definition;\n            }\n        }\n        if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n            // we do this because we want to allow multiple fragment definitions\n            // to precede an operation definition.\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(84);\n}\nfunction getDefaultValues(definition) {\n    var defaultValues = Object.create(null);\n    var defs = definition && definition.variableDefinitions;\n    if (defs && defs.length) {\n        defs.forEach(function(def) {\n            if (def.defaultValue) {\n                (0,_storeUtils_js__WEBPACK_IMPORTED_MODULE_1__.valueToObjectRepresentation)(defaultValues, def.variable.name, def.defaultValue);\n            }\n        });\n    }\n    return defaultValues;\n} //# sourceMappingURL=getFromAST.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9nZXRGcm9tQVNULmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDTDtBQUM5RCwrRUFBK0U7QUFDeEUsU0FBU0csY0FBY0MsR0FBRztJQUM3QkosNERBQVNBLENBQUNJLE9BQU9BLElBQUlDLElBQUksS0FBSyxZQUFZO0lBQzFDLElBQUlDLGFBQWFGLElBQUlHLFdBQVcsQ0FDM0JDLE1BQU0sQ0FBQyxTQUFVQyxDQUFDO1FBQUksT0FBT0EsRUFBRUosSUFBSSxLQUFLO0lBQXNCLEdBQzlESyxHQUFHLENBQUMsU0FBVUMsVUFBVTtRQUN6QixJQUFJQSxXQUFXTixJQUFJLEtBQUssdUJBQXVCO1lBQzNDLE1BQU1KLG9FQUFpQkEsQ0FBQyxJQUFJVSxXQUFXTixJQUFJO1FBQy9DO1FBQ0EsT0FBT007SUFDWDtJQUNBWCw0REFBU0EsQ0FBQ00sV0FBV00sTUFBTSxJQUFJLEdBQUcsSUFBSU4sV0FBV00sTUFBTTtJQUN2RCxPQUFPUjtBQUNYO0FBQ08sU0FBU1MsdUJBQXVCVCxHQUFHO0lBQ3RDRCxjQUFjQztJQUNkLE9BQU9BLElBQUlHLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDLFNBQVVHLFVBQVU7UUFDOUMsT0FBT0EsV0FBV04sSUFBSSxLQUFLO0lBQy9CLEVBQUUsQ0FBQyxFQUFFO0FBQ1Q7QUFDTyxTQUFTUyxpQkFBaUJWLEdBQUc7SUFDaEMsT0FBUUEsSUFBSUcsV0FBVyxDQUNsQkMsTUFBTSxDQUFDLFNBQVVHLFVBQVU7UUFDNUIsT0FBT0EsV0FBV04sSUFBSSxLQUFLLHlCQUF5QixDQUFDLENBQUNNLFdBQVdJLElBQUk7SUFDekUsR0FDS0wsR0FBRyxDQUFDLFNBQVVNLENBQUM7UUFBSSxPQUFPQSxFQUFFRCxJQUFJLENBQUNFLEtBQUs7SUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJO0FBQzFEO0FBQ0EseUVBQXlFO0FBQ2xFLFNBQVNDLHVCQUF1QmQsR0FBRztJQUN0QyxPQUFPQSxJQUFJRyxXQUFXLENBQUNDLE1BQU0sQ0FBQyxTQUFVRyxVQUFVO1FBQzlDLE9BQU9BLFdBQVdOLElBQUksS0FBSztJQUMvQjtBQUNKO0FBQ08sU0FBU2MsbUJBQW1CZixHQUFHO0lBQ2xDLElBQUlnQixXQUFXUCx1QkFBdUJUO0lBQ3RDSiw0REFBU0EsQ0FBQ29CLFlBQVlBLFNBQVNDLFNBQVMsS0FBSyxTQUFTO0lBQ3RELE9BQU9EO0FBQ1g7QUFDTyxTQUFTRSxzQkFBc0JsQixHQUFHO0lBQ3JDSiw0REFBU0EsQ0FBQ0ksSUFBSUMsSUFBSSxLQUFLLFlBQVk7SUFDbkNMLDREQUFTQSxDQUFDSSxJQUFJRyxXQUFXLENBQUNLLE1BQU0sSUFBSSxHQUFHO0lBQ3ZDLElBQUlXLGNBQWNuQixJQUFJRyxXQUFXLENBQUMsRUFBRTtJQUNwQ1AsNERBQVNBLENBQUN1QixZQUFZbEIsSUFBSSxLQUFLLHNCQUFzQjtJQUNyRCxPQUFPa0I7QUFDWDtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxrQkFBa0JDLFFBQVE7SUFDdEN0QixjQUFjc0I7SUFDZCxJQUFJQztJQUNKLElBQUssSUFBSUMsS0FBSyxHQUFHQyxLQUFLSCxTQUFTbEIsV0FBVyxFQUFFb0IsS0FBS0MsR0FBR2hCLE1BQU0sRUFBRWUsS0FBTTtRQUM5RCxJQUFJaEIsYUFBYWlCLEVBQUUsQ0FBQ0QsR0FBRztRQUN2QixJQUFJaEIsV0FBV04sSUFBSSxLQUFLLHVCQUF1QjtZQUMzQyxJQUFJZ0IsWUFBWVYsV0FBV1UsU0FBUztZQUNwQyxJQUFJQSxjQUFjLFdBQ2RBLGNBQWMsY0FDZEEsY0FBYyxnQkFBZ0I7Z0JBQzlCLE9BQU9WO1lBQ1g7UUFDSjtRQUNBLElBQUlBLFdBQVdOLElBQUksS0FBSyx3QkFBd0IsQ0FBQ3FCLG9CQUFvQjtZQUNqRSxvRUFBb0U7WUFDcEUsc0NBQXNDO1lBQ3RDQSxxQkFBcUJmO1FBQ3pCO0lBQ0o7SUFDQSxJQUFJZSxvQkFBb0I7UUFDcEIsT0FBT0E7SUFDWDtJQUNBLE1BQU16QixvRUFBaUJBLENBQUM7QUFDNUI7QUFDTyxTQUFTNEIsaUJBQWlCbEIsVUFBVTtJQUN2QyxJQUFJbUIsZ0JBQWdCQyxPQUFPQyxNQUFNLENBQUM7SUFDbEMsSUFBSUMsT0FBT3RCLGNBQWNBLFdBQVd1QixtQkFBbUI7SUFDdkQsSUFBSUQsUUFBUUEsS0FBS3JCLE1BQU0sRUFBRTtRQUNyQnFCLEtBQUtFLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1lBQ3RCLElBQUlBLElBQUlDLFlBQVksRUFBRTtnQkFDbEJuQywyRUFBMkJBLENBQUM0QixlQUFlTSxJQUFJRSxRQUFRLENBQUN2QixJQUFJLEVBQUVxQixJQUFJQyxZQUFZO1lBQ2xGO1FBQ0o7SUFDSjtJQUNBLE9BQU9QO0FBQ1gsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L3V0aWxpdGllcy9ncmFwaHFsL2dldEZyb21BU1QuanM/YzJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnZhcmlhbnQsIG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbiB9IGZyb20gXCIuL3N0b3JlVXRpbHMuanNcIjtcbi8vIENoZWNrcyB0aGUgZG9jdW1lbnQgZm9yIGVycm9ycyBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbiBlcnJvci5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RvY3VtZW50KGRvYykge1xuICAgIGludmFyaWFudChkb2MgJiYgZG9jLmtpbmQgPT09IFwiRG9jdW1lbnRcIiwgNzcpO1xuICAgIHZhciBvcGVyYXRpb25zID0gZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2luZCAhPT0gXCJGcmFnbWVudERlZmluaXRpb25cIjsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kICE9PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoNzgsIGRlZmluaXRpb24ua2luZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSk7XG4gICAgaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIDc5LCBvcGVyYXRpb25zLmxlbmd0aCk7XG4gICAgcmV0dXJuIGRvYztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvYykge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jKTtcbiAgICByZXR1cm4gZG9jLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIjtcbiAgICB9KVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25OYW1lKGRvYykge1xuICAgIHJldHVybiAoZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCIgJiYgISFkZWZpbml0aW9uLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lLnZhbHVlOyB9KVswXSB8fCBudWxsKTtcbn1cbi8vIFJldHVybnMgdGhlIEZyYWdtZW50RGVmaW5pdGlvbnMgZnJvbSBhIHBhcnRpY3VsYXIgZG9jdW1lbnQgYXMgYW4gYXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykge1xuICAgIHJldHVybiBkb2MuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09IFwiRnJhZ21lbnREZWZpbml0aW9uXCI7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlEZWZpbml0aW9uKGRvYykge1xuICAgIHZhciBxdWVyeURlZiA9IGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKTtcbiAgICBpbnZhcmlhbnQocXVlcnlEZWYgJiYgcXVlcnlEZWYub3BlcmF0aW9uID09PSBcInF1ZXJ5XCIsIDgwKTtcbiAgICByZXR1cm4gcXVlcnlEZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9uKGRvYykge1xuICAgIGludmFyaWFudChkb2Mua2luZCA9PT0gXCJEb2N1bWVudFwiLCA4MSk7XG4gICAgaW52YXJpYW50KGRvYy5kZWZpbml0aW9ucy5sZW5ndGggPD0gMSwgODIpO1xuICAgIHZhciBmcmFnbWVudERlZiA9IGRvYy5kZWZpbml0aW9uc1swXTtcbiAgICBpbnZhcmlhbnQoZnJhZ21lbnREZWYua2luZCA9PT0gXCJGcmFnbWVudERlZmluaXRpb25cIiwgODMpO1xuICAgIHJldHVybiBmcmFnbWVudERlZjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgb3BlcmF0aW9uIGRlZmluaXRpb24gZm91bmQgaW4gdGhpcyBkb2N1bWVudC5cbiAqIElmIG5vIG9wZXJhdGlvbiBkZWZpbml0aW9uIGlzIGZvdW5kLCB0aGUgZmlyc3QgZnJhZ21lbnQgZGVmaW5pdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuICogSWYgbm8gZGVmaW5pdGlvbnMgYXJlIGZvdW5kLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1haW5EZWZpbml0aW9uKHF1ZXJ5RG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChxdWVyeURvYyk7XG4gICAgdmFyIGZyYWdtZW50RGVmaW5pdGlvbjtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcXVlcnlEb2MuZGVmaW5pdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gX2FbX2ldO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGRlZmluaXRpb24ub3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gXCJxdWVyeVwiIHx8XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID09PSBcIm11dGF0aW9uXCIgfHxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIkZyYWdtZW50RGVmaW5pdGlvblwiICYmICFmcmFnbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IG11bHRpcGxlIGZyYWdtZW50IGRlZmluaXRpb25zXG4gICAgICAgICAgICAvLyB0byBwcmVjZWRlIGFuIG9wZXJhdGlvbiBkZWZpbml0aW9uLlxuICAgICAgICAgICAgZnJhZ21lbnREZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnREZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudERlZmluaXRpb247XG4gICAgfVxuICAgIHRocm93IG5ld0ludmFyaWFudEVycm9yKDg0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVzKGRlZmluaXRpb24pIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGRlZnMgPSBkZWZpbml0aW9uICYmIGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9ucztcbiAgICBpZiAoZGVmcyAmJiBkZWZzLmxlbmd0aCkge1xuICAgICAgICBkZWZzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oZGVmYXVsdFZhbHVlcywgZGVmLnZhcmlhYmxlLm5hbWUsIGRlZi5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGcm9tQVNULmpzLm1hcCJdLCJuYW1lcyI6WyJpbnZhcmlhbnQiLCJuZXdJbnZhcmlhbnRFcnJvciIsInZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbiIsImNoZWNrRG9jdW1lbnQiLCJkb2MiLCJraW5kIiwib3BlcmF0aW9ucyIsImRlZmluaXRpb25zIiwiZmlsdGVyIiwiZCIsIm1hcCIsImRlZmluaXRpb24iLCJsZW5ndGgiLCJnZXRPcGVyYXRpb25EZWZpbml0aW9uIiwiZ2V0T3BlcmF0aW9uTmFtZSIsIm5hbWUiLCJ4IiwidmFsdWUiLCJnZXRGcmFnbWVudERlZmluaXRpb25zIiwiZ2V0UXVlcnlEZWZpbml0aW9uIiwicXVlcnlEZWYiLCJvcGVyYXRpb24iLCJnZXRGcmFnbWVudERlZmluaXRpb24iLCJmcmFnbWVudERlZiIsImdldE1haW5EZWZpbml0aW9uIiwicXVlcnlEb2MiLCJmcmFnbWVudERlZmluaXRpb24iLCJfaSIsIl9hIiwiZ2V0RGVmYXVsdFZhbHVlcyIsImRlZmF1bHRWYWx1ZXMiLCJPYmplY3QiLCJjcmVhdGUiLCJkZWZzIiwidmFyaWFibGVEZWZpbml0aW9ucyIsImZvckVhY2giLCJkZWYiLCJkZWZhdWx0VmFsdWUiLCJ2YXJpYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/print.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/print.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   print: function() { return /* binding */ print; }\n/* harmony export */ });\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/printer.mjs\");\n/* harmony import */ var _caching_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js\");\n/* harmony import */ var _caching_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n\n\n\nvar printCache;\nvar print = Object.assign(function(ast) {\n    var result = printCache.get(ast);\n    if (!result) {\n        result = (0,graphql__WEBPACK_IMPORTED_MODULE_0__.print)(ast);\n        printCache.set(ast, result);\n    }\n    return result;\n}, {\n    reset: function() {\n        printCache = new _caching_index_js__WEBPACK_IMPORTED_MODULE_1__.AutoCleanedWeakCache(_caching_index_js__WEBPACK_IMPORTED_MODULE_2__.cacheSizes.print || 2000 /* defaultCacheSizes.print */ );\n    }\n});\nprint.reset();\nif (globalThis.__DEV__ !== false) {\n    (0,_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_3__.registerGlobalCache)(\"print\", function() {\n        return printCache ? printCache.size : 0;\n    });\n} //# sourceMappingURL=print.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9wcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2QztBQUMyQjtBQUNEO0FBQ3ZFLElBQUlLO0FBQ0csSUFBSUwsUUFBUU0sT0FBT0MsTUFBTSxDQUFDLFNBQVVDLEdBQUc7SUFDMUMsSUFBSUMsU0FBU0osV0FBV0ssR0FBRyxDQUFDRjtJQUM1QixJQUFJLENBQUNDLFFBQVE7UUFDVEEsU0FBU1IsOENBQVNBLENBQUNPO1FBQ25CSCxXQUFXTSxHQUFHLENBQUNILEtBQUtDO0lBQ3hCO0lBQ0EsT0FBT0E7QUFDWCxHQUFHO0lBQ0NHLE9BQU87UUFDSFAsYUFBYSxJQUFJSCxtRUFBb0JBLENBQUNDLHlEQUFVQSxDQUFDSCxLQUFLLElBQUksS0FBSywyQkFBMkI7SUFDOUY7QUFDSixHQUFHO0FBQ0hBLE1BQU1ZLEtBQUs7QUFDWCxJQUFJQyxXQUFXQyxPQUFPLEtBQUssT0FBTztJQUM5QlYsbUZBQW1CQSxDQUFDLFNBQVM7UUFBYyxPQUFRQyxhQUFhQSxXQUFXVSxJQUFJLEdBQUc7SUFBSTtBQUMxRixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dyYXBocWwvcHJpbnQuanM/ZTI4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcmludCBhcyBvcmlnUHJpbnQgfSBmcm9tIFwiZ3JhcGhxbFwiO1xuaW1wb3J0IHsgQXV0b0NsZWFuZWRXZWFrQ2FjaGUsIGNhY2hlU2l6ZXMsIH0gZnJvbSBcIi4uL2NhY2hpbmcvaW5kZXguanNcIjtcbmltcG9ydCB7IHJlZ2lzdGVyR2xvYmFsQ2FjaGUgfSBmcm9tIFwiLi4vY2FjaGluZy9nZXRNZW1vcnlJbnRlcm5hbHMuanNcIjtcbnZhciBwcmludENhY2hlO1xuZXhwb3J0IHZhciBwcmludCA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGFzdCkge1xuICAgIHZhciByZXN1bHQgPSBwcmludENhY2hlLmdldChhc3QpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IG9yaWdQcmludChhc3QpO1xuICAgICAgICBwcmludENhY2hlLnNldChhc3QsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59LCB7XG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJpbnRDYWNoZSA9IG5ldyBBdXRvQ2xlYW5lZFdlYWtDYWNoZShjYWNoZVNpemVzLnByaW50IHx8IDIwMDAgLyogZGVmYXVsdENhY2hlU2l6ZXMucHJpbnQgKi8pO1xuICAgIH0sXG59KTtcbnByaW50LnJlc2V0KCk7XG5pZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgIHJlZ2lzdGVyR2xvYmFsQ2FjaGUoXCJwcmludFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAocHJpbnRDYWNoZSA/IHByaW50Q2FjaGUuc2l6ZSA6IDApOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW50LmpzLm1hcCJdLCJuYW1lcyI6WyJwcmludCIsIm9yaWdQcmludCIsIkF1dG9DbGVhbmVkV2Vha0NhY2hlIiwiY2FjaGVTaXplcyIsInJlZ2lzdGVyR2xvYmFsQ2FjaGUiLCJwcmludENhY2hlIiwiT2JqZWN0IiwiYXNzaWduIiwiYXN0IiwicmVzdWx0IiwiZ2V0Iiwic2V0IiwicmVzZXQiLCJnbG9iYWxUaGlzIiwiX19ERVZfXyIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/print.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/storeUtils.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   argumentsObjectFromField: function() { return /* binding */ argumentsObjectFromField; },\n/* harmony export */   getStoreKeyName: function() { return /* binding */ getStoreKeyName; },\n/* harmony export */   getTypenameFromResult: function() { return /* binding */ getTypenameFromResult; },\n/* harmony export */   isDocumentNode: function() { return /* binding */ isDocumentNode; },\n/* harmony export */   isField: function() { return /* binding */ isField; },\n/* harmony export */   isInlineFragment: function() { return /* binding */ isInlineFragment; },\n/* harmony export */   isReference: function() { return /* binding */ isReference; },\n/* harmony export */   makeReference: function() { return /* binding */ makeReference; },\n/* harmony export */   resultKeyNameFromField: function() { return /* binding */ resultKeyNameFromField; },\n/* harmony export */   storeKeyNameFromField: function() { return /* binding */ storeKeyNameFromField; },\n/* harmony export */   valueToObjectRepresentation: function() { return /* binding */ valueToObjectRepresentation; }\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _common_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _common_canonicalStringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/canonicalStringify.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n\n\n\n\nfunction makeReference(id) {\n    return {\n        __ref: String(id)\n    };\n}\nfunction isReference(obj) {\n    return Boolean(obj && typeof obj === \"object\" && typeof obj.__ref === \"string\");\n}\nfunction isDocumentNode(value) {\n    return (0,_common_objects_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value) && value.kind === \"Document\" && Array.isArray(value.definitions);\n}\nfunction isStringValue(value) {\n    return value.kind === \"StringValue\";\n}\nfunction isBooleanValue(value) {\n    return value.kind === \"BooleanValue\";\n}\nfunction isIntValue(value) {\n    return value.kind === \"IntValue\";\n}\nfunction isFloatValue(value) {\n    return value.kind === \"FloatValue\";\n}\nfunction isVariable(value) {\n    return value.kind === \"Variable\";\n}\nfunction isObjectValue(value) {\n    return value.kind === \"ObjectValue\";\n}\nfunction isListValue(value) {\n    return value.kind === \"ListValue\";\n}\nfunction isEnumValue(value) {\n    return value.kind === \"EnumValue\";\n}\nfunction isNullValue(value) {\n    return value.kind === \"NullValue\";\n}\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    } else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    } else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function(obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    } else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    } else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function(listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    } else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    } else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    } else {\n        throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(85, name.value, value.kind);\n    }\n}\nfunction storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function(directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function(_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function(_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    \"connection\",\n    \"include\",\n    \"skip\",\n    \"client\",\n    \"rest\",\n    \"export\",\n    \"nonreactive\"\n];\n// Default stable JSON.stringify implementation used by getStoreKeyName. Can be\n// updated/replaced with something better by calling\n// getStoreKeyName.setStringify(newStringifyFunction).\nvar storeKeyNameStringify = _common_canonicalStringify_js__WEBPACK_IMPORTED_MODULE_2__.canonicalStringify;\nvar getStoreKeyName = Object.assign(function(fieldName, args, directives) {\n    if (args && directives && directives[\"connection\"] && directives[\"connection\"][\"key\"]) {\n        if (directives[\"connection\"][\"filter\"] && directives[\"connection\"][\"filter\"].length > 0) {\n            var filterKeys = directives[\"connection\"][\"filter\"] ? directives[\"connection\"][\"filter\"] : [];\n            filterKeys.sort();\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function(key) {\n                filteredArgs_1[key] = args[key];\n            });\n            return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(storeKeyNameStringify(filteredArgs_1), \")\");\n        } else {\n            return directives[\"connection\"][\"key\"];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        // We can't use `JSON.stringify` here since it's non-deterministic,\n        // and can lead to different store key names being created even though\n        // the `args` object used during creation has the same properties/values.\n        var stringifiedArgs = storeKeyNameStringify(args);\n        completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function(key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\".concat(key, \"(\").concat(storeKeyNameStringify(directives[key]), \")\");\n            } else {\n                completeFieldName += \"@\".concat(key);\n            }\n        });\n    }\n    return completeFieldName;\n}, {\n    setStringify: function(s) {\n        var previous = storeKeyNameStringify;\n        storeKeyNameStringify = s;\n        return previous;\n    }\n});\nfunction argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function(_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nfunction resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nfunction getTypenameFromResult(result, selectionSet, fragmentMap) {\n    var fragments;\n    for(var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++){\n        var selection = _a[_i];\n        if (isField(selection)) {\n            if (selection.name.value === \"__typename\") {\n                return result[resultKeyNameFromField(selection)];\n            }\n        } else if (fragments) {\n            fragments.push(selection);\n        } else {\n            fragments = [\n                selection\n            ];\n        }\n    }\n    if (typeof result.__typename === \"string\") {\n        return result.__typename;\n    }\n    if (fragments) {\n        for(var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++){\n            var selection = fragments_1[_b];\n            var typename = getTypenameFromResult(result, (0,_fragments_js__WEBPACK_IMPORTED_MODULE_3__.getFragmentFromSelection)(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === \"string\") {\n                return typename;\n            }\n        }\n    }\n}\nfunction isField(selection) {\n    return selection.kind === \"Field\";\n}\nfunction isInlineFragment(selection) {\n    return selection.kind === \"InlineFragment\";\n} //# sourceMappingURL=storeUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9zdG9yZVV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNEO0FBQ0c7QUFDVztBQUM5RCxTQUFTSSxjQUFjQyxFQUFFO0lBQzVCLE9BQU87UUFBRUMsT0FBT0MsT0FBT0Y7SUFBSTtBQUMvQjtBQUNPLFNBQVNHLFlBQVlDLEdBQUc7SUFDM0IsT0FBT0MsUUFBUUQsT0FBTyxPQUFPQSxRQUFRLFlBQVksT0FBT0EsSUFBSUgsS0FBSyxLQUFLO0FBQzFFO0FBQ08sU0FBU0ssZUFBZUMsS0FBSztJQUNoQyxPQUFRWCxtRUFBZUEsQ0FBQ1csVUFDcEJBLE1BQU1DLElBQUksS0FBSyxjQUNmQyxNQUFNQyxPQUFPLENBQUNILE1BQU1JLFdBQVc7QUFDdkM7QUFDQSxTQUFTQyxjQUFjTCxLQUFLO0lBQ3hCLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUMxQjtBQUNBLFNBQVNLLGVBQWVOLEtBQUs7SUFDekIsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFCO0FBQ0EsU0FBU00sV0FBV1AsS0FBSztJQUNyQixPQUFPQSxNQUFNQyxJQUFJLEtBQUs7QUFDMUI7QUFDQSxTQUFTTyxhQUFhUixLQUFLO0lBQ3ZCLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUMxQjtBQUNBLFNBQVNRLFdBQVdULEtBQUs7SUFDckIsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFCO0FBQ0EsU0FBU1MsY0FBY1YsS0FBSztJQUN4QixPQUFPQSxNQUFNQyxJQUFJLEtBQUs7QUFDMUI7QUFDQSxTQUFTVSxZQUFZWCxLQUFLO0lBQ3RCLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUMxQjtBQUNBLFNBQVNXLFlBQVlaLEtBQUs7SUFDdEIsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFCO0FBQ0EsU0FBU1ksWUFBWWIsS0FBSztJQUN0QixPQUFPQSxN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SUFBSUM7SUFDSixJQUFLLElBQUlDLEtBQUssR0FBRzlCLEtBQUsyQixhQUFhSSxVQUFVLEVBQUVELEtBQUs5QixHQUFHQyxNQUFNLEVBQUU2QixLQUFNO1FBQ2pFLElBQUlFLFlBQVloQyxFQUFFLENBQUM4QixHQUFHO1FBQ3RCLElBQUlHLFFBQVFELFlBQVk7WUFDcEIsSUFBSUEsVUFBVWpELElBQUksQ0FBQ2hCLEtBQUssS0FBSyxjQUFjO2dCQUN2QyxPQUFPMkQsTUFBTSxDQUFDSCx1QkFBdUJTLFdBQVc7WUFDcEQ7UUFDSixPQUNLLElBQUlILFdBQVc7WUFDaEJBLFVBQVVLLElBQUksQ0FBQ0Y7UUFDbkIsT0FDSztZQUNESCxZQUFZO2dCQUFDRzthQUFVO1FBQzNCO0lBQ0o7SUFDQSxJQUFJLE9BQU9OLE9BQU9TLFVBQVUsS0FBSyxVQUFVO1FBQ3ZDLE9BQU9ULE9BQU9TLFVBQVU7SUFDNUI7SUFDQSxJQUFJTixXQUFXO1FBQ1gsSUFBSyxJQUFJTyxLQUFLLEdBQUdDLGNBQWNSLFdBQVdPLEtBQUtDLFlBQVlwQyxNQUFNLEVBQUVtQyxLQUFNO1lBQ3JFLElBQUlKLFlBQVlLLFdBQVcsQ0FBQ0QsR0FBRztZQUMvQixJQUFJRSxXQUFXYixzQkFBc0JDLFFBQVFyRSx1RUFBd0JBLENBQUMyRSxXQUFXSixhQUFhRCxZQUFZLEVBQUVDO1lBQzVHLElBQUksT0FBT1UsYUFBYSxVQUFVO2dCQUM5QixPQUFPQTtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBQ08sU0FBU0wsUUFBUUQsU0FBUztJQUM3QixPQUFPQSxVQUFVaEUsSUFBSSxLQUFLO0FBQzlCO0FBQ08sU0FBU3VFLGlCQUFpQlAsU0FBUztJQUN0QyxPQUFPQSxVQUFVaEUsSUFBSSxLQUFLO0FBQzlCLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9zdG9yZVV0aWxzLmpzPzkzNjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNOb25OdWxsT2JqZWN0IH0gZnJvbSBcIi4uL2NvbW1vbi9vYmplY3RzLmpzXCI7XG5pbXBvcnQgeyBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24gfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGNhbm9uaWNhbFN0cmluZ2lmeSB9IGZyb20gXCIuLi9jb21tb24vY2Fub25pY2FsU3RyaW5naWZ5LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZmVyZW5jZShpZCkge1xuICAgIHJldHVybiB7IF9fcmVmOiBTdHJpbmcoaWQpIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZWZlcmVuY2Uob2JqKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai5fX3JlZiA9PT0gXCJzdHJpbmdcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEb2N1bWVudE5vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUua2luZCA9PT0gXCJEb2N1bWVudFwiICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUuZGVmaW5pdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJTdHJpbmdWYWx1ZVwiO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJCb29sZWFuVmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJJbnRWYWx1ZVwiO1xufVxuZnVuY3Rpb24gaXNGbG9hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiRmxvYXRWYWx1ZVwiO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSBcIlZhcmlhYmxlXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiT2JqZWN0VmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzTGlzdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiTGlzdFZhbHVlXCI7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSBcIkVudW1WYWx1ZVwiO1xufVxuZnVuY3Rpb24gaXNOdWxsVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJOdWxsVmFsdWVcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGlzSW50VmFsdWUodmFsdWUpIHx8IGlzRmxvYXRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gTnVtYmVyKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCb29sZWFuVmFsdWUodmFsdWUpIHx8IGlzU3RyaW5nVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdFZhbHVlKHZhbHVlKSkge1xuICAgICAgICB2YXIgbmVzdGVkQXJnT2JqXzEgPSB7fTtcbiAgICAgICAgdmFsdWUuZmllbGRzLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKG5lc3RlZEFyZ09ial8xLCBvYmoubmFtZSwgb2JqLnZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gbmVzdGVkQXJnT2JqXzE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmFyaWFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZVZhbHVlID0gKHZhcmlhYmxlcyB8fCB7fSlbdmFsdWUubmFtZS52YWx1ZV07XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhcmlhYmxlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTGlzdFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZXMubWFwKGZ1bmN0aW9uIChsaXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRBcmdBcnJheU9iaiA9IHt9O1xuICAgICAgICAgICAgdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKG5lc3RlZEFyZ0FycmF5T2JqLCBuYW1lLCBsaXN0VmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmVzdGVkQXJnQXJyYXlPYmpbbmFtZS52YWx1ZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0VudW1WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoODUsIG5hbWUudmFsdWUsIHZhbHVlLmtpbmQpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZUtleU5hbWVGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcykge1xuICAgIHZhciBkaXJlY3RpdmVzT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuZGlyZWN0aXZlcykge1xuICAgICAgICBkaXJlY3RpdmVzT2JqID0ge307XG4gICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSA9IHt9O1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgYXJnT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuYXJndW1lbnRzICYmIGZpZWxkLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJnT2JqID0ge307XG4gICAgICAgIGZpZWxkLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmosIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0b3JlS2V5TmFtZShmaWVsZC5uYW1lLnZhbHVlLCBhcmdPYmosIGRpcmVjdGl2ZXNPYmopO1xufVxudmFyIEtOT1dOX0RJUkVDVElWRVMgPSBbXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJpbmNsdWRlXCIsXG4gICAgXCJza2lwXCIsXG4gICAgXCJjbGllbnRcIixcbiAgICBcInJlc3RcIixcbiAgICBcImV4cG9ydFwiLFxuICAgIFwibm9ucmVhY3RpdmVcIixcbl07XG4vLyBEZWZhdWx0IHN0YWJsZSBKU09OLnN0cmluZ2lmeSBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IGdldFN0b3JlS2V5TmFtZS4gQ2FuIGJlXG4vLyB1cGRhdGVkL3JlcGxhY2VkIHdpdGggc29tZXRoaW5nIGJldHRlciBieSBjYWxsaW5nXG4vLyBnZXRTdG9yZUtleU5hbWUuc2V0U3RyaW5naWZ5KG5ld1N0cmluZ2lmeUZ1bmN0aW9uKS5cbnZhciBzdG9yZUtleU5hbWVTdHJpbmdpZnkgPSBjYW5vbmljYWxTdHJpbmdpZnk7XG5leHBvcnQgdmFyIGdldFN0b3JlS2V5TmFtZSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGZpZWxkTmFtZSwgYXJncywgZGlyZWN0aXZlcykge1xuICAgIGlmIChhcmdzICYmXG4gICAgICAgIGRpcmVjdGl2ZXMgJiZcbiAgICAgICAgZGlyZWN0aXZlc1tcImNvbm5lY3Rpb25cIl0gJiZcbiAgICAgICAgZGlyZWN0aXZlc1tcImNvbm5lY3Rpb25cIl1bXCJrZXlcIl0pIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdW1wiZmlsdGVyXCJdICYmXG4gICAgICAgICAgICBkaXJlY3RpdmVzW1wiY29ubmVjdGlvblwiXVtcImZpbHRlclwiXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyS2V5cyA9IGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdW1wiZmlsdGVyXCJdID9cbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzW1wiY29ubmVjdGlvblwiXVtcImZpbHRlclwiXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBmaWx0ZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEFyZ3NfMSA9IHt9O1xuICAgICAgICAgICAgZmlsdGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEFyZ3NfMVtrZXldID0gYXJnc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZGlyZWN0aXZlc1tcImNvbm5lY3Rpb25cIl1bXCJrZXlcIl0sIFwiKFwiKS5jb25jYXQoc3RvcmVLZXlOYW1lU3RyaW5naWZ5KGZpbHRlcmVkQXJnc18xKSwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdW1wia2V5XCJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb21wbGV0ZUZpZWxkTmFtZSA9IGZpZWxkTmFtZTtcbiAgICBpZiAoYXJncykge1xuICAgICAgICAvLyBXZSBjYW4ndCB1c2UgYEpTT04uc3RyaW5naWZ5YCBoZXJlIHNpbmNlIGl0J3Mgbm9uLWRldGVybWluaXN0aWMsXG4gICAgICAgIC8vIGFuZCBjYW4gbGVhZCB0byBkaWZmZXJlbnQgc3RvcmUga2V5IG5hbWVzIGJlaW5nIGNyZWF0ZWQgZXZlbiB0aG91Z2hcbiAgICAgICAgLy8gdGhlIGBhcmdzYCBvYmplY3QgdXNlZCBkdXJpbmcgY3JlYXRpb24gaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMvdmFsdWVzLlxuICAgICAgICB2YXIgc3RyaW5naWZpZWRBcmdzID0gc3RvcmVLZXlOYW1lU3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICBjb21wbGV0ZUZpZWxkTmFtZSArPSBcIihcIi5jb25jYXQoc3RyaW5naWZpZWRBcmdzLCBcIilcIik7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKEtOT1dOX0RJUkVDVElWRVMuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlc1trZXldICYmIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXNba2V5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIuY29uY2F0KGtleSwgXCIoXCIpLmNvbmNhdChzdG9yZUtleU5hbWVTdHJpbmdpZnkoZGlyZWN0aXZlc1trZXldKSwgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIuY29uY2F0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGVGaWVsZE5hbWU7XG59LCB7XG4gICAgc2V0U3RyaW5naWZ5OiBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBzdG9yZUtleU5hbWVTdHJpbmdpZnk7XG4gICAgICAgIHN0b3JlS2V5TmFtZVN0cmluZ2lmeSA9IHM7XG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9LFxufSk7XG5leHBvcnQgZnVuY3Rpb24gYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpIHtcbiAgICBpZiAoZmllbGQuYXJndW1lbnRzICYmIGZpZWxkLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyZ09ial8xID0ge307XG4gICAgICAgIGZpZWxkLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmpfMSwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJnT2JqXzE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc3VsdEtleU5hbWVGcm9tRmllbGQoZmllbGQpIHtcbiAgICByZXR1cm4gZmllbGQuYWxpYXMgPyBmaWVsZC5hbGlhcy52YWx1ZSA6IGZpZWxkLm5hbWUudmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgc2VsZWN0aW9uU2V0LCBmcmFnbWVudE1hcCkge1xuICAgIHZhciBmcmFnbWVudHM7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNlbGVjdGlvblNldC5zZWxlY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2FbX2ldO1xuICAgICAgICBpZiAoaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09IFwiX190eXBlbmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtyZXN1bHRLZXlOYW1lRnJvbUZpZWxkKHNlbGVjdGlvbildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyYWdtZW50cykge1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IFtzZWxlY3Rpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0Ll9fdHlwZW5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5fX3R5cGVuYW1lO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgZnJhZ21lbnRzXzEgPSBmcmFnbWVudHM7IF9iIDwgZnJhZ21lbnRzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZnJhZ21lbnRzXzFbX2JdO1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lID0gZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbiwgZnJhZ21lbnRNYXApLnNlbGVjdGlvblNldCwgZnJhZ21lbnRNYXApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkKHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gXCJGaWVsZFwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSBcIklubGluZUZyYWdtZW50XCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdG9yZVV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJuZXdJbnZhcmlhbnRFcnJvciIsImlzTm9uTnVsbE9iamVjdCIsImdldEZyYWdtZW50RnJvbVNlbGVjdGlvbiIsImNhbm9uaWNhbFN0cmluZ2lmeSIsIm1ha2VSZWZlcmVuY2UiLCJpZCIsIl9fcmVmIiwiU3RyaW5nIiwiaXNSZWZlcmVuY2UiLCJvYmoiLCJCb29sZWFuIiwiaXNEb2N1bWVudE5vZGUiLCJ2YWx1ZSIsImtpbmQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWZpbml0aW9ucyIsImlzU3RyaW5nVmFsdWUiLCJpc0Jvb2xlYW5WYWx1ZSIsImlzSW50VmFsdWUiLCJpc0Zsb2F0VmFsdWUiLCJpc1ZhcmlhYmxlIiwiaXNPYmplY3RWYWx1ZSIsImlzTGlzdFZhbHVlIiwiaXNFbnVtVmFsdWUiLCJpc051bGxWYWx1ZSIsInZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbiIsImFyZ09iaiIsIm5hbWUiLCJ2YXJpYWJsZXMiLCJOdW1iZXIiLCJuZXN0ZWRBcmdPYmpfMSIsImZpZWxkcyIsIm1hcCIsInZhcmlhYmxlVmFsdWUiLCJ2YWx1ZXMiLCJsaXN0VmFsdWUiLCJuZXN0ZWRBcmdBcnJheU9iaiIsInN0b3JlS2V5TmFtZUZyb21GaWVsZCIsImZpZWxkIiwiZGlyZWN0aXZlc09iaiIsImRpcmVjdGl2ZXMiLCJmb3JFYWNoIiwiZGlyZWN0aXZlIiwiYXJndW1lbnRzIiwiX2EiLCJsZW5ndGgiLCJnZXRTdG9yZUtleU5hbWUiLCJLTk9XTl9ESVJFQ1RJVkVTIiwic3RvcmVLZXlOYW1lU3RyaW5naWZ5IiwiT2JqZWN0IiwiYXNzaWduIiwiZmllbGROYW1lIiwiYXJncyIsImZpbHRlcktleXMiLCJzb3J0IiwiZmlsdGVyZWRBcmdzXzEiLCJrZXkiLCJjb25jYXQiLCJjb21wbGV0ZUZpZWxkTmFtZSIsInN0cmluZ2lmaWVkQXJncyIsImtleXMiLCJpbmRleE9mIiwic2V0U3RyaW5naWZ5IiwicyIsInByZXZpb3VzIiwiYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkIiwiYXJnT2JqXzEiLCJyZXN1bHRLZXlOYW1lRnJvbUZpZWxkIiwiYWxpYXMiLCJnZXRUeXBlbmFtZUZyb21SZXN1bHQiLCJyZXN1bHQiLCJzZWxlY3Rpb25TZXQiLCJmcmFnbWVudE1hcCIsImZyYWdtZW50cyIsIl9pIiwic2VsZWN0aW9ucyIsInNlbGVjdGlvbiIsImlzRmllbGQiLCJwdXNoIiwiX190eXBlbmFtZSIsIl9iIiwiZnJhZ21lbnRzXzEiLCJ0eXBlbmFtZSIsImlzSW5saW5lRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/transform.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTypenameToDocument: function() { return /* binding */ addTypenameToDocument; },\n/* harmony export */   buildQueryFromSelectionSet: function() { return /* binding */ buildQueryFromSelectionSet; },\n/* harmony export */   removeArgumentsFromDocument: function() { return /* binding */ removeArgumentsFromDocument; },\n/* harmony export */   removeClientSetsFromDocument: function() { return /* binding */ removeClientSetsFromDocument; },\n/* harmony export */   removeConnectionDirectiveFromDocument: function() { return /* binding */ removeConnectionDirectiveFromDocument; },\n/* harmony export */   removeDirectivesFromDocument: function() { return /* binding */ removeDirectivesFromDocument; },\n/* harmony export */   removeFragmentSpreadFromDocument: function() { return /* binding */ removeFragmentSpreadFromDocument; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n/* harmony import */ var _getFromAST_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getFromAST.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _storeUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./storeUtils.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _common_arrays_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/arrays.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n\n\n\n\n\n\n\nvar TYPENAME_FIELD = {\n    kind: graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.FIELD,\n    name: {\n        kind: graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.NAME,\n        value: \"__typename\"\n    }\n};\nfunction isEmpty(op, fragmentMap) {\n    return !op || op.selectionSet.selections.every(function(selection) {\n        return selection.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n    });\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty((0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinition)(doc) || (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinition)(doc), (0,_fragments_js__WEBPACK_IMPORTED_MODULE_3__.createFragmentMap)((0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinitions)(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(configs) {\n    var names = new Map();\n    var tests = new Map();\n    configs.forEach(function(directive) {\n        if (directive) {\n            if (directive.name) {\n                names.set(directive.name, directive);\n            } else if (directive.test) {\n                tests.set(directive.test, directive);\n            }\n        }\n    });\n    return function(directive) {\n        var config = names.get(directive.name.value);\n        if (!config && tests.size) {\n            tests.forEach(function(testConfig, test) {\n                if (test(directive)) {\n                    config = testConfig;\n                }\n            });\n        }\n        return config;\n    };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n    var map = new Map();\n    return function inUseGetterFunction(key) {\n        if (key === void 0) {\n            key = defaultKey;\n        }\n        var inUse = map.get(key);\n        if (!inUse) {\n            map.set(key, inUse = {\n                // Variable and fragment spread names used directly within this\n                // operation or fragment definition, as identified by key. These sets\n                // will be populated during the first traversal of the document in\n                // removeDirectivesFromDocument below.\n                variables: new Set(),\n                fragmentSpreads: new Set()\n            });\n        }\n        return inUse;\n    };\n}\nfunction removeDirectivesFromDocument(directives, doc) {\n    (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.checkDocument)(doc);\n    // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n    // operations as if their names were \"\". Anonymous fragment definitions are\n    // not supposed to be possible, but the same default naming strategy seems\n    // appropriate for that case as well.\n    var getInUseByOperationName = makeInUseGetterFunction(\"\");\n    var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n    var getInUse = function(ancestors) {\n        for(var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p){\n            if ((0,_common_arrays_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(ancestor)) continue;\n            if (ancestor.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.OPERATION_DEFINITION) {\n                // If an operation is anonymous, we use the empty string as its key.\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\n            }\n            if (ancestor.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.FRAGMENT_DEFINITION) {\n                return getInUseByFragmentName(ancestor.name.value);\n            }\n        }\n        globalThis.__DEV__ !== false && _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(86);\n        return null;\n    };\n    var operationCount = 0;\n    for(var i = doc.definitions.length - 1; i >= 0; --i){\n        if (doc.definitions[i].kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.OPERATION_DEFINITION) {\n            ++operationCount;\n        }\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var shouldRemoveField = function(nodeDirectives) {\n        return (0,_common_arrays_js__WEBPACK_IMPORTED_MODULE_4__.isNonEmptyArray)(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {\n            return config && config.remove;\n        });\n    };\n    var originalFragmentDefsByPath = new Map();\n    // Any time the first traversal of the document below makes a change like\n    // removing a fragment (by returning null), this variable should be set to\n    // true. Once it becomes true, it should never be set to false again. If this\n    // variable remains false throughout the traversal, then we can return the\n    // original doc immediately without any modifications.\n    var firstVisitMadeChanges = false;\n    var fieldOrInlineFragmentVisitor = {\n        enter: function(node) {\n            if (shouldRemoveField(node.directives)) {\n                firstVisitMadeChanges = true;\n                return null;\n            }\n        }\n    };\n    var docWithoutDirectiveSubtrees = (0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(doc, {\n        // These two AST node types share the same implementation, defined above.\n        Field: fieldOrInlineFragmentVisitor,\n        InlineFragment: fieldOrInlineFragmentVisitor,\n        VariableDefinition: {\n            enter: function() {\n                // VariableDefinition nodes do not count as variables in use, though\n                // they do contain Variable nodes that might be visited below. To avoid\n                // counting variable declarations as usages, we skip visiting the\n                // contents of this VariableDefinition node by returning false.\n                return false;\n            }\n        },\n        Variable: {\n            enter: function(node, _key, _parent, _path, ancestors) {\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.variables.add(node.name.value);\n                }\n            }\n        },\n        FragmentSpread: {\n            enter: function(node, _key, _parent, _path, ancestors) {\n                if (shouldRemoveField(node.directives)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.fragmentSpreads.add(node.name.value);\n                }\n            // We might like to remove this FragmentSpread by returning null here if\n            // the corresponding FragmentDefinition node is also going to be removed\n            // by the logic below, but we can't control the relative order of those\n            // events, so we have to postpone the removal of dangling FragmentSpread\n            // nodes until after the current visit of the document has finished.\n            }\n        },\n        FragmentDefinition: {\n            enter: function(node, _key, _parent, path) {\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\n            },\n            leave: function(node, _key, _parent, path) {\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n                if (node === originalNode) {\n                    // If the FragmentNode received by this leave function is identical to\n                    // the one received by the corresponding enter function (above), then\n                    // the visitor must not have made any changes within this\n                    // FragmentDefinition node. This fragment definition may still be\n                    // removed if there are no ...spread references to it, but it won't be\n                    // removed just because it has only a __typename field.\n                    return node;\n                }\n                if (// This logic applies only if the document contains one or more\n                // operations, since removing all fragments from a document containing\n                // only fragments makes the document useless.\n                operationCount > 0 && node.selectionSet.selections.every(function(selection) {\n                    return selection.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.FIELD && selection.name.value === \"__typename\";\n                })) {\n                    // This is a somewhat opinionated choice: if a FragmentDefinition ends\n                    // up having no fields other than __typename, we remove the whole\n                    // fragment definition, and later prune ...spread references to it.\n                    getInUseByFragmentName(node.name.value).removed = true;\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            }\n        },\n        Directive: {\n            leave: function(node) {\n                // If a matching directive is found, remove the directive itself. Note\n                // that this does not remove the target (field, argument, etc) of the\n                // directive, but only the directive itself.\n                if (directiveMatcher(node)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            }\n        }\n    });\n    if (!firstVisitMadeChanges) {\n        // If our first pass did not change anything about the document, then there\n        // is no cleanup we need to do, and we can return the original doc.\n        return doc;\n    }\n    // Utility for making sure inUse.transitiveVars is recursively populated.\n    // Because this logic assumes inUse.fragmentSpreads has been completely\n    // populated and inUse.removed has been set if appropriate,\n    // populateTransitiveVars must be called after that information has been\n    // collected by the first traversal of the document.\n    var populateTransitiveVars = function(inUse) {\n        if (!inUse.transitiveVars) {\n            inUse.transitiveVars = new Set(inUse.variables);\n            if (!inUse.removed) {\n                inUse.fragmentSpreads.forEach(function(childFragmentName) {\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {\n                        inUse.transitiveVars.add(varName);\n                    });\n                });\n            }\n        }\n        return inUse;\n    };\n    // Since we've been keeping track of fragment spreads used by particular\n    // operations and fragment definitions, we now need to compute the set of all\n    // spreads used (transitively) by any operations in the document.\n    var allFragmentNamesUsed = new Set();\n    docWithoutDirectiveSubtrees.definitions.forEach(function(def) {\n        if (def.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.OPERATION_DEFINITION) {\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {\n                allFragmentNamesUsed.add(childFragmentName);\n            });\n        } else if (def.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment\n        // definitions count as usages of their own fragment names. This heuristic\n        // prevents accidentally removing all fragment definitions from the\n        // document just because it contains no operations that use the fragments.\n        operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n            allFragmentNamesUsed.add(def.name.value);\n        }\n    });\n    // Now that we have added all fragment spreads used by operations to the\n    // allFragmentNamesUsed set, we can complete the set by transitively adding\n    // all fragment spreads used by those fragments, and so on.\n    allFragmentNamesUsed.forEach(function(fragmentName) {\n        // Once all the childFragmentName strings added here have been seen already,\n        // the top-level allFragmentNamesUsed.forEach loop will terminate.\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {\n            allFragmentNamesUsed.add(childFragmentName);\n        });\n    });\n    var fragmentWillBeRemoved = function(fragmentName) {\n        return !!// A fragment definition will be removed if there are no spreads that refer\n        // to it, or the fragment was explicitly removed because it had no fields\n        // other than __typename.\n        (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n    };\n    var enterVisitor = {\n        enter: function(node) {\n            if (fragmentWillBeRemoved(node.name.value)) {\n                return null;\n            }\n        }\n    };\n    return nullIfDocIsEmpty((0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(docWithoutDirectiveSubtrees, {\n        // If the fragment is going to be removed, then leaving any dangling\n        // FragmentSpread nodes with the same name would be a mistake.\n        FragmentSpread: enterVisitor,\n        // This is where the fragment definition is actually removed.\n        FragmentDefinition: enterVisitor,\n        OperationDefinition: {\n            leave: function(node) {\n                // Upon leaving each operation in the depth-first AST traversal, prune\n                // any variables that are declared by the operation but unused within.\n                if (node.variableDefinitions) {\n                    var usedVariableNames_1 = populateTransitiveVars(// If an operation is anonymous, we use the empty string as its key.\n                    getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n                    // According to the GraphQL spec, all variables declared by an\n                    // operation must either be used by that operation or used by some\n                    // fragment included transitively into that operation:\n                    // https://spec.graphql.org/draft/#sec-All-Variables-Used\n                    //\n                    // To stay on the right side of this validation rule, if/when we\n                    // remove the last $var references from an operation or its fragments,\n                    // we must also remove the corresponding $var declaration from the\n                    // enclosing operation. This pruning applies only to operations and\n                    // not fragment definitions, at the moment. Fragments may be able to\n                    // declare variables eventually, but today they can only consume them.\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\n                        return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, node), {\n                            variableDefinitions: node.variableDefinitions.filter(function(varDef) {\n                                return usedVariableNames_1.has(varDef.variable.name.value);\n                            })\n                        });\n                    }\n                }\n            }\n        }\n    }));\n}\nvar addTypenameToDocument = Object.assign(function(doc) {\n    return (0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(doc, {\n        SelectionSet: {\n            enter: function(node, _key, parent) {\n                // Don't add __typename to OperationDefinitions.\n                if (parent && parent.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.OPERATION_DEFINITION) {\n                    return;\n                }\n                // No changes if no selections.\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                // If selections already have a __typename, or are part of an\n                // introspection query, do nothing.\n                var skip = selections.some(function(selection) {\n                    return (0,_storeUtils_js__WEBPACK_IMPORTED_MODULE_7__.isField)(selection) && (selection.name.value === \"__typename\" || selection.name.value.lastIndexOf(\"__\", 0) === 0);\n                });\n                if (skip) {\n                    return;\n                }\n                // If this SelectionSet is @export-ed as an input variable, it should\n                // not have a __typename field (see issue #4691).\n                var field = parent;\n                if ((0,_storeUtils_js__WEBPACK_IMPORTED_MODULE_7__.isField)(field) && field.directives && field.directives.some(function(d) {\n                    return d.name.value === \"export\";\n                })) {\n                    return;\n                }\n                // Create and return a new SelectionSet with a __typename Field.\n                return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, node), {\n                    selections: (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__spreadArray)([], selections, true), [\n                        TYPENAME_FIELD\n                    ], false)\n                });\n            }\n        }\n    });\n}, {\n    added: function(field) {\n        return field === TYPENAME_FIELD;\n    }\n});\nvar connectionRemoveConfig = {\n    test: function(directive) {\n        var willRemove = directive.name.value === \"connection\";\n        if (willRemove) {\n            if (!directive.arguments || !directive.arguments.some(function(arg) {\n                return arg.name.value === \"key\";\n            })) {\n                globalThis.__DEV__ !== false && _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(87);\n            }\n        }\n        return willRemove;\n    }\n};\nfunction removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([\n        connectionRemoveConfig\n    ], (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.checkDocument)(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) {\n        nestedCheck = true;\n    }\n    return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function(selection) {\n        return hasDirectivesInSelection(directives, selection, nestedCheck);\n    });\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) {\n        nestedCheck = true;\n    }\n    if (!(0,_storeUtils_js__WEBPACK_IMPORTED_MODULE_7__.isField)(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function(aConfig) {\n            return argument.value && argument.value.kind === graphql__WEBPACK_IMPORTED_MODULE_1__.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n        });\n    };\n}\nfunction removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty((0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(doc, {\n        OperationDefinition: {\n            enter: function(node) {\n                return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, node), {\n                    // Remove matching top level variables definitions.\n                    variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {\n                        return !config.some(function(arg) {\n                            return arg.name === varDef.variable.name.value;\n                        });\n                    }) : []\n                });\n            }\n        },\n        Field: {\n            enter: function(node) {\n                // If `remove` is set to true for an argument, and an argument match\n                // is found for a field, remove the field as well.\n                var shouldRemoveField = config.some(function(argConfig) {\n                    return argConfig.remove;\n                });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function(arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            }\n        },\n        Argument: {\n            enter: function(node) {\n                // Remove all matching arguments.\n                if (argMatcher(node)) {\n                    return null;\n                }\n            }\n        }\n    }));\n}\nfunction removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function(def) {\n            return def.name === node.name.value;\n        })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty((0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(doc, {\n        FragmentSpread: {\n            enter: enter\n        },\n        FragmentDefinition: {\n            enter: enter\n        }\n    }));\n}\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nfunction buildQueryFromSelectionSet(document) {\n    var definition = (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.getMainDefinition)(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === \"query\") {\n        // Already a query, so return the existing document.\n        return document;\n    }\n    // Build a new query using the selection set of the main operation.\n    var modifiedDoc = (0,graphql__WEBPACK_IMPORTED_MODULE_5__.visit)(document, {\n        OperationDefinition: {\n            enter: function(node) {\n                return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_6__.__assign)({}, node), {\n                    operation: \"query\"\n                });\n            }\n        }\n    });\n    return modifiedDoc;\n}\n// Remove fields / selection sets that include an @client directive.\nfunction removeClientSetsFromDocument(document) {\n    (0,_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__.checkDocument)(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function(directive) {\n                return directive.name.value === \"client\";\n            },\n            remove: true\n        }\n    ], document);\n    return modifiedDoc;\n} //# sourceMappingURL=transform.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC90cmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0E7QUFDVjtBQUNxRztBQUNqRztBQUNTO0FBQ1k7QUFDL0QsSUFBSWMsaUJBQWlCO0lBQ2pCQyxNQUFNWCx5Q0FBSUEsQ0FBQ1ksS0FBSztJQUNoQkMsTUFBTTtRQUNGRixNQUFNWCx5Q0FBSUEsQ0FBQ2MsSUFBSTtRQUNmQyxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLFFBQVFDLEVBQUUsRUFBRUMsV0FBVztJQUM1QixPQUFRLENBQUNELE1BQ0xBLEdBQUdFLFlBQVksQ0FBQ0MsVUFBVSxDQUFDQyxLQUFLLENBQUMsU0FBVUMsU0FBUztRQUNoRCxPQUFPQSxVQUFVWCxJQUFJLEtBQUtYLHlDQUFJQSxDQUFDdUIsZUFBZSxJQUMxQ1AsUUFBUUUsV0FBVyxDQUFDSSxVQUFVVCxJQUFJLENBQUNFLEtBQUssQ0FBQyxFQUFFRztJQUNuRDtBQUNSO0FBQ0EsU0FBU00saUJBQWlCQyxHQUFHO0lBQ3pCLE9BQU8sUUFBU3ZCLHNFQUFzQkEsQ0FBQ3VCLFFBQVF0QixxRUFBcUJBLENBQUNzQixNQUFNbEIsZ0VBQWlCQSxDQUFDSCxzRUFBc0JBLENBQUNxQixTQUNoSCxPQUNFQTtBQUNWO0FBQ0EsU0FBU0Msb0JBQW9CQyxPQUFPO0lBQ2hDLElBQUlDLFFBQVEsSUFBSUM7SUFDaEIsSUFBSUMsUUFBUSxJQUFJRDtJQUNoQkYsUUFBUUksT0FBTyxDQUFDLFNBQVVDLFNBQVM7UUFDL0IsSUFBSUEsV0FBVztZQUNYLElBQUlBLFVBQVVuQixJQUFJLEVBQUU7Z0JBQ2hCZSxNQUFNSyxHQUFHLENBQUNELFVBQVVuQixJQUFJLEVBQUVtQjtZQUM5QixPQUNLLElBQUlBLFVBQVVFLElBQUksRUFBRTtnQkFDckJKLE1BQU1HLEdBQUcsQ0FBQ0QsVUFBVUUsSUFBSSxF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ZXMvZ3JhcGhxbC90cmFuc2Zvcm0uanM/MmIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZpc2l0LCBLaW5kIH0gZnJvbSBcImdyYXBocWxcIjtcbmltcG9ydCB7IGNoZWNrRG9jdW1lbnQsIGdldE9wZXJhdGlvbkRlZmluaXRpb24sIGdldEZyYWdtZW50RGVmaW5pdGlvbiwgZ2V0RnJhZ21lbnREZWZpbml0aW9ucywgZ2V0TWFpbkRlZmluaXRpb24sIH0gZnJvbSBcIi4vZ2V0RnJvbUFTVC5qc1wiO1xuaW1wb3J0IHsgaXNGaWVsZCB9IGZyb20gXCIuL3N0b3JlVXRpbHMuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUZyYWdtZW50TWFwIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBpc0FycmF5LCBpc05vbkVtcHR5QXJyYXkgfSBmcm9tIFwiLi4vY29tbW9uL2FycmF5cy5qc1wiO1xudmFyIFRZUEVOQU1FX0ZJRUxEID0ge1xuICAgIGtpbmQ6IEtpbmQuRklFTEQsXG4gICAgbmFtZToge1xuICAgICAgICBraW5kOiBLaW5kLk5BTUUsXG4gICAgICAgIHZhbHVlOiBcIl9fdHlwZW5hbWVcIixcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGlzRW1wdHkob3AsIGZyYWdtZW50TWFwKSB7XG4gICAgcmV0dXJuICghb3AgfHxcbiAgICAgICAgb3Auc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSBLaW5kLkZSQUdNRU5UX1NQUkVBRCAmJlxuICAgICAgICAgICAgICAgIGlzRW1wdHkoZnJhZ21lbnRNYXBbc2VsZWN0aW9uLm5hbWUudmFsdWVdLCBmcmFnbWVudE1hcCk7XG4gICAgICAgIH0pKTtcbn1cbmZ1bmN0aW9uIG51bGxJZkRvY0lzRW1wdHkoZG9jKSB7XG4gICAgcmV0dXJuIChpc0VtcHR5KGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKSB8fCBnZXRGcmFnbWVudERlZmluaXRpb24oZG9jKSwgY3JlYXRlRnJhZ21lbnRNYXAoZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2MpKSkpID9cbiAgICAgICAgbnVsbFxuICAgICAgICA6IGRvYztcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZU1hdGNoZXIoY29uZmlncykge1xuICAgIHZhciBuYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgdGVzdHMgPSBuZXcgTWFwKCk7XG4gICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMuc2V0KGRpcmVjdGl2ZS5uYW1lLCBkaXJlY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aXZlLnRlc3QpIHtcbiAgICAgICAgICAgICAgICB0ZXN0cy5zZXQoZGlyZWN0aXZlLnRlc3QsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgY29uZmlnID0gbmFtZXMuZ2V0KGRpcmVjdGl2ZS5uYW1lLnZhbHVlKTtcbiAgICAgICAgaWYgKCFjb25maWcgJiYgdGVzdHMuc2l6ZSkge1xuICAgICAgICAgICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdENvbmZpZywgdGVzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0KGRpcmVjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gdGVzdENvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlSW5Vc2VHZXR0ZXJGdW5jdGlvbihkZWZhdWx0S2V5KSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5Vc2VHZXR0ZXJGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7IGtleSA9IGRlZmF1bHRLZXk7IH1cbiAgICAgICAgdmFyIGluVXNlID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWluVXNlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgKGluVXNlID0ge1xuICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlIGFuZCBmcmFnbWVudCBzcHJlYWQgbmFtZXMgdXNlZCBkaXJlY3RseSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBvciBmcmFnbWVudCBkZWZpbml0aW9uLCBhcyBpZGVudGlmaWVkIGJ5IGtleS4gVGhlc2Ugc2V0c1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcG9wdWxhdGVkIGR1cmluZyB0aGUgZmlyc3QgdHJhdmVyc2FsIG9mIHRoZSBkb2N1bWVudCBpblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQgYmVsb3cuXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluVXNlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChkaXJlY3RpdmVzLCBkb2MpIHtcbiAgICBjaGVja0RvY3VtZW50KGRvYyk7XG4gICAgLy8gUGFzc2luZyBlbXB0eSBzdHJpbmdzIHRvIG1ha2VJblVzZUdldHRlckZ1bmN0aW9uIG1lYW5zIHdlIGhhbmRsZSBhbm9ueW1vdXNcbiAgICAvLyBvcGVyYXRpb25zIGFzIGlmIHRoZWlyIG5hbWVzIHdlcmUgXCJcIi4gQW5vbnltb3VzIGZyYWdtZW50IGRlZmluaXRpb25zIGFyZVxuICAgIC8vIG5vdCBzdXBwb3NlZCB0byBiZSBwb3NzaWJsZSwgYnV0IHRoZSBzYW1lIGRlZmF1bHQgbmFtaW5nIHN0cmF0ZWd5IHNlZW1zXG4gICAgLy8gYXBwcm9wcmlhdGUgZm9yIHRoYXQgY2FzZSBhcyB3ZWxsLlxuICAgIHZhciBnZXRJblVzZUJ5T3BlcmF0aW9uTmFtZSA9IG1ha2VJblVzZUdldHRlckZ1bmN0aW9uKFwiXCIpO1xuICAgIHZhciBnZXRJblVzZUJ5RnJhZ21lbnROYW1lID0gbWFrZUluVXNlR2V0dGVyRnVuY3Rpb24oXCJcIik7XG4gICAgdmFyIGdldEluVXNlID0gZnVuY3Rpb24gKGFuY2VzdG9ycykge1xuICAgICAgICBmb3IgKHZhciBwID0gMCwgYW5jZXN0b3IgPSB2b2lkIDA7IHAgPCBhbmNlc3RvcnMubGVuZ3RoICYmIChhbmNlc3RvciA9IGFuY2VzdG9yc1twXSk7ICsrcCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYW5jZXN0b3IpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLmtpbmQgPT09IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBvcGVyYXRpb24gaXMgYW5vbnltb3VzLCB3ZSB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBpdHMga2V5LlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJblVzZUJ5T3BlcmF0aW9uTmFtZShhbmNlc3Rvci5uYW1lICYmIGFuY2VzdG9yLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLmtpbmQgPT09IEtpbmQuRlJBR01FTlRfREVGSU5JVElPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJblVzZUJ5RnJhZ21lbnROYW1lKGFuY2VzdG9yLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmVycm9yKDg2KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB2YXIgb3BlcmF0aW9uQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBkb2MuZGVmaW5pdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKGRvYy5kZWZpbml0aW9uc1tpXS5raW5kID09PSBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgICAgICAgICArK29wZXJhdGlvbkNvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkaXJlY3RpdmVNYXRjaGVyID0gZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKTtcbiAgICB2YXIgc2hvdWxkUmVtb3ZlRmllbGQgPSBmdW5jdGlvbiAobm9kZURpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9uRW1wdHlBcnJheShub2RlRGlyZWN0aXZlcykgJiZcbiAgICAgICAgICAgIG5vZGVEaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgLm1hcChkaXJlY3RpdmVNYXRjaGVyKVxuICAgICAgICAgICAgICAgIC5zb21lKGZ1bmN0aW9uIChjb25maWcpIHsgcmV0dXJuIGNvbmZpZyAmJiBjb25maWcucmVtb3ZlOyB9KTtcbiAgICB9O1xuICAgIHZhciBvcmlnaW5hbEZyYWdtZW50RGVmc0J5UGF0aCA9IG5ldyBNYXAoKTtcbiAgICAvLyBBbnkgdGltZSB0aGUgZmlyc3QgdHJhdmVyc2FsIG9mIHRoZSBkb2N1bWVudCBiZWxvdyBtYWtlcyBhIGNoYW5nZSBsaWtlXG4gICAgLy8gcmVtb3ZpbmcgYSBmcmFnbWVudCAoYnkgcmV0dXJuaW5nIG51bGwpLCB0aGlzIHZhcmlhYmxlIHNob3VsZCBiZSBzZXQgdG9cbiAgICAvLyB0cnVlLiBPbmNlIGl0IGJlY29tZXMgdHJ1ZSwgaXQgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBmYWxzZSBhZ2Fpbi4gSWYgdGhpc1xuICAgIC8vIHZhcmlhYmxlIHJlbWFpbnMgZmFsc2UgdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsLCB0aGVuIHdlIGNhbiByZXR1cm4gdGhlXG4gICAgLy8gb3JpZ2luYWwgZG9jIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbnMuXG4gICAgdmFyIGZpcnN0VmlzaXRNYWRlQ2hhbmdlcyA9IGZhbHNlO1xuICAgIHZhciBmaWVsZE9ySW5saW5lRnJhZ21lbnRWaXNpdG9yID0ge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVGaWVsZChub2RlLmRpcmVjdGl2ZXMpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RWaXNpdE1hZGVDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHZhciBkb2NXaXRob3V0RGlyZWN0aXZlU3VidHJlZXMgPSB2aXNpdChkb2MsIHtcbiAgICAgICAgLy8gVGhlc2UgdHdvIEFTVCBub2RlIHR5cGVzIHNoYXJlIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uLCBkZWZpbmVkIGFib3ZlLlxuICAgICAgICBGaWVsZDogZmllbGRPcklubGluZUZyYWdtZW50VmlzaXRvcixcbiAgICAgICAgSW5saW5lRnJhZ21lbnQ6IGZpZWxkT3JJbmxpbmVGcmFnbWVudFZpc2l0b3IsXG4gICAgICAgIFZhcmlhYmxlRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZURlZmluaXRpb24gbm9kZXMgZG8gbm90IGNvdW50IGFzIHZhcmlhYmxlcyBpbiB1c2UsIHRob3VnaFxuICAgICAgICAgICAgICAgIC8vIHRoZXkgZG8gY29udGFpbiBWYXJpYWJsZSBub2RlcyB0aGF0IG1pZ2h0IGJlIHZpc2l0ZWQgYmVsb3cuIFRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gY291bnRpbmcgdmFyaWFibGUgZGVjbGFyYXRpb25zIGFzIHVzYWdlcywgd2Ugc2tpcCB2aXNpdGluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50cyBvZiB0aGlzIFZhcmlhYmxlRGVmaW5pdGlvbiBub2RlIGJ5IHJldHVybmluZyBmYWxzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBWYXJpYWJsZToge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBfcGFyZW50LCBfcGF0aCwgYW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluVXNlID0gZ2V0SW5Vc2UoYW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5Vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Vc2UudmFyaWFibGVzLmFkZChub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEZyYWdtZW50U3ByZWFkOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIF9wYXJlbnQsIF9wYXRoLCBhbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlRmllbGQobm9kZS5kaXJlY3RpdmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFZpc2l0TWFkZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluVXNlID0gZ2V0SW5Vc2UoYW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5Vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Vc2UuZnJhZ21lbnRTcHJlYWRzLmFkZChub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBsaWtlIHRvIHJlbW92ZSB0aGlzIEZyYWdtZW50U3ByZWFkIGJ5IHJldHVybmluZyBudWxsIGhlcmUgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29ycmVzcG9uZGluZyBGcmFnbWVudERlZmluaXRpb24gbm9kZSBpcyBhbHNvIGdvaW5nIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgbG9naWMgYmVsb3csIGJ1dCB3ZSBjYW4ndCBjb250cm9sIHRoZSByZWxhdGl2ZSBvcmRlciBvZiB0aG9zZVxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cywgc28gd2UgaGF2ZSB0byBwb3N0cG9uZSB0aGUgcmVtb3ZhbCBvZiBkYW5nbGluZyBGcmFnbWVudFNwcmVhZFxuICAgICAgICAgICAgICAgIC8vIG5vZGVzIHVudGlsIGFmdGVyIHRoZSBjdXJyZW50IHZpc2l0IG9mIHRoZSBkb2N1bWVudCBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGcmFnbWVudERlZmluaXRpb246IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgX2tleSwgX3BhcmVudCwgcGF0aCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRnJhZ21lbnREZWZzQnlQYXRoLnNldChKU09OLnN0cmluZ2lmeShwYXRoKSwgbm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBfcGFyZW50LCBwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsTm9kZSA9IG9yaWdpbmFsRnJhZ21lbnREZWZzQnlQYXRoLmdldChKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IG9yaWdpbmFsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgRnJhZ21lbnROb2RlIHJlY2VpdmVkIGJ5IHRoaXMgbGVhdmUgZnVuY3Rpb24gaXMgaWRlbnRpY2FsIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvbmUgcmVjZWl2ZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgZW50ZXIgZnVuY3Rpb24gKGFib3ZlKSwgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmlzaXRvciBtdXN0IG5vdCBoYXZlIG1hZGUgYW55IGNoYW5nZXMgd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJhZ21lbnREZWZpbml0aW9uIG5vZGUuIFRoaXMgZnJhZ21lbnQgZGVmaW5pdGlvbiBtYXkgc3RpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBpZiB0aGVyZSBhcmUgbm8gLi4uc3ByZWFkIHJlZmVyZW5jZXMgdG8gaXQsIGJ1dCBpdCB3b24ndCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGp1c3QgYmVjYXVzZSBpdCBoYXMgb25seSBhIF9fdHlwZW5hbWUgZmllbGQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBsb2dpYyBhcHBsaWVzIG9ubHkgaWYgdGhlIGRvY3VtZW50IGNvbnRhaW5zIG9uZSBvciBtb3JlXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucywgc2luY2UgcmVtb3ZpbmcgYWxsIGZyYWdtZW50cyBmcm9tIGEgZG9jdW1lbnQgY29udGFpbmluZ1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgZnJhZ21lbnRzIG1ha2VzIHRoZSBkb2N1bWVudCB1c2VsZXNzLlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbkNvdW50ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gS2luZC5GSUVMRCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5uYW1lLnZhbHVlID09PSBcIl9fdHlwZW5hbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IG9waW5pb25hdGVkIGNob2ljZTogaWYgYSBGcmFnbWVudERlZmluaXRpb24gZW5kc1xuICAgICAgICAgICAgICAgICAgICAvLyB1cCBoYXZpbmcgbm8gZmllbGRzIG90aGVyIHRoYW4gX190eXBlbmFtZSwgd2UgcmVtb3ZlIHRoZSB3aG9sZVxuICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBkZWZpbml0aW9uLCBhbmQgbGF0ZXIgcHJ1bmUgLi4uc3ByZWFkIHJlZmVyZW5jZXMgdG8gaXQuXG4gICAgICAgICAgICAgICAgICAgIGdldEluVXNlQnlGcmFnbWVudE5hbWUobm9kZS5uYW1lLnZhbHVlKS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWaXNpdE1hZGVDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRGlyZWN0aXZlOiB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoaW5nIGRpcmVjdGl2ZSBpcyBmb3VuZCwgcmVtb3ZlIHRoZSBkaXJlY3RpdmUgaXRzZWxmLiBOb3RlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGRvZXMgbm90IHJlbW92ZSB0aGUgdGFyZ2V0IChmaWVsZCwgYXJndW1lbnQsIGV0Yykgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0aXZlLCBidXQgb25seSB0aGUgZGlyZWN0aXZlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlTWF0Y2hlcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFZpc2l0TWFkZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghZmlyc3RWaXNpdE1hZGVDaGFuZ2VzKSB7XG4gICAgICAgIC8vIElmIG91ciBmaXJzdCBwYXNzIGRpZCBub3QgY2hhbmdlIGFueXRoaW5nIGFib3V0IHRoZSBkb2N1bWVudCwgdGhlbiB0aGVyZVxuICAgICAgICAvLyBpcyBubyBjbGVhbnVwIHdlIG5lZWQgdG8gZG8sIGFuZCB3ZSBjYW4gcmV0dXJuIHRoZSBvcmlnaW5hbCBkb2MuXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIC8vIFV0aWxpdHkgZm9yIG1ha2luZyBzdXJlIGluVXNlLnRyYW5zaXRpdmVWYXJzIGlzIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlZC5cbiAgICAvLyBCZWNhdXNlIHRoaXMgbG9naWMgYXNzdW1lcyBpblVzZS5mcmFnbWVudFNwcmVhZHMgaGFzIGJlZW4gY29tcGxldGVseVxuICAgIC8vIHBvcHVsYXRlZCBhbmQgaW5Vc2UucmVtb3ZlZCBoYXMgYmVlbiBzZXQgaWYgYXBwcm9wcmlhdGUsXG4gICAgLy8gcG9wdWxhdGVUcmFuc2l0aXZlVmFycyBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGF0IGluZm9ybWF0aW9uIGhhcyBiZWVuXG4gICAgLy8gY29sbGVjdGVkIGJ5IHRoZSBmaXJzdCB0cmF2ZXJzYWwgb2YgdGhlIGRvY3VtZW50LlxuICAgIHZhciBwb3B1bGF0ZVRyYW5zaXRpdmVWYXJzID0gZnVuY3Rpb24gKGluVXNlKSB7XG4gICAgICAgIGlmICghaW5Vc2UudHJhbnNpdGl2ZVZhcnMpIHtcbiAgICAgICAgICAgIGluVXNlLnRyYW5zaXRpdmVWYXJzID0gbmV3IFNldChpblVzZS52YXJpYWJsZXMpO1xuICAgICAgICAgICAgaWYgKCFpblVzZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgaW5Vc2UuZnJhZ21lbnRTcHJlYWRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkRnJhZ21lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlVHJhbnNpdGl2ZVZhcnMoZ2V0SW5Vc2VCeUZyYWdtZW50TmFtZShjaGlsZEZyYWdtZW50TmFtZSkpLnRyYW5zaXRpdmVWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluVXNlLnRyYW5zaXRpdmVWYXJzLmFkZCh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluVXNlO1xuICAgIH07XG4gICAgLy8gU2luY2Ugd2UndmUgYmVlbiBrZWVwaW5nIHRyYWNrIG9mIGZyYWdtZW50IHNwcmVhZHMgdXNlZCBieSBwYXJ0aWN1bGFyXG4gICAgLy8gb3BlcmF0aW9ucyBhbmQgZnJhZ21lbnQgZGVmaW5pdGlvbnMsIHdlIG5vdyBuZWVkIHRvIGNvbXB1dGUgdGhlIHNldCBvZiBhbGxcbiAgICAvLyBzcHJlYWRzIHVzZWQgKHRyYW5zaXRpdmVseSkgYnkgYW55IG9wZXJhdGlvbnMgaW4gdGhlIGRvY3VtZW50LlxuICAgIHZhciBhbGxGcmFnbWVudE5hbWVzVXNlZCA9IG5ldyBTZXQoKTtcbiAgICBkb2NXaXRob3V0RGlyZWN0aXZlU3VidHJlZXMuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgIGlmIChkZWYua2luZCA9PT0gS2luZC5PUEVSQVRJT05fREVGSU5JVElPTikge1xuICAgICAgICAgICAgcG9wdWxhdGVUcmFuc2l0aXZlVmFycyhnZXRJblVzZUJ5T3BlcmF0aW9uTmFtZShkZWYubmFtZSAmJiBkZWYubmFtZS52YWx1ZSkpLmZyYWdtZW50U3ByZWFkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEZyYWdtZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGFsbEZyYWdtZW50TmFtZXNVc2VkLmFkZChjaGlsZEZyYWdtZW50TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWYua2luZCA9PT0gS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OICYmXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3BlcmF0aW9ucyBpbiB0aGUgZG9jdW1lbnQsIHRoZW4gYWxsIGZyYWdtZW50XG4gICAgICAgICAgICAvLyBkZWZpbml0aW9ucyBjb3VudCBhcyB1c2FnZXMgb2YgdGhlaXIgb3duIGZyYWdtZW50IG5hbWVzLiBUaGlzIGhldXJpc3RpY1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHJlbW92aW5nIGFsbCBmcmFnbWVudCBkZWZpbml0aW9ucyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gZG9jdW1lbnQganVzdCBiZWNhdXNlIGl0IGNvbnRhaW5zIG5vIG9wZXJhdGlvbnMgdGhhdCB1c2UgdGhlIGZyYWdtZW50cy5cbiAgICAgICAgICAgIG9wZXJhdGlvbkNvdW50ID09PSAwICYmXG4gICAgICAgICAgICAhZ2V0SW5Vc2VCeUZyYWdtZW50TmFtZShkZWYubmFtZS52YWx1ZSkucmVtb3ZlZCkge1xuICAgICAgICAgICAgYWxsRnJhZ21lbnROYW1lc1VzZWQuYWRkKGRlZi5uYW1lLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgYWRkZWQgYWxsIGZyYWdtZW50IHNwcmVhZHMgdXNlZCBieSBvcGVyYXRpb25zIHRvIHRoZVxuICAgIC8vIGFsbEZyYWdtZW50TmFtZXNVc2VkIHNldCwgd2UgY2FuIGNvbXBsZXRlIHRoZSBzZXQgYnkgdHJhbnNpdGl2ZWx5IGFkZGluZ1xuICAgIC8vIGFsbCBmcmFnbWVudCBzcHJlYWRzIHVzZWQgYnkgdGhvc2UgZnJhZ21lbnRzLCBhbmQgc28gb24uXG4gICAgYWxsRnJhZ21lbnROYW1lc1VzZWQuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnROYW1lKSB7XG4gICAgICAgIC8vIE9uY2UgYWxsIHRoZSBjaGlsZEZyYWdtZW50TmFtZSBzdHJpbmdzIGFkZGVkIGhlcmUgaGF2ZSBiZWVuIHNlZW4gYWxyZWFkeSxcbiAgICAgICAgLy8gdGhlIHRvcC1sZXZlbCBhbGxGcmFnbWVudE5hbWVzVXNlZC5mb3JFYWNoIGxvb3Agd2lsbCB0ZXJtaW5hdGUuXG4gICAgICAgIHBvcHVsYXRlVHJhbnNpdGl2ZVZhcnMoZ2V0SW5Vc2VCeUZyYWdtZW50TmFtZShmcmFnbWVudE5hbWUpKS5mcmFnbWVudFNwcmVhZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRGcmFnbWVudE5hbWUpIHtcbiAgICAgICAgICAgIGFsbEZyYWdtZW50TmFtZXNVc2VkLmFkZChjaGlsZEZyYWdtZW50TmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBmcmFnbWVudFdpbGxCZVJlbW92ZWQgPSBmdW5jdGlvbiAoZnJhZ21lbnROYW1lKSB7XG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgLy8gQSBmcmFnbWVudCBkZWZpbml0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpZiB0aGVyZSBhcmUgbm8gc3ByZWFkcyB0aGF0IHJlZmVyXG4gICAgICAgIC8vIHRvIGl0LCBvciB0aGUgZnJhZ21lbnQgd2FzIGV4cGxpY2l0bHkgcmVtb3ZlZCBiZWNhdXNlIGl0IGhhZCBubyBmaWVsZHNcbiAgICAgICAgLy8gb3RoZXIgdGhhbiBfX3R5cGVuYW1lLlxuICAgICAgICAoIWFsbEZyYWdtZW50TmFtZXNVc2VkLmhhcyhmcmFnbWVudE5hbWUpIHx8XG4gICAgICAgICAgICBnZXRJblVzZUJ5RnJhZ21lbnROYW1lKGZyYWdtZW50TmFtZSkucmVtb3ZlZCkpO1xuICAgIH07XG4gICAgdmFyIGVudGVyVmlzaXRvciA9IHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRXaWxsQmVSZW1vdmVkKG5vZGUubmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBudWxsSWZEb2NJc0VtcHR5KHZpc2l0KGRvY1dpdGhvdXREaXJlY3RpdmVTdWJ0cmVlcywge1xuICAgICAgICAvLyBJZiB0aGUgZnJhZ21lbnQgaXMgZ29pbmcgdG8gYmUgcmVtb3ZlZCwgdGhlbiBsZWF2aW5nIGFueSBkYW5nbGluZ1xuICAgICAgICAvLyBGcmFnbWVudFNwcmVhZCBub2RlcyB3aXRoIHRoZSBzYW1lIG5hbWUgd291bGQgYmUgYSBtaXN0YWtlLlxuICAgICAgICBGcmFnbWVudFNwcmVhZDogZW50ZXJWaXNpdG9yLFxuICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIHRoZSBmcmFnbWVudCBkZWZpbml0aW9uIGlzIGFjdHVhbGx5IHJlbW92ZWQuXG4gICAgICAgIEZyYWdtZW50RGVmaW5pdGlvbjogZW50ZXJWaXNpdG9yLFxuICAgICAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBVcG9uIGxlYXZpbmcgZWFjaCBvcGVyYXRpb24gaW4gdGhlIGRlcHRoLWZpcnN0IEFTVCB0cmF2ZXJzYWwsIHBydW5lXG4gICAgICAgICAgICAgICAgLy8gYW55IHZhcmlhYmxlcyB0aGF0IGFyZSBkZWNsYXJlZCBieSB0aGUgb3BlcmF0aW9uIGJ1dCB1bnVzZWQgd2l0aGluLlxuICAgICAgICAgICAgICAgIGlmIChub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZWRWYXJpYWJsZU5hbWVzXzEgPSBwb3B1bGF0ZVRyYW5zaXRpdmVWYXJzKFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiBvcGVyYXRpb24gaXMgYW5vbnltb3VzLCB3ZSB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBpdHMga2V5LlxuICAgICAgICAgICAgICAgICAgICBnZXRJblVzZUJ5T3BlcmF0aW9uTmFtZShub2RlLm5hbWUgJiYgbm9kZS5uYW1lLnZhbHVlKSkudHJhbnNpdGl2ZVZhcnM7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgR3JhcGhRTCBzcGVjLCBhbGwgdmFyaWFibGVzIGRlY2xhcmVkIGJ5IGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBtdXN0IGVpdGhlciBiZSB1c2VkIGJ5IHRoYXQgb3BlcmF0aW9uIG9yIHVzZWQgYnkgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBpbmNsdWRlZCB0cmFuc2l0aXZlbHkgaW50byB0aGF0IG9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9zcGVjLmdyYXBocWwub3JnL2RyYWZ0LyNzZWMtQWxsLVZhcmlhYmxlcy1Vc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHN0YXkgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhpcyB2YWxpZGF0aW9uIHJ1bGUsIGlmL3doZW4gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0ICR2YXIgcmVmZXJlbmNlcyBmcm9tIGFuIG9wZXJhdGlvbiBvciBpdHMgZnJhZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IGFsc28gcmVtb3ZlIHRoZSBjb3JyZXNwb25kaW5nICR2YXIgZGVjbGFyYXRpb24gZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5jbG9zaW5nIG9wZXJhdGlvbi4gVGhpcyBwcnVuaW5nIGFwcGxpZXMgb25seSB0byBvcGVyYXRpb25zIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZnJhZ21lbnQgZGVmaW5pdGlvbnMsIGF0IHRoZSBtb21lbnQuIEZyYWdtZW50cyBtYXkgYmUgYWJsZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNsYXJlIHZhcmlhYmxlcyBldmVudHVhbGx5LCBidXQgdG9kYXkgdGhleSBjYW4gb25seSBjb25zdW1lIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VkVmFyaWFibGVOYW1lc18xLnNpemUgPCBub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vZGUpLCB7IHZhcmlhYmxlRGVmaW5pdGlvbnM6IG5vZGUudmFyaWFibGVEZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHZhckRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlZFZhcmlhYmxlTmFtZXNfMS5oYXModmFyRGVmLnZhcmlhYmxlLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5leHBvcnQgdmFyIGFkZFR5cGVuYW1lVG9Eb2N1bWVudCA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGRvYykge1xuICAgIHJldHVybiB2aXNpdChkb2MsIHtcbiAgICAgICAgU2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBfX3R5cGVuYW1lIHRvIE9wZXJhdGlvbkRlZmluaXRpb25zLlxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmtpbmQgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlcyBpZiBubyBzZWxlY3Rpb25zLlxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gbm9kZS5zZWxlY3Rpb25zO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdGlvbnMgYWxyZWFkeSBoYXZlIGEgX190eXBlbmFtZSwgb3IgYXJlIHBhcnQgb2YgYW5cbiAgICAgICAgICAgICAgICAvLyBpbnRyb3NwZWN0aW9uIHF1ZXJ5LCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgIHZhciBza2lwID0gc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc0ZpZWxkKHNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24ubmFtZS52YWx1ZSA9PT0gXCJfX3R5cGVuYW1lXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ubmFtZS52YWx1ZS5sYXN0SW5kZXhPZihcIl9fXCIsIDApID09PSAwKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIFNlbGVjdGlvblNldCBpcyBAZXhwb3J0LWVkIGFzIGFuIGlucHV0IHZhcmlhYmxlLCBpdCBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBub3QgaGF2ZSBhIF9fdHlwZW5hbWUgZmllbGQgKHNlZSBpc3N1ZSAjNDY5MSkuXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkKGZpZWxkKSAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXJlY3RpdmVzICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnZhbHVlID09PSBcImV4cG9ydFwiOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFNlbGVjdGlvblNldCB3aXRoIGEgX190eXBlbmFtZSBGaWVsZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vZGUpLCB7IHNlbGVjdGlvbnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgc2VsZWN0aW9ucywgdHJ1ZSksIFtUWVBFTkFNRV9GSUVMRF0sIGZhbHNlKSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59LCB7XG4gICAgYWRkZWQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQgPT09IFRZUEVOQU1FX0ZJRUxEO1xuICAgIH0sXG59KTtcbnZhciBjb25uZWN0aW9uUmVtb3ZlQ29uZmlnID0ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIHdpbGxSZW1vdmUgPSBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCI7XG4gICAgICAgIGlmICh3aWxsUmVtb3ZlKSB7XG4gICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZS5hcmd1bWVudHMgfHxcbiAgICAgICAgICAgICAgICAhZGlyZWN0aXZlLmFyZ3VtZW50cy5zb21lKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZy5uYW1lLnZhbHVlID09PSBcImtleVwiOyB9KSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oODcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWxsUmVtb3ZlO1xuICAgIH0sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgcmV0dXJuIHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoW2Nvbm5lY3Rpb25SZW1vdmVDb25maWddLCBjaGVja0RvY3VtZW50KGRvYykpO1xufVxuZnVuY3Rpb24gaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uU2V0KGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCwgbmVzdGVkQ2hlY2spIHtcbiAgICBpZiAobmVzdGVkQ2hlY2sgPT09IHZvaWQgMCkgeyBuZXN0ZWRDaGVjayA9IHRydWU7IH1cbiAgICByZXR1cm4gKCEhc2VsZWN0aW9uU2V0ICYmXG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zICYmXG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvbihkaXJlY3RpdmVzLCBzZWxlY3Rpb24sIG5lc3RlZENoZWNrKTtcbiAgICAgICAgfSkpO1xufVxuZnVuY3Rpb24gaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uKGRpcmVjdGl2ZXMsIHNlbGVjdGlvbiwgbmVzdGVkQ2hlY2spIHtcbiAgICBpZiAobmVzdGVkQ2hlY2sgPT09IHZvaWQgMCkgeyBuZXN0ZWRDaGVjayA9IHRydWU7IH1cbiAgICBpZiAoIWlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24uZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoc2VsZWN0aW9uLmRpcmVjdGl2ZXMuc29tZShnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpKSB8fFxuICAgICAgICAobmVzdGVkQ2hlY2sgJiZcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvblNldChkaXJlY3RpdmVzLCBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LCBuZXN0ZWRDaGVjaykpKTtcbn1cbmZ1bmN0aW9uIGdldEFyZ3VtZW50TWF0Y2hlcihjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXJndW1lbnRNYXRjaGVyKGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBjb25maWcuc29tZShmdW5jdGlvbiAoYUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgYXJndW1lbnQudmFsdWUua2luZCA9PT0gS2luZC5WQVJJQUJMRSAmJlxuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnZhbHVlLm5hbWUgJiZcbiAgICAgICAgICAgICAgICAoYUNvbmZpZy5uYW1lID09PSBhcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgIChhQ29uZmlnLnRlc3QgJiYgYUNvbmZpZy50ZXN0KGFyZ3VtZW50KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudChjb25maWcsIGRvYykge1xuICAgIHZhciBhcmdNYXRjaGVyID0gZ2V0QXJndW1lbnRNYXRjaGVyKGNvbmZpZyk7XG4gICAgcmV0dXJuIG51bGxJZkRvY0lzRW1wdHkodmlzaXQoZG9jLCB7XG4gICAgICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyB0b3AgbGV2ZWwgdmFyaWFibGVzIGRlZmluaXRpb25zLlxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiBub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS52YXJpYWJsZURlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodmFyRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjb25maWcuc29tZShmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcubmFtZSA9PT0gdmFyRGVmLnZhcmlhYmxlLm5hbWUudmFsdWU7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGaWVsZDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYHJlbW92ZWAgaXMgc2V0IHRvIHRydWUgZm9yIGFuIGFyZ3VtZW50LCBhbmQgYW4gYXJndW1lbnQgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBpcyBmb3VuZCBmb3IgYSBmaWVsZCwgcmVtb3ZlIHRoZSBmaWVsZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmVGaWVsZCA9IGNvbmZpZy5zb21lKGZ1bmN0aW9uIChhcmdDb25maWcpIHsgcmV0dXJuIGFyZ0NvbmZpZy5yZW1vdmU7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnTWF0Y2hDb3VudF8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ01hdGNoQ291bnRfMSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaENvdW50XzEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgQXJndW1lbnQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hpbmcgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaGVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50U3ByZWFkRnJvbURvY3VtZW50KGNvbmZpZywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZW50ZXIobm9kZSkge1xuICAgICAgICBpZiAoY29uZmlnLnNvbWUoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZGVmLm5hbWUgPT09IG5vZGUubmFtZS52YWx1ZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsSWZEb2NJc0VtcHR5KHZpc2l0KGRvYywge1xuICAgICAgICBGcmFnbWVudFNwcmVhZDogeyBlbnRlcjogZW50ZXIgfSxcbiAgICAgICAgRnJhZ21lbnREZWZpbml0aW9uOiB7IGVudGVyOiBlbnRlciB9LFxuICAgIH0pKTtcbn1cbi8vIElmIHRoZSBpbmNvbWluZyBkb2N1bWVudCBpcyBhIHF1ZXJ5LCByZXR1cm4gaXQgYXMgaXMuIE90aGVyd2lzZSwgYnVpbGQgYVxuLy8gbmV3IGRvY3VtZW50IGNvbnRhaW5pbmcgYSBxdWVyeSBvcGVyYXRpb24gYmFzZWQgb24gdGhlIHNlbGVjdGlvbiBzZXRcbi8vIG9mIHRoZSBwcmV2aW91cyBtYWluIG9wZXJhdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFF1ZXJ5RnJvbVNlbGVjdGlvblNldChkb2N1bWVudCkge1xuICAgIHZhciBkZWZpbml0aW9uID0gZ2V0TWFpbkRlZmluaXRpb24oZG9jdW1lbnQpO1xuICAgIHZhciBkZWZpbml0aW9uT3BlcmF0aW9uID0gZGVmaW5pdGlvbi5vcGVyYXRpb247XG4gICAgaWYgKGRlZmluaXRpb25PcGVyYXRpb24gPT09IFwicXVlcnlcIikge1xuICAgICAgICAvLyBBbHJlYWR5IGEgcXVlcnksIHNvIHJldHVybiB0aGUgZXhpc3RpbmcgZG9jdW1lbnQuXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgLy8gQnVpbGQgYSBuZXcgcXVlcnkgdXNpbmcgdGhlIHNlbGVjdGlvbiBzZXQgb2YgdGhlIG1haW4gb3BlcmF0aW9uLlxuICAgIHZhciBtb2RpZmllZERvYyA9IHZpc2l0KGRvY3VtZW50LCB7XG4gICAgICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgb3BlcmF0aW9uOiBcInF1ZXJ5XCIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cbi8vIFJlbW92ZSBmaWVsZHMgLyBzZWxlY3Rpb24gc2V0cyB0aGF0IGluY2x1ZGUgYW4gQGNsaWVudCBkaXJlY3RpdmUuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIHZhciBtb2RpZmllZERvYyA9IHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gXCJjbGllbnRcIjsgfSxcbiAgICAgICAgICAgIHJlbW92ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICBdLCBkb2N1bWVudCk7XG4gICAgcmV0dXJuIG1vZGlmaWVkRG9jO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fc3ByZWFkQXJyYXkiLCJpbnZhcmlhbnQiLCJ2aXNpdCIsIktpbmQiLCJjaGVja0RvY3VtZW50IiwiZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiIsImdldEZyYWdtZW50RGVmaW5pdGlvbiIsImdldEZyYWdtZW50RGVmaW5pdGlvbnMiLCJnZXRNYWluRGVmaW5pdGlvbiIsImlzRmllbGQiLCJjcmVhdGVGcmFnbWVudE1hcCIsImlzQXJyYXkiLCJpc05vbkVtcHR5QXJyYXkiLCJUWVBFTkFNRV9GSUVMRCIsImtpbmQiLCJGSUVMRCIsIm5hbWUiLCJOQU1FIiwidmFsdWUiLCJpc0VtcHR5Iiwib3AiLCJmcmFnbWVudE1hcCIsInNlbGVjdGlvblNldCIsInNlbGVjdGlvbnMiLCJldmVyeSIsInNlbGVjdGlvbiIsIkZSQUdNRU5UX1NQUkVBRCIsIm51bGxJZkRvY0lzRW1wdHkiLCJkb2MiLCJnZXREaXJlY3RpdmVNYXRjaGVyIiwiY29uZmlncyIsIm5hbWVzIiwiTWFwIiwidGVzdHMiLCJmb3JFYWNoIiwiZGlyZWN0aXZlIiwic2V0IiwidGVzdCIsImNvbmZpZyIsImdldCIsInNpemUiLCJ0ZXN0Q29uZmlnIiwibWFrZUluVXNlR2V0dGVyRnVuY3Rpb24iLCJkZWZhdWx0S2V5IiwibWFwIiwiaW5Vc2VHZXR0ZXJGdW5jdGlvbiIsImtleSIsImluVXNlIiwidmFyaWFibGVzIiwiU2V0IiwiZnJhZ21lbnRTcHJlYWRzIiwicmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudCIsImRpcmVjdGl2ZXMiLCJnZXRJblVzZUJ5T3BlcmF0aW9uTmFtZSIsImdldEluVXNlQnlGcmFnbWVudE5hbWUiLCJnZXRJblVzZSIsImFuY2VzdG9ycyIsInAiLCJhbmNlc3RvciIsImxlbmd0aCIsIk9QRVJBVElPTl9ERUZJTklUSU9OIiwiRlJBR01FTlRfREVGSU5JVElPTiIsImdsb2JhbFRoaXMiLCJfX0RFVl9fIiwiZXJyb3IiLCJvcGVyYXRpb25Db3VudCIsImkiLCJkZWZpbml0aW9ucyIsImRpcmVjdGl2ZU1hdGNoZXIiLCJzaG91bGRSZW1vdmVGaWVsZCIsIm5vZGVEaXJlY3RpdmVzIiwic29tZSIsInJlbW92ZSIsIm9yaWdpbmFsRnJhZ21lbnREZWZzQnlQYXRoIiwiZmlyc3RWaXNpdE1hZGVDaGFuZ2VzIiwiZmllbGRPcklubGluZUZyYWdtZW50VmlzaXRvciIsImVudGVyIiwibm9kZSIsImRvY1dpdGhvdXREaXJlY3RpdmVTdWJ0cmVlcyIsIkZpZWxkIiwiSW5saW5lRnJhZ21lbnQiLCJWYXJpYWJsZURlZmluaXRpb24iLCJWYXJpYWJsZSIsIl9rZXkiLCJfcGFyZW50IiwiX3BhdGgiLCJhZGQiLCJGcmFnbWVudFNwcmVhZCIsIkZyYWdtZW50RGVmaW5pdGlvbiIsInBhdGgiLCJKU09OIiwic3RyaW5naWZ5IiwibGVhdmUiLCJvcmlnaW5hbE5vZGUiLCJyZW1vdmVkIiwiRGlyZWN0aXZlIiwicG9wdWxhdGVUcmFuc2l0aXZlVmFycyIsInRyYW5zaXRpdmVWYXJzIiwiY2hpbGRGcmFnbWVudE5hbWUiLCJ2YXJOYW1lIiwiYWxsRnJhZ21lbnROYW1lc1VzZWQiLCJkZWYiLCJmcmFnbWVudE5hbWUiLCJmcmFnbWVudFdpbGxCZVJlbW92ZWQiLCJoYXMiLCJlbnRlclZpc2l0b3IiLCJPcGVyYXRpb25EZWZpbml0aW9uIiwidmFyaWFibGVEZWZpbml0aW9ucyIsInVzZWRWYXJpYWJsZU5hbWVzXzEiLCJmaWx0ZXIiLCJ2YXJEZWYiLCJ2YXJpYWJsZSIsImFkZFR5cGVuYW1lVG9Eb2N1bWVudCIsIk9iamVjdCIsImFzc2lnbiIsIlNlbGVjdGlvblNldCIsInBhcmVudCIsInNraXAiLCJsYXN0SW5kZXhPZiIsImZpZWxkIiwiZCIsImFkZGVkIiwiY29ubmVjdGlvblJlbW92ZUNvbmZpZyIsIndpbGxSZW1vdmUiLCJhcmd1bWVudHMiLCJhcmciLCJ3YXJuIiwicmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudCIsImhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvblNldCIsIm5lc3RlZENoZWNrIiwiaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uIiwiZ2V0QXJndW1lbnRNYXRjaGVyIiwiYXJndW1lbnRNYXRjaGVyIiwiYXJndW1lbnQiLCJhQ29uZmlnIiwiVkFSSUFCTEUiLCJyZW1vdmVBcmd1bWVudHNGcm9tRG9jdW1lbnQiLCJhcmdNYXRjaGVyIiwiYXJnQ29uZmlnIiwiYXJnTWF0Y2hDb3VudF8xIiwiQXJndW1lbnQiLCJyZW1vdmVGcmFnbWVudFNwcmVhZEZyb21Eb2N1bWVudCIsImJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0IiwiZG9jdW1lbnQiLCJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbk9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsIm1vZGlmaWVkRG9jIiwicmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/transform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/Concast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/Concast.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Concast: function() { return /* binding */ Concast; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _iteration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iteration.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js\");\n/* harmony import */ var _subclassing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./subclassing.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js\");\n\n\n\n\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nvar Concast = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Concast, _super);\n    // Not only can the individual elements of the iterable be promises, but\n    // also the iterable itself can be wrapped in a promise.\n    function Concast(sources) {\n        var _this = _super.call(this, function(observer) {\n            _this.addObserver(observer);\n            return function() {\n                return _this.removeObserver(observer);\n            };\n        }) || this;\n        // Active observers receiving broadcast messages. Thanks to this.latest,\n        // we can assume all observers in this Set have received the same most\n        // recent message, though possibly at different times in the past.\n        _this.observers = new Set();\n        _this.promise = new Promise(function(resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n        // Bound handler functions that can be reused for every internal\n        // subscription.\n        _this.handlers = {\n            next: function(result) {\n                if (_this.sub !== null) {\n                    _this.latest = [\n                        \"next\",\n                        result\n                    ];\n                    _this.notify(\"next\", result);\n                    (0,_iteration_js__WEBPACK_IMPORTED_MODULE_1__.iterateObserversSafely)(_this.observers, \"next\", result);\n                }\n            },\n            error: function(error) {\n                var sub = _this.sub;\n                if (sub !== null) {\n                    // Delay unsubscribing from the underlying subscription slightly,\n                    // so that immediately subscribing another observer can keep the\n                    // subscription active.\n                    if (sub) setTimeout(function() {\n                        return sub.unsubscribe();\n                    });\n                    _this.sub = null;\n                    _this.latest = [\n                        \"error\",\n                        error\n                    ];\n                    _this.reject(error);\n                    _this.notify(\"error\", error);\n                    (0,_iteration_js__WEBPACK_IMPORTED_MODULE_1__.iterateObserversSafely)(_this.observers, \"error\", error);\n                }\n            },\n            complete: function() {\n                var _a = _this, sub = _a.sub, _b = _a.sources, sources = _b === void 0 ? [] : _b;\n                if (sub !== null) {\n                    // If complete is called before concast.start, this.sources may be\n                    // undefined, so we use a default value of [] for sources. That works\n                    // here because it falls into the if (!value) {...} block, which\n                    // appropriately terminates the Concast, even if this.sources might\n                    // eventually have been initialized to a non-empty array.\n                    var value = sources.shift();\n                    if (!value) {\n                        if (sub) setTimeout(function() {\n                            return sub.unsubscribe();\n                        });\n                        _this.sub = null;\n                        if (_this.latest && _this.latest[0] === \"next\") {\n                            _this.resolve(_this.latest[1]);\n                        } else {\n                            _this.resolve();\n                        }\n                        _this.notify(\"complete\");\n                        // We do not store this.latest = [\"complete\"], because doing so\n                        // discards useful information about the previous next (or\n                        // error) message. Instead, if new observers subscribe after\n                        // this Concast has completed, they will receive the final\n                        // 'next' message (unless there was an error) immediately\n                        // followed by a 'complete' message (see addObserver).\n                        (0,_iteration_js__WEBPACK_IMPORTED_MODULE_1__.iterateObserversSafely)(_this.observers, \"complete\");\n                    } else if (isPromiseLike(value)) {\n                        value.then(function(obs) {\n                            return _this.sub = obs.subscribe(_this.handlers);\n                        }, _this.handlers.error);\n                    } else {\n                        _this.sub = value.subscribe(_this.handlers);\n                    }\n                }\n            }\n        };\n        _this.nextResultListeners = new Set();\n        // A public way to abort observation and broadcast.\n        _this.cancel = function(reason) {\n            _this.reject(reason);\n            _this.sources = [];\n            _this.handlers.error(reason);\n        };\n        // Suppress rejection warnings for this.promise, since it's perfectly\n        // acceptable to pay no attention to this.promise if you're consuming\n        // the results through the normal observable API.\n        _this.promise.catch(function(_) {});\n        // If someone accidentally tries to create a Concast using a subscriber\n        // function, recover by creating an Observable from that subscriber and\n        // using it as the source.\n        if (typeof sources === \"function\") {\n            sources = [\n                new _Observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable(sources)\n            ];\n        }\n        if (isPromiseLike(sources)) {\n            sources.then(function(iterable) {\n                return _this.start(iterable);\n            }, _this.handlers.error);\n        } else {\n            _this.start(sources);\n        }\n        return _this;\n    }\n    Concast.prototype.start = function(sources) {\n        if (this.sub !== void 0) return;\n        // In practice, sources is most often simply an Array of observables.\n        // TODO Consider using sources[Symbol.iterator]() to take advantage\n        // of the laziness of non-Array iterables.\n        this.sources = Array.from(sources);\n        // Calling this.handlers.complete() kicks off consumption of the first\n        // source observable. It's tempting to do this step lazily in\n        // addObserver, but this.promise can be accessed without calling\n        // addObserver, so consumption needs to begin eagerly.\n        this.handlers.complete();\n    };\n    Concast.prototype.deliverLastMessage = function(observer) {\n        if (this.latest) {\n            var nextOrError = this.latest[0];\n            var method = observer[nextOrError];\n            if (method) {\n                method.call(observer, this.latest[1]);\n            }\n            // If the subscription is already closed, and the last message was\n            // a 'next' message, simulate delivery of the final 'complete'\n            // message again.\n            if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n                observer.complete();\n            }\n        }\n    };\n    Concast.prototype.addObserver = function(observer) {\n        if (!this.observers.has(observer)) {\n            // Immediately deliver the most recent message, so we can always\n            // be sure all observers have the latest information.\n            this.deliverLastMessage(observer);\n            this.observers.add(observer);\n        }\n    };\n    Concast.prototype.removeObserver = function(observer) {\n        if (this.observers.delete(observer) && this.observers.size < 1) {\n            // In case there are still any listeners in this.nextResultListeners, and\n            // no error or completion has been broadcast yet, make sure those\n            // observers have a chance to run and then remove themselves from\n            // this.observers.\n            this.handlers.complete();\n        }\n    };\n    Concast.prototype.notify = function(method, arg) {\n        var nextResultListeners = this.nextResultListeners;\n        if (nextResultListeners.size) {\n            // Replacing this.nextResultListeners first ensures it does not grow while\n            // we are iterating over it, potentially leading to infinite loops.\n            this.nextResultListeners = new Set();\n            nextResultListeners.forEach(function(listener) {\n                return listener(method, arg);\n            });\n        }\n    };\n    // We need a way to run callbacks just *before* the next result (or error or\n    // completion) is delivered by this Concast, so we can be sure any code that\n    // runs as a result of delivering that result/error observes the effects of\n    // running the callback(s). It was tempting to reuse the Observer type instead\n    // of introducing NextResultListener, but that messes with the sizing and\n    // maintenance of this.observers, and ends up being more code overall.\n    Concast.prototype.beforeNext = function(callback) {\n        var called = false;\n        this.nextResultListeners.add(function(method, arg) {\n            if (!called) {\n                called = true;\n                callback(method, arg);\n            }\n        });\n    };\n    return Concast;\n}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable);\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\n(0,_subclassing_js__WEBPACK_IMPORTED_MODULE_3__.fixObservableSubclass)(Concast); //# sourceMappingURL=Concast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvQ29uY2FzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNXO0FBQ1c7QUFDQztBQUN6RCxTQUFTSSxjQUFjQyxLQUFLO0lBQ3hCLE9BQU9BLFNBQVMsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFDO0FBQ0EsdUVBQXVFO0FBQ3ZFLHlFQUF5RTtBQUN6RSxrRUFBa0U7QUFDbEUsdUVBQXVFO0FBQ3ZFLG1CQUFtQjtBQUNuQixFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLHlFQUF5RTtBQUN6RSxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx1RUFBdUU7QUFDdkUsdUVBQXVFO0FBQ3ZFLDBFQUEwRTtBQUMxRSxxRUFBcUU7QUFDckUsa0JBQWtCO0FBQ2xCLEVBQUU7QUFDRixpRUFBaUU7QUFDakUsd0VBQXdFO0FBQ3hFLDJDQUEyQztBQUMzQyxFQUFFO0FBQ0YscUVBQXFFO0FBQ3JFLDBFQUEwRTtBQUMxRSx1RUFBdUU7QUFDdkUsd0VBQXdFO0FBQ3hFLG9FQUFvRTtBQUNwRSxxRUFBcUU7QUFDckUsd0VBQXdFO0FBQ3hFLGdEQUFnRDtBQUNoRCxJQUFJQyxVQUFVLFdBQVcsR0FBSSxTQUFVQyxNQUFNO0lBQ3pDUixnREFBU0EsQ0FBQ08sU0FBU0M7SUFDbkIsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxTQUFTRCxRQUFRRSxPQUFPO1FBQ3BCLElBQUlDLFFBQVFGLE9BQU9HLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBVUMsUUFBUTtZQUM1Q0YsTUFBTUcsV0FBVyxDQUFDRDtZQUNsQixPQUFPO2dCQUFjLE9BQU9GLE1BQU1JLGNBQWMsQ0FBQ0Y7WUFBVztRQUNoRSxNQUFNLElBQUk7UUFDVix3RUFBd0U7UUFDeEUsc0VBQXNFO1FBQ3RFLGtFQUFrRTtRQUNsRUYsTUFBTUssU0FBUyxHQUFHLElBQUlDO1FB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YSxVQUFVLEdBQUcsU0FBVUMsUUFBUTtRQUM3QyxJQUFJQyxTQUFTO1FBQ2IsSUFBSSxDQUFDdEIsbUJBQW1CLENBQUNjLEdBQUcsQ0FBQyxTQUFVRixNQUFNLEVBQUVLLEdBQUc7WUFDOUMsSUFBSSxDQUFDSyxRQUFRO2dCQUNUQSxTQUFTO2dCQUNURCxTQUFTVCxRQUFRSztZQUNyQjtRQUNKO0lBQ0o7SUFDQSxPQUFPOUM7QUFDWCxFQUFFTixzREFBVUE7QUFDTztBQUNuQixzRUFBc0U7QUFDdEUsbUNBQW1DO0FBQ25DRSxzRUFBcUJBLENBQUNJLFVBQ3RCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL29ic2VydmFibGVzL0NvbmNhc3QuanM/Y2VmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi9PYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5IH0gZnJvbSBcIi4vaXRlcmF0aW9uLmpzXCI7XG5pbXBvcnQgeyBmaXhPYnNlcnZhYmxlU3ViY2xhc3MgfSBmcm9tIFwiLi9zdWJjbGFzc2luZy5qc1wiO1xuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuLy8gQSBDb25jYXN0PFQ+IG9ic2VydmFibGUgY29uY2F0ZW5hdGVzIHRoZSBnaXZlbiBzb3VyY2VzIGludG8gYSBzaW5nbGVcbi8vIG5vbi1vdmVybGFwcGluZyBzZXF1ZW5jZSBvZiBUcywgYXV0b21hdGljYWxseSB1bndyYXBwaW5nIGFueSBwcm9taXNlcyxcbi8vIGFuZCBicm9hZGNhc3RzIHRoZSBUIGVsZW1lbnRzIG9mIHRoYXQgc2VxdWVuY2UgdG8gYW55IG51bWJlciBvZlxuLy8gc3Vic2NyaWJlcnMsIGFsbCB3aXRob3V0IGNyZWF0aW5nIGEgYnVuY2ggb2YgaW50ZXJtZWRpYXJ5IE9ic2VydmFibGVcbi8vIHdyYXBwZXIgb2JqZWN0cy5cbi8vXG4vLyBFdmVuIHRob3VnaCBhbnkgbnVtYmVyIG9mIG9ic2VydmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZSBDb25jYXN0LCBlYWNoXG4vLyBzb3VyY2Ugb2JzZXJ2YWJsZSBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYXQgbW9zdCBvbmUgc3Vic2NyaWJlIGNhbGwsXG4vLyBhbmQgdGhlIHJlc3VsdHMgYXJlIG11bHRpY2FzdCB0byBhbGwgb2JzZXJ2ZXJzLlxuLy9cbi8vIEluIGFkZGl0aW9uIHRvIGJyb2FkY2FzdGluZyBldmVyeSBuZXh0L2Vycm9yIG1lc3NhZ2UgdG8gdGhpcy5vYnNlcnZlcnMsXG4vLyB0aGUgQ29uY2FzdCBzdG9yZXMgdGhlIG1vc3QgcmVjZW50IG1lc3NhZ2UgdXNpbmcgdGhpcy5sYXRlc3QsIHNvIGFueVxuLy8gbmV3IG9ic2VydmVycyBjYW4gaW1tZWRpYXRlbHkgcmVjZWl2ZSB0aGUgbGF0ZXN0IG1lc3NhZ2UsIGV2ZW4gaWYgaXRcbi8vIHdhcyBvcmlnaW5hbGx5IGRlbGl2ZXJlZCBpbiB0aGUgcGFzdC4gVGhpcyBiZWhhdmlvciBtZWFucyB3ZSBjYW4gYXNzdW1lXG4vLyBldmVyeSBhY3RpdmUgb2JzZXJ2ZXIgaW4gdGhpcy5vYnNlcnZlcnMgaGFzIHJlY2VpdmVkIHRoZSBzYW1lIG1vc3Rcbi8vIHJlY2VudCBtZXNzYWdlLlxuLy9cbi8vIFdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGlzLmxhdGVzdCByZXBsYXksIGEgQ29uY2FzdCBpcyBhIFwiaG90XCJcbi8vIG9ic2VydmFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgZG9lcyBub3QgcmVwbGF5IHBhc3QgcmVzdWx0cyBmcm9tIHRoZVxuLy8gYmVnaW5uaW5nIG9mIHRpbWUgZm9yIGVhY2ggbmV3IG9ic2VydmVyLlxuLy9cbi8vIENvdWxkIHdlIGhhdmUgdXNlZCBzb21lIGV4aXN0aW5nIFJ4SlMgY2xhc3MgaW5zdGVhZD8gQ29uY2FzdDxUPiBpc1xuLy8gc2ltaWxhciB0byBhIEJlaGF2aW9yU3ViamVjdDxUPiwgYmVjYXVzZSBpdCBpcyBtdWx0aWNhc3QgYW5kIHJlZGVsaXZlcnNcbi8vIHRoZSBsYXRlc3QgbmV4dC9lcnJvciBtZXNzYWdlIHRvIG5ldyBzdWJzY3JpYmVycy4gVW5saWtlIFN1YmplY3Q8VD4sXG4vLyBDb25jYXN0PFQ+IGRvZXMgbm90IGV4cG9zZSBhbiBPYnNlcnZlcjxUPiBpbnRlcmZhY2UgKHRoaXMuaGFuZGxlcnMgaXNcbi8vIGludGVudGlvbmFsbHkgcHJpdmF0ZSksIHNpbmNlIENvbmNhc3Q8VD4gZ2V0cyBpdHMgaW5wdXRzIGZyb20gdGhlXG4vLyBjb25jYXRlbmF0ZWQgc291cmNlcy4gSWYgd2UgZXZlciBzd2l0Y2ggdG8gUnhKUywgdGhlcmUgbWF5IGJlIHNvbWVcbi8vIHZhbHVlIGluIHJldXNpbmcgdGhlaXIgY29kZSwgYnV0IGZvciBub3cgd2UgdXNlIHplbi1vYnNlcnZhYmxlLCB3aGljaFxuLy8gZG9lcyBub3QgY29udGFpbiBhbnkgU3ViamVjdCBpbXBsZW1lbnRhdGlvbnMuXG52YXIgQ29uY2FzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2FzdCwgX3N1cGVyKTtcbiAgICAvLyBOb3Qgb25seSBjYW4gdGhlIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIGl0ZXJhYmxlIGJlIHByb21pc2VzLCBidXRcbiAgICAvLyBhbHNvIHRoZSBpdGVyYWJsZSBpdHNlbGYgY2FuIGJlIHdyYXBwZWQgaW4gYSBwcm9taXNlLlxuICAgIGZ1bmN0aW9uIENvbmNhc3Qoc291cmNlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7IH07XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIC8vIEFjdGl2ZSBvYnNlcnZlcnMgcmVjZWl2aW5nIGJyb2FkY2FzdCBtZXNzYWdlcy4gVGhhbmtzIHRvIHRoaXMubGF0ZXN0LFxuICAgICAgICAvLyB3ZSBjYW4gYXNzdW1lIGFsbCBvYnNlcnZlcnMgaW4gdGhpcyBTZXQgaGF2ZSByZWNlaXZlZCB0aGUgc2FtZSBtb3N0XG4gICAgICAgIC8vIHJlY2VudCBtZXNzYWdlLCB0aG91Z2ggcG9zc2libHkgYXQgZGlmZmVyZW50IHRpbWVzIGluIHRoZSBwYXN0LlxuICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJvdW5kIGhhbmRsZXIgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHJldXNlZCBmb3IgZXZlcnkgaW50ZXJuYWxcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uLlxuICAgICAgICBfdGhpcy5oYW5kbGVycyA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhdGVzdCA9IFtcIm5leHRcIiwgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5KFwibmV4dFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KF90aGlzLm9ic2VydmVycywgXCJuZXh0XCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3RoaXMuc3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdW5zdWJzY3JpYmluZyBmcm9tIHRoZSB1bmRlcmx5aW5nIHN1YnNjcmlwdGlvbiBzbGlnaHRseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCBpbW1lZGlhdGVseSBzdWJzY3JpYmluZyBhbm90aGVyIG9ic2VydmVyIGNhbiBrZWVwIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gYWN0aXZlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhdGVzdCA9IFtcImVycm9yXCIsIGVycm9yXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KF90aGlzLm9ic2VydmVycywgXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHN1YiA9IF9hLnN1YiwgX2IgPSBfYS5zb3VyY2VzLCBzb3VyY2VzID0gX2IgPT09IHZvaWQgMCA/IFtdIDogX2I7XG4gICAgICAgICAgICAgICAgaWYgKHN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb21wbGV0ZSBpcyBjYWxsZWQgYmVmb3JlIGNvbmNhc3Quc3RhcnQsIHRoaXMuc291cmNlcyBtYXkgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkLCBzbyB3ZSB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIFtdIGZvciBzb3VyY2VzLiBUaGF0IHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUgYmVjYXVzZSBpdCBmYWxscyBpbnRvIHRoZSBpZiAoIXZhbHVlKSB7Li4ufSBibG9jaywgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGVseSB0ZXJtaW5hdGVzIHRoZSBDb25jYXN0LCBldmVuIGlmIHRoaXMuc291cmNlcyBtaWdodFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudHVhbGx5IGhhdmUgYmVlbiBpbml0aWFsaXplZCB0byBhIG5vbi1lbXB0eSBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ViID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYXRlc3QgJiYgX3RoaXMubGF0ZXN0WzBdID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoX3RoaXMubGF0ZXN0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeShcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHN0b3JlIHRoaXMubGF0ZXN0ID0gW1wiY29tcGxldGVcIl0sIGJlY2F1c2UgZG9pbmcgc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmRzIHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcHJldmlvdXMgbmV4dCAob3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yKSBtZXNzYWdlLiBJbnN0ZWFkLCBpZiBuZXcgb2JzZXJ2ZXJzIHN1YnNjcmliZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBDb25jYXN0IGhhcyBjb21wbGV0ZWQsIHRoZXkgd2lsbCByZWNlaXZlIHRoZSBmaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25leHQnIG1lc3NhZ2UgKHVubGVzcyB0aGVyZSB3YXMgYW4gZXJyb3IpIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dlZCBieSBhICdjb21wbGV0ZScgbWVzc2FnZSAoc2VlIGFkZE9ic2VydmVyKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkoX3RoaXMub2JzZXJ2ZXJzLCBcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIChfdGhpcy5zdWIgPSBvYnMuc3Vic2NyaWJlKF90aGlzLmhhbmRsZXJzKSk7IH0sIF90aGlzLmhhbmRsZXJzLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IHZhbHVlLnN1YnNjcmliZShfdGhpcy5oYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5uZXh0UmVzdWx0TGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBBIHB1YmxpYyB3YXkgdG8gYWJvcnQgb2JzZXJ2YXRpb24gYW5kIGJyb2FkY2FzdC5cbiAgICAgICAgX3RoaXMuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgX3RoaXMucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2VzID0gW107XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVycy5lcnJvcihyZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTdXBwcmVzcyByZWplY3Rpb24gd2FybmluZ3MgZm9yIHRoaXMucHJvbWlzZSwgc2luY2UgaXQncyBwZXJmZWN0bHlcbiAgICAgICAgLy8gYWNjZXB0YWJsZSB0byBwYXkgbm8gYXR0ZW50aW9uIHRvIHRoaXMucHJvbWlzZSBpZiB5b3UncmUgY29uc3VtaW5nXG4gICAgICAgIC8vIHRoZSByZXN1bHRzIHRocm91Z2ggdGhlIG5vcm1hbCBvYnNlcnZhYmxlIEFQSS5cbiAgICAgICAgX3RoaXMucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoXykgeyB9KTtcbiAgICAgICAgLy8gSWYgc29tZW9uZSBhY2NpZGVudGFsbHkgdHJpZXMgdG8gY3JlYXRlIGEgQ29uY2FzdCB1c2luZyBhIHN1YnNjcmliZXJcbiAgICAgICAgLy8gZnVuY3Rpb24sIHJlY292ZXIgYnkgY3JlYXRpbmcgYW4gT2JzZXJ2YWJsZSBmcm9tIHRoYXQgc3Vic2NyaWJlciBhbmRcbiAgICAgICAgLy8gdXNpbmcgaXQgYXMgdGhlIHNvdXJjZS5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNvdXJjZXMgPSBbbmV3IE9ic2VydmFibGUoc291cmNlcyldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb21pc2VMaWtlKHNvdXJjZXMpKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnRoZW4oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7IHJldHVybiBfdGhpcy5zdGFydChpdGVyYWJsZSk7IH0sIF90aGlzLmhhbmRsZXJzLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0KHNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2FzdC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoc291cmNlcykge1xuICAgICAgICBpZiAodGhpcy5zdWIgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gSW4gcHJhY3RpY2UsIHNvdXJjZXMgaXMgbW9zdCBvZnRlbiBzaW1wbHkgYW4gQXJyYXkgb2Ygb2JzZXJ2YWJsZXMuXG4gICAgICAgIC8vIFRPRE8gQ29uc2lkZXIgdXNpbmcgc291cmNlc1tTeW1ib2wuaXRlcmF0b3JdKCkgdG8gdGFrZSBhZHZhbnRhZ2VcbiAgICAgICAgLy8gb2YgdGhlIGxhemluZXNzIG9mIG5vbi1BcnJheSBpdGVyYWJsZXMuXG4gICAgICAgIHRoaXMuc291cmNlcyA9IEFycmF5LmZyb20oc291cmNlcyk7XG4gICAgICAgIC8vIENhbGxpbmcgdGhpcy5oYW5kbGVycy5jb21wbGV0ZSgpIGtpY2tzIG9mZiBjb25zdW1wdGlvbiBvZiB0aGUgZmlyc3RcbiAgICAgICAgLy8gc291cmNlIG9ic2VydmFibGUuIEl0J3MgdGVtcHRpbmcgdG8gZG8gdGhpcyBzdGVwIGxhemlseSBpblxuICAgICAgICAvLyBhZGRPYnNlcnZlciwgYnV0IHRoaXMucHJvbWlzZSBjYW4gYmUgYWNjZXNzZWQgd2l0aG91dCBjYWxsaW5nXG4gICAgICAgIC8vIGFkZE9ic2VydmVyLCBzbyBjb25zdW1wdGlvbiBuZWVkcyB0byBiZWdpbiBlYWdlcmx5LlxuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5kZWxpdmVyTGFzdE1lc3NhZ2UgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0KSB7XG4gICAgICAgICAgICB2YXIgbmV4dE9yRXJyb3IgPSB0aGlzLmxhdGVzdFswXTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYnNlcnZlcltuZXh0T3JFcnJvcl07XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwob2JzZXJ2ZXIsIHRoaXMubGF0ZXN0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBjbG9zZWQsIGFuZCB0aGUgbGFzdCBtZXNzYWdlIHdhc1xuICAgICAgICAgICAgLy8gYSAnbmV4dCcgbWVzc2FnZSwgc2ltdWxhdGUgZGVsaXZlcnkgb2YgdGhlIGZpbmFsICdjb21wbGV0ZSdcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYWdhaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5zdWIgPT09IG51bGwgJiYgbmV4dE9yRXJyb3IgPT09IFwibmV4dFwiICYmIG9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2FzdC5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5oYXMob2JzZXJ2ZXIpKSB7XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGVseSBkZWxpdmVyIHRoZSBtb3N0IHJlY2VudCBtZXNzYWdlLCBzbyB3ZSBjYW4gYWx3YXlzXG4gICAgICAgICAgICAvLyBiZSBzdXJlIGFsbCBvYnNlcnZlcnMgaGF2ZSB0aGUgbGF0ZXN0IGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgdGhpcy5kZWxpdmVyTGFzdE1lc3NhZ2Uob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2FzdC5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcikgJiYgdGhpcy5vYnNlcnZlcnMuc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlcmUgYXJlIHN0aWxsIGFueSBsaXN0ZW5lcnMgaW4gdGhpcy5uZXh0UmVzdWx0TGlzdGVuZXJzLCBhbmRcbiAgICAgICAgICAgIC8vIG5vIGVycm9yIG9yIGNvbXBsZXRpb24gaGFzIGJlZW4gYnJvYWRjYXN0IHlldCwgbWFrZSBzdXJlIHRob3NlXG4gICAgICAgICAgICAvLyBvYnNlcnZlcnMgaGF2ZSBhIGNoYW5jZSB0byBydW4gYW5kIHRoZW4gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbVxuICAgICAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMuXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmNhc3QucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgICB2YXIgbmV4dFJlc3VsdExpc3RlbmVycyA9IHRoaXMubmV4dFJlc3VsdExpc3RlbmVycztcbiAgICAgICAgaWYgKG5leHRSZXN1bHRMaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgICAgICAgLy8gUmVwbGFjaW5nIHRoaXMubmV4dFJlc3VsdExpc3RlbmVycyBmaXJzdCBlbnN1cmVzIGl0IGRvZXMgbm90IGdyb3cgd2hpbGVcbiAgICAgICAgICAgIC8vIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciBpdCwgcG90ZW50aWFsbHkgbGVhZGluZyB0byBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgIHRoaXMubmV4dFJlc3VsdExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIG5leHRSZXN1bHRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKG1ldGhvZCwgYXJnKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFdlIG5lZWQgYSB3YXkgdG8gcnVuIGNhbGxiYWNrcyBqdXN0ICpiZWZvcmUqIHRoZSBuZXh0IHJlc3VsdCAob3IgZXJyb3Igb3JcbiAgICAvLyBjb21wbGV0aW9uKSBpcyBkZWxpdmVyZWQgYnkgdGhpcyBDb25jYXN0LCBzbyB3ZSBjYW4gYmUgc3VyZSBhbnkgY29kZSB0aGF0XG4gICAgLy8gcnVucyBhcyBhIHJlc3VsdCBvZiBkZWxpdmVyaW5nIHRoYXQgcmVzdWx0L2Vycm9yIG9ic2VydmVzIHRoZSBlZmZlY3RzIG9mXG4gICAgLy8gcnVubmluZyB0aGUgY2FsbGJhY2socykuIEl0IHdhcyB0ZW1wdGluZyB0byByZXVzZSB0aGUgT2JzZXJ2ZXIgdHlwZSBpbnN0ZWFkXG4gICAgLy8gb2YgaW50cm9kdWNpbmcgTmV4dFJlc3VsdExpc3RlbmVyLCBidXQgdGhhdCBtZXNzZXMgd2l0aCB0aGUgc2l6aW5nIGFuZFxuICAgIC8vIG1haW50ZW5hbmNlIG9mIHRoaXMub2JzZXJ2ZXJzLCBhbmQgZW5kcyB1cCBiZWluZyBtb3JlIGNvZGUgb3ZlcmFsbC5cbiAgICBDb25jYXN0LnByb3RvdHlwZS5iZWZvcmVOZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0TGlzdGVuZXJzLmFkZChmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtZXRob2QsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhc3Q7XG59KE9ic2VydmFibGUpKTtcbmV4cG9ydCB7IENvbmNhc3QgfTtcbi8vIE5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBDb25jYXN0IGNvbnN0cnVjdG9yIGhhcyBhIGRpZmZlcmVudCBzaWduYXR1cmVcbi8vIHRoYW4gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3IuXG5maXhPYnNlcnZhYmxlU3ViY2xhc3MoQ29uY2FzdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25jYXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJPYnNlcnZhYmxlIiwiaXRlcmF0ZU9ic2VydmVyc1NhZmVseSIsImZpeE9ic2VydmFibGVTdWJjbGFzcyIsImlzUHJvbWlzZUxpa2UiLCJ2YWx1ZSIsInRoZW4iLCJDb25jYXN0IiwiX3N1cGVyIiwic291cmNlcyIsIl90aGlzIiwiY2FsbCIsIm9ic2VydmVyIiwiYWRkT2JzZXJ2ZXIiLCJyZW1vdmVPYnNlcnZlciIsIm9ic2VydmVycyIsIlNldCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImhhbmRsZXJzIiwibmV4dCIsInJlc3VsdCIsInN1YiIsImxhdGVzdCIsIm5vdGlmeSIsImVycm9yIiwic2V0VGltZW91dCIsInVuc3Vic2NyaWJlIiwiY29tcGxldGUiLCJfYSIsIl9iIiwic2hpZnQiLCJvYnMiLCJzdWJzY3JpYmUiLCJuZXh0UmVzdWx0TGlzdGVuZXJzIiwiY2FuY2VsIiwicmVhc29uIiwiY2F0Y2giLCJfIiwiaXRlcmFibGUiLCJzdGFydCIsInByb3RvdHlwZSIsIkFycmF5IiwiZnJvbSIsImRlbGl2ZXJMYXN0TWVzc2FnZSIsIm5leHRPckVycm9yIiwibWV0aG9kIiwiaGFzIiwiYWRkIiwiZGVsZXRlIiwic2l6ZSIsImFyZyIsImZvckVhY2giLCJsaXN0ZW5lciIsImJlZm9yZU5leHQiLCJjYWxsYmFjayIsImNhbGxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/Concast.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/asyncMap.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/asyncMap.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asyncMap: function() { return /* binding */ asyncMap; }\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nfunction asyncMap(observable, mapFn, catchFn) {\n    return new _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable(function(observer) {\n        var promiseQueue = {\n            // Normally we would initialize promiseQueue to Promise.resolve(), but\n            // in this case, for backwards compatibility, we need to be careful to\n            // invoke the first callback synchronously.\n            then: function(callback) {\n                return new Promise(function(resolve) {\n                    return resolve(callback());\n                });\n            }\n        };\n        function makeCallback(examiner, key) {\n            return function(arg) {\n                if (examiner) {\n                    var both = function() {\n                        // If the observer is closed, we don't want to continue calling the\n                        // mapping function - it's result will be swallowed anyways.\n                        return observer.closed ? /* will be swallowed */ 0 : examiner(arg);\n                    };\n                    promiseQueue = promiseQueue.then(both, both).then(function(result) {\n                        return observer.next(result);\n                    }, function(error) {\n                        return observer.error(error);\n                    });\n                } else {\n                    observer[key](arg);\n                }\n            };\n        }\n        var handler = {\n            next: makeCallback(mapFn, \"next\"),\n            error: makeCallback(catchFn, \"error\"),\n            complete: function() {\n                // no need to reassign `promiseQueue`, after `observer.complete`,\n                // the observer will be closed and short-circuit everything anyways\n                /*promiseQueue = */ promiseQueue.then(function() {\n                    return observer.complete();\n                });\n            }\n        };\n        var sub = observable.subscribe(handler);\n        return function() {\n            return sub.unsubscribe();\n        };\n    });\n} //# sourceMappingURL=asyncMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvYXN5bmNNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkM7QUFDN0Msc0VBQXNFO0FBQ3RFLDZDQUE2QztBQUN0QyxTQUFTQyxTQUFTQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsT0FBTztJQUMvQyxPQUFPLElBQUlKLHNEQUFVQSxDQUFDLFNBQVVLLFFBQVE7UUFDcEMsSUFBSUMsZUFBZTtZQUNmLHNFQUFzRTtZQUN0RSxzRUFBc0U7WUFDdEUsMkNBQTJDO1lBQzNDQyxNQUFNLFNBQVVDLFFBQVE7Z0JBQ3BCLE9BQU8sSUFBSUMsUUFBUSxTQUFVQyxPQUFPO29CQUFJLE9BQU9BLFFBQVFGO2dCQUFhO1lBQ3hFO1FBQ0o7UUFDQSxTQUFTRyxhQUFhQyxRQUFRLEVBQUVDLEdBQUc7WUFDL0IsT0FBTyxTQUFVQyxHQUFHO2dCQUNoQixJQUFJRixVQUFVO29CQUNWLElBQUlHLE9BQU87d0JBQ1AsbUVBQW1FO3dCQUNuRSw0REFBNEQ7d0JBQzVELE9BQU9WLFNBQVNXLE1BQU0sR0FDbEIscUJBQXFCLEdBQUcsSUFDdEJKLFNBQVNFO29CQUNuQjtvQkFDQVIsZUFBZUEsYUFBYUMsSUFBSSxDQUFDUSxNQUFNQSxNQUFNUixJQUFJLENBQUMsU0FBVVUsTUFBTTt3QkFBSSxPQUFPWixTQUFTYSxJQUFJLENBQUNEO29CQUFTLEdBQUcsU0FBVUUsS0FBSzt3QkFBSSxPQUFPZCxTQUFTYyxLQUFLLENBQUNBO29CQUFRO2dCQUM1SixPQUNLO29CQUNEZCxRQUFRLENBQUNRLElBQUksQ0FBQ0M7Z0JBQ2xCO1lBQ0o7UUFDSjtRQUNBLElBQUlNLFVBQVU7WUFDVkYsTUFBTVAsYUFBYVIsT0FBTztZQUMxQmdCLE9BQU9SLGFBQWFQLFNBQVM7WUFDN0JpQixVQUFVO2dCQUNOLGlFQUFpRTtnQkFDakUsbUVBQW1FO2dCQUNuRSxpQkFBaUIsR0FBR2YsYUFBYUMsSUFBSSxDQUFDO29CQUFjLE9BQU9GLFNBQVNnQixRQUFRO2dCQUFJO1lBQ3BGO1FBQ0o7UUFDQSxJQUFJQyxNQUFNcEIsV0FBV3FCLFNBQVMsQ0FBQ0g7UUFDL0IsT0FBTztZQUFjLE9BQU9FLElBQUlFLFdBQVc7UUFBSTtJQUNuRDtBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvYXN5bmNNYXAuanM/YWYyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcIi4vT2JzZXJ2YWJsZS5qc1wiO1xuLy8gTGlrZSBPYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAsIGV4Y2VwdCB0aGF0IHRoZSBtYXBwaW5nIGZ1bmN0aW9uIGNhblxuLy8gb3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIChvciBiZSBhc3luYykuXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNNYXAob2JzZXJ2YWJsZSwgbWFwRm4sIGNhdGNoRm4pIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBwcm9taXNlUXVldWUgPSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxseSB3ZSB3b3VsZCBpbml0aWFsaXplIHByb21pc2VRdWV1ZSB0byBQcm9taXNlLnJlc29sdmUoKSwgYnV0XG4gICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2UsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgbmVlZCB0byBiZSBjYXJlZnVsIHRvXG4gICAgICAgICAgICAvLyBpbnZva2UgdGhlIGZpcnN0IGNhbGxiYWNrIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHJlc29sdmUoY2FsbGJhY2soKSk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNhbGxiYWNrKGV4YW1pbmVyLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4YW1pbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9ic2VydmVyIGlzIGNsb3NlZCwgd2UgZG9uJ3Qgd2FudCB0byBjb250aW51ZSBjYWxsaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGluZyBmdW5jdGlvbiAtIGl0J3MgcmVzdWx0IHdpbGwgYmUgc3dhbGxvd2VkIGFueXdheXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuY2xvc2VkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB3aWxsIGJlIHN3YWxsb3dlZCAqLyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBleGFtaW5lcihhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUXVldWUgPSBwcm9taXNlUXVldWUudGhlbihib3RoLCBib3RoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBvYnNlcnZlci5lcnJvcihlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJba2V5XShhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB7XG4gICAgICAgICAgICBuZXh0OiBtYWtlQ2FsbGJhY2sobWFwRm4sIFwibmV4dFwiKSxcbiAgICAgICAgICAgIGVycm9yOiBtYWtlQ2FsbGJhY2soY2F0Y2hGbiwgXCJlcnJvclwiKSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZWFzc2lnbiBgcHJvbWlzZVF1ZXVlYCwgYWZ0ZXIgYG9ic2VydmVyLmNvbXBsZXRlYCxcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2JzZXJ2ZXIgd2lsbCBiZSBjbG9zZWQgYW5kIHNob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBhbnl3YXlzXG4gICAgICAgICAgICAgICAgLypwcm9taXNlUXVldWUgPSAqLyBwcm9taXNlUXVldWUudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSgpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdWIgPSBvYnNlcnZhYmxlLnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9O1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNNYXAuanMubWFwIl0sIm5hbWVzIjpbIk9ic2VydmFibGUiLCJhc3luY01hcCIsIm9ic2VydmFibGUiLCJtYXBGbiIsImNhdGNoRm4iLCJvYnNlcnZlciIsInByb21pc2VRdWV1ZSIsInRoZW4iLCJjYWxsYmFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwibWFrZUNhbGxiYWNrIiwiZXhhbWluZXIiLCJrZXkiLCJhcmciLCJib3RoIiwiY2xvc2VkIiwicmVzdWx0IiwibmV4dCIsImVycm9yIiwiaGFuZGxlciIsImNvbXBsZXRlIiwic3ViIiwic3Vic2NyaWJlIiwidW5zdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/asyncMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js":
/*!************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/iteration.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iterateObserversSafely: function() { return /* binding */ iterateObserversSafely; }\n/* harmony export */ });\nfunction iterateObserversSafely(observers, method, argument) {\n    // In case observers is modified during iteration, we need to commit to the\n    // original elements, which also provides an opportunity to filter them down\n    // to just the observers with the given method.\n    var observersWithMethod = [];\n    observers.forEach(function(obs) {\n        return obs[method] && observersWithMethod.push(obs);\n    });\n    observersWithMethod.forEach(function(obs) {\n        return obs[method](argument);\n    });\n} //# sourceMappingURL=iteration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvaXRlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSx1QkFBdUJDLFNBQVMsRUFBRUMsTUFBTSxFQUFFQyxRQUFRO0lBQzlELDJFQUEyRTtJQUMzRSw0RUFBNEU7SUFDNUUsK0NBQStDO0lBQy9DLElBQUlDLHNCQUFzQixFQUFFO0lBQzVCSCxVQUFVSSxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUFJLE9BQU9BLEdBQUcsQ0FBQ0osT0FBTyxJQUFJRSxvQkFBb0JHLElBQUksQ0FBQ0Q7SUFBTTtJQUN4RkYsb0JBQW9CQyxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUFJLE9BQU9BLEdBQUcsQ0FBQ0osT0FBTyxDQUFDQztJQUFXO0FBQy9FLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvaXRlcmF0aW9uLmpzP2I0NzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkob2JzZXJ2ZXJzLCBtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgLy8gSW4gY2FzZSBvYnNlcnZlcnMgaXMgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbiwgd2UgbmVlZCB0byBjb21taXQgdG8gdGhlXG4gICAgLy8gb3JpZ2luYWwgZWxlbWVudHMsIHdoaWNoIGFsc28gcHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gZmlsdGVyIHRoZW0gZG93blxuICAgIC8vIHRvIGp1c3QgdGhlIG9ic2VydmVycyB3aXRoIHRoZSBnaXZlbiBtZXRob2QuXG4gICAgdmFyIG9ic2VydmVyc1dpdGhNZXRob2QgPSBbXTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnNbbWV0aG9kXSAmJiBvYnNlcnZlcnNXaXRoTWV0aG9kLnB1c2gob2JzKTsgfSk7XG4gICAgb2JzZXJ2ZXJzV2l0aE1ldGhvZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdKGFyZ3VtZW50KTsgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIml0ZXJhdGVPYnNlcnZlcnNTYWZlbHkiLCJvYnNlcnZlcnMiLCJtZXRob2QiLCJhcmd1bWVudCIsIm9ic2VydmVyc1dpdGhNZXRob2QiLCJmb3JFYWNoIiwib2JzIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/subclassing.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixObservableSubclass: function() { return /* binding */ fixObservableSubclass; }\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _common_canUse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/canUse.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n\n\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nfunction fixObservableSubclass(subclass) {\n    function set(key) {\n        // Object.defineProperty is necessary because the Symbol.species\n        // property is a getter by default in modern JS environments, so we\n        // can't assign to it with a normal assignment expression.\n        Object.defineProperty(subclass, key, {\n            value: _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable\n        });\n    }\n    if (_common_canUse_js__WEBPACK_IMPORTED_MODULE_1__.canUseSymbol && Symbol.species) {\n        set(Symbol.species);\n    }\n    // The \"@@species\" string is used as a fake Symbol.species value in some\n    // polyfill systems (including the SymbolSpecies variable used by\n    // zen-observable), so we should set it as well, to be safe.\n    set(\"@@species\");\n    return subclass;\n} //# sourceMappingURL=subclassing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvc3ViY2xhc3NpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ007QUFDbkQsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSxtRUFBbUU7QUFDbkUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSx3RUFBd0U7QUFDeEUsdUVBQXVFO0FBQ3ZFLHVFQUF1RTtBQUNoRSxTQUFTRSxzQkFBc0JDLFFBQVE7SUFDMUMsU0FBU0MsSUFBSUMsR0FBRztRQUNaLGdFQUFnRTtRQUNoRSxtRUFBbUU7UUFDbkUsMERBQTBEO1FBQzFEQyxPQUFPQyxjQUFjLENBQUNKLFVBQVVFLEtBQUs7WUFBRUcsT0FBT1Isc0RBQVVBO1FBQUM7SUFDN0Q7SUFDQSxJQUFJQywyREFBWUEsSUFBSVEsT0FBT0MsT0FBTyxFQUFFO1FBQ2hDTixJQUFJSyxPQUFPQyxPQUFPO0lBQ3RCO0lBQ0Esd0VBQXdFO0lBQ3hFLGlFQUFpRTtJQUNqRSw0REFBNEQ7SUFDNUROLElBQUk7SUFDSixPQUFPRDtBQUNYLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvc3ViY2xhc3NpbmcuanM/YTFmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcIi4vT2JzZXJ2YWJsZS5qc1wiO1xuaW1wb3J0IHsgY2FuVXNlU3ltYm9sIH0gZnJvbSBcIi4uL2NvbW1vbi9jYW5Vc2UuanNcIjtcbi8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25zIG9mIE9ic2VydmFibGUucHJvdG90eXBlIG1ldGhvZHMgbGlrZSBtYXAgYW5kXG4vLyBmaWx0ZXIgbmVlZCB0byBrbm93IGhvdyB0byBjcmVhdGUgYSBuZXcgT2JzZXJ2YWJsZSBmcm9tIGFuIE9ic2VydmFibGVcbi8vIHN1YmNsYXNzIChsaWtlIENvbmNhc3Qgb3IgT2JzZXJ2YWJsZVF1ZXJ5KS4gVGhvc2UgbWV0aG9kcyBhc3N1bWVcbi8vIChwZXJoYXBzIHVud2lzZWx5PykgdGhhdCB0aGV5IGNhbiBjYWxsIHRoZSBzdWJ0eXBlJ3MgY29uc3RydWN0b3Igd2l0aCBhXG4vLyBTdWJzY3JpYmVyIGZ1bmN0aW9uLCBldmVuIHRob3VnaCB0aGUgc3ViY2xhc3MgY29uc3RydWN0b3IgbWlnaHQgZXhwZWN0XG4vLyBkaWZmZXJlbnQgcGFyYW1ldGVycy4gRGVmaW5pbmcgdGhpcyBzdGF0aWMgU3ltYm9sLnNwZWNpZXMgcHJvcGVydHkgb25cbi8vIHRoZSBzdWJjbGFzcyBpcyBhIGhpbnQgdG8gZ2VuZXJpYyBPYnNlcnZhYmxlIGNvZGUgdG8gdXNlIHRoZSBkZWZhdWx0XG4vLyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRyeWluZyB0byBkbyBgbmV3IFN1YmNsYXNzKG9ic2VydmVyID0+IC4uLilgLlxuZXhwb3J0IGZ1bmN0aW9uIGZpeE9ic2VydmFibGVTdWJjbGFzcyhzdWJjbGFzcykge1xuICAgIGZ1bmN0aW9uIHNldChrZXkpIHtcbiAgICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBTeW1ib2wuc3BlY2llc1xuICAgICAgICAvLyBwcm9wZXJ0eSBpcyBhIGdldHRlciBieSBkZWZhdWx0IGluIG1vZGVybiBKUyBlbnZpcm9ubWVudHMsIHNvIHdlXG4gICAgICAgIC8vIGNhbid0IGFzc2lnbiB0byBpdCB3aXRoIGEgbm9ybWFsIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YmNsYXNzLCBrZXksIHsgdmFsdWU6IE9ic2VydmFibGUgfSk7XG4gICAgfVxuICAgIGlmIChjYW5Vc2VTeW1ib2wgJiYgU3ltYm9sLnNwZWNpZXMpIHtcbiAgICAgICAgc2V0KFN5bWJvbC5zcGVjaWVzKTtcbiAgICB9XG4gICAgLy8gVGhlIFwiQEBzcGVjaWVzXCIgc3RyaW5nIGlzIHVzZWQgYXMgYSBmYWtlIFN5bWJvbC5zcGVjaWVzIHZhbHVlIGluIHNvbWVcbiAgICAvLyBwb2x5ZmlsbCBzeXN0ZW1zIChpbmNsdWRpbmcgdGhlIFN5bWJvbFNwZWNpZXMgdmFyaWFibGUgdXNlZCBieVxuICAgIC8vIHplbi1vYnNlcnZhYmxlKSwgc28gd2Ugc2hvdWxkIHNldCBpdCBhcyB3ZWxsLCB0byBiZSBzYWZlLlxuICAgIHNldChcIkBAc3BlY2llc1wiKTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjbGFzc2luZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JzZXJ2YWJsZSIsImNhblVzZVN5bWJvbCIsImZpeE9ic2VydmFibGVTdWJjbGFzcyIsInN1YmNsYXNzIiwic2V0Iiwia2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIlN5bWJvbCIsInNwZWNpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/version.js":
/*!************************************************!*\
  !*** ./node_modules/@apollo/client/version.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\nvar version = \"3.11.10\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFJQSxVQUFVLFVBQVUsQ0FDL0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC92ZXJzaW9uLmpzPzZmZGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciB2ZXJzaW9uID0gXCIzLjExLjEwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/caches/lib/strong.js":
/*!************************************************!*\
  !*** ./node_modules/@wry/caches/lib/strong.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StrongCache: function() { return /* binding */ StrongCache; }\n/* harmony export */ });\nfunction defaultDispose() {}\nclass StrongCache {\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    get size() {\n        return this.map.size;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return node.value = value;\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.map.set(key, node);\n        return node.value;\n    }\n    clean() {\n        while(this.oldest && this.map.size > this.max){\n            this.delete(this.oldest.key);\n        }\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            if (node === this.newest) {\n                this.newest = node.older;\n            }\n            if (node === this.oldest) {\n                this.oldest = node.newer;\n            }\n            if (node.newer) {\n                node.newer.older = node.older;\n            }\n            if (node.older) {\n                node.older.newer = node.newer;\n            }\n            this.map.delete(key);\n            this.dispose(node.value, key);\n            return true;\n        }\n        return false;\n    }\n    constructor(max = Infinity, dispose = defaultDispose){\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new Map();\n        this.newest = null;\n        this.oldest = null;\n    }\n} //# sourceMappingURL=strong.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NhY2hlcy9saWIvc3Ryb25nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxrQkFBbUI7QUFDckIsTUFBTUM7SUFRVEMsSUFBSUMsR0FBRyxFQUFFO1FBQ0wsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0YsR0FBRyxDQUFDQztJQUN4QjtJQUNBRSxJQUFJRixHQUFHLEVBQUU7UUFDTCxNQUFNRyxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDSjtRQUMxQixPQUFPRyxRQUFRQSxLQUFLRSxLQUFLO0lBQzdCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDTCxHQUFHLENBQUNLLElBQUk7SUFDeEI7SUFDQUYsUUFBUUosR0FBRyxFQUFFO1FBQ1QsTUFBTUcsT0FBTyxJQUFJLENBQUNGLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDRjtRQUMxQixJQUFJRyxRQUFRQSxTQUFTLElBQUksQ0FBQ0ksTUFBTSxFQUFFO1lBQzlCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBR047WUFDekIsSUFBSU0sT0FBTztnQkFDUEEsTUFBTUQsS0FBSyxHQUFHQTtZQUNsQjtZQUNBLElBQUlBLE9BQU87Z0JBQ1BBLE1BQU1DLEtBQUssR0FBR0E7WUFDbEI7WUFDQU4sS0FBS0ssS0FBSyxHQUFHLElBQUksQ0FBQ0QsTUFBTTtZQUN4QkosS0FBS0ssS0FBSyxDQUFDQyxLQUFLLEdBQUdOO1lBQ25CQSxLQUFLTSxLQUFLLEdBQUc7WUFDYixJQUFJLENBQUNGLE1BQU0sR0FBR0o7WUFDZCxJQUFJQSxTQUFTLElBQUksQ0FBQ08sTUFBTSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLE1BQU0sR0FBR0Q7WUFDbEI7UUFDSjtRQUNBLE9BQU9OO0lBQ1g7SUFDQVEsSUFBSVgsR0FBRyxFQUFFSyxLQUFLLEVBQUU7UUFDWixJQUFJRixPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDSjtRQUN4QixJQUFJRyxNQUFNO1lBQ04sT0FBT0EsS0FBS0UsS0FBSyxHQUFHQTtRQUN4QjtRQUNBRixPQUFPO1lBQ0hIO1lBQ0FLO1lBQ0FJLE9BQU87WUFDUEQsT0FBTyxJQUFJLENBQUNELE1BQU07UUFDdEI7UUFDQSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDQSxNQUFNLENBQUNFLEtBQUssR0FBR047UUFDeEI7UUFDQSxJQUFJLENBQUNJLE1BQU0sR0FBR0o7UUFDZCxJQUFJLENBQUNPLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sSUFBSVA7UUFDN0IsSUFBSSxDQUFDRixHQUFHLENBQUNVLEdBQUcsQ0FBQ1gsS0FBS0c7UUFDbEIsT0FBT0EsS0FBS0UsS0FBSztJQUNyQjtJQUNBTyxRQUFRO1FBQ0osTUFBTyxJQUFJLENBQUNGLE1BQU0sSUFBSSxJQUFJLENBQUNULEdBQUcsQ0FBQ0ssSUFBSSxHQUFHLElBQUksQ0FBQ08sR0FBRyxDQUFFO1lBQzVDLElBQUksQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQ0osTUFBTSxDQUFDVixHQUFHO1FBQy9CO0lBQ0o7SUFDQWMsT0FBT2QsR0FBRyxFQUFFO1FBQ1IsTUFBTUcsT0FBTyxJQUFJLENBQUNGLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDRjtRQUMxQixJQUFJRyxNQUFNO1lBQ04sSUFBSUEsU0FBUyxJQUFJLENBQUNJLE1BQU0sRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdKLEtBQUtLLEtBQUs7WUFDNUI7WUFDQSxJQUFJTCxTQUFTLElBQUksQ0FBQ08sTUFBTSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLE1BQU0sR0FBR1AsS0FBS00sS0FBSztZQUM1QjtZQUNBLElBQUlOLEtBQUtNLEtBQUssRUFBRTtnQkFDWk4sS0FBS00sS0FBSyxDQUFDRCxLQUFLLEdBQUdMLEtBQUtLLEtBQUs7WUFDakM7WUFDQSxJQUFJTCxLQUFLSyxLQUFLLEVBQUU7Z0JBQ1pMLEtBQUtLLEtBQUssQ0FBQ0MsS0FBSyxHQUFHTixLQUFLTSxLQUFLO1lBQ2pDO1lBQ0EsSUFBSSxDQUFDUixHQUFHLENBQUNhLE1BQU0sQ0FBQ2Q7WUFDaEIsSUFBSSxDQUFDZSxPQUFPLENBQUNaLEtBQUtFLEtBQUssRUFBRUw7WUFDekIsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBakZBZ0IsWUFBWUgsTUFBTUksUUFBUSxFQUFFRixVQUFVbEIsY0FBYyxDQUFFO1FBQ2xELElBQUksQ0FBQ2dCLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNFLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNkLEdBQUcsR0FBRyxJQUFJaUI7UUFDZixJQUFJLENBQUNYLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0csTUFBTSxHQUFHO0lBQ2xCO0FBNEVKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NhY2hlcy9saWIvc3Ryb25nLmpzP2RkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVmYXVsdERpc3Bvc2UoKSB7IH1cbmV4cG9ydCBjbGFzcyBTdHJvbmdDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobWF4ID0gSW5maW5pdHksIGRpc3Bvc2UgPSBkZWZhdWx0RGlzcG9zZSkge1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV3ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRlc3QgPSBudWxsO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKGtleSk7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcbiAgICB9XG4gICAgZ2V0Tm9kZShrZXkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlICE9PSB0aGlzLm5ld2VzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbGRlciwgbmV3ZXIgfSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobmV3ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXdlci5vbGRlciA9IG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgb2xkZXIubmV3ZXIgPSBuZXdlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUub2xkZXIgPSB0aGlzLm5ld2VzdDtcbiAgICAgICAgICAgIG5vZGUub2xkZXIubmV3ZXIgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5uZXdlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5ld2VzdCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5vbGRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZGVzdCA9IG5ld2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0Tm9kZShrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBuZXdlcjogbnVsbCxcbiAgICAgICAgICAgIG9sZGVyOiB0aGlzLm5ld2VzdFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5uZXdlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubmV3ZXN0Lm5ld2VyID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5ld2VzdCA9IG5vZGU7XG4gICAgICAgIHRoaXMub2xkZXN0ID0gdGhpcy5vbGRlc3QgfHwgbm9kZTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMub2xkZXN0ICYmIHRoaXMubWFwLnNpemUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy5vbGRlc3Qua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLm5ld2VzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3ZXN0ID0gbm9kZS5vbGRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLm9sZGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkZXN0ID0gbm9kZS5uZXdlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5ld2VyKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5uZXdlci5vbGRlciA9IG5vZGUub2xkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vbGRlcikge1xuICAgICAgICAgICAgICAgIG5vZGUub2xkZXIubmV3ZXIgPSBub2RlLm5ld2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2Uobm9kZS52YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJvbmcuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHREaXNwb3NlIiwiU3Ryb25nQ2FjaGUiLCJoYXMiLCJrZXkiLCJtYXAiLCJnZXQiLCJub2RlIiwiZ2V0Tm9kZSIsInZhbHVlIiwic2l6ZSIsIm5ld2VzdCIsIm9sZGVyIiwibmV3ZXIiLCJvbGRlc3QiLCJzZXQiLCJjbGVhbiIsIm1heCIsImRlbGV0ZSIsImRpc3Bvc2UiLCJjb25zdHJ1Y3RvciIsIkluZmluaXR5IiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/caches/lib/strong.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/caches/lib/weak.js":
/*!**********************************************!*\
  !*** ./node_modules/@wry/caches/lib/weak.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WeakCache: function() { return /* binding */ WeakCache; }\n/* harmony export */ });\nfunction noop() {}\nconst defaultDispose = noop;\nconst _WeakRef = typeof WeakRef !== \"undefined\" ? WeakRef : function(value) {\n    return {\n        deref: ()=>value\n    };\n};\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\" ? FinalizationRegistry : function() {\n    return {\n        register: noop,\n        unregister: noop\n    };\n};\nconst finalizationBatchSize = 10024;\nclass WeakCache {\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return node.value = value;\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.scheduleFinalization(node);\n        this.map.set(key, node);\n        this.size++;\n        return node.value;\n    }\n    clean() {\n        while(this.oldest && this.size > this.max){\n            this.deleteNode(this.oldest);\n        }\n    }\n    deleteNode(node) {\n        if (node === this.newest) {\n            this.newest = node.older;\n        }\n        if (node === this.oldest) {\n            this.oldest = node.newer;\n        }\n        if (node.newer) {\n            node.newer.older = node.older;\n        }\n        if (node.older) {\n            node.older.newer = node.newer;\n        }\n        this.size--;\n        const key = node.key || node.keyRef && node.keyRef.deref();\n        this.dispose(node.value, key);\n        if (!node.keyRef) {\n            this.unfinalizedNodes.delete(node);\n        } else {\n            this.registry.unregister(node);\n        }\n        if (key) this.map.delete(key);\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            this.deleteNode(node);\n            return true;\n        }\n        return false;\n    }\n    scheduleFinalization(node) {\n        this.unfinalizedNodes.add(node);\n        if (!this.finalizationScheduled) {\n            this.finalizationScheduled = true;\n            queueMicrotask(this.finalize);\n        }\n    }\n    constructor(max = Infinity, dispose = defaultDispose){\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new _WeakMap();\n        this.newest = null;\n        this.oldest = null;\n        this.unfinalizedNodes = new Set();\n        this.finalizationScheduled = false;\n        this.size = 0;\n        this.finalize = ()=>{\n            const iterator = this.unfinalizedNodes.values();\n            for(let i = 0; i < finalizationBatchSize; i++){\n                const node = iterator.next().value;\n                if (!node) break;\n                this.unfinalizedNodes.delete(node);\n                const key = node.key;\n                delete node.key;\n                node.keyRef = new _WeakRef(key);\n                this.registry.register(key, node, node);\n            }\n            if (this.unfinalizedNodes.size > 0) {\n                queueMicrotask(this.finalize);\n            } else {\n                this.finalizationScheduled = false;\n            }\n        };\n        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n    }\n} //# sourceMappingURL=weak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NhY2hlcy9saWIvd2Vhay5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsUUFBUztBQUNsQixNQUFNQyxpQkFBaUJEO0FBQ3ZCLE1BQU1FLFdBQVcsT0FBT0MsWUFBWSxjQUM5QkEsVUFDQSxTQUFVQyxLQUFLO0lBQ2IsT0FBTztRQUFFQyxPQUFPLElBQU1EO0lBQU07QUFDaEM7QUFDSixNQUFNRSxXQUFXLE9BQU9DLFlBQVksY0FBY0EsVUFBVUM7QUFDNUQsTUFBTUMsd0JBQXdCLE9BQU9DLHlCQUF5QixjQUN4REEsdUJBQ0E7SUFDRSxPQUFPO1FBQ0hDLFVBQVVYO1FBQ1ZZLFlBQVlaO0lBQ2hCO0FBQ0o7QUFDSixNQUFNYSx3QkFBd0I7QUFDdkIsTUFBTUM7SUErQlRDLElBQUlDLEdBQUcsRUFBRTtRQUNMLE9BQU8sSUFBSSxDQUFDQyxHQUFHLENBQUNGLEdBQUcsQ0FBQ0M7SUFDeEI7SUFDQUUsSUFBSUYsR0FBRyxFQUFFO1FBQ0wsTUFBTUcsT0FBTyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0o7UUFDMUIsT0FBT0csUUFBUUEsS0FBS2YsS0FBSztJQUM3QjtJQUNBZ0IsUUFBUUosR0FBRyxFQUFFO1FBQ1QsTUFBTUcsT0FBTyxJQUFJLENBQUNGLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDRjtRQUMxQixJQUFJRyxRQUFRQSxTQUFTLElBQUksQ0FBQ0UsTUFBTSxFQUFFO1lBQzlCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBR0o7WUFDekIsSUFBSUksT0FBTztnQkFDUEEsTUFBTUQsS0FBSyxHQUFHQTtZQUNsQjtZQUNBLElBQUlBLE9BQU87Z0JBQ1BBLE1BQU1DLEtBQUssR0FBR0E7WUFDbEI7WUFDQUosS0FBS0csS0FBSyxHQUFHLElBQUksQ0FBQ0QsTUFBTTtZQUN4QkYsS0FBS0csS0FBSyxDQUFDQyxLQUFLLEdBQUdKO1lBQ25CQSxLQUFLSSxLQUFLLEdBQUc7WUFD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QUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDZixHQUFHLEdBQUcsSUFBSVg7UUFDZixJQUFJLENBQUNlLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0csTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDUyxnQkFBZ0IsR0FBRyxJQUFJUztRQUM1QixJQUFJLENBQUNMLHFCQUFxQixHQUFHO1FBQzdCLElBQUksQ0FBQ1YsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDWSxRQUFRLEdBQUc7WUFDWixNQUFNSSxXQUFXLElBQUksQ0FBQ1YsZ0JBQWdCLENBQUNXLE1BQU07WUFDN0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUloQyx1QkFBdUJnQyxJQUFLO2dCQUM1QyxNQUFNMUIsT0FBT3dCLFNBQVNHLElBQUksR0FBRzFDLEtBQUs7Z0JBQ2xDLElBQUksQ0FBQ2UsTUFDRDtnQkFDSixJQUFJLENBQUNjLGdCQUFnQixDQUFDQyxNQUFNLENBQUNmO2dCQUM3QixNQUFNSCxNQUFNRyxLQUFLSCxHQUFHO2dCQUNwQixPQUFPRyxLQUFLSCxHQUFHO2dCQUNmRyxLQUFLWSxNQUFNLEdBQUcsSUFBSTdCLFNBQVNjO2dCQUMzQixJQUFJLENBQUNtQixRQUFRLENBQUN4QixRQUFRLENBQUNLLEtBQUtHLE1BQU1BO1lBQ3RDO1lBQ0EsSUFBSSxJQUFJLENBQUNjLGdCQUFnQixDQUFDTixJQUFJLEdBQUcsR0FBRztnQkFDaENXLGVBQWUsSUFBSSxDQUFDQyxRQUFRO1lBQ2hDLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDRixxQkFBcUIsR0FBRztZQUNqQztRQUNKO1FBQ0EsSUFBSSxDQUFDRixRQUFRLEdBQUcsSUFBSTFCLHNCQUFzQixJQUFJLENBQUNxQixVQUFVLENBQUNpQixJQUFJLENBQUMsSUFBSTtJQUN2RTtBQThGSixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdyeS9jYWNoZXMvbGliL3dlYWsuanM/YTE5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBkZWZhdWx0RGlzcG9zZSA9IG5vb3A7XG5jb25zdCBfV2Vha1JlZiA9IHR5cGVvZiBXZWFrUmVmICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBXZWFrUmVmXG4gICAgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZGVyZWY6ICgpID0+IHZhbHVlIH07XG4gICAgfTtcbmNvbnN0IF9XZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgIT09IFwidW5kZWZpbmVkXCIgPyBXZWFrTWFwIDogTWFwO1xuY29uc3QgX0ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaXN0ZXI6IG5vb3AsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiBub29wLFxuICAgICAgICB9O1xuICAgIH07XG5jb25zdCBmaW5hbGl6YXRpb25CYXRjaFNpemUgPSAxMDAyNDtcbmV4cG9ydCBjbGFzcyBXZWFrQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG1heCA9IEluZmluaXR5LCBkaXNwb3NlID0gZGVmYXVsdERpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2U7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IF9XZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubmV3ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRlc3QgPSBudWxsO1xuICAgICAgICB0aGlzLnVuZmluYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZmluYWxpemF0aW9uU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudW5maW5hbGl6ZWROb2Rlcy52YWx1ZXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluYWxpemF0aW9uQmF0Y2hTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy51bmZpbmFsaXplZE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5rZXlSZWYgPSBuZXcgX1dlYWtSZWYoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyKGtleSwgbm9kZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51bmZpbmFsaXplZE5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2sodGhpcy5maW5hbGl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXphdGlvblNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IF9GaW5hbGl6YXRpb25SZWdpc3RyeSh0aGlzLmRlbGV0ZU5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZTtcbiAgICB9XG4gICAgZ2V0Tm9kZShrZXkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlICE9PSB0aGlzLm5ld2VzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbGRlciwgbmV3ZXIgfSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobmV3ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXdlci5vbGRlciA9IG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgb2xkZXIubmV3ZXIgPSBuZXdlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUub2xkZXIgPSB0aGlzLm5ld2VzdDtcbiAgICAgICAgICAgIG5vZGUub2xkZXIubmV3ZXIgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5uZXdlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5ld2VzdCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5vbGRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZGVzdCA9IG5ld2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0Tm9kZShrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChub2RlLnZhbHVlID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG5ld2VyOiBudWxsLFxuICAgICAgICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5uZXdlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubmV3ZXN0Lm5ld2VyID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5ld2VzdCA9IG5vZGU7XG4gICAgICAgIHRoaXMub2xkZXN0ID0gdGhpcy5vbGRlc3QgfHwgbm9kZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUZpbmFsaXphdGlvbihub2RlKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgbm9kZSk7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG4gICAgY2xlYW4oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm9sZGVzdCAmJiB0aGlzLnNpemUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlKHRoaXMub2xkZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGVOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubmV3ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm5ld2VzdCA9IG5vZGUub2xkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMub2xkZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm9sZGVzdCA9IG5vZGUubmV3ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmV3ZXIpIHtcbiAgICAgICAgICAgIG5vZGUubmV3ZXIub2xkZXIgPSBub2RlLm9sZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm9sZGVyKSB7XG4gICAgICAgICAgICBub2RlLm9sZGVyLm5ld2VyID0gbm9kZS5uZXdlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgY29uc3Qga2V5ID0gbm9kZS5rZXkgfHwgKG5vZGUua2V5UmVmICYmIG5vZGUua2V5UmVmLmRlcmVmKCkpO1xuICAgICAgICB0aGlzLmRpc3Bvc2Uobm9kZS52YWx1ZSwga2V5KTtcbiAgICAgICAgaWYgKCFub2RlLmtleVJlZikge1xuICAgICAgICAgICAgdGhpcy51bmZpbmFsaXplZE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnkudW5yZWdpc3Rlcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5KVxuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzY2hlZHVsZUZpbmFsaXphdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudW5maW5hbGl6ZWROb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGlmICghdGhpcy5maW5hbGl6YXRpb25TY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemF0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKHRoaXMuZmluYWxpemUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vhay5qcy5tYXAiXSwibmFtZXMiOlsibm9vcCIsImRlZmF1bHREaXNwb3NlIiwiX1dlYWtSZWYiLCJXZWFrUmVmIiwidmFsdWUiLCJkZXJlZiIsIl9XZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsIl9GaW5hbGl6YXRpb25SZWdpc3RyeSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiZmluYWxpemF0aW9uQmF0Y2hTaXplIiwiV2Vha0NhY2hlIiwiaGFzIiwia2V5IiwibWFwIiwiZ2V0Iiwibm9kZSIsImdldE5vZGUiLCJuZXdlc3QiLCJvbGRlciIsIm5ld2VyIiwib2xkZXN0Iiwic2V0Iiwic2NoZWR1bGVGaW5hbGl6YXRpb24iLCJzaXplIiwiY2xlYW4iLCJtYXgiLCJkZWxldGVOb2RlIiwia2V5UmVmIiwiZGlzcG9zZSIsInVuZmluYWxpemVkTm9kZXMiLCJkZWxldGUiLCJyZWdpc3RyeSIsImFkZCIsImZpbmFsaXphdGlvblNjaGVkdWxlZCIsInF1ZXVlTWljcm90YXNrIiwiZmluYWxpemUiLCJjb25zdHJ1Y3RvciIsIkluZmluaXR5IiwiU2V0IiwiaXRlcmF0b3IiLCJ2YWx1ZXMiLCJpIiwibmV4dCIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/caches/lib/weak.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/context/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@wry/context/lib/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: function() { return /* reexport safe */ _slot_js__WEBPACK_IMPORTED_MODULE_0__.Slot; },\n/* harmony export */   asyncFromGen: function() { return /* binding */ asyncFromGen; },\n/* harmony export */   bind: function() { return /* binding */ bind; },\n/* harmony export */   noContext: function() { return /* binding */ noContext; },\n/* harmony export */   setTimeout: function() { return /* binding */ setTimeoutWithContext; },\n/* harmony export */   wrapYieldingFiberMethods: function() { return /* binding */ wrapYieldingFiberMethods; }\n/* harmony export */ });\n/* harmony import */ var _slot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slot.js */ \"(app-pages-browser)/./node_modules/@wry/context/lib/slot.js\");\n\n\nconst { bind, noContext } = _slot_js__WEBPACK_IMPORTED_MODULE_0__.Slot;\n// Like global.setTimeout, except the callback runs with captured context.\n\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn) {\n    return function() {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject)=>{\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                } catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                } else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value)=>invoke(boundNext, value);\n            const invokeThrow = (error)=>invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nfunction wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method)=>{\n            const fn = obj[method];\n            obj[method] = function() {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDakI7QUFDVCxNQUFNLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFLEdBQUdGLDBDQUFJQSxDQUFDO0FBQ3hDLDBFQUEwRTtBQUMzQjtBQUMvQyxTQUFTRyxzQkFBc0JFLFFBQVEsRUFBRUMsS0FBSztJQUMxQyxPQUFPRixXQUFXSCxLQUFLSSxXQUFXQztBQUN0QztBQUNBLDBFQUEwRTtBQUMxRSxpRUFBaUU7QUFDMUQsU0FBU0MsYUFBYUMsS0FBSztJQUM5QixPQUFPO1FBQ0gsTUFBTUMsTUFBTUQsTUFBTUUsS0FBSyxDQUFDLElBQUksRUFBRUM7UUFDOUIsTUFBTUMsWUFBWVgsS0FBS1EsSUFBSUksSUFBSTtRQUMvQixNQUFNQyxhQUFhYixLQUFLUSxJQUFJTSxLQUFLO1FBQ2pDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN6QixTQUFTQyxPQUFPQyxNQUFNLEVBQUVDLFFBQVE7Z0JBQzVCLElBQUk7b0JBQ0EsSUFBSUMsU0FBU0YsT0FBT0csSUFBSSxDQUFDZCxLQUFLWTtnQkFDbEMsRUFDQSxPQUFPRyxPQUFPO29CQUNWLE9BQU9OLE9BQU9NO2dCQUNsQjtnQkFDQSxNQUFNWCxPQUFPUyxPQUFPRyxJQUFJLEdBQUdSLFVBQVVTO2dCQUNyQyxJQUFJQyxjQUFjTCxPQUFPTSxLQUFLLEdBQUc7b0JBQzdCTixPQUFPTSxLQUFLLENBQUNDLElBQUksQ0FBQ2hCLE1BQU1TLE9BQU9HLElBQUksR0FBR1AsU0FBU1k7Z0JBQ25ELE9BQ0s7b0JBQ0RqQixLQUFLUyxPQUFPTSxLQUFLO2dCQUNyQjtZQUNKO1lBQ0EsTUFBTUYsYUFBYSxDQUFDRSxRQUFVVCxPQUFPUCxXQUFXZ0I7WUFDaEQsTUFBTUUsY0FBYyxDQUFDTixRQUFVTCxPQUFPTCxZQUFZVTtZQUNsREU7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTQyxjQUFjQyxLQUFLO0lBQ3hCLE9BQU9BLFNBQVMsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFDO0FBQ0Esd0VBQXdFO0FBQ3hFLDJFQUEyRTtBQUMzRSxzQ0FBc0M7QUFDdEMsTUFBTUUsZ0JBQWdCLEVBQUU7QUFDakIsU0FBU0MseUJBQXlCQyxLQUFLO0lBQzFDLDJFQUEyRTtJQUMzRSw2Q0FBNkM7SUFDN0MsSUFBSUYsY0FBY0csT0FBTyxDQUFDRCxTQUFTLEdBQUc7UUFDbEMsTUFBTUUsT0FBTyxDQUFDQyxLQUFLaEI7WUFDZixNQUFNaUIsS0FBS0QsR0FBRyxDQUFDaEIsT0FBTztZQUN0QmdCLEdBQUcsQ0FBQ2hCLE9BQU8sR0FBRztnQkFDVixPQUFPbEIsVUFBVW1DLElBQUkxQixXQUFXLElBQUk7WUFDeEM7UUFDSjtRQUNBLHdDQUF3QztRQUN4QywyR0FBMkc7UUFDM0d3QixLQUFLRixPQUFPO1FBQ1pFLEtBQUtGLE1BQU1LLFNBQVMsRUFBRTtRQUN0QkgsS0FBS0YsTUFBTUssU0FBUyxFQUFFO1FBQ3RCUCxjQUFjUSxJQUFJLENBQUNOO0lBQ3ZCO0lBQ0EsT0FBT0E7QUFDWCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdyeS9jb250ZXh0L2xpYi9pbmRleC5qcz80N2ZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsb3QgfSBmcm9tIFwiLi9zbG90LmpzXCI7XG5leHBvcnQgeyBTbG90IH07XG5leHBvcnQgY29uc3QgeyBiaW5kLCBub0NvbnRleHQgfSA9IFNsb3Q7XG4vLyBMaWtlIGdsb2JhbC5zZXRUaW1lb3V0LCBleGNlcHQgdGhlIGNhbGxiYWNrIHJ1bnMgd2l0aCBjYXB0dXJlZCBjb250ZXh0LlxuZXhwb3J0IHsgc2V0VGltZW91dFdpdGhDb250ZXh0IGFzIHNldFRpbWVvdXQgfTtcbmZ1bmN0aW9uIHNldFRpbWVvdXRXaXRoQ29udGV4dChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kKGNhbGxiYWNrKSwgZGVsYXkpO1xufVxuLy8gVHVybiBhbnkgZ2VuZXJhdG9yIGZ1bmN0aW9uIGludG8gYW4gYXN5bmMgZnVuY3Rpb24gKHVzaW5nIHlpZWxkIGluc3RlYWRcbi8vIG9mIGF3YWl0KSwgd2l0aCBjb250ZXh0IGF1dG9tYXRpY2FsbHkgcHJlc2VydmVkIGFjcm9zcyB5aWVsZHMuXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNGcm9tR2VuKGdlbkZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZ2VuID0gZ2VuRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgYm91bmROZXh0ID0gYmluZChnZW4ubmV4dCk7XG4gICAgICAgIGNvbnN0IGJvdW5kVGhyb3cgPSBiaW5kKGdlbi50aHJvdyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbChnZW4sIGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzdWx0LmRvbmUgPyByZXNvbHZlIDogaW52b2tlTmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKG5leHQsIHJlc3VsdC5kb25lID8gcmVqZWN0IDogaW52b2tlVGhyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGludm9rZU5leHQgPSAodmFsdWUpID0+IGludm9rZShib3VuZE5leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGludm9rZVRocm93ID0gKGVycm9yKSA9PiBpbnZva2UoYm91bmRUaHJvdywgZXJyb3IpO1xuICAgICAgICAgICAgaW52b2tlTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuLy8gSWYgeW91IHVzZSB0aGUgZmliZXJzIG5wbSBwYWNrYWdlIHRvIGltcGxlbWVudCBjb3JvdXRpbmVzIGluIE5vZGUuanMsXG4vLyB5b3Ugc2hvdWxkIGNhbGwgdGhpcyBmdW5jdGlvbiBhdCBsZWFzdCBvbmNlIHRvIGVuc3VyZSBjb250ZXh0IG1hbmFnZW1lbnRcbi8vIHJlbWFpbnMgY29oZXJlbnQgYWNyb3NzIGFueSB5aWVsZHMuXG5jb25zdCB3cmFwcGVkRmliZXJzID0gW107XG5leHBvcnQgZnVuY3Rpb24gd3JhcFlpZWxkaW5nRmliZXJNZXRob2RzKEZpYmVyKSB7XG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGltcGxlbWVudGF0aW9uIG9mIEZpYmVyIHBlciBwcm9jZXNzLCBzbyB0aGlzIGFycmF5XG4gICAgLy8gc2hvdWxkIG5ldmVyIGdyb3cgbG9uZ2VyIHRoYW4gb25lIGVsZW1lbnQuXG4gICAgaWYgKHdyYXBwZWRGaWJlcnMuaW5kZXhPZihGaWJlcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdyYXAgPSAob2JqLCBtZXRob2QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gb2JqW21ldGhvZF07XG4gICAgICAgICAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9Db250ZXh0KGZuLCBhcmd1bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlc2UgbWV0aG9kcyBjYW4geWllbGQsIGFjY29yZGluZyB0b1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGF2ZXJkZXQvbm9kZS1maWJlcnMvYmxvYi9kZGViZWQ5YjhhZTM4ODNlNTdmODIyZTIxMDhlNjk0M2U1YzhkMmE4L2ZpYmVycy5qcyNMOTctTDEwMFxuICAgICAgICB3cmFwKEZpYmVyLCBcInlpZWxkXCIpO1xuICAgICAgICB3cmFwKEZpYmVyLnByb3RvdHlwZSwgXCJydW5cIik7XG4gICAgICAgIHdyYXAoRmliZXIucHJvdG90eXBlLCBcInRocm93SW50b1wiKTtcbiAgICAgICAgd3JhcHBlZEZpYmVycy5wdXNoKEZpYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpYmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlNsb3QiLCJiaW5kIiwibm9Db250ZXh0Iiwic2V0VGltZW91dFdpdGhDb250ZXh0Iiwic2V0VGltZW91dCIsImNhbGxiYWNrIiwiZGVsYXkiLCJhc3luY0Zyb21HZW4iLCJnZW5GbiIsImdlbiIsImFwcGx5IiwiYXJndW1lbnRzIiwiYm91bmROZXh0IiwibmV4dCIsImJvdW5kVGhyb3ciLCJ0aHJvdyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW52b2tlIiwibWV0aG9kIiwiYXJndW1lbnQiLCJyZXN1bHQiLCJjYWxsIiwiZXJyb3IiLCJkb25lIiwiaW52b2tlTmV4dCIsImlzUHJvbWlzZUxpa2UiLCJ2YWx1ZSIsInRoZW4iLCJpbnZva2VUaHJvdyIsIndyYXBwZWRGaWJlcnMiLCJ3cmFwWWllbGRpbmdGaWJlck1ldGhvZHMiLCJGaWJlciIsImluZGV4T2YiLCJ3cmFwIiwib2JqIiwiZm4iLCJwcm90b3R5cGUiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/context/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/context/lib/slot.js":
/*!***********************************************!*\
  !*** ./node_modules/@wry/context/lib/slot.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: function() { return /* binding */ Slot; }\n/* harmony export */ });\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE = {};\nlet idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = ()=>{\n    class Slot {\n        hasValue() {\n            for(let context = currentContext; context; context = context.parent){\n                // We use the Slot object iself as a key to its value, which means the\n                // value cannot be obtained without a reference to the Slot object.\n                if (this.id in context.slots) {\n                    const value = context.slots[this.id];\n                    if (value === MISSING_VALUE) break;\n                    if (context !== currentContext) {\n                        // Cache the value in currentContext.slots so the next lookup will\n                        // be faster. This caching is safe because the tree of contexts and\n                        // the values of the slots are logically immutable.\n                        currentContext.slots[this.id] = value;\n                    }\n                    return true;\n                }\n            }\n            if (currentContext) {\n                // If a value was not found for this Slot, it's never going to be found\n                // no matter how many times we look it up, so we might as well cache\n                // the absence of the value, too.\n                currentContext.slots[this.id] = MISSING_VALUE;\n            }\n            return false;\n        }\n        getValue() {\n            if (this.hasValue()) {\n                return currentContext.slots[this.id];\n            }\n        }\n        withValue(value, callback, // Given the prevalence of arrow functions, specifying arguments is likely\n        // to be much more common than specifying `this`, hence this ordering:\n        args, thisArg) {\n            const slots = {\n                __proto__: null,\n                [this.id]: value\n            };\n            const parent = currentContext;\n            currentContext = {\n                parent,\n                slots\n            };\n            try {\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            } finally{\n                currentContext = parent;\n            }\n        }\n        // Capture the current context and wrap a callback function so that it\n        // reestablishes the captured context when called.\n        static bind(callback) {\n            const context = currentContext;\n            return function() {\n                const saved = currentContext;\n                try {\n                    currentContext = context;\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentContext = saved;\n                }\n            };\n        }\n        // Immediately run a callback function without any captured context.\n        static noContext(callback, // Given the prevalence of arrow functions, specifying arguments is likely\n        // to be much more common than specifying `this`, hence this ordering:\n        args, thisArg) {\n            if (currentContext) {\n                const saved = currentContext;\n                try {\n                    currentContext = null;\n                    // Function.prototype.apply allows the arguments array argument to be\n                    // omitted or undefined, so args! is fine here.\n                    return callback.apply(thisArg, args);\n                } finally{\n                    currentContext = saved;\n                }\n            } else {\n                return callback.apply(thisArg, args);\n            }\n        }\n        constructor(){\n            // If you have a Slot object, you can find out its slot.id, but you cannot\n            // guess the slot.id of a Slot you don't have access to, thanks to the\n            // randomized suffix.\n            this.id = [\n                \"slot\",\n                idCounter++,\n                Date.now(),\n                Math.random().toString(36).slice(2)\n            ].join(\":\");\n        }\n    }\n    return Slot;\n};\nfunction maybe(fn) {\n    try {\n        return fn();\n    } catch (ignored) {}\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = // Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(()=>globalThis) || // Fall back to global, which works in Node.js and may be converted by some\n// bundlers to the appropriate identifier (window, self, ...) depending on the\n// bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\nmaybe(()=>global) || // Otherwise, use a dummy host that's local to this module. We used to fall\n// back to using the Array constructor as a namespace, but that was flagged in\n// https://github.com/benjamn/wryware/issues/347, and can be avoided.\nObject.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost = host;\nconst Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array\n// constructor, so we check there as well, to prevent Slot class duplication.\nArray[globalKey] || function(Slot) {\n    try {\n        Object.defineProperty(globalHost, globalKey, {\n            value: Slot,\n            enumerable: false,\n            writable: false,\n            // When it was possible for globalHost to be the Array constructor (a\n            // legacy Slot dedup strategy), it was important for the property to be\n            // configurable:true so it could be deleted. That does not seem to be as\n            // important when globalHost is the global object, but I don't want to\n            // cause similar problems again, and configurable:true seems safest.\n            // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n            configurable: true\n        });\n    } finally{\n        return Slot;\n    }\n}(makeSlotClass()); //# sourceMappingURL=slot.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL3Nsb3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHNFQUFzRTtBQUN0RSwwRUFBMEU7QUFDMUUsdUNBQXVDO0FBQ3ZDLElBQUlBLGlCQUFpQjtBQUNyQix1RUFBdUU7QUFDdkUsMERBQTBEO0FBQzFELE1BQU1DLGdCQUFnQixDQUFDO0FBQ3ZCLElBQUlDLFlBQVk7QUFDaEIsdUVBQXVFO0FBQ3ZFLDRFQUE0RTtBQUM1RSxvRUFBb0U7QUFDcEUsTUFBTUMsZ0JBQWdCO0lBQU0sTUFBTUM7UUFZOUJDLFdBQVc7WUFDUCxJQUFLLElBQUlDLFVBQVVOLGdCQUFnQk0sU0FBU0EsVUFBVUEsUUFBUUMsTUFBTSxDQUFFO2dCQUNsRSxzRUFBc0U7Z0JBQ3RFLG1FQUFtRTtnQkFDbkUsSUFBSSxJQUFJLENBQUNDLEVBQUUsSUFBSUYsUUFBUUcsS0FBSyxFQUFFO29CQUMxQixNQUFNQyxRQUFRSixRQUFRRyxLQUFLLENBQUMsSUFBSSxDQUFDRCxFQUFFLENBQUM7b0JBQ3BDLElBQUlFLFVBQVVULGVBQ1Y7b0JBQ0osSUFBSUssWUFBWU4sZ0JBQWdCO3dCQUM1QixrRUFBa0U7d0JBQ2xFLG1FQUFtRTt3QkFDbkUsbURBQW1EO3dCQUNuREEsZUFBZVMsS0FBSyxDQUFDLElBQUksQ0FBQ0QsRUFBRSxDQUFDLEdBQUdFO29CQUNwQztvQkFDQSxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxJQUFJVixnQkFBZ0I7Z0JBQ2hCLHVFQUF1RTtnQkFDdkUsb0VBQW9FO2dCQUNwRSxpQ0FBaUM7Z0JBQ2pDQSxlQUFlUyxLQUFLLENBQUMsSUFBSSxDQUFDRCxFQUFFLENBQUMsR0FBR1A7WUFDcEM7WUFDQSxPQUFPO1FBQ1g7UUFDQVUsV0FBVztZQUNQLElBQUksSUFBSSxDQUFDTixRQUFRLElBQUk7Z0JBQ2pCLE9BQU9MLGVBQWVTLEtBQUssQ0FBQyxJQUFJLENBQUNELEVBQUUsQ0FBQztZQUN4QztRQUNK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WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL3Nsb3QuanM/NjFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGN1cnJlbnRDb250ZXh0IHZhcmlhYmxlIHdpbGwgb25seSBiZSB1c2VkIGlmIHRoZSBtYWtlU2xvdENsYXNzXG4vLyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdoaWNoIGhhcHBlbnMgb25seSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjb3B5IG9mIHRoZVxuLy8gQHdyeS9jb250ZXh0IHBhY2thZ2UgdG8gYmUgaW1wb3J0ZWQuXG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLy8gVGhpcyB1bmlxdWUgaW50ZXJuYWwgb2JqZWN0IGlzIHVzZWQgdG8gZGVub3RlIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWVcbi8vIGZvciBhIGdpdmVuIFNsb3QsIGFuZCBpcyBuZXZlciBleHBvc2VkIHRvIG91dHNpZGUgY29kZS5cbmNvbnN0IE1JU1NJTkdfVkFMVUUgPSB7fTtcbmxldCBpZENvdW50ZXIgPSAxO1xuLy8gQWx0aG91Z2ggd2UgY2FuJ3QgZG8gYW55dGhpbmcgYWJvdXQgdGhlIGNvc3Qgb2YgZHVwbGljYXRlZCBjb2RlIGZyb21cbi8vIGFjY2lkZW50YWxseSBidW5kbGluZyBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlLCB3ZSBjYW5cbi8vIGF2b2lkIGNyZWF0aW5nIHRoZSBTbG90IGNsYXNzIG1vcmUgdGhhbiBvbmNlIHVzaW5nIG1ha2VTbG90Q2xhc3MuXG5jb25zdCBtYWtlU2xvdENsYXNzID0gKCkgPT4gY2xhc3MgU2xvdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIElmIHlvdSBoYXZlIGEgU2xvdCBvYmplY3QsIHlvdSBjYW4gZmluZCBvdXQgaXRzIHNsb3QuaWQsIGJ1dCB5b3UgY2Fubm90XG4gICAgICAgIC8vIGd1ZXNzIHRoZSBzbG90LmlkIG9mIGEgU2xvdCB5b3UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8sIHRoYW5rcyB0byB0aGVcbiAgICAgICAgLy8gcmFuZG9taXplZCBzdWZmaXguXG4gICAgICAgIHRoaXMuaWQgPSBbXG4gICAgICAgICAgICBcInNsb3RcIixcbiAgICAgICAgICAgIGlkQ291bnRlcisrLFxuICAgICAgICAgICAgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICAgICAgICBdLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgICBoYXNWYWx1ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY29udGV4dCA9IGN1cnJlbnRDb250ZXh0OyBjb250ZXh0OyBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgU2xvdCBvYmplY3QgaXNlbGYgYXMgYSBrZXkgdG8gaXRzIHZhbHVlLCB3aGljaCBtZWFucyB0aGVcbiAgICAgICAgICAgIC8vIHZhbHVlIGNhbm5vdCBiZSBvYnRhaW5lZCB3aXRob3V0IGEgcmVmZXJlbmNlIHRvIHRoZSBTbG90IG9iamVjdC5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkIGluIGNvbnRleHQuc2xvdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHQuc2xvdHNbdGhpcy5pZF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBNSVNTSU5HX1ZBTFVFKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAhPT0gY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHZhbHVlIGluIGN1cnJlbnRDb250ZXh0LnNsb3RzIHNvIHRoZSBuZXh0IGxvb2t1cCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGZhc3Rlci4gVGhpcyBjYWNoaW5nIGlzIHNhZmUgYmVjYXVzZSB0aGUgdHJlZSBvZiBjb250ZXh0cyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBvZiB0aGUgc2xvdHMgYXJlIGxvZ2ljYWxseSBpbW11dGFibGUuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LnNsb3RzW3RoaXMuaWRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgLy8gSWYgYSB2YWx1ZSB3YXMgbm90IGZvdW5kIGZvciB0aGlzIFNsb3QsIGl0J3MgbmV2ZXIgZ29pbmcgdG8gYmUgZm91bmRcbiAgICAgICAgICAgIC8vIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyB3ZSBsb29rIGl0IHVwLCBzbyB3ZSBtaWdodCBhcyB3ZWxsIGNhY2hlXG4gICAgICAgICAgICAvLyB0aGUgYWJzZW5jZSBvZiB0aGUgdmFsdWUsIHRvby5cbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LnNsb3RzW3RoaXMuaWRdID0gTUlTU0lOR19WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQuc2xvdHNbdGhpcy5pZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aFZhbHVlKHZhbHVlLCBjYWxsYmFjaywgXG4gICAgLy8gR2l2ZW4gdGhlIHByZXZhbGVuY2Ugb2YgYXJyb3cgZnVuY3Rpb25zLCBzcGVjaWZ5aW5nIGFyZ3VtZW50cyBpcyBsaWtlbHlcbiAgICAvLyB0byBiZSBtdWNoIG1vcmUgY29tbW9uIHRoYW4gc3BlY2lmeWluZyBgdGhpc2AsIGhlbmNlIHRoaXMgb3JkZXJpbmc6XG4gICAgYXJncywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBzbG90cyA9IHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICAgIFt0aGlzLmlkXTogdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHsgcGFyZW50LCBzbG90cyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5IGFsbG93cyB0aGUgYXJndW1lbnRzIGFycmF5IGFyZ3VtZW50IHRvIGJlXG4gICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FwdHVyZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB3cmFwIGEgY2FsbGJhY2sgZnVuY3Rpb24gc28gdGhhdCBpdFxuICAgIC8vIHJlZXN0YWJsaXNoZXMgdGhlIGNhcHR1cmVkIGNvbnRleHQgd2hlbiBjYWxsZWQuXG4gICAgc3RhdGljIGJpbmQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBzYXZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW1tZWRpYXRlbHkgcnVuIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aG91dCBhbnkgY2FwdHVyZWQgY29udGV4dC5cbiAgICBzdGF0aWMgbm9Db250ZXh0KGNhbGxiYWNrLCBcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxuICAgIC8vIHRvIGJlIG11Y2ggbW9yZSBjb21tb24gdGhhbiBzcGVjaWZ5aW5nIGB0aGlzYCwgaGVuY2UgdGhpcyBvcmRlcmluZzpcbiAgICBhcmdzLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxuICAgICAgICAgICAgICAgIC8vIG9taXR0ZWQgb3IgdW5kZWZpbmVkLCBzbyBhcmdzISBpcyBmaW5lIGhlcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBzYXZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBtYXliZShmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlZCkgeyB9XG59XG4vLyBXZSBzdG9yZSBhIHNpbmdsZSBnbG9iYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNsb3QgY2xhc3MgYXMgYSBwZXJtYW5lbnRcbi8vIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9mIHRoZSBnbG9iYWxUaGlzIG9iamVjdC4gVGhpcyBvYmZ1c2NhdGlvbiBkb2VzXG4vLyBub3RoaW5nIHRvIHByZXZlbnQgYWNjZXNzIHRvIHRoZSBTbG90IGNsYXNzLCBidXQgYXQgbGVhc3QgaXQgZW5zdXJlcyB0aGVcbi8vIGltcGxlbWVudGF0aW9uIChpLmUuIGN1cnJlbnRDb250ZXh0KSBjYW5ub3QgYmUgdGFtcGVyZWQgd2l0aCwgYW5kIGFsbCBjb3BpZXNcbi8vIG9mIHRoZSBAd3J5L2NvbnRleHQgcGFja2FnZSAoaG9wZWZ1bGx5IGp1c3Qgb25lKSB3aWxsIHNoYXJlIHRoZSBzYW1lIFNsb3Rcbi8vIGltcGxlbWVudGF0aW9uLiBTaW5jZSB0aGUgZmlyc3QgY29weSBvZiB0aGUgQHdyeS9jb250ZXh0IHBhY2thZ2UgdG8gYmVcbi8vIGltcG9ydGVkIHdpbnMsIHRoaXMgdGVjaG5pcXVlIGltcG9zZXMgYSBzdGVlcCBjb3N0IGZvciBhbnkgZnV0dXJlIGJyZWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBTbG90IGNsYXNzLlxuY29uc3QgZ2xvYmFsS2V5ID0gXCJAd3J5L2NvbnRleHQ6U2xvdFwiO1xuY29uc3QgaG9zdCA9IFxuLy8gUHJlZmVyIGdsb2JhbFRoaXMgd2hlbiBhdmFpbGFibGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtbi93cnl3YXJlL2lzc3Vlcy8zNDdcbm1heWJlKCgpID0+IGdsb2JhbFRoaXMpIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIGdsb2JhbCwgd2hpY2ggd29ya3MgaW4gTm9kZS5qcyBhbmQgbWF5IGJlIGNvbnZlcnRlZCBieSBzb21lXG4gICAgLy8gYnVuZGxlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGlkZW50aWZpZXIgKHdpbmRvdywgc2VsZiwgLi4uKSBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gYnVuZGxpbmcgdGFyZ2V0LiBodHRwczovL2dpdGh1Yi5jb20vZW5kb2pzL2VuZG8vaXNzdWVzLzU3NiNpc3N1ZWNvbW1lbnQtMTE3ODUxNTIyNFxuICAgIG1heWJlKCgpID0+IGdsb2JhbCkgfHxcbiAgICAvLyBPdGhlcndpc2UsIHVzZSBhIGR1bW15IGhvc3QgdGhhdCdzIGxvY2FsIHRvIHRoaXMgbW9kdWxlLiBXZSB1c2VkIHRvIGZhbGxcbiAgICAvLyBiYWNrIHRvIHVzaW5nIHRoZSBBcnJheSBjb25zdHJ1Y3RvciBhcyBhIG5hbWVzcGFjZSwgYnV0IHRoYXQgd2FzIGZsYWdnZWQgaW5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtbi93cnl3YXJlL2lzc3Vlcy8zNDcsIGFuZCBjYW4gYmUgYXZvaWRlZC5cbiAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gV2hpY2hldmVyIGdsb2JhbEhvc3Qgd2UncmUgdXNpbmcsIG1ha2UgVHlwZVNjcmlwdCBoYXBweSBhYm91dCB0aGUgYWRkaXRpb25hbFxuLy8gZ2xvYmFsS2V5IHByb3BlcnR5LlxuY29uc3QgZ2xvYmFsSG9zdCA9IGhvc3Q7XG5leHBvcnQgY29uc3QgU2xvdCA9IGdsb2JhbEhvc3RbZ2xvYmFsS2V5XSB8fFxuICAgIC8vIEVhcmxpZXIgdmVyc2lvbnMgb2YgdGhpcyBwYWNrYWdlIHN0b3JlZCB0aGUgZ2xvYmFsS2V5IHByb3BlcnR5IG9uIHRoZSBBcnJheVxuICAgIC8vIGNvbnN0cnVjdG9yLCBzbyB3ZSBjaGVjayB0aGVyZSBhcyB3ZWxsLCB0byBwcmV2ZW50IFNsb3QgY2xhc3MgZHVwbGljYXRpb24uXG4gICAgQXJyYXlbZ2xvYmFsS2V5XSB8fFxuICAgIChmdW5jdGlvbiAoU2xvdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbEhvc3QsIGdsb2JhbEtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBTbG90LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGl0IHdhcyBwb3NzaWJsZSBmb3IgZ2xvYmFsSG9zdCB0byBiZSB0aGUgQXJyYXkgY29uc3RydWN0b3IgKGFcbiAgICAgICAgICAgICAgICAvLyBsZWdhY3kgU2xvdCBkZWR1cCBzdHJhdGVneSksIGl0IHdhcyBpbXBvcnRhbnQgZm9yIHRoZSBwcm9wZXJ0eSB0byBiZVxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTp0cnVlIHNvIGl0IGNvdWxkIGJlIGRlbGV0ZWQuIFRoYXQgZG9lcyBub3Qgc2VlbSB0byBiZSBhc1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydGFudCB3aGVuIGdsb2JhbEhvc3QgaXMgdGhlIGdsb2JhbCBvYmplY3QsIGJ1dCBJIGRvbid0IHdhbnQgdG9cbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBzaW1pbGFyIHByb2JsZW1zIGFnYWluLCBhbmQgY29uZmlndXJhYmxlOnRydWUgc2VlbXMgc2FmZXN0LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmRvanMvZW5kby9pc3N1ZXMvNTc2I2lzc3VlY29tbWVudC0xMTc4Mjc0MDA4XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJldHVybiBTbG90O1xuICAgICAgICB9XG4gICAgfSkobWFrZVNsb3RDbGFzcygpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsb3QuanMubWFwIl0sIm5hbWVzIjpbImN1cnJlbnRDb250ZXh0IiwiTUlTU0lOR19WQUxVRSIsImlkQ291bnRlciIsIm1ha2VTbG90Q2xhc3MiLCJTbG90IiwiaGFzVmFsdWUiLCJjb250ZXh0IiwicGFyZW50IiwiaWQiLCJzbG90cyIsInZhbHVlIiwiZ2V0VmFsdWUiLCJ3aXRoVmFsdWUiLCJjYWxsYmFjayIsImFyZ3MiLCJ0aGlzQXJnIiwiX19wcm90b19fIiwiYXBwbHkiLCJiaW5kIiwic2F2ZWQiLCJhcmd1bWVudHMiLCJub0NvbnRleHQiLCJjb25zdHJ1Y3RvciIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImpvaW4iLCJtYXliZSIsImZuIiwiaWdub3JlZCIsImdsb2JhbEtleSIsImhvc3QiLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ2xvYmFsSG9zdCIsIkFycmF5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/context/lib/slot.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/equality/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@wry/equality/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equal: function() { return /* binding */ equal; }\n/* harmony export */ });\nconst { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map();\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */ function equal(a, b) {\n    try {\n        return check(a, b);\n    } finally{\n        previousComparisons.clear();\n    }\n}\n// Allow default imports as well.\n/* harmony default export */ __webpack_exports__[\"default\"] = (equal);\nfunction check(a, b) {\n    // If the two values are strictly equal, our job is easy.\n    if (a === b) {\n        return true;\n    }\n    // Object.prototype.toString returns a representation of the runtime type of\n    // the given value that is considerably more precise than typeof.\n    const aTag = toString.call(a);\n    const bTag = toString.call(b);\n    // If the runtime types of a and b are different, they could maybe be equal\n    // under some interpretation of equality, but for simplicity and performance\n    // we just return false instead.\n    if (aTag !== bTag) {\n        return false;\n    }\n    switch(aTag){\n        case \"[object Array]\":\n            // Arrays are a lot like other objects, but we can cheaply compare their\n            // lengths as a short-cut before comparing their elements.\n            if (a.length !== b.length) return false;\n        // Fall through to object case...\n        case \"[object Object]\":\n            {\n                if (previouslyCompared(a, b)) return true;\n                const aKeys = definedKeys(a);\n                const bKeys = definedKeys(b);\n                // If `a` and `b` have a different number of enumerable keys, they\n                // must be different.\n                const keyCount = aKeys.length;\n                if (keyCount !== bKeys.length) return false;\n                // Now make sure they have the same keys.\n                for(let k = 0; k < keyCount; ++k){\n                    if (!hasOwnProperty.call(b, aKeys[k])) {\n                        return false;\n                    }\n                }\n                // Finally, check deep equality of all child properties.\n                for(let k = 0; k < keyCount; ++k){\n                    const key = aKeys[k];\n                    if (!check(a[key], b[key])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        case \"[object Error]\":\n            return a.name === b.name && a.message === b.message;\n        case \"[object Number]\":\n            // Handle NaN, which is !== itself.\n            if (a !== a) return b !== b;\n        // Fall through to shared +a === +b case...\n        case \"[object Boolean]\":\n        case \"[object Date]\":\n            return +a === +b;\n        case \"[object RegExp]\":\n        case \"[object String]\":\n            return a == \"\".concat(b);\n        case \"[object Map]\":\n        case \"[object Set]\":\n            {\n                if (a.size !== b.size) return false;\n                if (previouslyCompared(a, b)) return true;\n                const aIterator = a.entries();\n                const isMap = aTag === \"[object Map]\";\n                while(true){\n                    const info = aIterator.next();\n                    if (info.done) break;\n                    // If a instanceof Set, aValue === aKey.\n                    const [aKey, aValue] = info.value;\n                    // So this works the same way for both Set and Map.\n                    if (!b.has(aKey)) {\n                        return false;\n                    }\n                    // However, we care about deep equality of values only when dealing\n                    // with Map structures.\n                    if (isMap && !check(aValue, b.get(aKey))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        case \"[object Uint16Array]\":\n        case \"[object Uint8Array]\":\n        case \"[object Uint32Array]\":\n        case \"[object Int32Array]\":\n        case \"[object Int8Array]\":\n        case \"[object Int16Array]\":\n        case \"[object ArrayBuffer]\":\n            // DataView doesn't need these conversions, but the equality check is\n            // otherwise the same.\n            a = new Uint8Array(a);\n            b = new Uint8Array(b);\n        // Fall through...\n        case \"[object DataView]\":\n            {\n                let len = a.byteLength;\n                if (len === b.byteLength) {\n                    while(len-- && a[len] === b[len]){\n                    // Keep looping as long as the bytes are equal.\n                    }\n                }\n                return len === -1;\n            }\n        case \"[object AsyncFunction]\":\n        case \"[object GeneratorFunction]\":\n        case \"[object AsyncGeneratorFunction]\":\n        case \"[object Function]\":\n            {\n                const aCode = fnToStr.call(a);\n                if (aCode !== fnToStr.call(b)) {\n                    return false;\n                }\n                // We consider non-native functions equal if they have the same code\n                // (native functions require === because their code is censored).\n                // Note that this behavior is not entirely sound, since !== function\n                // objects with the same code can behave differently depending on\n                // their closure scope. However, any function can behave differently\n                // depending on the values of its input arguments (including this)\n                // and its calling context (including its closure scope), even\n                // though the function object is === to itself; and it is entirely\n                // possible for functions that are not === to behave exactly the\n                // same under all conceivable circumstances. Because none of these\n                // factors are statically decidable in JavaScript, JS function\n                // equality is not well-defined. This ambiguity allows us to\n                // consider the best possible heuristic among various imperfect\n                // options, and equating non-native functions that have the same\n                // code has enormous practical benefits, such as when comparing\n                // functions that are repeatedly passed as fresh function\n                // expressions within objects that are otherwise deeply equal. Since\n                // any function created from the same syntactic expression (in the\n                // same code location) will always stringify to the same code\n                // according to fnToStr.call, we can reasonably expect these\n                // repeatedly passed function expressions to have the same code, and\n                // thus behave \"the same\" (with all the caveats mentioned above),\n                // even though the runtime function objects are !== to one another.\n                return !endsWith(aCode, nativeCodeSuffix);\n            }\n    }\n    // Otherwise the values are not equal.\n    return false;\n}\nfunction definedKeys(obj) {\n    // Remember that the second argument to Array.prototype.filter will be\n    // used as `this` within the callback function.\n    return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey(key) {\n    return this[key] !== void 0;\n}\nconst nativeCodeSuffix = \"{ [native code] }\";\nfunction endsWith(full, suffix) {\n    const fromIndex = full.length - suffix.length;\n    return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;\n}\nfunction previouslyCompared(a, b) {\n    // Though cyclic references can make an object graph appear infinite from the\n    // perspective of a depth-first traversal, the graph still contains a finite\n    // number of distinct object references. We use the previousComparisons cache\n    // to avoid comparing the same pair of object references more than once, which\n    // guarantees termination (even if we end up comparing every object in one\n    // graph to every object in the other graph, which is extremely unlikely),\n    // while still allowing weird isomorphic structures (like rings with different\n    // lengths) a chance to pass the equality test.\n    let bSet = previousComparisons.get(a);\n    if (bSet) {\n        // Return true here because we can be sure false will be returned somewhere\n        // else if the objects are not equivalent.\n        if (bSet.has(b)) return true;\n    } else {\n        previousComparisons.set(a, bSet = new Set);\n    }\n    bSet.add(b);\n    return false;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2VxdWFsaXR5L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxFQUFFQSxRQUFRLEVBQUVDLGNBQWMsRUFBRSxHQUFHQyxPQUFPQyxTQUFTO0FBQ3JELE1BQU1DLFVBQVVDLFNBQVNGLFNBQVMsQ0FBQ0gsUUFBUTtBQUMzQyxNQUFNTSxzQkFBc0IsSUFBSUM7QUFDaEM7O0NBRUMsR0FDTSxTQUFTQyxNQUFNQyxDQUFDLEVBQUVDLENBQUM7SUFDdEIsSUFBSTtRQUNBLE9BQU9DLE1BQU1GLEdBQUdDO0lBQ3BCLFNBQ1E7UUFDSkosb0JBQW9CTSxLQUFLO0lBQzdCO0FBQ0o7QUFDQSxpQ0FBaUM7QUFDakMsK0RBQWVKLEtBQUtBLEVBQUM7QUFDckIsU0FBU0csTUFBTUYsQ0FBQyxFQUFFQyxDQUFDO0lBQ2YseURBQXlEO0lBQ3pELElBQUlELE1BQU1DLEdBQUc7UUFDVCxPQUFPO0lBQ1g7SUFDQSw0RUFBNEU7SUFDNUUsaUVBQWlFO0lBQ2pFLE1BQU1HLE9BQU9iLFNBQVNjLElBQUksQ0FBQ0w7SUFDM0IsTUFBTU0sT0FBT2YsU0FBU2MsSUFBSSxDQUFDSjtJQUMzQiwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLGdDQUFnQztJQUNoQyxJQUFJRyxTQUFTRSxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBUUY7UUFDSixLQUFLO1lBQ0Qsd0VBQXdFO1lBQ3hFLDBEQUEwRDtZQUMxRCxJQUFJSixFQUFFTyxNQUFNLEtBQUtOLEVBQUVNLE1BQU0sRUFDckIsT0FBTztRQUNmLGlDQUFpQztRQUNqQyxLQUFLO1lBQW1CO2dCQUNwQixJQUFJQyxtQkFBbUJSLEdBQUdDLElBQ3RCLE9BQU87Z0JBQ1gsTUFBTVEsUUFBUUMsWUFBWVY7Z0JBQzFCLE1BQU1XLFFBQVFELFlBQVlUO2dCQUMxQixrRUFBa0U7Z0JBQ2xFLHFCQUFxQjtnQkFDckIsTUFBTVcsV0FBV0gsTUFBTUYsTUFBTTtnQkFDN0IsSUFBSUssYUFBYUQsTUFBTUosTUFBTSxFQUN6QixPQUFPO2dCQUNYLHlDQUF5QztnQkFDekMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELFVBQVUsRUFBRUMsRUFBRztvQkFDL0IsSUFBSSxDQUFDckIsZUFBZWEsSUFBSSxDQUFDSixHQUFHUSxLQUFLLENBQUNJLEVBQUUsR0FBRzt3QkFDbkMsT0FBTztvQkFDWDtnQkFDSjtnQkFDQSx3REFBd0Q7Z0JBQ3hELElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJRCxVQUFVLEVBQUVDLEVBQUc7b0JBQy9CLE1BQU1DLE1BQU1MLEtBQUssQ0FBQ0ksRUFBRTtvQkFDcEIsSUFBSSxDQUFDWCxNQUFNRixDQUFDLENBQUNjLElBQUksRUFBRWIsQ0FBQyxDQUFDYSxJQUFJLEdBQUc7d0JBQ3hCLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBQ0EsT0FBTztZQUNYO1FBQ0EsS0FBSztZQUNELE9BQU9kLEVBQUVlLElBQUksS0FBS2QsRUFBRWMsSUFBSSxJQUFJZixFQUFFZ0IsT0FBTyxLQUFLZixFQUFFZSxPQUFPO1FBQ3ZELEtBQUs7WUFDRCxtQ0FBbUM7WUFDbkMsSUFBSWhCLE1BQU1BLEdBQ04sT0FBT0MsTUFBTUE7UUFDckIsMkNBQTJDO1FBQzNDLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTyxDQUFDRCxNQUFNLENBQUNDO1FBQ25CLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBT0QsS0FBSyxHQUFLLE9BQUZDO1FBQ25CLEtBQUs7UUFDTCxLQUFLO1lBQWdCO2dCQUNqQixJQUFJRCxFQUFFaUIsSUFBSSxLQUFLaEIsRUFBRWdCLElBQUksRUFDakIsT0FBTztnQkFDWCxJQUFJVCxtQkFBbUJSLEdBQUdDLElBQ3RCLE9BQU87Z0JBQ1gsTUFBTWlCLFlBQVlsQixFQUFFbUIsT0FBTztnQkFDM0IsTUFBTUMsUUFBUWhCLFNBQVM7Z0JBQ3ZCLE1BQU8sS0FBTTtvQkFDVCxNQUFNaUIsT0FBT0gsVUFBVUksSUFBSTtvQkFDM0IsSUFBSUQsS0FBS0UsSUFBSSxFQUNUO29CQUNKLHdDQUF3QztvQkFDeEMsTUFBTSxDQUFDQyxNQUFNQyxPQUFPLEdBQUdKLEtBQUtLLEtBQUs7b0JBQ2pDLG1EQUFtRDtvQkFDbkQsSUFBSSxDQUFDekIsRUFBRTBCLEdBQUcsQ0FBQ0gsT0FBTzt3QkFDZCxPQUFPO29CQUNYO29CQUNBLG1FQUFtRTtvQkFDbkUsdUJBQXVCO29CQUN2QixJQUFJSixTQUFTLENBQUNsQixNQUFNdUIsUUFBUXhCLEVBQUUyQixHQUFHLENBQUNKLFFBQVE7d0JBQ3RDLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBQ0EsT0FBTztZQUNYO1FBQ0EsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELHFFQUFxRTtZQUNyRSxzQkFBc0I7WUFDdEJ4QixJQUFJLElBQUk2QixXQUFXN0I7WUFDbkJDLElBQUksSUFBSTRCLFdBQVc1QjtRQUN2QixrQkFBa0I7UUFDbEIsS0FBSztZQUFxQjtnQkFDdEIsSUFBSTZCLE1BQU05QixFQUFFK0IsVUFBVTtnQkFDdEIsSUFBSUQsUUFBUTdCLEVBQUU4QixVQUFVLEVBQUU7b0JBQ3RCLE1BQU9ELFNBQVM5QixDQUFDLENBQUM4QixJQUFJLEtBQUs3QixDQUFDLENBQUM2QixJQUFJLENBQUU7b0JBQy9CLCtDQUErQztvQkFDbkQ7Z0JBQ0o7Z0JBQ0EsT0FBT0EsUUFBUSxDQUFDO1lBQ3BCO1FBQ0EsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUFxQjtnQkFDdEIsTUFBTUUsUUFBUXJDLFFBQVFVLElBQUksQ0FBQ0w7Z0JBQzNCLElBQUlnQyxVQUFVckMsUUFBUVUsSUFBSSxDQUFDSixJQUFJO29CQUMzQixPQUFPO2dCQUNYO2dCQUNBLG9FQUFvRTtnQkFDcEUsaUVBQWlFO2dCQUNqRSxvRUFBb0U7Z0JBQ3BFLGlFQUFpRTtnQkFDakUsb0VBQW9FO2dCQUNwRSxrRUFBa0U7Z0JBQ2xFLDhEQUE4RDtnQkFDOUQsa0VBQWtFO2dCQUNsRSxnRUFBZ0U7Z0JBQ2hFLGtFQUFrRTtnQkFDbEUsOERBQThEO2dCQUM5RCw0REFBNEQ7Z0JBQzVELCtEQUErRDtnQkFDL0QsZ0VBQWdFO2dCQUNoRSwrREFBK0Q7Z0JBQy9ELHlEQUF5RDtnQkFDekQsb0VBQW9FO2dCQUNwRSxrRUFBa0U7Z0JBQ2xFLDZEQUE2RDtnQkFDN0QsNERBQTREO2dCQUM1RCxvRUFBb0U7Z0JBQ3BFLGlFQUFpRTtnQkFDakUsbUVBQW1FO2dCQUNuRSxPQUFPLENBQUNnQyxTQUFTRCxPQUFPRTtZQUM1QjtJQUNKO0lBQ0Esc0NBQXNDO0lBQ3RDLE9BQU87QUFDWDtBQUNBLFNBQVN4QixZQUFZeUIsR0FBRztJQUNwQixzRUFBc0U7SUFDdEUsK0NBQStDO0lBQy9DLE9BQU8xQyxPQUFPMkMsSUFBSSxDQUFDRCxLQUFLRSxNQUFNLENBQUNDLGNBQWNIO0FBQ2pEO0FBQ0EsU0FBU0csYUFBYXhCLEdBQUc7SUFDckIsT0FBTyxJQUFJLENBQUNBLElBQUksS0FBSyxLQUFLO0FBQzlCO0FBQ0EsTUFBTW9CLG1CQUFtQjtBQUN6QixTQUFTRCxTQUFTTSxJQUFJLEVBQUVDLE1BQU07SUFDMUIsTUFBTUMsWUFBWUYsS0FBS2hDLE1BQU0sR0FBR2lDLE9BQU9qQyxNQUFNO0lBQzdDLE9BQU9rQyxhQUFhLEtBQ2hCRixLQUFLRyxPQUFPLENBQUNGLFFBQVFDLGVBQWVBO0FBQzVDO0FBQ0EsU0FBU2pDLG1CQUFtQlIsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsMEVBQTBFO0lBQzFFLDhFQUE4RTtJQUM5RSwrQ0FBK0M7SUFDL0MsSUFBSTBDLE9BQU85QyxvQkFBb0IrQixHQUFHLENBQUM1QjtJQUNuQyxJQUFJMkMsTUFBTTtRQUNOLDJFQUEyRTtRQUMzRSwwQ0FBMEM7UUFDMUMsSUFBSUEsS0FBS2hCLEdBQUcsQ0FBQzFCLElBQ1QsT0FBTztJQUNmLE9BQ0s7UUFDREosb0JBQW9CK0MsR0FBRyxDQUFDNUMsR0FBRzJDLE9BQU8sSUFBSUU7SUFDMUM7SUFDQUYsS0FBS0csR0FBRyxDQUFDN0M7SUFDVCxPQUFPO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B3cnkvZXF1YWxpdHkvbGliL2luZGV4LmpzPzI4MWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyB0b1N0cmluZywgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgcHJldmlvdXNDb21wYXJpc29ucyA9IG5ldyBNYXAoKTtcbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrIG9uIHR3byBKYXZhU2NyaXB0IHZhbHVlcywgdG9sZXJhdGluZyBjeWNsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNoZWNrKGEsIGIpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcHJldmlvdXNDb21wYXJpc29ucy5jbGVhcigpO1xuICAgIH1cbn1cbi8vIEFsbG93IGRlZmF1bHQgaW1wb3J0cyBhcyB3ZWxsLlxuZXhwb3J0IGRlZmF1bHQgZXF1YWw7XG5mdW5jdGlvbiBjaGVjayhhLCBiKSB7XG4gICAgLy8gSWYgdGhlIHR3byB2YWx1ZXMgYXJlIHN0cmljdGx5IGVxdWFsLCBvdXIgam9iIGlzIGVhc3kuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgcmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW50aW1lIHR5cGUgb2ZcbiAgICAvLyB0aGUgZ2l2ZW4gdmFsdWUgdGhhdCBpcyBjb25zaWRlcmFibHkgbW9yZSBwcmVjaXNlIHRoYW4gdHlwZW9mLlxuICAgIGNvbnN0IGFUYWcgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGNvbnN0IGJUYWcgPSB0b1N0cmluZy5jYWxsKGIpO1xuICAgIC8vIElmIHRoZSBydW50aW1lIHR5cGVzIG9mIGEgYW5kIGIgYXJlIGRpZmZlcmVudCwgdGhleSBjb3VsZCBtYXliZSBiZSBlcXVhbFxuICAgIC8vIHVuZGVyIHNvbWUgaW50ZXJwcmV0YXRpb24gb2YgZXF1YWxpdHksIGJ1dCBmb3Igc2ltcGxpY2l0eSBhbmQgcGVyZm9ybWFuY2VcbiAgICAvLyB3ZSBqdXN0IHJldHVybiBmYWxzZSBpbnN0ZWFkLlxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChhVGFnKSB7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgICAgICAgIC8vIEFycmF5cyBhcmUgYSBsb3QgbGlrZSBvdGhlciBvYmplY3RzLCBidXQgd2UgY2FuIGNoZWFwbHkgY29tcGFyZSB0aGVpclxuICAgICAgICAgICAgLy8gbGVuZ3RocyBhcyBhIHNob3J0LWN1dCBiZWZvcmUgY29tcGFyaW5nIHRoZWlyIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBvYmplY3QgY2FzZS4uLlxuICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNseUNvbXBhcmVkKGEsIGIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYUtleXMgPSBkZWZpbmVkS2V5cyhhKTtcbiAgICAgICAgICAgIGNvbnN0IGJLZXlzID0gZGVmaW5lZEtleXMoYik7XG4gICAgICAgICAgICAvLyBJZiBgYWAgYW5kIGBiYCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnVtZXJhYmxlIGtleXMsIHRoZXlcbiAgICAgICAgICAgIC8vIG11c3QgYmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgY29uc3Qga2V5Q291bnQgPSBhS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoa2V5Q291bnQgIT09IGJLZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBOb3cgbWFrZSBzdXJlIHRoZXkgaGF2ZSB0aGUgc2FtZSBrZXlzLlxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlDb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGFLZXlzW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2hlY2sgZGVlcCBlcXVhbGl0eSBvZiBhbGwgY2hpbGQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2V5Q291bnQ7ICsraykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFLZXlzW2tdO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2soYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6XG4gICAgICAgICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgICAgICAvLyBIYW5kbGUgTmFOLCB3aGljaCBpcyAhPT0gaXRzZWxmLlxuICAgICAgICAgICAgaWYgKGEgIT09IGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgIT09IGI7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBzaGFyZWQgK2EgPT09ICtiIGNhc2UuLi5cbiAgICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIHJldHVybiBhID09IGAke2J9YDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBNYXBdJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzoge1xuICAgICAgICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c2x5Q29tcGFyZWQoYSwgYikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb25zdCBhSXRlcmF0b3IgPSBhLmVudHJpZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzTWFwID0gYVRhZyA9PT0gJ1tvYmplY3QgTWFwXSc7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgaW5zdGFuY2VvZiBTZXQsIGFWYWx1ZSA9PT0gYUtleS5cbiAgICAgICAgICAgICAgICBjb25zdCBbYUtleSwgYVZhbHVlXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gU28gdGhpcyB3b3JrcyB0aGUgc2FtZSB3YXkgZm9yIGJvdGggU2V0IGFuZCBNYXAuXG4gICAgICAgICAgICAgICAgaWYgKCFiLmhhcyhhS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGNhcmUgYWJvdXQgZGVlcCBlcXVhbGl0eSBvZiB2YWx1ZXMgb25seSB3aGVuIGRlYWxpbmdcbiAgICAgICAgICAgICAgICAvLyB3aXRoIE1hcCBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgICAgIGlmIChpc01hcCAmJiAhY2hlY2soYVZhbHVlLCBiLmdldChhS2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDE2QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OEFycmF5XSc6IC8vIEJ1ZmZlciwgaW4gTm9kZS5qcy5cbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50MzJBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEludDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQ4QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQxNkFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXlCdWZmZXJdJzpcbiAgICAgICAgICAgIC8vIERhdGFWaWV3IGRvZXNuJ3QgbmVlZCB0aGVzZSBjb252ZXJzaW9ucywgYnV0IHRoZSBlcXVhbGl0eSBjaGVjayBpc1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBzYW1lLlxuICAgICAgICAgICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgICAgICAgICAgYiA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guLi5cbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRhVmlld10nOiB7XG4gICAgICAgICAgICBsZXQgbGVuID0gYS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tICYmIGFbbGVuXSA9PT0gYltsZW5dKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgbG9vcGluZyBhcyBsb25nIGFzIHRoZSBieXRlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzoge1xuICAgICAgICAgICAgY29uc3QgYUNvZGUgPSBmblRvU3RyLmNhbGwoYSk7XG4gICAgICAgICAgICBpZiAoYUNvZGUgIT09IGZuVG9TdHIuY2FsbChiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGNvbnNpZGVyIG5vbi1uYXRpdmUgZnVuY3Rpb25zIGVxdWFsIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBjb2RlXG4gICAgICAgICAgICAvLyAobmF0aXZlIGZ1bmN0aW9ucyByZXF1aXJlID09PSBiZWNhdXNlIHRoZWlyIGNvZGUgaXMgY2Vuc29yZWQpLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgbm90IGVudGlyZWx5IHNvdW5kLCBzaW5jZSAhPT0gZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBjb2RlIGNhbiBiZWhhdmUgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uXG4gICAgICAgICAgICAvLyB0aGVpciBjbG9zdXJlIHNjb3BlLiBIb3dldmVyLCBhbnkgZnVuY3Rpb24gY2FuIGJlaGF2ZSBkaWZmZXJlbnRseVxuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgaXRzIGlucHV0IGFyZ3VtZW50cyAoaW5jbHVkaW5nIHRoaXMpXG4gICAgICAgICAgICAvLyBhbmQgaXRzIGNhbGxpbmcgY29udGV4dCAoaW5jbHVkaW5nIGl0cyBjbG9zdXJlIHNjb3BlKSwgZXZlblxuICAgICAgICAgICAgLy8gdGhvdWdoIHRoZSBmdW5jdGlvbiBvYmplY3QgaXMgPT09IHRvIGl0c2VsZjsgYW5kIGl0IGlzIGVudGlyZWx5XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBmb3IgZnVuY3Rpb25zIHRoYXQgYXJlIG5vdCA9PT0gdG8gYmVoYXZlIGV4YWN0bHkgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIHVuZGVyIGFsbCBjb25jZWl2YWJsZSBjaXJjdW1zdGFuY2VzLiBCZWNhdXNlIG5vbmUgb2YgdGhlc2VcbiAgICAgICAgICAgIC8vIGZhY3RvcnMgYXJlIHN0YXRpY2FsbHkgZGVjaWRhYmxlIGluIEphdmFTY3JpcHQsIEpTIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBlcXVhbGl0eSBpcyBub3Qgd2VsbC1kZWZpbmVkLiBUaGlzIGFtYmlndWl0eSBhbGxvd3MgdXMgdG9cbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBiZXN0IHBvc3NpYmxlIGhldXJpc3RpYyBhbW9uZyB2YXJpb3VzIGltcGVyZmVjdFxuICAgICAgICAgICAgLy8gb3B0aW9ucywgYW5kIGVxdWF0aW5nIG5vbi1uYXRpdmUgZnVuY3Rpb25zIHRoYXQgaGF2ZSB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gY29kZSBoYXMgZW5vcm1vdXMgcHJhY3RpY2FsIGJlbmVmaXRzLCBzdWNoIGFzIHdoZW4gY29tcGFyaW5nXG4gICAgICAgICAgICAvLyBmdW5jdGlvbnMgdGhhdCBhcmUgcmVwZWF0ZWRseSBwYXNzZWQgYXMgZnJlc2ggZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zIHdpdGhpbiBvYmplY3RzIHRoYXQgYXJlIG90aGVyd2lzZSBkZWVwbHkgZXF1YWwuIFNpbmNlXG4gICAgICAgICAgICAvLyBhbnkgZnVuY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBzYW1lIHN5bnRhY3RpYyBleHByZXNzaW9uIChpbiB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgY29kZSBsb2NhdGlvbikgd2lsbCBhbHdheXMgc3RyaW5naWZ5IHRvIHRoZSBzYW1lIGNvZGVcbiAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byBmblRvU3RyLmNhbGwsIHdlIGNhbiByZWFzb25hYmx5IGV4cGVjdCB0aGVzZVxuICAgICAgICAgICAgLy8gcmVwZWF0ZWRseSBwYXNzZWQgZnVuY3Rpb24gZXhwcmVzc2lvbnMgdG8gaGF2ZSB0aGUgc2FtZSBjb2RlLCBhbmRcbiAgICAgICAgICAgIC8vIHRodXMgYmVoYXZlIFwidGhlIHNhbWVcIiAod2l0aCBhbGwgdGhlIGNhdmVhdHMgbWVudGlvbmVkIGFib3ZlKSxcbiAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBydW50aW1lIGZ1bmN0aW9uIG9iamVjdHMgYXJlICE9PSB0byBvbmUgYW5vdGhlci5cbiAgICAgICAgICAgIHJldHVybiAhZW5kc1dpdGgoYUNvZGUsIG5hdGl2ZUNvZGVTdWZmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSB0aGUgdmFsdWVzIGFyZSBub3QgZXF1YWwuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lZEtleXMob2JqKSB7XG4gICAgLy8gUmVtZW1iZXIgdGhhdCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgd2lsbCBiZVxuICAgIC8vIHVzZWQgYXMgYHRoaXNgIHdpdGhpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKGlzRGVmaW5lZEtleSwgb2JqKTtcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZEtleShrZXkpIHtcbiAgICByZXR1cm4gdGhpc1trZXldICE9PSB2b2lkIDA7XG59XG5jb25zdCBuYXRpdmVDb2RlU3VmZml4ID0gXCJ7IFtuYXRpdmUgY29kZV0gfVwiO1xuZnVuY3Rpb24gZW5kc1dpdGgoZnVsbCwgc3VmZml4KSB7XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZnVsbC5sZW5ndGggLSBzdWZmaXgubGVuZ3RoO1xuICAgIHJldHVybiBmcm9tSW5kZXggPj0gMCAmJlxuICAgICAgICBmdWxsLmluZGV4T2Yoc3VmZml4LCBmcm9tSW5kZXgpID09PSBmcm9tSW5kZXg7XG59XG5mdW5jdGlvbiBwcmV2aW91c2x5Q29tcGFyZWQoYSwgYikge1xuICAgIC8vIFRob3VnaCBjeWNsaWMgcmVmZXJlbmNlcyBjYW4gbWFrZSBhbiBvYmplY3QgZ3JhcGggYXBwZWFyIGluZmluaXRlIGZyb20gdGhlXG4gICAgLy8gcGVyc3BlY3RpdmUgb2YgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwsIHRoZSBncmFwaCBzdGlsbCBjb250YWlucyBhIGZpbml0ZVxuICAgIC8vIG51bWJlciBvZiBkaXN0aW5jdCBvYmplY3QgcmVmZXJlbmNlcy4gV2UgdXNlIHRoZSBwcmV2aW91c0NvbXBhcmlzb25zIGNhY2hlXG4gICAgLy8gdG8gYXZvaWQgY29tcGFyaW5nIHRoZSBzYW1lIHBhaXIgb2Ygb2JqZWN0IHJlZmVyZW5jZXMgbW9yZSB0aGFuIG9uY2UsIHdoaWNoXG4gICAgLy8gZ3VhcmFudGVlcyB0ZXJtaW5hdGlvbiAoZXZlbiBpZiB3ZSBlbmQgdXAgY29tcGFyaW5nIGV2ZXJ5IG9iamVjdCBpbiBvbmVcbiAgICAvLyBncmFwaCB0byBldmVyeSBvYmplY3QgaW4gdGhlIG90aGVyIGdyYXBoLCB3aGljaCBpcyBleHRyZW1lbHkgdW5saWtlbHkpLFxuICAgIC8vIHdoaWxlIHN0aWxsIGFsbG93aW5nIHdlaXJkIGlzb21vcnBoaWMgc3RydWN0dXJlcyAobGlrZSByaW5ncyB3aXRoIGRpZmZlcmVudFxuICAgIC8vIGxlbmd0aHMpIGEgY2hhbmNlIHRvIHBhc3MgdGhlIGVxdWFsaXR5IHRlc3QuXG4gICAgbGV0IGJTZXQgPSBwcmV2aW91c0NvbXBhcmlzb25zLmdldChhKTtcbiAgICBpZiAoYlNldCkge1xuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBoZXJlIGJlY2F1c2Ugd2UgY2FuIGJlIHN1cmUgZmFsc2Ugd2lsbCBiZSByZXR1cm5lZCBzb21ld2hlcmVcbiAgICAgICAgLy8gZWxzZSBpZiB0aGUgb2JqZWN0cyBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIGlmIChiU2V0LmhhcyhiKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJldmlvdXNDb21wYXJpc29ucy5zZXQoYSwgYlNldCA9IG5ldyBTZXQpO1xuICAgIH1cbiAgICBiU2V0LmFkZChiKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsidG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsImZuVG9TdHIiLCJGdW5jdGlvbiIsInByZXZpb3VzQ29tcGFyaXNvbnMiLCJNYXAiLCJlcXVhbCIsImEiLCJiIiwiY2hlY2siLCJjbGVhciIsImFUYWciLCJjYWxsIiwiYlRhZyIsImxlbmd0aCIsInByZXZpb3VzbHlDb21wYXJlZCIsImFLZXlzIiwiZGVmaW5lZEtleXMiLCJiS2V5cyIsImtleUNvdW50IiwiayIsImtleSIsIm5hbWUiLCJtZXNzYWdlIiwic2l6ZSIsImFJdGVyYXRvciIsImVudHJpZXMiLCJpc01hcCIsImluZm8iLCJuZXh0IiwiZG9uZSIsImFLZXkiLCJhVmFsdWUiLCJ2YWx1ZSIsImhhcyIsImdldCIsIlVpbnQ4QXJyYXkiLCJsZW4iLCJieXRlTGVuZ3RoIiwiYUNvZGUiLCJlbmRzV2l0aCIsIm5hdGl2ZUNvZGVTdWZmaXgiLCJvYmoiLCJrZXlzIiwiZmlsdGVyIiwiaXNEZWZpbmVkS2V5IiwiZnVsbCIsInN1ZmZpeCIsImZyb21JbmRleCIsImluZGV4T2YiLCJiU2V0Iiwic2V0IiwiU2V0IiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/trie/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@wry/trie/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Trie: function() { return /* binding */ Trie; }\n/* harmony export */ });\n// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = ()=>Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nclass Trie {\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, (key)=>node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for(let i = 0, len = array.length; node && i < len; ++i){\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        } else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap : void 0) : this.strong || (create ? this.strong = new Map : void 0);\n    }\n    constructor(weakness = true, makeData = defaultMakeData){\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n}\nfunction isObjRef(value) {\n    switch(typeof value){\n        case \"object\":\n            if (value === null) break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L3RyaWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBQ3BFLG9CQUFvQjtBQUNwQiw0RUFBNEU7QUFDNUUseUJBQXlCO0FBQ3pCLE1BQU1BLGtCQUFrQixJQUFNQyxPQUFPQyxNQUFNLENBQUM7QUFDNUMsNkRBQTZEO0FBQzdELE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsTUFBTUMsU0FBUztBQUMxQyxNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHTixPQUFPSyxTQUFTO0FBQ3BDLE1BQU1FO0lBS1RDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDQztJQUM1QjtJQUNBRCxZQUFZRSxLQUFLLEVBQUU7UUFDZixJQUFJQyxPQUFPLElBQUk7UUFDZlYsUUFBUVcsSUFBSSxDQUFDRixPQUFPRyxDQUFBQSxNQUFPRixPQUFPQSxLQUFLRyxZQUFZLENBQUNEO1FBQ3BELE9BQU9SLGVBQWVPLElBQUksQ0FBQ0QsTUFBTSxVQUMzQkEsS0FBS0ksSUFBSSxHQUNUSixLQUFLSSxJQUFJLEdBQUcsSUFBSSxDQUFDQyxRQUFRLENBQUNkLE1BQU1VLElBQUksQ0FBQ0Y7SUFDL0M7SUFDQU8sT0FBTztRQUNILE9BQU8sSUFBSSxDQUFDQyxTQUFTLENBQUNUO0lBQzFCO0lBQ0FTLFVBQVVSLEtBQUssRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSTtRQUNmLElBQUssSUFBSVEsSUFBSSxHQUFHQyxNQUFNVixNQUFNVyxNQUFNLEVBQUVWLFFBQVFRLElBQUlDLEtBQUssRUFBRUQsRUFBRztZQUN0RCxNQUFNRyxNQUFNWCxLQUFLWSxNQUFNLENBQUNiLEtBQUssQ0FBQ1MsRUFBRSxFQUFFO1lBQ2xDUixPQUFPVyxPQUFPQSxJQUFJRSxHQUFHLENBQUNkLEtBQUssQ0FBQ1MsRUFBRTtRQUNsQztRQUNBLE9BQU9SLFFBQVFBLEtBQUtJLElBQUk7SUFDNUI7SUFDQVUsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDQyxXQUFXLENBQUNqQjtJQUM1QjtJQUNBaUIsWUFBWWhCLEtBQUssRUFBRTtRQUNmLElBQUlLO1FBQ0osSUFBSUwsTUFBTVcsTUFBTSxFQUFFO1lBQ2QsTUFBTU0sT0FBT2pCLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE1BQU1ZLE1BQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNJLE1BQU07WUFDOUIsTUFBTUMsUUFBUU4sT0FBT0EsSUFBSUUsR0FBRyxDQUFDRztZQUM3QixJQUFJQyxPQUFPO2dCQUNQYixPQUFPYSxNQUFNRixXQUFXLENBQUN4QixNQUFNVSxJQUFJLENBQUNGLE9BQU87Z0JBQzNDLElBQUksQ0FBQ2tCLE1BQU1iLElBQUksSUFBSSxDQUFDYSxNQUFNQyxJQUFJLElBQUksQ0FBRUQsQ0FBQUEsTUFBTUUsTUFBTSxJQUFJRixNQUFNRSxNQUFNLENBQUNDLElBQUksR0FBRztvQkFDcEVULElBQUlVLE1BQU0sQ0FBQ0w7Z0JBQ2Y7WUFDSjtRQUNKLE9BQ0s7WUFDRFosT0FBTyxJQUFJLENBQUNBLElBQUk7WUFDaEIsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDcEI7UUFDQSxPQUFPQTtJQUNYO0lBQ0FELGFBQWFELEdBQUcsRUFBRTtRQUNkLE1BQU1TLE1BQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNWLEtBQUs7UUFDN0IsSUFBSWUsUUFBUU4sSUFBSUUsR0FBRyxDQUFDWDtRQUNwQixJQUFJLENBQUNlLE9BQ0ROLElBQUlXLEdBQUcsQ0FBQ3BCLEtBQUtlLFFBQVEsSUFBSXRCLEtBQUssSUFBSSxDQUFDNEIsUUFBUSxFQUFFLElBQUksQ0FBQ2xCLFFBQVE7UUFDOUQsT0FBT1k7SUFDWDtJQUNBTCxPQUFPVixHQUFHLEVBQUViLE1BQU0sRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ2tDLFFBQVEsSUFBSUMsU0FBU3RCLE9BQzNCLElBQUksQ0FBQ2dCLElBQUksSUFBSzdCLENBQUFBLFNBQVMsSUFBSSxDQUFDNkIsSUFBSSxHQUFHLElBQUlPLFVBQVUsS0FBSyxLQUN0RCxJQUFJLENBQUNOLE1BQU0sSUFBSzlCLENBQUFBLFNBQVMsSUFBSSxDQUFDOEIsTUFBTSxHQUFHLElBQUlPLE1BQU0sS0FBSztJQUNoRTtJQTFEQUMsWUFBWUosV0FBVyxJQUFJLEVBQUVsQixXQUFXbEIsZUFBZSxDQUFFO1FBQ3JELElBQUksQ0FBQ29DLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDbEIsUUFBUSxHQUFHQTtJQUNwQjtBQXdESjtBQUNBLFNBQVNtQixTQUFTSSxLQUFLO0lBQ25CLE9BQVEsT0FBT0E7UUFDWCxLQUFLO1lBQ0QsSUFBSUEsVUFBVSxNQUNWO1FBQ1IsaUNBQWlDO1FBQ2pDLEtBQUs7WUFDRCxPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B3cnkvdHJpZS9saWIvaW5kZXguanM/ZDk1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIFt0cmllXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmllKSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhvbGRzXG4vLyBvYmplY3Qga2V5cyB3ZWFrbHksIHlldCBjYW4gYWxzbyBob2xkIG5vbi1vYmplY3Qga2V5cywgdW5saWtlIHRoZVxuLy8gbmF0aXZlIGBXZWFrTWFwYC5cbi8vIElmIG5vIG1ha2VEYXRhIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLCB0aGUgbG9va2VkLXVwIGRhdGEgd2lsbCBiZSBhbiBlbXB0eSxcbi8vIG51bGwtcHJvdG90eXBlIE9iamVjdC5cbmNvbnN0IGRlZmF1bHRNYWtlRGF0YSA9ICgpID0+IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBVc2VmdWwgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzIG9iamVjdHMgYXMgd2VsbCBhcyBhcnJheXMuXG5jb25zdCB7IGZvckVhY2gsIHNsaWNlIH0gPSBBcnJheS5wcm90b3R5cGU7XG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IGNsYXNzIFRyaWUge1xuICAgIGNvbnN0cnVjdG9yKHdlYWtuZXNzID0gdHJ1ZSwgbWFrZURhdGEgPSBkZWZhdWx0TWFrZURhdGEpIHtcbiAgICAgICAgdGhpcy53ZWFrbmVzcyA9IHdlYWtuZXNzO1xuICAgICAgICB0aGlzLm1ha2VEYXRhID0gbWFrZURhdGE7XG4gICAgfVxuICAgIGxvb2t1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwQXJyYXkoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgbG9va3VwQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoLmNhbGwoYXJyYXksIGtleSA9PiBub2RlID0gbm9kZS5nZXRDaGlsZFRyaWUoa2V5KSk7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIFwiZGF0YVwiKVxuICAgICAgICAgICAgPyBub2RlLmRhdGFcbiAgICAgICAgICAgIDogbm9kZS5kYXRhID0gdGhpcy5tYWtlRGF0YShzbGljZS5jYWxsKGFycmF5KSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZWtBcnJheShhcmd1bWVudHMpO1xuICAgIH1cbiAgICBwZWVrQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBub2RlICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gbm9kZS5tYXBGb3IoYXJyYXlbaV0sIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUgPSBtYXAgJiYgbWFwLmdldChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5kYXRhO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFycmF5KGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJlbW92ZUFycmF5KGFycmF5KSB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYXJyYXlbMF07XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLm1hcEZvcihoZWFkLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG1hcCAmJiBtYXAuZ2V0KGhlYWQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGNoaWxkLnJlbW92ZUFycmF5KHNsaWNlLmNhbGwoYXJyYXksIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRhdGEgJiYgIWNoaWxkLndlYWsgJiYgIShjaGlsZC5zdHJvbmcgJiYgY2hpbGQuc3Ryb25nLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5kZWxldGUoaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGdldENoaWxkVHJpZShrZXkpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5tYXBGb3Ioa2V5LCB0cnVlKTtcbiAgICAgICAgbGV0IGNoaWxkID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgbWFwLnNldChrZXksIGNoaWxkID0gbmV3IFRyaWUodGhpcy53ZWFrbmVzcywgdGhpcy5tYWtlRGF0YSkpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIG1hcEZvcihrZXksIGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWFrbmVzcyAmJiBpc09ialJlZihrZXkpXG4gICAgICAgICAgICA/IHRoaXMud2VhayB8fCAoY3JlYXRlID8gdGhpcy53ZWFrID0gbmV3IFdlYWtNYXAgOiB2b2lkIDApXG4gICAgICAgICAgICA6IHRoaXMuc3Ryb25nIHx8IChjcmVhdGUgPyB0aGlzLnN0cm9uZyA9IG5ldyBNYXAgOiB2b2lkIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT2JqUmVmKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gcmV0dXJuIHRydWUuLi5cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHRNYWtlRGF0YSIsIk9iamVjdCIsImNyZWF0ZSIsImZvckVhY2giLCJzbGljZSIsIkFycmF5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJUcmllIiwibG9va3VwIiwibG9va3VwQXJyYXkiLCJhcmd1bWVudHMiLCJhcnJheSIsIm5vZGUiLCJjYWxsIiwia2V5IiwiZ2V0Q2hpbGRUcmllIiwiZGF0YSIsIm1ha2VEYXRhIiwicGVlayIsInBlZWtBcnJheSIsImkiLCJsZW4iLCJsZW5ndGgiLCJtYXAiLCJtYXBGb3IiLCJnZXQiLCJyZW1vdmUiLCJyZW1vdmVBcnJheSIsImhlYWQiLCJjaGlsZCIsIndlYWsiLCJzdHJvbmciLCJzaXplIiwiZGVsZXRlIiwic2V0Iiwid2Vha25lc3MiLCJpc09ialJlZiIsIldlYWtNYXAiLCJNYXAiLCJjb25zdHJ1Y3RvciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/jsutils/devAssert.mjs":
/*!****************************************************!*\
  !*** ./node_modules/graphql/jsutils/devAssert.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devAssert: function() { return /* binding */ devAssert; }\n/* harmony export */ });\nfunction devAssert(condition, message) {\n    const booleanCondition = Boolean(condition);\n    if (!booleanCondition) {\n        throw new Error(message);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0EsVUFBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQzFDLE1BQU1DLG1CQUFtQkMsUUFBUUg7SUFFakMsSUFBSSxDQUFDRSxrQkFBa0I7UUFDckIsTUFBTSxJQUFJRSxNQUFNSDtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qcz82NDUwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBkZXZBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGJvb2xlYW5Db25kaXRpb24gPSBCb29sZWFuKGNvbmRpdGlvbik7XG5cbiAgaWYgKCFib29sZWFuQ29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiZGV2QXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsImJvb2xlYW5Db25kaXRpb24iLCJCb29sZWFuIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/jsutils/devAssert.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/jsutils/inspect.mjs":
/*!**************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inspect: function() { return /* binding */ inspect; }\n/* harmony export */ });\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */ function inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch(typeof value){\n        case \"string\":\n            return JSON.stringify(value);\n        case \"function\":\n            return value.name ? \"[function \".concat(value.name, \"]\") : \"[function]\";\n        case \"object\":\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (value === null) {\n        return \"null\";\n    }\n    if (previouslySeenValues.includes(value)) {\n        return \"[Circular]\";\n    }\n    const seenValues = [\n        ...previouslySeenValues,\n        value\n    ];\n    if (isJSONable(value)) {\n        const jsonValue = value.toJSON(); // check for infinite recursion\n        if (jsonValue !== value) {\n            return typeof jsonValue === \"string\" ? jsonValue : formatValue(jsonValue, seenValues);\n        }\n    } else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n    return typeof value.toJSON === \"function\";\n}\nfunction formatObject(object, seenValues) {\n    const entries = Object.entries(object);\n    if (entries.length === 0) {\n        return \"{}\";\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return \"[\" + getObjectTag(object) + \"]\";\n    }\n    const properties = entries.map((param)=>{\n        let [key, value] = param;\n        return key + \": \" + formatValue(value, seenValues);\n    });\n    return \"{ \" + properties.join(\", \") + \" }\";\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return \"[]\";\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return \"[Array]\";\n    }\n    const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    const remaining = array.length - len;\n    const items = [];\n    for(let i = 0; i < len; ++i){\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push(\"... 1 more item\");\n    } else if (remaining > 1) {\n        items.push(\"... \".concat(remaining, \" more items\"));\n    }\n    return \"[\" + items.join(\", \") + \"]\";\n}\nfunction getObjectTag(object) {\n    const tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n    if (tag === \"Object\" && typeof object.constructor === \"function\") {\n        const name = object.constructor.name;\n        if (typeof name === \"string\" && name !== \"\") {\n            return name;\n        }\n    }\n    return tag;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaW5zcGVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLG1CQUFtQjtBQUN6QixNQUFNQyxzQkFBc0I7QUFDNUI7O0NBRUMsR0FFTSxTQUFTQyxRQUFRQyxLQUFLO0lBQzNCLE9BQU9DLFlBQVlELE9BQU8sRUFBRTtBQUM5QjtBQUVBLFNBQVNDLFlBQVlELEtBQUssRUFBRUUsVUFBVTtJQUNwQyxPQUFRLE9BQU9GO1FBQ2IsS0FBSztZQUNILE9BQU9HLEtBQUtDLFNBQVMsQ0FBQ0o7UUFFeEIsS0FBSztZQUNILE9BQU9BLE1BQU1LLElBQUksR0FBRyxhQUF3QixPQUFYTCxNQUFNSyxJQUFJLEVBQUMsT0FBSztRQUVuRCxLQUFLO1lBQ0gsT0FBT0Msa0JBQWtCTixPQUFPRTtRQUVsQztZQUNFLE9BQU9LLE9BQU9QO0lBQ2xCO0FBQ0Y7QUFFQSxTQUFTTSxrQkFBa0JOLEtBQUssRUFBRVEsb0JBQW9CO0lBQ3BELElBQUlSLFVBQVUsTUFBTTtRQUNsQixPQUFPO0lBQ1Q7SUFFQSxJQUFJUSxxQkFBcUJDLFFBQVEsQ0FBQ1QsUUFBUTtRQUN4QyxPQUFPO0lBQ1Q7SUFFQSxNQUFNRSxhQUFhO1dBQUlNO1FBQXNCUjtLQUFNO0lBRW5ELElBQUlVLFdBQVdWLFFBQVE7UUFDckIsTUFBTVcsWUFBWVgsTUFBTVksTUFBTSxJQUFJLCtCQUErQjtRQUVqRSxJQUFJRCxjQUFjWCxPQUFPO1lBQ3ZCLE9BQU8sT0FBT1csY0FBYyxXQUN4QkEsWUFDQVYsWUFBWVUsV0FBV1Q7UUFDN0I7SUFDRixPQUFPLElBQUlXLE1BQU1DLE9BQU8sQ0FBQ2QsUUFBUTtRQUMvQixPQUFPZSxZQUFZZixPQUFPRTtJQUM1QjtJQUVBLE9BQU9jLGFBQWFoQixPQUFPRTtBQUM3QjtBQUVBLFNBQVNRLFdBQVdWLEtBQUs7SUFDdkIsT0FBTyxPQUFPQSxNQUFNWSxNQUFNLEtBQUs7QUFDakM7QUFFQSxTQUFTSSxhQUFhQyxNQUFNLEVBQUVmLFVBQVU7SUFDdEMsTUFBTWdCLFVBQVVDLE9BQU9ELE9BQU8sQ0FBQ0Q7SUFFL0IsSUFBSUMsUUFBUUUsTUFBTSxLQUFLLEdBQUc7UUFDeEIsT0FBTztJQUNUO0lBRUEsSUFBSWxCLFdBQVdrQixNQUFNLEdBQUd0QixxQkFBcUI7UUFDM0MsT0FBTyxNQUFNdUIsYUFBYUosVUFBVTtJQUN0QztJQUVBLE1BQU1LLGFBQWFKLFFBQVFLLEdBQUcsQ0FDNUI7WUFBQyxDQUFDQyxLQUFLeEIsTUFBTTtlQUFLd0IsTUFBTSxPQUFPdkIsWUFBWUQsT0FBT0U7O0lBRXBELE9BQU8sT0FBT29CLFdBQVdHLElBQUksQ0FBQyxRQUFRO0FBQ3hDO0FBRUEsU0FBU1YsWUFBWVcsS0FBSyxFQUFFeEIsVUFBVTtJQUNwQyxJQUFJd0IsTUFBTU4sTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBTztJQUNUO0lBRUEsSUFBSWxCLFdBQVdrQixNQUFNLEdBQUd0QixxQkFBcUI7UUFDM0MsT0FBTztJQUNUO0lBRUEsTUFBTTZCLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ2hDLGtCQUFrQjZCLE1BQU1OLE1BQU07SUFDbkQsTUFBTVUsWUFBWUosTUFBTU4sTUFBTSxHQUFHTztJQUNqQyxNQUFNSSxRQUFRLEVBQUU7SUFFaEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLEtBQUssRUFBRUssRUFBRztRQUM1QkQsTUFBTUUsSUFBSSxDQUFDaEMsWUFBWXlCLEtBQUssQ0FBQ00sRUFBRSxFQUFFOUI7SUFDbkM7SUFFQSxJQUFJNEIsY0FBYyxHQUFHO1FBQ25CQyxNQUFNRSxJQUFJLENBQUM7SUFDYixPQUFPLElBQUlILFlBQVksR0FBRztRQUN4QkMsTUFBTUUsSUFBSSxDQUFDLE9BQWlCLE9BQVZILFdBQVU7SUFDOUI7SUFFQSxPQUFPLE1BQU1DLE1BQU1OLElBQUksQ0FBQyxRQUFRO0FBQ2xDO0FBRUEsU0FBU0osYUFBYUosTUFBTTtJQUMxQixNQUFNaUIsTUFBTWYsT0FBT2dCLFNBQVMsQ0FBQ0MsUUFBUSxDQUNsQ0MsSUFBSSxDQUFDcEIsUUFDTHFCLE9BQU8sQ0FBQyxjQUFjLElBQ3RCQSxPQUFPLENBQUMsTUFBTTtJQUVqQixJQUFJSixRQUFRLFlBQVksT0FBT2pCLE9BQU9zQixXQUFXLEtBQUssWUFBWTtRQUNoRSxNQUFNbEMsT0FBT1ksT0FBT3NCLFdBQVcsQ0FBQ2xDLElBQUk7UUFFcEMsSUFBSSxPQUFPQSxTQUFTLFlBQVlBLFNBQVMsSUFBSTtZQUMzQyxPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPNkI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3BlY3QubWpzP2ZmY2IiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTUFYX0FSUkFZX0xFTkdUSCA9IDEwO1xuY29uc3QgTUFYX1JFQ1VSU0lWRV9ERVBUSCA9IDI7XG4vKipcbiAqIFVzZWQgdG8gcHJpbnQgdmFsdWVzIGluIGVycm9yIG1lc3NhZ2VzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlKSB7XG4gIHJldHVybiBmb3JtYXRWYWx1ZSh2YWx1ZSwgW10pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcykge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgPyBgW2Z1bmN0aW9uICR7dmFsdWUubmFtZX1dYCA6ICdbZnVuY3Rpb25dJztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBwcmV2aW91c2x5U2VlblZhbHVlcykge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzbHlTZWVuVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gIH1cblxuICBjb25zdCBzZWVuVmFsdWVzID0gWy4uLnByZXZpb3VzbHlTZWVuVmFsdWVzLCB2YWx1ZV07XG5cbiAgaWYgKGlzSlNPTmFibGUodmFsdWUpKSB7XG4gICAgY29uc3QganNvblZhbHVlID0gdmFsdWUudG9KU09OKCk7IC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cblxuICAgIGlmIChqc29uVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGpzb25WYWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBqc29uVmFsdWVcbiAgICAgICAgOiBmb3JtYXRWYWx1ZShqc29uVmFsdWUsIHNlZW5WYWx1ZXMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRBcnJheSh2YWx1ZSwgc2VlblZhbHVlcyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0T2JqZWN0KHZhbHVlLCBzZWVuVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gaXNKU09OYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG9iamVjdCwgc2VlblZhbHVlcykge1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqZWN0KTtcblxuICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3t9JztcbiAgfVxuXG4gIGlmIChzZWVuVmFsdWVzLmxlbmd0aCA+IE1BWF9SRUNVUlNJVkVfREVQVEgpIHtcbiAgICByZXR1cm4gJ1snICsgZ2V0T2JqZWN0VGFnKG9iamVjdCkgKyAnXSc7XG4gIH1cblxuICBjb25zdCBwcm9wZXJ0aWVzID0gZW50cmllcy5tYXAoXG4gICAgKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzogJyArIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKSxcbiAgKTtcbiAgcmV0dXJuICd7ICcgKyBwcm9wZXJ0aWVzLmpvaW4oJywgJykgKyAnIH0nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdbXSc7XG4gIH1cblxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuICdbQXJyYXldJztcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKE1BWF9BUlJBWV9MRU5HVEgsIGFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aCAtIGxlbjtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaXRlbXMucHVzaChmb3JtYXRWYWx1ZShhcnJheVtpXSwgc2VlblZhbHVlcykpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA9PT0gMSkge1xuICAgIGl0ZW1zLnB1c2goJy4uLiAxIG1vcmUgaXRlbScpO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDEpIHtcbiAgICBpdGVtcy5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbXNgKTtcbiAgfVxuXG4gIHJldHVybiAnWycgKyBpdGVtcy5qb2luKCcsICcpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RUYWcob2JqZWN0KSB7XG4gIGNvbnN0IHRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbChvYmplY3QpXG4gICAgLnJlcGxhY2UoL15cXFtvYmplY3QgLywgJycpXG4gICAgLnJlcGxhY2UoL10kLywgJycpO1xuXG4gIGlmICh0YWcgPT09ICdPYmplY3QnICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUgIT09ICcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFnO1xufVxuIl0sIm5hbWVzIjpbIk1BWF9BUlJBWV9MRU5HVEgiLCJNQVhfUkVDVVJTSVZFX0RFUFRIIiwiaW5zcGVjdCIsInZhbHVlIiwiZm9ybWF0VmFsdWUiLCJzZWVuVmFsdWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUiLCJmb3JtYXRPYmplY3RWYWx1ZSIsIlN0cmluZyIsInByZXZpb3VzbHlTZWVuVmFsdWVzIiwiaW5jbHVkZXMiLCJpc0pTT05hYmxlIiwianNvblZhbHVlIiwidG9KU09OIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRPYmplY3QiLCJvYmplY3QiLCJlbnRyaWVzIiwiT2JqZWN0IiwibGVuZ3RoIiwiZ2V0T2JqZWN0VGFnIiwicHJvcGVydGllcyIsIm1hcCIsImtleSIsImpvaW4iLCJhcnJheSIsImxlbiIsIk1hdGgiLCJtaW4iLCJyZW1haW5pbmciLCJpdGVtcyIsImkiLCJwdXNoIiwidGFnIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwicmVwbGFjZSIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/jsutils/inspect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/ast.mjs":
/*!***********************************************!*\
  !*** ./node_modules/graphql/language/ast.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Location: function() { return /* binding */ Location; },\n/* harmony export */   OperationTypeNode: function() { return /* binding */ OperationTypeNode; },\n/* harmony export */   QueryDocumentKeys: function() { return /* binding */ QueryDocumentKeys; },\n/* harmony export */   Token: function() { return /* binding */ Token; },\n/* harmony export */   isNode: function() { return /* binding */ isNode; }\n/* harmony export */ });\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */ class Location {\n    get [Symbol.toStringTag]() {\n        return \"Location\";\n    }\n    toJSON() {\n        return {\n            start: this.start,\n            end: this.end\n        };\n    }\n    /**\n   * The character offset at which this Node begins.\n   */ /**\n   * The character offset at which this Node ends.\n   */ /**\n   * The Token at which this Node begins.\n   */ /**\n   * The Token at which this Node ends.\n   */ /**\n   * The Source document the AST represents.\n   */ constructor(startToken, endToken, source){\n        this.start = startToken.start;\n        this.end = endToken.end;\n        this.startToken = startToken;\n        this.endToken = endToken;\n        this.source = source;\n    }\n}\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */ class Token {\n    get [Symbol.toStringTag]() {\n        return \"Token\";\n    }\n    toJSON() {\n        return {\n            kind: this.kind,\n            value: this.value,\n            line: this.line,\n            column: this.column\n        };\n    }\n    /**\n   * The kind of Token.\n   */ /**\n   * The character offset at which this Node begins.\n   */ /**\n   * The character offset at which this Node ends.\n   */ /**\n   * The 1-indexed line number on which this Token appears.\n   */ /**\n   * The 1-indexed column number at which this Token begins.\n   */ /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   *\n   * Note: is undefined for punctuation tokens, but typed as string for\n   * convenience in the parser.\n   */ /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */ constructor(kind, start, end, line, column, value){\n        this.kind = kind;\n        this.start = start;\n        this.end = end;\n        this.line = line;\n        this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.value = value;\n        this.prev = null;\n        this.next = null;\n    }\n}\n/**\n * The list of all possible AST node types.\n */ /**\n * @internal\n */ const QueryDocumentKeys = {\n    Name: [],\n    Document: [\n        \"definitions\"\n    ],\n    OperationDefinition: [\n        \"name\",\n        \"variableDefinitions\",\n        \"directives\",\n        \"selectionSet\"\n    ],\n    VariableDefinition: [\n        \"variable\",\n        \"type\",\n        \"defaultValue\",\n        \"directives\"\n    ],\n    Variable: [\n        \"name\"\n    ],\n    SelectionSet: [\n        \"selections\"\n    ],\n    Field: [\n        \"alias\",\n        \"name\",\n        \"arguments\",\n        \"directives\",\n        \"selectionSet\"\n    ],\n    Argument: [\n        \"name\",\n        \"value\"\n    ],\n    FragmentSpread: [\n        \"name\",\n        \"directives\"\n    ],\n    InlineFragment: [\n        \"typeCondition\",\n        \"directives\",\n        \"selectionSet\"\n    ],\n    FragmentDefinition: [\n        \"name\",\n        \"variableDefinitions\",\n        \"typeCondition\",\n        \"directives\",\n        \"selectionSet\"\n    ],\n    IntValue: [],\n    FloatValue: [],\n    StringValue: [],\n    BooleanValue: [],\n    NullValue: [],\n    EnumValue: [],\n    ListValue: [\n        \"values\"\n    ],\n    ObjectValue: [\n        \"fields\"\n    ],\n    ObjectField: [\n        \"name\",\n        \"value\"\n    ],\n    Directive: [\n        \"name\",\n        \"arguments\"\n    ],\n    NamedType: [\n        \"name\"\n    ],\n    ListType: [\n        \"type\"\n    ],\n    NonNullType: [\n        \"type\"\n    ],\n    SchemaDefinition: [\n        \"description\",\n        \"directives\",\n        \"operationTypes\"\n    ],\n    OperationTypeDefinition: [\n        \"type\"\n    ],\n    ScalarTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"directives\"\n    ],\n    ObjectTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"interfaces\",\n        \"directives\",\n        \"fields\"\n    ],\n    FieldDefinition: [\n        \"description\",\n        \"name\",\n        \"arguments\",\n        \"type\",\n        \"directives\"\n    ],\n    InputValueDefinition: [\n        \"description\",\n        \"name\",\n        \"type\",\n        \"defaultValue\",\n        \"directives\"\n    ],\n    InterfaceTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"interfaces\",\n        \"directives\",\n        \"fields\"\n    ],\n    UnionTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"directives\",\n        \"types\"\n    ],\n    EnumTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"directives\",\n        \"values\"\n    ],\n    EnumValueDefinition: [\n        \"description\",\n        \"name\",\n        \"directives\"\n    ],\n    InputObjectTypeDefinition: [\n        \"description\",\n        \"name\",\n        \"directives\",\n        \"fields\"\n    ],\n    DirectiveDefinition: [\n        \"description\",\n        \"name\",\n        \"arguments\",\n        \"locations\"\n    ],\n    SchemaExtension: [\n        \"directives\",\n        \"operationTypes\"\n    ],\n    ScalarTypeExtension: [\n        \"name\",\n        \"directives\"\n    ],\n    ObjectTypeExtension: [\n        \"name\",\n        \"interfaces\",\n        \"directives\",\n        \"fields\"\n    ],\n    InterfaceTypeExtension: [\n        \"name\",\n        \"interfaces\",\n        \"directives\",\n        \"fields\"\n    ],\n    UnionTypeExtension: [\n        \"name\",\n        \"directives\",\n        \"types\"\n    ],\n    EnumTypeExtension: [\n        \"name\",\n        \"directives\",\n        \"values\"\n    ],\n    InputObjectTypeExtension: [\n        \"name\",\n        \"directives\",\n        \"fields\"\n    ]\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\n/**\n * @internal\n */ function isNode(maybeNode) {\n    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n    return typeof maybeKind === \"string\" && kindValues.has(maybeKind);\n}\n/** Name */ var OperationTypeNode;\n(function(OperationTypeNode) {\n    OperationTypeNode[\"QUERY\"] = \"query\";\n    OperationTypeNode[\"MUTATION\"] = \"mutation\";\n    OperationTypeNode[\"SUBSCRIPTION\"] = \"subscription\";\n})(OperationTypeNode || (OperationTypeNode = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDTSxNQUFNQTtJQTRCWCxJQUFJLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUVBQyxTQUFTO1FBQ1AsT0FBTztZQUNMQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkMsS0FBSyxJQUFJLENBQUNBLEdBQUc7UUFDZjtJQUNGO0lBcENBOztHQUVDLEdBRUQ7O0dBRUMsR0FFRDs7R0FFQyxHQUVEOztHQUVDLEdBRUQ7O0dBRUMsR0FDREMsWUFBWUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sQ0FBRTtRQUN4QyxJQUFJLENBQUNMLEtBQUssR0FBR0csV0FBV0gsS0FBSztRQUM3QixJQUFJLENBQUNDLEdBQUcsR0FBR0csU0FBU0gsR0FBRztRQUN2QixJQUFJLENBQUNFLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNoQjtBQVlGO0FBQ0E7OztDQUdDLEdBRU0sTUFBTUM7SUE2Q1gsSUFBSSxDQUFDVCxPQUFPQyxXQUFXLENBQUMsR0FBRztRQUN6QixPQUFPO0lBQ1Q7SUFFQUMsU0FBUztRQUNQLE9BQU87WUFDTFEsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkMsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1FBQ3JCO0lBQ0Y7SUF2REE7O0dBRUMsR0FFRDs7R0FFQyxHQUVEOztHQUVDLEdBRUQ7O0dBRUMsR0FFRDs7R0FFQyxHQUVEOzs7OztHQUtDLEdBRUQ7Ozs7R0FJQyxHQUNEUixZQUFZSyxJQUFJLEVBQUVQLEtBQUssRUFBRUMsR0FBRyxFQUFFUSxJQUFJLEVBQUVDLE1BQU0s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RDtBQUNBLFNBQVMsR0FFVCxJQUFJRTtBQUVILFVBQVVBLGlCQUFpQjtJQUMxQkEsaUJBQWlCLENBQUMsUUFBUSxHQUFHO0lBQzdCQSxpQkFBaUIsQ0FBQyxXQUFXLEdBQUc7SUFDaENBLGlCQUFpQixDQUFDLGVBQWUsR0FBRztBQUN0QyxHQUFHQSxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBRWpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanM/YTNiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIGEgcmFuZ2Ugb2YgVVRGLTggY2hhcmFjdGVyIG9mZnNldHMgYW5kIHRva2VuIHJlZmVyZW5jZXMgdGhhdFxuICogaWRlbnRpZnkgdGhlIHJlZ2lvbiBvZiB0aGUgc291cmNlIGZyb20gd2hpY2ggdGhlIEFTVCBkZXJpdmVkLlxuICovXG5leHBvcnQgY2xhc3MgTG9jYXRpb24ge1xuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIFRva2VuIGF0IHdoaWNoIHRoaXMgTm9kZSBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgU291cmNlIGRvY3VtZW50IHRoZSBBU1QgcmVwcmVzZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRUb2tlbi5zdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZFRva2VuLmVuZDtcbiAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgIHRoaXMuZW5kVG9rZW4gPSBlbmRUb2tlbjtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kLFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHJhbmdlIG9mIGNoYXJhY3RlcnMgcmVwcmVzZW50ZWQgYnkgYSBsZXhpY2FsIHRva2VuXG4gKiB3aXRoaW4gYSBTb3VyY2UuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRva2VuIHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIFRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIDEtaW5kZXhlZCBsaW5lIG51bWJlciBvbiB3aGljaCB0aGlzIFRva2VuIGFwcGVhcnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgMS1pbmRleGVkIGNvbHVtbiBudW1iZXIgYXQgd2hpY2ggdGhpcyBUb2tlbiBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGb3Igbm9uLXB1bmN0dWF0aW9uIHRva2VucywgcmVwcmVzZW50cyB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgKlxuICAgKiBOb3RlOiBpcyB1bmRlZmluZWQgZm9yIHB1bmN0dWF0aW9uIHRva2VucywgYnV0IHR5cGVkIGFzIHN0cmluZyBmb3JcbiAgICogY29udmVuaWVuY2UgaW4gdGhlIHBhcnNlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRva2VucyBleGlzdCBhcyBub2RlcyBpbiBhIGRvdWJsZS1saW5rZWQtbGlzdCBhbW9uZ3N0IGFsbCB0b2tlbnNcbiAgICogaW5jbHVkaW5nIGlnbm9yZWQgdG9rZW5zLiA8U09GPiBpcyBhbHdheXMgdGhlIGZpcnN0IG5vZGUgYW5kIDxFT0Y+XG4gICAqIHRoZSBsYXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2luZCwgc3RhcnQsIGVuZCwgbGluZSwgY29sdW1uLCB2YWx1ZSkge1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnVG9rZW4nO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgbGlzdCBvZiBhbGwgcG9zc2libGUgQVNUIG5vZGUgdHlwZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFF1ZXJ5RG9jdW1lbnRLZXlzID0ge1xuICBOYW1lOiBbXSxcbiAgRG9jdW1lbnQ6IFsnZGVmaW5pdGlvbnMnXSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjogW1xuICAgICduYW1lJyxcbiAgICAndmFyaWFibGVEZWZpbml0aW9ucycsXG4gICAgJ2RpcmVjdGl2ZXMnLFxuICAgICdzZWxlY3Rpb25TZXQnLFxuICBdLFxuICBWYXJpYWJsZURlZmluaXRpb246IFsndmFyaWFibGUnLCAndHlwZScsICdkZWZhdWx0VmFsdWUnLCAnZGlyZWN0aXZlcyddLFxuICBWYXJpYWJsZTogWyduYW1lJ10sXG4gIFNlbGVjdGlvblNldDogWydzZWxlY3Rpb25zJ10sXG4gIEZpZWxkOiBbJ2FsaWFzJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEFyZ3VtZW50OiBbJ25hbWUnLCAndmFsdWUnXSxcbiAgRnJhZ21lbnRTcHJlYWQ6IFsnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElubGluZUZyYWdtZW50OiBbJ3R5cGVDb25kaXRpb24nLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgRnJhZ21lbnREZWZpbml0aW9uOiBbXG4gICAgJ25hbWUnLCAvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCByZW1vdmVkIGluIHYxNy4wLjBcbiAgICAndmFyaWFibGVEZWZpbml0aW9ucycsXG4gICAgJ3R5cGVDb25kaXRpb24nLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnc2VsZWN0aW9uU2V0JyxcbiAgXSxcbiAgSW50VmFsdWU6IFtdLFxuICBGbG9hdFZhbHVlOiBbXSxcbiAgU3RyaW5nVmFsdWU6IFtdLFxuICBCb29sZWFuVmFsdWU6IFtdLFxuICBOdWxsVmFsdWU6IFtdLFxuICBFbnVtVmFsdWU6IFtdLFxuICBMaXN0VmFsdWU6IFsndmFsdWVzJ10sXG4gIE9iamVjdFZhbHVlOiBbJ2ZpZWxkcyddLFxuICBPYmplY3RGaWVsZDogWyduYW1lJywgJ3ZhbHVlJ10sXG4gIERpcmVjdGl2ZTogWyduYW1lJywgJ2FyZ3VtZW50cyddLFxuICBOYW1lZFR5cGU6IFsnbmFtZSddLFxuICBMaXN0VHlwZTogWyd0eXBlJ10sXG4gIE5vbk51bGxUeXBlOiBbJ3R5cGUnXSxcbiAgU2NoZW1hRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICdkaXJlY3RpdmVzJywgJ29wZXJhdGlvblR5cGVzJ10sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiBbJ3R5cGUnXSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiBbXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnbmFtZScsXG4gICAgJ2ludGVyZmFjZXMnLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnZmllbGRzJyxcbiAgXSxcbiAgRmllbGREZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ3R5cGUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogW1xuICAgICdkZXNjcmlwdGlvbicsXG4gICAgJ25hbWUnLFxuICAgICd0eXBlJyxcbiAgICAnZGVmYXVsdFZhbHVlJyxcbiAgICAnZGlyZWN0aXZlcycsXG4gIF0sXG4gIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiBbXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnbmFtZScsXG4gICAgJ2ludGVyZmFjZXMnLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnZmllbGRzJyxcbiAgXSxcbiAgVW5pb25UeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndHlwZXMnXSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcycsICd2YWx1ZXMnXSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnXSxcbiAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIERpcmVjdGl2ZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdhcmd1bWVudHMnLCAnbG9jYXRpb25zJ10sXG4gIFNjaGVtYUV4dGVuc2lvbjogWydkaXJlY3RpdmVzJywgJ29wZXJhdGlvblR5cGVzJ10sXG4gIFNjYWxhclR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIE9iamVjdFR5cGVFeHRlbnNpb246IFsnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIEludGVyZmFjZVR5cGVFeHRlbnNpb246IFsnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndHlwZXMnXSxcbiAgRW51bVR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ3ZhbHVlcyddLFxuICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxufTtcbmNvbnN0IGtpbmRWYWx1ZXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKFF1ZXJ5RG9jdW1lbnRLZXlzKSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGUobWF5YmVOb2RlKSB7XG4gIGNvbnN0IG1heWJlS2luZCA9XG4gICAgbWF5YmVOb2RlID09PSBudWxsIHx8IG1heWJlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVOb2RlLmtpbmQ7XG4gIHJldHVybiB0eXBlb2YgbWF5YmVLaW5kID09PSAnc3RyaW5nJyAmJiBraW5kVmFsdWVzLmhhcyhtYXliZUtpbmQpO1xufVxuLyoqIE5hbWUgKi9cblxudmFyIE9wZXJhdGlvblR5cGVOb2RlO1xuXG4oZnVuY3Rpb24gKE9wZXJhdGlvblR5cGVOb2RlKSB7XG4gIE9wZXJhdGlvblR5cGVOb2RlWydRVUVSWSddID0gJ3F1ZXJ5JztcbiAgT3BlcmF0aW9uVHlwZU5vZGVbJ01VVEFUSU9OJ10gPSAnbXV0YXRpb24nO1xuICBPcGVyYXRpb25UeXBlTm9kZVsnU1VCU0NSSVBUSU9OJ10gPSAnc3Vic2NyaXB0aW9uJztcbn0pKE9wZXJhdGlvblR5cGVOb2RlIHx8IChPcGVyYXRpb25UeXBlTm9kZSA9IHt9KSk7XG5cbmV4cG9ydCB7IE9wZXJhdGlvblR5cGVOb2RlIH07XG4iXSwibmFtZXMiOlsiTG9jYXRpb24iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInRvSlNPTiIsInN0YXJ0IiwiZW5kIiwiY29uc3RydWN0b3IiLCJzdGFydFRva2VuIiwiZW5kVG9rZW4iLCJzb3VyY2UiLCJUb2tlbiIsImtpbmQiLCJ2YWx1ZSIsImxpbmUiLCJjb2x1bW4iLCJwcmV2IiwibmV4dCIsIlF1ZXJ5RG9jdW1lbnRLZXlzIiwiTmFtZSIsIkRvY3VtZW50IiwiT3BlcmF0aW9uRGVmaW5pdGlvbiIsIlZhcmlhYmxlRGVmaW5pdGlvbiIsIlZhcmlhYmxlIiwiU2VsZWN0aW9uU2V0IiwiRmllbGQiLCJBcmd1bWVudCIsIkZyYWdtZW50U3ByZWFkIiwiSW5saW5lRnJhZ21lbnQiLCJGcmFnbWVudERlZmluaXRpb24iLCJJbnRWYWx1ZSIsIkZsb2F0VmFsdWUiLCJTdHJpbmdWYWx1ZSIsIkJvb2xlYW5WYWx1ZSIsIk51bGxWYWx1ZSIsIkVudW1WYWx1ZSIsIkxpc3RWYWx1ZSIsIk9iamVjdFZhbHVlIiwiT2JqZWN0RmllbGQiLCJEaXJlY3RpdmUiLCJOYW1lZFR5cGUiLCJMaXN0VHlwZSIsIk5vbk51bGxUeXBlIiwiU2NoZW1hRGVmaW5pdGlvbiIsIk9wZXJhdGlvblR5cGVEZWZpbml0aW9uIiwiU2NhbGFyVHlwZURlZmluaXRpb24iLCJPYmplY3RUeXBlRGVmaW5pdGlvbiIsIkZpZWxkRGVmaW5pdGlvbiIsIklucHV0VmFsdWVEZWZpbml0aW9uIiwiSW50ZXJmYWNlVHlwZURlZmluaXRpb24iLCJVbmlvblR5cGVEZWZpbml0aW9uIiwiRW51bVR5cGVEZWZpbml0aW9uIiwiRW51bVZhbHVlRGVmaW5pdGlvbiIsIklucHV0T2JqZWN0VHlwZURlZmluaXRpb24iLCJEaXJlY3RpdmVEZWZpbml0aW9uIiwiU2NoZW1hRXh0ZW5zaW9uIiwiU2NhbGFyVHlwZUV4dGVuc2lvbiIsIk9iamVjdFR5cGVFeHRlbnNpb24iLCJJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uIiwiVW5pb25UeXBlRXh0ZW5zaW9uIiwiRW51bVR5cGVFeHRlbnNpb24iLCJJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24iLCJraW5kVmFsdWVzIiwiU2V0IiwiT2JqZWN0Iiwia2V5cyIsImlzTm9kZSIsIm1heWJlTm9kZSIsIm1heWJlS2luZCIsImhhcyIsIk9wZXJhdGlvblR5cGVOb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/ast.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/blockString.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dedentBlockStringLines: function() { return /* binding */ dedentBlockStringLines; },\n/* harmony export */   isPrintableAsBlockString: function() { return /* binding */ isPrintableAsBlockString; },\n/* harmony export */   printBlockString: function() { return /* binding */ printBlockString; }\n/* harmony export */ });\n/* harmony import */ var _characterClasses_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./characterClasses.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/characterClasses.mjs\");\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */ function dedentBlockStringLines(lines) {\n    var _firstNonEmptyLine2;\n    let commonIndent = Number.MAX_SAFE_INTEGER;\n    let firstNonEmptyLine = null;\n    let lastNonEmptyLine = -1;\n    for(let i = 0; i < lines.length; ++i){\n        var _firstNonEmptyLine;\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;\n        lastNonEmptyLine = i;\n        if (i !== 0 && indent < commonIndent) {\n            commonIndent = indent;\n        }\n    }\n    return lines // Remove common indentation from all lines but first.\n    .map((line, i)=>i === 0 ? line : line.slice(commonIndent)) // Remove leading and trailing blank lines.\n    .slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while(i < str.length && (0,_characterClasses_mjs__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(str.charCodeAt(i))){\n        ++i;\n    }\n    return i;\n}\n/**\n * @internal\n */ function isPrintableAsBlockString(value) {\n    if (value === \"\") {\n        return true; // empty string is printable\n    }\n    let isEmptyLine = true;\n    let hasIndent = false;\n    let hasCommonIndent = true;\n    let seenNonEmptyLine = false;\n    for(let i = 0; i < value.length; ++i){\n        switch(value.codePointAt(i)){\n            case 0x0000:\n            case 0x0001:\n            case 0x0002:\n            case 0x0003:\n            case 0x0004:\n            case 0x0005:\n            case 0x0006:\n            case 0x0007:\n            case 0x0008:\n            case 0x000b:\n            case 0x000c:\n            case 0x000e:\n            case 0x000f:\n                return false;\n            // Has non-printable characters\n            case 0x000d:\n                //  \\r\n                return false;\n            // Has \\r or \\r\\n which will be replaced as \\n\n            case 10:\n                //  \\n\n                if (isEmptyLine && !seenNonEmptyLine) {\n                    return false; // Has leading new line\n                }\n                seenNonEmptyLine = true;\n                isEmptyLine = true;\n                hasIndent = false;\n                break;\n            case 9:\n            case 32:\n                //  <space>\n                hasIndent || (hasIndent = isEmptyLine);\n                break;\n            default:\n                hasCommonIndent && (hasCommonIndent = hasIndent);\n                isEmptyLine = false;\n        }\n    }\n    if (isEmptyLine) {\n        return false; // Has trailing empty lines\n    }\n    if (hasCommonIndent && seenNonEmptyLine) {\n        return false; // Has internal indent\n    }\n    return true;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */ function printBlockString(value, options) {\n    const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"'); // Expand a block string's raw value into independent lines.\n    const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n    const isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line\n    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line)=>line.length === 0 || (0,_characterClasses_mjs__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(line.charCodeAt(0))); // Trailing triple quotes just looks confusing but doesn't force trailing new line\n    const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"'); // Trailing quote (single or double) or slash forces trailing new line\n    const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n    const hasTrailingSlash = value.endsWith(\"\\\\\");\n    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability\n    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);\n    let result = \"\"; // Format a multi-line block quote to account for leading space.\n    const skipLeadingNewLine = isSingleLine && (0,_characterClasses_mjs__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(value.charCodeAt(0));\n    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n        result += \"\\n\";\n    }\n    result += escapedValue;\n    if (printAsMultipleLines || forceTrailingNewline) {\n        result += \"\\n\";\n    }\n    return '\"\"\"' + result + '\"\"\"';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2Jsb2NrU3RyaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNEO0FBQ3REOzs7Ozs7O0NBT0MsR0FFTSxTQUFTQyx1QkFBdUJDLEtBQUs7SUFDMUMsSUFBSUM7SUFFSixJQUFJQyxlQUFlQyxPQUFPQyxnQkFBZ0I7SUFDMUMsSUFBSUMsb0JBQW9CO0lBQ3hCLElBQUlDLG1CQUFtQixDQUFDO0lBRXhCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxNQUFNUSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxJQUFJRTtRQUVKLE1BQU1DLE9BQU9WLEtBQUssQ0FBQ08sRUFBRTtRQUNyQixNQUFNSSxTQUFTQyxrQkFBa0JGO1FBRWpDLElBQUlDLFdBQVdELEtBQUtGLE1BQU0sRUFBRTtZQUMxQixVQUFVLG1CQUFtQjtRQUMvQjtRQUVBSCxvQkFDRSxDQUFDSSxxQkFBcUJKLGlCQUFnQixNQUFPLFFBQzdDSSx1QkFBdUIsS0FBSyxJQUN4QkEscUJBQ0FGO1FBQ05ELG1CQUFtQkM7UUFFbkIsSUFBSUEsTUFBTSxLQUFLSSxTQUFTVCxjQUFjO1lBQ3BDQSxlQUFlUztRQUNqQjtJQUNGO0lBRUEsT0FBT1gsTUFBTSxzREFBc0Q7S0FDaEVhLEdBQUcsQ0FBQyxDQUFDSCxNQUFNSCxJQUFPQSxNQUFNLElBQUlHLE9BQU9BLEtBQUtJLEtBQUssQ0FBQ1osZUFBZ0IsMkNBQTJDO0tBQ3pHWSxLQUFLLENBQ0osQ0FBQ2Isc0JBQXNCSSxpQkFBZ0IsTUFBTyxRQUM1Q0osd0JBQXdCLEtBQUssSUFDM0JBLHNCQUNBLEdBQ0pLLG1CQUFtQjtBQUV6QjtBQUVBLFNBQVNNLGtCQUFrQkcsR0FBRztJQUM1QixJQUFJUixJQUFJO0lBRVIsTUFBT0EsSUFBSVEsSUFBSVAsTUFBTSxJQUFJVixtRUFBWUEsQ0FBQ2lCLElBQUlDLFVBQVUsQ0FBQ1QsSUFBSztRQUN4RCxFQUFFQTtJQUNKO0lBRUEsT0FBT0E7QUFDVDtBQUNBOztDQUVDLEdBRU0sU0FBU1UseUJBQXlCQyxLQUFLO0lBQzVDLElBQUlBLFVBQVUsSUFBSTtRQUNoQixPQUFPLE1BQU0sNEJBQTRCO0lBQzNDO0lBRUEsSUFBSUMsY0FBYztJQUNsQixJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLGtCQUFrQjtJQUN0QixJQUFJQyxtQkFBbUI7SUFFdkIsSUFBSyxJQUFJZixJQUFJLEdBQUdBLElBQUlXLE1BQU1WLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ3JDLE9BQVFXLE1BQU1LLFdBQVcsQ0FBQ2hCO1lBQ3hCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTztZQUNULCtCQUErQjtZQUUvQixLQUFLO2dCQUNILE1BQU07Z0JBQ04sT0FBTztZQUNULDhDQUE4QztZQUU5QyxLQUFLO2dCQUNILE1BQU07Z0JBQ04sSUFBSVksZUFBZSxDQUFDRyxrQkFBa0I7b0JBQ3BDLE9BQU8sT0FBTyx1QkFBdUI7Z0JBQ3ZDO2dCQUVBQSxtQkFBbUI7Z0JBQ25CSCxjQUFjO2dCQUNkQyxZQUFZO2dCQUNaO1lBRUYsS0FBSztZQUVMLEtBQUs7Z0JBQ0gsV0FBVztnQkFDWEEsYUFBY0EsQ0FBQUEsWUFBWUQsV0FBVTtnQkFDcEM7WUFFRjtnQkFDRUUsbUJBQW9CQSxDQUFBQSxrQkFBa0JELFNBQVE7Z0JBQzlDRCxjQUFjO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJQSxhQUFhO1FBQ2YsT0FBTyxPQUFPLDJCQUEyQjtJQUMzQztJQUVBLElBQUlFLG1CQUFtQkMsa0JBQWtCO1FBQ3ZDLE9BQU8sT0FBTyxzQkFBc0I7SUFDdEM7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7Ozs7O0NBTUMsR0FFTSxTQUFTRSxpQkFBaUJOLEtBQUssRUFBRU8sT0FBTztJQUM3QyxNQUFNQyxlQUFlUixNQUFNUyxPQUFPLENBQUMsUUFBUSxVQUFVLDREQUE0RDtJQUVqSCxNQUFNM0IsUUFBUTBCLGFBQWFFLEtBQUssQ0FBQztJQUNqQyxNQUFNQyxlQUFlN0IsTUFBTVEsTUFBTSxLQUFLLEdBQUcsMkZBQTJGO0lBRXBJLE1BQU1zQixzQkFDSjlCLE1BQU1RLE1BQU0sR0FBRyxLQUNmUixNQUNHYyxLQUFLLENBQUMsR0FDTmlCLEtBQUssQ0FBQyxDQUFDckIsT0FBU0EsS0FBS0YsTUFBTSxLQUFLLEtBQUtWLG1FQUFZQSxDQUFDWSxLQUFLTSxVQUFVLENBQUMsTUFBTSxrRkFBa0Y7SUFFL0osTUFBTWdCLDBCQUEwQk4sYUFBYU8sUUFBUSxDQUFDLFVBQVUsc0VBQXNFO0lBRXRJLE1BQU1DLG1CQUFtQmhCLE1BQU1lLFFBQVEsQ0FBQyxRQUFRLENBQUNEO0lBQ2pELE1BQU1HLG1CQUFtQmpCLE1BQU1lLFFBQVEsQ0FBQztJQUN4QyxNQUFNRyx1QkFBdUJGLG9CQUFvQkM7SUFDakQsTUFBTUUsdUJBQ0osQ0FBRVosQ0FBQUEsWUFBWSxRQUFRQSxZQUFZLEtBQUssS0FBS0EsUUFBUWEsUUFBUSxLQUFLLHFFQUFxRTtJQUNySSxFQUFDVCxnQkFDQVgsTUFBTVYsTUFBTSxHQUFHLE1BQ2Y0Qix3QkFDQU4sdUJBQ0FFLHVCQUFzQjtJQUMxQixJQUFJTyxTQUFTLElBQUksZ0VBQWdFO0lBRWpGLE1BQU1DLHFCQUFxQlgsZ0JBQWdCL0IsbUVBQVlBLENBQUNvQixNQUFNRixVQUFVLENBQUM7SUFFekUsSUFBSSx3QkFBeUIsQ0FBQ3dCLHNCQUF1QlYscUJBQXFCO1FBQ3hFUyxVQUFVO0lBQ1o7SUFFQUEsVUFBVWI7SUFFVixJQUFJVyx3QkFBd0JELHNCQUFzQjtRQUNoREcsVUFBVTtJQUNaO0lBRUEsT0FBTyxRQUFRQSxTQUFTO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2Jsb2NrU3RyaW5nLm1qcz8xNzcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzV2hpdGVTcGFjZSB9IGZyb20gJy4vY2hhcmFjdGVyQ2xhc3Nlcy5tanMnO1xuLyoqXG4gKiBQcm9kdWNlcyB0aGUgdmFsdWUgb2YgYSBibG9jayBzdHJpbmcgZnJvbSBpdHMgcGFyc2VkIHJhdyB2YWx1ZSwgc2ltaWxhciB0b1xuICogQ29mZmVlU2NyaXB0J3MgYmxvY2sgc3RyaW5nLCBQeXRob24ncyBkb2NzdHJpbmcgdHJpbSBvciBSdWJ5J3Mgc3RyaXBfaGVyZWRvYy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIEdyYXBoUUwgc3BlYydzIEJsb2NrU3RyaW5nVmFsdWUoKSBzdGF0aWMgYWxnb3JpdGhtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWRlbnRCbG9ja1N0cmluZ0xpbmVzKGxpbmVzKSB7XG4gIHZhciBfZmlyc3ROb25FbXB0eUxpbmUyO1xuXG4gIGxldCBjb21tb25JbmRlbnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgbGV0IGZpcnN0Tm9uRW1wdHlMaW5lID0gbnVsbDtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAtMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIF9maXJzdE5vbkVtcHR5TGluZTtcblxuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZShsaW5lKTtcblxuICAgIGlmIChpbmRlbnQgPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eSBsaW5lc1xuICAgIH1cblxuICAgIGZpcnN0Tm9uRW1wdHlMaW5lID1cbiAgICAgIChfZmlyc3ROb25FbXB0eUxpbmUgPSBmaXJzdE5vbkVtcHR5TGluZSkgIT09IG51bGwgJiZcbiAgICAgIF9maXJzdE5vbkVtcHR5TGluZSAhPT0gdm9pZCAwXG4gICAgICAgID8gX2ZpcnN0Tm9uRW1wdHlMaW5lXG4gICAgICAgIDogaTtcbiAgICBsYXN0Tm9uRW1wdHlMaW5lID0gaTtcblxuICAgIGlmIChpICE9PSAwICYmIGluZGVudCA8IGNvbW1vbkluZGVudCkge1xuICAgICAgY29tbW9uSW5kZW50ID0gaW5kZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5lcyAvLyBSZW1vdmUgY29tbW9uIGluZGVudGF0aW9uIGZyb20gYWxsIGxpbmVzIGJ1dCBmaXJzdC5cbiAgICAubWFwKChsaW5lLCBpKSA9PiAoaSA9PT0gMCA/IGxpbmUgOiBsaW5lLnNsaWNlKGNvbW1vbkluZGVudCkpKSAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgYmxhbmsgbGluZXMuXG4gICAgLnNsaWNlKFxuICAgICAgKF9maXJzdE5vbkVtcHR5TGluZTIgPSBmaXJzdE5vbkVtcHR5TGluZSkgIT09IG51bGwgJiZcbiAgICAgICAgX2ZpcnN0Tm9uRW1wdHlMaW5lMiAhPT0gdm9pZCAwXG4gICAgICAgID8gX2ZpcnN0Tm9uRW1wdHlMaW5lMlxuICAgICAgICA6IDAsXG4gICAgICBsYXN0Tm9uRW1wdHlMaW5lICsgMSxcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsZWFkaW5nV2hpdGVzcGFjZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgc3RyLmxlbmd0aCAmJiBpc1doaXRlU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgKytpO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW50YWJsZUFzQmxvY2tTdHJpbmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgcHJpbnRhYmxlXG4gIH1cblxuICBsZXQgaXNFbXB0eUxpbmUgPSB0cnVlO1xuICBsZXQgaGFzSW5kZW50ID0gZmFsc2U7XG4gIGxldCBoYXNDb21tb25JbmRlbnQgPSB0cnVlO1xuICBsZXQgc2Vlbk5vbkVtcHR5TGluZSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvZGVQb2ludEF0KGkpKSB7XG4gICAgICBjYXNlIDB4MDAwMDpcbiAgICAgIGNhc2UgMHgwMDAxOlxuICAgICAgY2FzZSAweDAwMDI6XG4gICAgICBjYXNlIDB4MDAwMzpcbiAgICAgIGNhc2UgMHgwMDA0OlxuICAgICAgY2FzZSAweDAwMDU6XG4gICAgICBjYXNlIDB4MDAwNjpcbiAgICAgIGNhc2UgMHgwMDA3OlxuICAgICAgY2FzZSAweDAwMDg6XG4gICAgICBjYXNlIDB4MDAwYjpcbiAgICAgIGNhc2UgMHgwMDBjOlxuICAgICAgY2FzZSAweDAwMGU6XG4gICAgICBjYXNlIDB4MDAwZjpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gSGFzIG5vbi1wcmludGFibGUgY2hhcmFjdGVyc1xuXG4gICAgICBjYXNlIDB4MDAwZDpcbiAgICAgICAgLy8gIFxcclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBIYXMgXFxyIG9yIFxcclxcbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIGFzIFxcblxuXG4gICAgICBjYXNlIDEwOlxuICAgICAgICAvLyAgXFxuXG4gICAgICAgIGlmIChpc0VtcHR5TGluZSAmJiAhc2Vlbk5vbkVtcHR5TGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSGFzIGxlYWRpbmcgbmV3IGxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5Ob25FbXB0eUxpbmUgPSB0cnVlO1xuICAgICAgICBpc0VtcHR5TGluZSA9IHRydWU7XG4gICAgICAgIGhhc0luZGVudCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5OiAvLyAgIFxcdFxuXG4gICAgICBjYXNlIDMyOlxuICAgICAgICAvLyAgPHNwYWNlPlxuICAgICAgICBoYXNJbmRlbnQgfHwgKGhhc0luZGVudCA9IGlzRW1wdHlMaW5lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhhc0NvbW1vbkluZGVudCAmJiAoaGFzQ29tbW9uSW5kZW50ID0gaGFzSW5kZW50KTtcbiAgICAgICAgaXNFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNFbXB0eUxpbmUpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIEhhcyB0cmFpbGluZyBlbXB0eSBsaW5lc1xuICB9XG5cbiAgaWYgKGhhc0NvbW1vbkluZGVudCAmJiBzZWVuTm9uRW1wdHlMaW5lKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBIYXMgaW50ZXJuYWwgaW5kZW50XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUHJpbnQgYSBibG9jayBzdHJpbmcgaW4gdGhlIGluZGVudGVkIGJsb2NrIGZvcm0gYnkgYWRkaW5nIGEgbGVhZGluZyBhbmRcbiAqIHRyYWlsaW5nIGJsYW5rIGxpbmUuIEhvd2V2ZXIsIGlmIGEgYmxvY2sgc3RyaW5nIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UgYW5kIGlzXG4gKiBhIHNpbmdsZS1saW5lLCBhZGRpbmcgYSBsZWFkaW5nIGJsYW5rIGxpbmUgd291bGQgc3RyaXAgdGhhdCB3aGl0ZXNwYWNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludEJsb2NrU3RyaW5nKHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLCAnXFxcXFwiXCJcIicpOyAvLyBFeHBhbmQgYSBibG9jayBzdHJpbmcncyByYXcgdmFsdWUgaW50byBpbmRlcGVuZGVudCBsaW5lcy5cblxuICBjb25zdCBsaW5lcyA9IGVzY2FwZWRWYWx1ZS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBpc1NpbmdsZUxpbmUgPSBsaW5lcy5sZW5ndGggPT09IDE7IC8vIElmIGNvbW1vbiBpbmRlbnRhdGlvbiBpcyBmb3VuZCB3ZSBjYW4gZml4IHNvbWUgb2YgdGhvc2UgY2FzZXMgYnkgYWRkaW5nIGxlYWRpbmcgbmV3IGxpbmVcblxuICBjb25zdCBmb3JjZUxlYWRpbmdOZXdMaW5lID1cbiAgICBsaW5lcy5sZW5ndGggPiAxICYmXG4gICAgbGluZXNcbiAgICAgIC5zbGljZSgxKVxuICAgICAgLmV2ZXJ5KChsaW5lKSA9PiBsaW5lLmxlbmd0aCA9PT0gMCB8fCBpc1doaXRlU3BhY2UobGluZS5jaGFyQ29kZUF0KDApKSk7IC8vIFRyYWlsaW5nIHRyaXBsZSBxdW90ZXMganVzdCBsb29rcyBjb25mdXNpbmcgYnV0IGRvZXNuJ3QgZm9yY2UgdHJhaWxpbmcgbmV3IGxpbmVcblxuICBjb25zdCBoYXNUcmFpbGluZ1RyaXBsZVF1b3RlcyA9IGVzY2FwZWRWYWx1ZS5lbmRzV2l0aCgnXFxcXFwiXCJcIicpOyAvLyBUcmFpbGluZyBxdW90ZSAoc2luZ2xlIG9yIGRvdWJsZSkgb3Igc2xhc2ggZm9yY2VzIHRyYWlsaW5nIG5ldyBsaW5lXG5cbiAgY29uc3QgaGFzVHJhaWxpbmdRdW90ZSA9IHZhbHVlLmVuZHNXaXRoKCdcIicpICYmICFoYXNUcmFpbGluZ1RyaXBsZVF1b3RlcztcbiAgY29uc3QgaGFzVHJhaWxpbmdTbGFzaCA9IHZhbHVlLmVuZHNXaXRoKCdcXFxcJyk7XG4gIGNvbnN0IGZvcmNlVHJhaWxpbmdOZXdsaW5lID0gaGFzVHJhaWxpbmdRdW90ZSB8fCBoYXNUcmFpbGluZ1NsYXNoO1xuICBjb25zdCBwcmludEFzTXVsdGlwbGVMaW5lcyA9XG4gICAgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm1pbmltaXplKSAmJiAvLyBhZGQgbGVhZGluZyBhbmQgdHJhaWxpbmcgbmV3IGxpbmVzIG9ubHkgaWYgaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHlcbiAgICAoIWlzU2luZ2xlTGluZSB8fFxuICAgICAgdmFsdWUubGVuZ3RoID4gNzAgfHxcbiAgICAgIGZvcmNlVHJhaWxpbmdOZXdsaW5lIHx8XG4gICAgICBmb3JjZUxlYWRpbmdOZXdMaW5lIHx8XG4gICAgICBoYXNUcmFpbGluZ1RyaXBsZVF1b3Rlcyk7XG4gIGxldCByZXN1bHQgPSAnJzsgLy8gRm9ybWF0IGEgbXVsdGktbGluZSBibG9jayBxdW90ZSB0byBhY2NvdW50IGZvciBsZWFkaW5nIHNwYWNlLlxuXG4gIGNvbnN0IHNraXBMZWFkaW5nTmV3TGluZSA9IGlzU2luZ2xlTGluZSAmJiBpc1doaXRlU3BhY2UodmFsdWUuY2hhckNvZGVBdCgwKSk7XG5cbiAgaWYgKChwcmludEFzTXVsdGlwbGVMaW5lcyAmJiAhc2tpcExlYWRpbmdOZXdMaW5lKSB8fCBmb3JjZUxlYWRpbmdOZXdMaW5lKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgcmVzdWx0ICs9IGVzY2FwZWRWYWx1ZTtcblxuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMgfHwgZm9yY2VUcmFpbGluZ05ld2xpbmUpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICByZXR1cm4gJ1wiXCJcIicgKyByZXN1bHQgKyAnXCJcIlwiJztcbn1cbiJdLCJuYW1lcyI6WyJpc1doaXRlU3BhY2UiLCJkZWRlbnRCbG9ja1N0cmluZ0xpbmVzIiwibGluZXMiLCJfZmlyc3ROb25FbXB0eUxpbmUyIiwiY29tbW9uSW5kZW50IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImZpcnN0Tm9uRW1wdHlMaW5lIiwibGFzdE5vbkVtcHR5TGluZSIsImkiLCJsZW5ndGgiLCJfZmlyc3ROb25FbXB0eUxpbmUiLCJsaW5lIiwiaW5kZW50IiwibGVhZGluZ1doaXRlc3BhY2UiLCJtYXAiLCJzbGljZSIsInN0ciIsImNoYXJDb2RlQXQiLCJpc1ByaW50YWJsZUFzQmxvY2tTdHJpbmciLCJ2YWx1ZSIsImlzRW1wdHlMaW5lIiwiaGFzSW5kZW50IiwiaGFzQ29tbW9uSW5kZW50Iiwic2Vlbk5vbkVtcHR5TGluZSIsImNvZGVQb2ludEF0IiwicHJpbnRCbG9ja1N0cmluZyIsIm9wdGlvbnMiLCJlc2NhcGVkVmFsdWUiLCJyZXBsYWNlIiwic3BsaXQiLCJpc1NpbmdsZUxpbmUiLCJmb3JjZUxlYWRpbmdOZXdMaW5lIiwiZXZlcnkiLCJoYXNUcmFpbGluZ1RyaXBsZVF1b3RlcyIsImVuZHNXaXRoIiwiaGFzVHJhaWxpbmdRdW90ZSIsImhhc1RyYWlsaW5nU2xhc2giLCJmb3JjZVRyYWlsaW5nTmV3bGluZSIsInByaW50QXNNdWx0aXBsZUxpbmVzIiwibWluaW1pemUiLCJyZXN1bHQiLCJza2lwTGVhZGluZ05ld0xpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/blockString.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/characterClasses.mjs":
/*!************************************************************!*\
  !*** ./node_modules/graphql/language/characterClasses.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDigit: function() { return /* binding */ isDigit; },\n/* harmony export */   isLetter: function() { return /* binding */ isLetter; },\n/* harmony export */   isNameContinue: function() { return /* binding */ isNameContinue; },\n/* harmony export */   isNameStart: function() { return /* binding */ isNameStart; },\n/* harmony export */   isWhiteSpace: function() { return /* binding */ isWhiteSpace; }\n/* harmony export */ });\n/**\n * ```\n * WhiteSpace ::\n *   - \"Horizontal Tab (U+0009)\"\n *   - \"Space (U+0020)\"\n * ```\n * @internal\n */ function isWhiteSpace(code) {\n    return code === 0x0009 || code === 0x0020;\n}\n/**\n * ```\n * Digit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n * ```\n * @internal\n */ function isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n/**\n * ```\n * Letter :: one of\n *   - `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M`\n *   - `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`\n *   - `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`\n *   - `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`\n * ```\n * @internal\n */ function isLetter(code) {\n    return code >= 0x0061 && code <= 0x007a || // A-Z\n    code >= 0x0041 && code <= 0x005a // a-z\n    ;\n}\n/**\n * ```\n * NameStart ::\n *   - Letter\n *   - `_`\n * ```\n * @internal\n */ function isNameStart(code) {\n    return isLetter(code) || code === 0x005f;\n}\n/**\n * ```\n * NameContinue ::\n *   - Letter\n *   - Digit\n *   - `_`\n * ```\n * @internal\n */ function isNameContinue(code) {\n    return isLetter(code) || isDigit(code) || code === 0x005f;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2NoYXJhY3RlckNsYXNzZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNBLGFBQWFDLElBQUk7SUFDL0IsT0FBT0EsU0FBUyxVQUFVQSxTQUFTO0FBQ3JDO0FBQ0E7Ozs7OztDQU1DLEdBRU0sU0FBU0MsUUFBUUQsSUFBSTtJQUMxQixPQUFPQSxRQUFRLFVBQVVBLFFBQVE7QUFDbkM7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FFTSxTQUFTRSxTQUFTRixJQUFJO0lBQzNCLE9BQ0UsUUFBUyxVQUFVQSxRQUFRLFVBQVcsTUFBTTtJQUMzQ0EsUUFBUSxVQUFVQSxRQUFRLE9BQVEsTUFBTTs7QUFFN0M7QUFDQTs7Ozs7OztDQU9DLEdBRU0sU0FBU0csWUFBWUgsSUFBSTtJQUM5QixPQUFPRSxTQUFTRixTQUFTQSxTQUFTO0FBQ3BDO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FFTSxTQUFTSSxlQUFlSixJQUFJO0lBQ2pDLE9BQU9FLFNBQVNGLFNBQVNDLFFBQVFELFNBQVNBLFNBQVM7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvY2hhcmFjdGVyQ2xhc3Nlcy5tanM/YTUzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGBgYFxuICogV2hpdGVTcGFjZSA6OlxuICogICAtIFwiSG9yaXpvbnRhbCBUYWIgKFUrMDAwOSlcIlxuICogICAtIFwiU3BhY2UgKFUrMDAyMClcIlxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwO1xufVxuLyoqXG4gKiBgYGBcbiAqIERpZ2l0IDo6IG9uZSBvZlxuICogICAtIGAwYCBgMWAgYDJgIGAzYCBgNGAgYDVgIGA2YCBgN2AgYDhgIGA5YFxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOTtcbn1cbi8qKlxuICogYGBgXG4gKiBMZXR0ZXIgOjogb25lIG9mXG4gKiAgIC0gYEFgIGBCYCBgQ2AgYERgIGBFYCBgRmAgYEdgIGBIYCBgSWAgYEpgIGBLYCBgTGAgYE1gXG4gKiAgIC0gYE5gIGBPYCBgUGAgYFFgIGBSYCBgU2AgYFRgIGBVYCBgVmAgYFdgIGBYYCBgWWAgYFpgXG4gKiAgIC0gYGFgIGBiYCBgY2AgYGRgIGBlYCBgZmAgYGdgIGBoYCBgaWAgYGpgIGBrYCBgbGAgYG1gXG4gKiAgIC0gYG5gIGBvYCBgcGAgYHFgIGByYCBgc2AgYHRgIGB1YCBgdmAgYHdgIGB4YCBgeWAgYHpgXG4gKiBgYGBcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xldHRlcihjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDdhKSB8fCAvLyBBLVpcbiAgICAoY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEpIC8vIGEtelxuICApO1xufVxuLyoqXG4gKiBgYGBcbiAqIE5hbWVTdGFydCA6OlxuICogICAtIExldHRlclxuICogICAtIGBfYFxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lU3RhcnQoY29kZSkge1xuICByZXR1cm4gaXNMZXR0ZXIoY29kZSkgfHwgY29kZSA9PT0gMHgwMDVmO1xufVxuLyoqXG4gKiBgYGBcbiAqIE5hbWVDb250aW51ZSA6OlxuICogICAtIExldHRlclxuICogICAtIERpZ2l0XG4gKiAgIC0gYF9gXG4gKiBgYGBcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVDb250aW51ZShjb2RlKSB7XG4gIHJldHVybiBpc0xldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IGNvZGUgPT09IDB4MDA1Zjtcbn1cbiJdLCJuYW1lcyI6WyJpc1doaXRlU3BhY2UiLCJjb2RlIiwiaXNEaWdpdCIsImlzTGV0dGVyIiwiaXNOYW1lU3RhcnQiLCJpc05hbWVDb250aW51ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/characterClasses.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/kinds.mjs":
/*!*************************************************!*\
  !*** ./node_modules/graphql/language/kinds.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kind: function() { return /* binding */ Kind; }\n/* harmony export */ });\n/**\n * The set of allowed kind values for AST nodes.\n */ var Kind;\n(function(Kind) {\n    Kind[\"NAME\"] = \"Name\";\n    Kind[\"DOCUMENT\"] = \"Document\";\n    Kind[\"OPERATION_DEFINITION\"] = \"OperationDefinition\";\n    Kind[\"VARIABLE_DEFINITION\"] = \"VariableDefinition\";\n    Kind[\"SELECTION_SET\"] = \"SelectionSet\";\n    Kind[\"FIELD\"] = \"Field\";\n    Kind[\"ARGUMENT\"] = \"Argument\";\n    Kind[\"FRAGMENT_SPREAD\"] = \"FragmentSpread\";\n    Kind[\"INLINE_FRAGMENT\"] = \"InlineFragment\";\n    Kind[\"FRAGMENT_DEFINITION\"] = \"FragmentDefinition\";\n    Kind[\"VARIABLE\"] = \"Variable\";\n    Kind[\"INT\"] = \"IntValue\";\n    Kind[\"FLOAT\"] = \"FloatValue\";\n    Kind[\"STRING\"] = \"StringValue\";\n    Kind[\"BOOLEAN\"] = \"BooleanValue\";\n    Kind[\"NULL\"] = \"NullValue\";\n    Kind[\"ENUM\"] = \"EnumValue\";\n    Kind[\"LIST\"] = \"ListValue\";\n    Kind[\"OBJECT\"] = \"ObjectValue\";\n    Kind[\"OBJECT_FIELD\"] = \"ObjectField\";\n    Kind[\"DIRECTIVE\"] = \"Directive\";\n    Kind[\"NAMED_TYPE\"] = \"NamedType\";\n    Kind[\"LIST_TYPE\"] = \"ListType\";\n    Kind[\"NON_NULL_TYPE\"] = \"NonNullType\";\n    Kind[\"SCHEMA_DEFINITION\"] = \"SchemaDefinition\";\n    Kind[\"OPERATION_TYPE_DEFINITION\"] = \"OperationTypeDefinition\";\n    Kind[\"SCALAR_TYPE_DEFINITION\"] = \"ScalarTypeDefinition\";\n    Kind[\"OBJECT_TYPE_DEFINITION\"] = \"ObjectTypeDefinition\";\n    Kind[\"FIELD_DEFINITION\"] = \"FieldDefinition\";\n    Kind[\"INPUT_VALUE_DEFINITION\"] = \"InputValueDefinition\";\n    Kind[\"INTERFACE_TYPE_DEFINITION\"] = \"InterfaceTypeDefinition\";\n    Kind[\"UNION_TYPE_DEFINITION\"] = \"UnionTypeDefinition\";\n    Kind[\"ENUM_TYPE_DEFINITION\"] = \"EnumTypeDefinition\";\n    Kind[\"ENUM_VALUE_DEFINITION\"] = \"EnumValueDefinition\";\n    Kind[\"INPUT_OBJECT_TYPE_DEFINITION\"] = \"InputObjectTypeDefinition\";\n    Kind[\"DIRECTIVE_DEFINITION\"] = \"DirectiveDefinition\";\n    Kind[\"SCHEMA_EXTENSION\"] = \"SchemaExtension\";\n    Kind[\"SCALAR_TYPE_EXTENSION\"] = \"ScalarTypeExtension\";\n    Kind[\"OBJECT_TYPE_EXTENSION\"] = \"ObjectTypeExtension\";\n    Kind[\"INTERFACE_TYPE_EXTENSION\"] = \"InterfaceTypeExtension\";\n    Kind[\"UNION_TYPE_EXTENSION\"] = \"UnionTypeExtension\";\n    Kind[\"ENUM_TYPE_EXTENSION\"] = \"EnumTypeExtension\";\n    Kind[\"INPUT_OBJECT_TYPE_EXTENSION\"] = \"InputObjectTypeExtension\";\n})(Kind || (Kind = {}));\n /**\n * The enum type representing the possible kind values of AST nodes.\n *\n * @deprecated Please use `Kind`. Will be remove in v17.\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2tpbmRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDRCxJQUFJQTtBQUVILFVBQVVBLElBQUk7SUFDYkEsSUFBSSxDQUFDLE9BQU8sR0FBRztJQUNmQSxJQUFJLENBQUMsV0FBVyxHQUFHO0lBQ25CQSxJQUFJLENBQUMsdUJBQXVCLEdBQUc7SUFDL0JBLElBQUksQ0FBQyxzQkFBc0IsR0FBRztJQUM5QkEsSUFBSSxDQUFDLGdCQUFnQixHQUFHO0lBQ3hCQSxJQUFJLENBQUMsUUFBUSxHQUFHO0lBQ2hCQSxJQUFJLENBQUMsV0FBVyxHQUFHO0lBQ25CQSxJQUFJLENBQUMsa0JBQWtCLEdBQUc7SUFDMUJBLElBQUksQ0FBQyxrQkFBa0IsR0FBRztJQUMxQkEsSUFBSSxDQUFDLHNCQUFzQixHQUFHO0lBQzlCQSxJQUFJLENBQUMsV0FBVyxHQUFHO0lBQ25CQSxJQUFJLENBQUMsTUFBTSxHQUFHO0lBQ2RBLElBQUksQ0FBQyxRQUFRLEdBQUc7SUFDaEJBLElBQUksQ0FBQyxTQUFTLEdBQUc7SUFDakJBLElBQUksQ0FBQyxVQUFVLEdBQUc7SUFDbEJBLElBQUksQ0FBQyxPQUFPLEdBQUc7SUFDZkEsSUFBSSxDQUFDLE9BQU8sR0FBRztJQUNmQSxJQUFJLENBQUMsT0FBTyxHQUFHO0lBQ2ZBLElBQUksQ0FBQyxTQUFTLEdBQUc7SUFDakJBLElBQUksQ0FBQyxlQUFlLEdBQUc7SUFDdkJBLElBQUksQ0FBQyxZQUFZLEdBQUc7SUFDcEJBLElBQUksQ0FBQyxhQUFhLEdBQUc7SUFDckJBLElBQUksQ0FBQyxZQUFZLEdBQUc7SUFDcEJBLElBQUksQ0FBQyxnQkFBZ0IsR0FBRztJQUN4QkEsSUFBSSxDQUFDLG9CQUFvQixHQUFHO0lBQzVCQSxJQUFJLENBQUMsNEJBQTRCLEdBQUc7SUFDcENBLElBQUksQ0FBQyx5QkFBeUIsR0FBRztJQUNqQ0EsSUFBSSxDQUFDLHlCQUF5QixHQUFHO0lBQ2pDQSxJQUFJLENBQUMsbUJBQW1CLEdBQUc7SUFDM0JBLElBQUksQ0FBQyx5QkFBeUIsR0FBRztJQUNqQ0EsSUFBSSxDQUFDLDRCQUE0QixHQUFHO0lBQ3BDQSxJQUFJLENBQUMsd0JBQXdCLEdBQUc7SUFDaENBLElBQUksQ0FBQyx1QkFBdUIsR0FBRztJQUMvQkEsSUFBSSxDQUFDLHdCQUF3QixHQUFHO0lBQ2hDQSxJQUFJLENBQUMsK0JBQStCLEdBQUc7SUFDdkNBLElBQUksQ0FBQyx1QkFBdUIsR0FBRztJQUMvQkEsSUFBSSxDQUFDLG1CQUFtQixHQUFHO0lBQzNCQSxJQUFJLENBQUMsd0JBQXdCLEdBQUc7SUFDaENBLElBQUksQ0FBQyx3QkFBd0IsR0FBRztJQUNoQ0EsSUFBSSxDQUFDLDJCQUEyQixHQUFHO0lBQ25DQSxJQUFJLENBQUMsdUJBQXVCLEdBQUc7SUFDL0JBLElBQUksQ0FBQyxzQkFBc0IsR0FBRztJQUM5QkEsSUFBSSxDQUFDLDhCQUE4QixHQUFHO0FBQ3hDLEdBQUdBLFFBQVNBLENBQUFBLE9BQU8sQ0FBQztBQUVKLENBQ2hCOzs7O0NBSUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2Uva2luZHMubWpzP2E3YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgc2V0IG9mIGFsbG93ZWQga2luZCB2YWx1ZXMgZm9yIEFTVCBub2Rlcy5cbiAqL1xudmFyIEtpbmQ7XG5cbihmdW5jdGlvbiAoS2luZCkge1xuICBLaW5kWydOQU1FJ10gPSAnTmFtZSc7XG4gIEtpbmRbJ0RPQ1VNRU5UJ10gPSAnRG9jdW1lbnQnO1xuICBLaW5kWydPUEVSQVRJT05fREVGSU5JVElPTiddID0gJ09wZXJhdGlvbkRlZmluaXRpb24nO1xuICBLaW5kWydWQVJJQUJMRV9ERUZJTklUSU9OJ10gPSAnVmFyaWFibGVEZWZpbml0aW9uJztcbiAgS2luZFsnU0VMRUNUSU9OX1NFVCddID0gJ1NlbGVjdGlvblNldCc7XG4gIEtpbmRbJ0ZJRUxEJ10gPSAnRmllbGQnO1xuICBLaW5kWydBUkdVTUVOVCddID0gJ0FyZ3VtZW50JztcbiAgS2luZFsnRlJBR01FTlRfU1BSRUFEJ10gPSAnRnJhZ21lbnRTcHJlYWQnO1xuICBLaW5kWydJTkxJTkVfRlJBR01FTlQnXSA9ICdJbmxpbmVGcmFnbWVudCc7XG4gIEtpbmRbJ0ZSQUdNRU5UX0RFRklOSVRJT04nXSA9ICdGcmFnbWVudERlZmluaXRpb24nO1xuICBLaW5kWydWQVJJQUJMRSddID0gJ1ZhcmlhYmxlJztcbiAgS2luZFsnSU5UJ10gPSAnSW50VmFsdWUnO1xuICBLaW5kWydGTE9BVCddID0gJ0Zsb2F0VmFsdWUnO1xuICBLaW5kWydTVFJJTkcnXSA9ICdTdHJpbmdWYWx1ZSc7XG4gIEtpbmRbJ0JPT0xFQU4nXSA9ICdCb29sZWFuVmFsdWUnO1xuICBLaW5kWydOVUxMJ10gPSAnTnVsbFZhbHVlJztcbiAgS2luZFsnRU5VTSddID0gJ0VudW1WYWx1ZSc7XG4gIEtpbmRbJ0xJU1QnXSA9ICdMaXN0VmFsdWUnO1xuICBLaW5kWydPQkpFQ1QnXSA9ICdPYmplY3RWYWx1ZSc7XG4gIEtpbmRbJ09CSkVDVF9GSUVMRCddID0gJ09iamVjdEZpZWxkJztcbiAgS2luZFsnRElSRUNUSVZFJ10gPSAnRGlyZWN0aXZlJztcbiAgS2luZFsnTkFNRURfVFlQRSddID0gJ05hbWVkVHlwZSc7XG4gIEtpbmRbJ0xJU1RfVFlQRSddID0gJ0xpc3RUeXBlJztcbiAgS2luZFsnTk9OX05VTExfVFlQRSddID0gJ05vbk51bGxUeXBlJztcbiAgS2luZFsnU0NIRU1BX0RFRklOSVRJT04nXSA9ICdTY2hlbWFEZWZpbml0aW9uJztcbiAgS2luZFsnT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTiddID0gJ09wZXJhdGlvblR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnU0NBTEFSX1RZUEVfREVGSU5JVElPTiddID0gJ1NjYWxhclR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnT0JKRUNUX1RZUEVfREVGSU5JVElPTiddID0gJ09iamVjdFR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnRklFTERfREVGSU5JVElPTiddID0gJ0ZpZWxkRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0lOUFVUX1ZBTFVFX0RFRklOSVRJT04nXSA9ICdJbnB1dFZhbHVlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0lOVEVSRkFDRV9UWVBFX0RFRklOSVRJT04nXSA9ICdJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ1VOSU9OX1RZUEVfREVGSU5JVElPTiddID0gJ1VuaW9uVHlwZURlZmluaXRpb24nO1xuICBLaW5kWydFTlVNX1RZUEVfREVGSU5JVElPTiddID0gJ0VudW1UeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0VOVU1fVkFMVUVfREVGSU5JVElPTiddID0gJ0VudW1WYWx1ZURlZmluaXRpb24nO1xuICBLaW5kWydJTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OJ10gPSAnSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0RJUkVDVElWRV9ERUZJTklUSU9OJ10gPSAnRGlyZWN0aXZlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ1NDSEVNQV9FWFRFTlNJT04nXSA9ICdTY2hlbWFFeHRlbnNpb24nO1xuICBLaW5kWydTQ0FMQVJfVFlQRV9FWFRFTlNJT04nXSA9ICdTY2FsYXJUeXBlRXh0ZW5zaW9uJztcbiAgS2luZFsnT0JKRUNUX1RZUEVfRVhURU5TSU9OJ10gPSAnT2JqZWN0VHlwZUV4dGVuc2lvbic7XG4gIEtpbmRbJ0lOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTiddID0gJ0ludGVyZmFjZVR5cGVFeHRlbnNpb24nO1xuICBLaW5kWydVTklPTl9UWVBFX0VYVEVOU0lPTiddID0gJ1VuaW9uVHlwZUV4dGVuc2lvbic7XG4gIEtpbmRbJ0VOVU1fVFlQRV9FWFRFTlNJT04nXSA9ICdFbnVtVHlwZUV4dGVuc2lvbic7XG4gIEtpbmRbJ0lOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTiddID0gJ0lucHV0T2JqZWN0VHlwZUV4dGVuc2lvbic7XG59KShLaW5kIHx8IChLaW5kID0ge30pKTtcblxuZXhwb3J0IHsgS2luZCB9O1xuLyoqXG4gKiBUaGUgZW51bSB0eXBlIHJlcHJlc2VudGluZyB0aGUgcG9zc2libGUga2luZCB2YWx1ZXMgb2YgQVNUIG5vZGVzLlxuICpcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYEtpbmRgLiBXaWxsIGJlIHJlbW92ZSBpbiB2MTcuXG4gKi9cbiJdLCJuYW1lcyI6WyJLaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/predicates.mjs":
/*!******************************************************!*\
  !*** ./node_modules/graphql/language/predicates.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isConstValueNode: function() { return /* binding */ isConstValueNode; },\n/* harmony export */   isDefinitionNode: function() { return /* binding */ isDefinitionNode; },\n/* harmony export */   isExecutableDefinitionNode: function() { return /* binding */ isExecutableDefinitionNode; },\n/* harmony export */   isSelectionNode: function() { return /* binding */ isSelectionNode; },\n/* harmony export */   isTypeDefinitionNode: function() { return /* binding */ isTypeDefinitionNode; },\n/* harmony export */   isTypeExtensionNode: function() { return /* binding */ isTypeExtensionNode; },\n/* harmony export */   isTypeNode: function() { return /* binding */ isTypeNode; },\n/* harmony export */   isTypeSystemDefinitionNode: function() { return /* binding */ isTypeSystemDefinitionNode; },\n/* harmony export */   isTypeSystemExtensionNode: function() { return /* binding */ isTypeSystemExtensionNode; },\n/* harmony export */   isValueNode: function() { return /* binding */ isValueNode; }\n/* harmony export */ });\n/* harmony import */ var _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kinds.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n\nfunction isDefinitionNode(node) {\n    return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);\n}\nfunction isExecutableDefinitionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_DEFINITION;\n}\nfunction isSelectionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.FIELD || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_SPREAD || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INLINE_FRAGMENT;\n}\nfunction isValueNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.VARIABLE || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INT || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.FLOAT || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.STRING || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.BOOLEAN || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.NULL || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.ENUM || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.LIST || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.OBJECT;\n}\nfunction isConstValueNode(node) {\n    return isValueNode(node) && (node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.OBJECT ? node.fields.some((field)=>isConstValueNode(field.value)) : node.kind !== _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.VARIABLE);\n}\nfunction isTypeNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.NAMED_TYPE || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.LIST_TYPE || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.NON_NULL_TYPE;\n}\nfunction isTypeSystemDefinitionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.DIRECTIVE_DEFINITION;\n}\nfunction isTypeDefinitionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INPUT_OBJECT_TYPE_DEFINITION;\n}\nfunction isTypeSystemExtensionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nfunction isTypeExtensionNode(node) {\n    return node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds_mjs__WEBPACK_IMPORTED_MODULE_0__.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByZWRpY2F0ZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQzVCLFNBQVNDLGlCQUFpQkMsSUFBSTtJQUNuQyxPQUNFQywyQkFBMkJELFNBQzNCRSwyQkFBMkJGLFNBQzNCRywwQkFBMEJIO0FBRTlCO0FBQ08sU0FBU0MsMkJBQTJCRCxJQUFJO0lBQzdDLE9BQ0VBLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNPLG9CQUFvQixJQUN2Q0wsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ1EsbUJBQW1CO0FBRTFDO0FBQ08sU0FBU0MsZ0JBQWdCUCxJQUFJO0lBQ2xDLE9BQ0VBLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNVLEtBQUssSUFDeEJSLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNXLGVBQWUsSUFDbENULEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNZLGVBQWU7QUFFdEM7QUFDTyxTQUFTQyxZQUFZWCxJQUFJO0lBQzlCLE9BQ0VBLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNjLFFBQVEsSUFDM0JaLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNlLEdBQUcsSUFDdEJiLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNnQixLQUFLLElBQ3hCZCxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDaUIsTUFBTSxJQUN6QmYsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ2tCLE9BQU8sSUFDMUJoQixLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDbUIsSUFBSSxJQUN2QmpCLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNvQixJQUFJLElBQ3ZCbEIsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ3FCLElBQUksSUFDdkJuQixLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDc0IsTUFBTTtBQUU3QjtBQUNPLFNBQVNDLGlCQUFpQnJCLElBQUk7SUFDbkMsT0FDRVcsWUFBWVgsU0FDWEEsQ0FBQUEsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ3FCLElBQUksR0FDcEJuQixLQUFLc0IsTUFBTSxDQUFDQyxJQUFJLENBQUNGLG9CQUNqQnJCLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNzQixNQUFNLEdBQ3pCcEIsS0FBS3dCLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLENBQUNFLFFBQVVKLGlCQUFpQkksTUFBTUMsS0FBSyxLQUN4RDFCLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNjLFFBQVE7QUFFbkM7QUFDTyxTQUFTZSxXQUFXM0IsSUFBSTtJQUM3QixPQUNFQSxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDOEIsVUFBVSxJQUM3QjVCLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUMrQixTQUFTLElBQzVCN0IsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ2dDLGFBQWE7QUFFcEM7QUFDTyxTQUFTNUIsMkJBQTJCRixJQUFJO0lBQzdDLE9BQ0VBLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNpQyxpQkFBaUIsSUFDcENDLHFCQUFxQmhDLFNBQ3JCQSxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDbUMsb0JBQW9CO0FBRTNDO0FBQ08sU0FBU0QscUJBQXFCaEMsSUFBSTtJQUN2QyxPQUNFQSxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDb0Msc0JBQXNCLElBQ3pDbEMsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ3FDLHNCQUFzQixJQUN6Q25DLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNzQyx5QkFBeUIsSUFDNUNwQyxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDdUMscUJBQXFCLElBQ3hDckMsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ3dDLG9CQUFvQixJQUN2Q3RDLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUN5Qyw0QkFBNEI7QUFFbkQ7QUFDTyxTQUFTcEMsMEJBQTBCSCxJQUFJO0lBQzVDLE9BQU9BLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUMwQyxnQkFBZ0IsSUFBSUMsb0JBQW9CekM7QUFDcEU7QUFDTyxTQUFTeUMsb0JBQW9CekMsSUFBSTtJQUN0QyxPQUNFQSxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDNEMscUJBQXFCLElBQ3hDMUMsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQzZDLHFCQUFxQixJQUN4QzNDLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUM4Qyx3QkFBd0IsSUFDM0M1QyxLQUFLSSxJQUFJLEtBQUtOLDRDQUFJQSxDQUFDK0Msb0JBQW9CLElBQ3ZDN0MsS0FBS0ksSUFBSSxLQUFLTiw0Q0FBSUEsQ0FBQ2dELG1CQUFtQixJQUN0QzlDLEtBQUtJLElBQUksS0FBS04sNENBQUlBLENBQUNpRCwyQkFBMkI7QUFFbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJlZGljYXRlcy5tanM/MDRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBLaW5kIH0gZnJvbSAnLi9raW5kcy5tanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbk5vZGUobm9kZSkge1xuICByZXR1cm4gKFxuICAgIGlzRXhlY3V0YWJsZURlZmluaXRpb25Ob2RlKG5vZGUpIHx8XG4gICAgaXNUeXBlU3lzdGVtRGVmaW5pdGlvbk5vZGUobm9kZSkgfHxcbiAgICBpc1R5cGVTeXN0ZW1FeHRlbnNpb25Ob2RlKG5vZGUpXG4gICk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFeGVjdXRhYmxlRGVmaW5pdGlvbk5vZGUobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5PUEVSQVRJT05fREVGSU5JVElPTiB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OXG4gICk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZWxlY3Rpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuRklFTEQgfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuRlJBR01FTlRfU1BSRUFEIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLklOTElORV9GUkFHTUVOVFxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuVkFSSUFCTEUgfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuSU5UIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLkZMT0FUIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLlNUUklORyB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5CT09MRUFOIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLk5VTEwgfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuRU5VTSB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5MSVNUIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLk9CSkVDVFxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RWYWx1ZU5vZGUobm9kZSkge1xuICByZXR1cm4gKFxuICAgIGlzVmFsdWVOb2RlKG5vZGUpICYmXG4gICAgKG5vZGUua2luZCA9PT0gS2luZC5MSVNUXG4gICAgICA/IG5vZGUudmFsdWVzLnNvbWUoaXNDb25zdFZhbHVlTm9kZSlcbiAgICAgIDogbm9kZS5raW5kID09PSBLaW5kLk9CSkVDVFxuICAgICAgPyBub2RlLmZpZWxkcy5zb21lKChmaWVsZCkgPT4gaXNDb25zdFZhbHVlTm9kZShmaWVsZC52YWx1ZSkpXG4gICAgICA6IG5vZGUua2luZCAhPT0gS2luZC5WQVJJQUJMRSlcbiAgKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuTkFNRURfVFlQRSB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5MSVNUX1RZUEUgfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuTk9OX05VTExfVFlQRVxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZVN5c3RlbURlZmluaXRpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuU0NIRU1BX0RFRklOSVRJT04gfHxcbiAgICBpc1R5cGVEZWZpbml0aW9uTm9kZShub2RlKSB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5ESVJFQ1RJVkVfREVGSU5JVElPTlxuICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZURlZmluaXRpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuU0NBTEFSX1RZUEVfREVGSU5JVElPTiB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5PQkpFQ1RfVFlQRV9ERUZJTklUSU9OIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT04gfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuVU5JT05fVFlQRV9ERUZJTklUSU9OIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT05cbiAgKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVTeXN0ZW1FeHRlbnNpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUua2luZCA9PT0gS2luZC5TQ0hFTUFfRVhURU5TSU9OIHx8IGlzVHlwZUV4dGVuc2lvbk5vZGUobm9kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlRXh0ZW5zaW9uTm9kZShub2RlKSB7XG4gIHJldHVybiAoXG4gICAgbm9kZS5raW5kID09PSBLaW5kLlNDQUxBUl9UWVBFX0VYVEVOU0lPTiB8fFxuICAgIG5vZGUua2luZCA9PT0gS2luZC5PQkpFQ1RfVFlQRV9FWFRFTlNJT04gfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLlVOSU9OX1RZUEVfRVhURU5TSU9OIHx8XG4gICAgbm9kZS5raW5kID09PSBLaW5kLkVOVU1fVFlQRV9FWFRFTlNJT04gfHxcbiAgICBub2RlLmtpbmQgPT09IEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OXG4gICk7XG59XG4iXSwibmFtZXMiOlsiS2luZCIsImlzRGVmaW5pdGlvbk5vZGUiLCJub2RlIiwiaXNFeGVjdXRhYmxlRGVmaW5pdGlvbk5vZGUiLCJpc1R5cGVTeXN0ZW1EZWZpbml0aW9uTm9kZSIsImlzVHlwZVN5c3RlbUV4dGVuc2lvbk5vZGUiLCJraW5kIiwiT1BFUkFUSU9OX0RFRklOSVRJT04iLCJGUkFHTUVOVF9ERUZJTklUSU9OIiwiaXNTZWxlY3Rpb25Ob2RlIiwiRklFTEQiLCJGUkFHTUVOVF9TUFJFQUQiLCJJTkxJTkVfRlJBR01FTlQiLCJpc1ZhbHVlTm9kZSIsIlZBUklBQkxFIiwiSU5UIiwiRkxPQVQiLCJTVFJJTkciLCJCT09MRUFOIiwiTlVMTCIsIkVOVU0iLCJMSVNUIiwiT0JKRUNUIiwiaXNDb25zdFZhbHVlTm9kZSIsInZhbHVlcyIsInNvbWUiLCJmaWVsZHMiLCJmaWVsZCIsInZhbHVlIiwiaXNUeXBlTm9kZSIsIk5BTUVEX1RZUEUiLCJMSVNUX1RZUEUiLCJOT05fTlVMTF9UWVBFIiwiU0NIRU1BX0RFRklOSVRJT04iLCJpc1R5cGVEZWZpbml0aW9uTm9kZSIsIkRJUkVDVElWRV9ERUZJTklUSU9OIiwiU0NBTEFSX1RZUEVfREVGSU5JVElPTiIsIk9CSkVDVF9UWVBFX0RFRklOSVRJT04iLCJJTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OIiwiVU5JT05fVFlQRV9ERUZJTklUSU9OIiwiRU5VTV9UWVBFX0RFRklOSVRJT04iLCJJTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OIiwiU0NIRU1BX0VYVEVOU0lPTiIsImlzVHlwZUV4dGVuc2lvbk5vZGUiLCJTQ0FMQVJfVFlQRV9FWFRFTlNJT04iLCJPQkpFQ1RfVFlQRV9FWFRFTlNJT04iLCJJTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT04iLCJVTklPTl9UWVBFX0VYVEVOU0lPTiIsIkVOVU1fVFlQRV9FWFRFTlNJT04iLCJJTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT04iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/predicates.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/printString.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/language/printString.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   printString: function() { return /* binding */ printString; }\n/* harmony export */ });\n/**\n * Prints a string as a GraphQL StringValue literal. Replaces control characters\n * and excluded characters (\" U+0022 and \\\\ U+005C) with escape sequences.\n */ function printString(str) {\n    return '\"'.concat(str.replace(escapedRegExp, escapedReplacer), '\"');\n} // eslint-disable-next-line no-control-regex\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\nfunction escapedReplacer(str) {\n    return escapeSequences[str.charCodeAt(0)];\n} // prettier-ignore\nconst escapeSequences = [\n    \"\\\\u0000\",\n    \"\\\\u0001\",\n    \"\\\\u0002\",\n    \"\\\\u0003\",\n    \"\\\\u0004\",\n    \"\\\\u0005\",\n    \"\\\\u0006\",\n    \"\\\\u0007\",\n    \"\\\\b\",\n    \"\\\\t\",\n    \"\\\\n\",\n    \"\\\\u000B\",\n    \"\\\\f\",\n    \"\\\\r\",\n    \"\\\\u000E\",\n    \"\\\\u000F\",\n    \"\\\\u0010\",\n    \"\\\\u0011\",\n    \"\\\\u0012\",\n    \"\\\\u0013\",\n    \"\\\\u0014\",\n    \"\\\\u0015\",\n    \"\\\\u0016\",\n    \"\\\\u0017\",\n    \"\\\\u0018\",\n    \"\\\\u0019\",\n    \"\\\\u001A\",\n    \"\\\\u001B\",\n    \"\\\\u001C\",\n    \"\\\\u001D\",\n    \"\\\\u001E\",\n    \"\\\\u001F\",\n    \"\",\n    \"\",\n    '\\\\\"',\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\\\\\\\\\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\\\\u007F\",\n    \"\\\\u0080\",\n    \"\\\\u0081\",\n    \"\\\\u0082\",\n    \"\\\\u0083\",\n    \"\\\\u0084\",\n    \"\\\\u0085\",\n    \"\\\\u0086\",\n    \"\\\\u0087\",\n    \"\\\\u0088\",\n    \"\\\\u0089\",\n    \"\\\\u008A\",\n    \"\\\\u008B\",\n    \"\\\\u008C\",\n    \"\\\\u008D\",\n    \"\\\\u008E\",\n    \"\\\\u008F\",\n    \"\\\\u0090\",\n    \"\\\\u0091\",\n    \"\\\\u0092\",\n    \"\\\\u0093\",\n    \"\\\\u0094\",\n    \"\\\\u0095\",\n    \"\\\\u0096\",\n    \"\\\\u0097\",\n    \"\\\\u0098\",\n    \"\\\\u0099\",\n    \"\\\\u009A\",\n    \"\\\\u009B\",\n    \"\\\\u009C\",\n    \"\\\\u009D\",\n    \"\\\\u009E\",\n    \"\\\\u009F\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50U3RyaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBQ00sU0FBU0EsWUFBWUMsR0FBRztJQUM3QixPQUFPLElBQWdELE9BQTVDQSxJQUFJQyxPQUFPLENBQUNDLGVBQWVDLGtCQUFpQjtBQUN6RCxFQUFFLDRDQUE0QztBQUU5QyxNQUFNRCxnQkFBZ0I7QUFFdEIsU0FBU0MsZ0JBQWdCSCxHQUFHO0lBQzFCLE9BQU9JLGVBQWUsQ0FBQ0osSUFBSUssVUFBVSxDQUFDLEdBQUc7QUFDM0MsRUFBRSxrQkFBa0I7QUFFcEIsTUFBTUQsa0JBQWtCO0lBQ3RCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRTdHJpbmcubWpzPzAzYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcmludHMgYSBzdHJpbmcgYXMgYSBHcmFwaFFMIFN0cmluZ1ZhbHVlIGxpdGVyYWwuIFJlcGxhY2VzIGNvbnRyb2wgY2hhcmFjdGVyc1xuICogYW5kIGV4Y2x1ZGVkIGNoYXJhY3RlcnMgKFwiIFUrMDAyMiBhbmQgXFxcXCBVKzAwNUMpIHdpdGggZXNjYXBlIHNlcXVlbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RyaW5nKHN0cikge1xuICByZXR1cm4gYFwiJHtzdHIucmVwbGFjZShlc2NhcGVkUmVnRXhwLCBlc2NhcGVkUmVwbGFjZXIpfVwiYDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuY29uc3QgZXNjYXBlZFJlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyMlxceDVjXFx4N2YtXFx4OWZdL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZWRSZXBsYWNlcihzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZVNlcXVlbmNlc1tzdHIuY2hhckNvZGVBdCgwKV07XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5jb25zdCBlc2NhcGVTZXF1ZW5jZXMgPSBbXG4gICdcXFxcdTAwMDAnLFxuICAnXFxcXHUwMDAxJyxcbiAgJ1xcXFx1MDAwMicsXG4gICdcXFxcdTAwMDMnLFxuICAnXFxcXHUwMDA0JyxcbiAgJ1xcXFx1MDAwNScsXG4gICdcXFxcdTAwMDYnLFxuICAnXFxcXHUwMDA3JyxcbiAgJ1xcXFxiJyxcbiAgJ1xcXFx0JyxcbiAgJ1xcXFxuJyxcbiAgJ1xcXFx1MDAwQicsXG4gICdcXFxcZicsXG4gICdcXFxccicsXG4gICdcXFxcdTAwMEUnLFxuICAnXFxcXHUwMDBGJyxcbiAgJ1xcXFx1MDAxMCcsXG4gICdcXFxcdTAwMTEnLFxuICAnXFxcXHUwMDEyJyxcbiAgJ1xcXFx1MDAxMycsXG4gICdcXFxcdTAwMTQnLFxuICAnXFxcXHUwMDE1JyxcbiAgJ1xcXFx1MDAxNicsXG4gICdcXFxcdTAwMTcnLFxuICAnXFxcXHUwMDE4JyxcbiAgJ1xcXFx1MDAxOScsXG4gICdcXFxcdTAwMUEnLFxuICAnXFxcXHUwMDFCJyxcbiAgJ1xcXFx1MDAxQycsXG4gICdcXFxcdTAwMUQnLFxuICAnXFxcXHUwMDFFJyxcbiAgJ1xcXFx1MDAxRicsXG4gICcnLFxuICAnJyxcbiAgJ1xcXFxcIicsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyAyRlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJywgLy8gM0ZcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsIC8vIDRGXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICdcXFxcXFxcXCcsXG4gICcnLFxuICAnJyxcbiAgJycsIC8vIDVGXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyA2RlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnXFxcXHUwMDdGJyxcbiAgJ1xcXFx1MDA4MCcsXG4gICdcXFxcdTAwODEnLFxuICAnXFxcXHUwMDgyJyxcbiAgJ1xcXFx1MDA4MycsXG4gICdcXFxcdTAwODQnLFxuICAnXFxcXHUwMDg1JyxcbiAgJ1xcXFx1MDA4NicsXG4gICdcXFxcdTAwODcnLFxuICAnXFxcXHUwMDg4JyxcbiAgJ1xcXFx1MDA4OScsXG4gICdcXFxcdTAwOEEnLFxuICAnXFxcXHUwMDhCJyxcbiAgJ1xcXFx1MDA4QycsXG4gICdcXFxcdTAwOEQnLFxuICAnXFxcXHUwMDhFJyxcbiAgJ1xcXFx1MDA4RicsXG4gICdcXFxcdTAwOTAnLFxuICAnXFxcXHUwMDkxJyxcbiAgJ1xcXFx1MDA5MicsXG4gICdcXFxcdTAwOTMnLFxuICAnXFxcXHUwMDk0JyxcbiAgJ1xcXFx1MDA5NScsXG4gICdcXFxcdTAwOTYnLFxuICAnXFxcXHUwMDk3JyxcbiAgJ1xcXFx1MDA5OCcsXG4gICdcXFxcdTAwOTknLFxuICAnXFxcXHUwMDlBJyxcbiAgJ1xcXFx1MDA5QicsXG4gICdcXFxcdTAwOUMnLFxuICAnXFxcXHUwMDlEJyxcbiAgJ1xcXFx1MDA5RScsXG4gICdcXFxcdTAwOUYnLFxuXTtcbiJdLCJuYW1lcyI6WyJwcmludFN0cmluZyIsInN0ciIsInJlcGxhY2UiLCJlc2NhcGVkUmVnRXhwIiwiZXNjYXBlZFJlcGxhY2VyIiwiZXNjYXBlU2VxdWVuY2VzIiwiY2hhckNvZGVBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/printString.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/printer.mjs":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/printer.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   print: function() { return /* binding */ print; }\n/* harmony export */ });\n/* harmony import */ var _blockString_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blockString.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/blockString.mjs\");\n/* harmony import */ var _printString_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./printString.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/printString.mjs\");\n/* harmony import */ var _visitor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visitor.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n\n\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */ function print(ast) {\n    return (0,_visitor_mjs__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, printDocASTReducer);\n}\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n    Name: {\n        leave: (node)=>node.value\n    },\n    Variable: {\n        leave: (node)=>\"$\" + node.name\n    },\n    // Document\n    Document: {\n        leave: (node)=>join(node.definitions, \"\\n\\n\")\n    },\n    OperationDefinition: {\n        leave (node) {\n            const varDefs = wrap(\"(\", join(node.variableDefinitions, \", \"), \")\");\n            const prefix = join([\n                node.operation,\n                join([\n                    node.name,\n                    varDefs\n                ]),\n                join(node.directives, \" \")\n            ], \" \"); // Anonymous queries with no directives or variable definitions can use\n            // the query short form.\n            return (prefix === \"query\" ? \"\" : prefix + \" \") + node.selectionSet;\n        }\n    },\n    VariableDefinition: {\n        leave: (param)=>{\n            let { variable, type, defaultValue, directives } = param;\n            return variable + \": \" + type + wrap(\" = \", defaultValue) + wrap(\" \", join(directives, \" \"));\n        }\n    },\n    SelectionSet: {\n        leave: (param)=>{\n            let { selections } = param;\n            return block(selections);\n        }\n    },\n    Field: {\n        leave (param) {\n            let { alias, name, arguments: args, directives, selectionSet } = param;\n            const prefix = wrap(\"\", alias, \": \") + name;\n            let argsLine = prefix + wrap(\"(\", join(args, \", \"), \")\");\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\");\n            }\n            return join([\n                argsLine,\n                join(directives, \" \"),\n                selectionSet\n            ], \" \");\n        }\n    },\n    Argument: {\n        leave: (param)=>{\n            let { name, value } = param;\n            return name + \": \" + value;\n        }\n    },\n    // Fragments\n    FragmentSpread: {\n        leave: (param)=>{\n            let { name, directives } = param;\n            return \"...\" + name + wrap(\" \", join(directives, \" \"));\n        }\n    },\n    InlineFragment: {\n        leave: (param)=>{\n            let { typeCondition, directives, selectionSet } = param;\n            return join([\n                \"...\",\n                wrap(\"on \", typeCondition),\n                join(directives, \" \"),\n                selectionSet\n            ], \" \");\n        }\n    },\n    FragmentDefinition: {\n        leave: (param)=>{\n            let { name, typeCondition, variableDefinitions, directives, selectionSet } = param;\n            return(// or removed in the future.\n            \"fragment \".concat(name).concat(wrap(\"(\", join(variableDefinitions, \", \"), \")\"), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap(\"\", join(directives, \" \"), \" \")) + selectionSet);\n        }\n    },\n    // Value\n    IntValue: {\n        leave: (param)=>{\n            let { value } = param;\n            return value;\n        }\n    },\n    FloatValue: {\n        leave: (param)=>{\n            let { value } = param;\n            return value;\n        }\n    },\n    StringValue: {\n        leave: (param)=>{\n            let { value, block: isBlockString } = param;\n            return isBlockString ? (0,_blockString_mjs__WEBPACK_IMPORTED_MODULE_1__.printBlockString)(value) : (0,_printString_mjs__WEBPACK_IMPORTED_MODULE_2__.printString)(value);\n        }\n    },\n    BooleanValue: {\n        leave: (param)=>{\n            let { value } = param;\n            return value ? \"true\" : \"false\";\n        }\n    },\n    NullValue: {\n        leave: ()=>\"null\"\n    },\n    EnumValue: {\n        leave: (param)=>{\n            let { value } = param;\n            return value;\n        }\n    },\n    ListValue: {\n        leave: (param)=>{\n            let { values } = param;\n            return \"[\" + join(values, \", \") + \"]\";\n        }\n    },\n    ObjectValue: {\n        leave: (param)=>{\n            let { fields } = param;\n            return \"{\" + join(fields, \", \") + \"}\";\n        }\n    },\n    ObjectField: {\n        leave: (param)=>{\n            let { name, value } = param;\n            return name + \": \" + value;\n        }\n    },\n    // Directive\n    Directive: {\n        leave: (param)=>{\n            let { name, arguments: args } = param;\n            return \"@\" + name + wrap(\"(\", join(args, \", \"), \")\");\n        }\n    },\n    // Type\n    NamedType: {\n        leave: (param)=>{\n            let { name } = param;\n            return name;\n        }\n    },\n    ListType: {\n        leave: (param)=>{\n            let { type } = param;\n            return \"[\" + type + \"]\";\n        }\n    },\n    NonNullType: {\n        leave: (param)=>{\n            let { type } = param;\n            return type + \"!\";\n        }\n    },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: (param)=>{\n            let { description, directives, operationTypes } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"schema\",\n                join(directives, \" \"),\n                block(operationTypes)\n            ], \" \");\n        }\n    },\n    OperationTypeDefinition: {\n        leave: (param)=>{\n            let { operation, type } = param;\n            return operation + \": \" + type;\n        }\n    },\n    ScalarTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, directives } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"scalar\",\n                name,\n                join(directives, \" \")\n            ], \" \");\n        }\n    },\n    ObjectTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, interfaces, directives, fields } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"type\",\n                name,\n                wrap(\"implements \", join(interfaces, \" & \")),\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    },\n    FieldDefinition: {\n        leave: (param)=>{\n            let { description, name, arguments: args, type, directives } = param;\n            return wrap(\"\", description, \"\\n\") + name + (hasMultilineItems(args) ? wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + \": \" + type + wrap(\" \", join(directives, \" \"));\n        }\n    },\n    InputValueDefinition: {\n        leave: (param)=>{\n            let { description, name, type, defaultValue, directives } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                name + \": \" + type,\n                wrap(\"= \", defaultValue),\n                join(directives, \" \")\n            ], \" \");\n        }\n    },\n    InterfaceTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, interfaces, directives, fields } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"interface\",\n                name,\n                wrap(\"implements \", join(interfaces, \" & \")),\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    },\n    UnionTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, directives, types } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"union\",\n                name,\n                join(directives, \" \"),\n                wrap(\"= \", join(types, \" | \"))\n            ], \" \");\n        }\n    },\n    EnumTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, directives, values } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"enum\",\n                name,\n                join(directives, \" \"),\n                block(values)\n            ], \" \");\n        }\n    },\n    EnumValueDefinition: {\n        leave: (param)=>{\n            let { description, name, directives } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                name,\n                join(directives, \" \")\n            ], \" \");\n        }\n    },\n    InputObjectTypeDefinition: {\n        leave: (param)=>{\n            let { description, name, directives, fields } = param;\n            return wrap(\"\", description, \"\\n\") + join([\n                \"input\",\n                name,\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    },\n    DirectiveDefinition: {\n        leave: (param)=>{\n            let { description, name, arguments: args, repeatable, locations } = param;\n            return wrap(\"\", description, \"\\n\") + \"directive @\" + name + (hasMultilineItems(args) ? wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + (repeatable ? \" repeatable\" : \"\") + \" on \" + join(locations, \" | \");\n        }\n    },\n    SchemaExtension: {\n        leave: (param)=>{\n            let { directives, operationTypes } = param;\n            return join([\n                \"extend schema\",\n                join(directives, \" \"),\n                block(operationTypes)\n            ], \" \");\n        }\n    },\n    ScalarTypeExtension: {\n        leave: (param)=>{\n            let { name, directives } = param;\n            return join([\n                \"extend scalar\",\n                name,\n                join(directives, \" \")\n            ], \" \");\n        }\n    },\n    ObjectTypeExtension: {\n        leave: (param)=>{\n            let { name, interfaces, directives, fields } = param;\n            return join([\n                \"extend type\",\n                name,\n                wrap(\"implements \", join(interfaces, \" & \")),\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    },\n    InterfaceTypeExtension: {\n        leave: (param)=>{\n            let { name, interfaces, directives, fields } = param;\n            return join([\n                \"extend interface\",\n                name,\n                wrap(\"implements \", join(interfaces, \" & \")),\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    },\n    UnionTypeExtension: {\n        leave: (param)=>{\n            let { name, directives, types } = param;\n            return join([\n                \"extend union\",\n                name,\n                join(directives, \" \"),\n                wrap(\"= \", join(types, \" | \"))\n            ], \" \");\n        }\n    },\n    EnumTypeExtension: {\n        leave: (param)=>{\n            let { name, directives, values } = param;\n            return join([\n                \"extend enum\",\n                name,\n                join(directives, \" \"),\n                block(values)\n            ], \" \");\n        }\n    },\n    InputObjectTypeExtension: {\n        leave: (param)=>{\n            let { name, directives, fields } = param;\n            return join([\n                \"extend input\",\n                name,\n                join(directives, \" \"),\n                block(fields)\n            ], \" \");\n        }\n    }\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */ function join(maybeArray) {\n    let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    var _maybeArray$filter$jo;\n    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x)=>x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : \"\";\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */ function block(array) {\n    return wrap(\"{\\n\", indent(join(array, \"\\n\")), \"\\n}\");\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */ function wrap(start, maybeString) {\n    let end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n    return maybeString != null && maybeString !== \"\" ? start + maybeString + end : \"\";\n}\nfunction indent(str) {\n    return wrap(\"  \", str.replace(/\\n/g, \"\\n  \"));\n}\nfunction hasMultilineItems(maybeArray) {\n    var _maybeArray$some;\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    /* c8 ignore next */ return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str)=>str.includes(\"\\n\"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUQ7QUFDTDtBQUNWO0FBQ3RDOzs7Q0FHQyxHQUVNLFNBQVNHLE1BQU1DLEdBQUc7SUFDdkIsT0FBT0YsbURBQUtBLENBQUNFLEtBQUtDO0FBQ3BCO0FBQ0EsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1ELHFCQUFxQjtJQUN6QkUsTUFBTTtRQUNKQyxPQUFPLENBQUNDLE9BQVNBLEtBQUtDLEtBQUs7SUFDN0I7SUFDQUMsVUFBVTtRQUNSSCxPQUFPLENBQUNDLE9BQVMsTUFBTUEsS0FBS0csSUFBSTtJQUNsQztJQUNBLFdBQVc7SUFDWEMsVUFBVTtRQUNSTCxPQUFPLENBQUNDLE9BQVNLLEtBQUtMLEtBQUtNLFdBQVcsRUFBRTtJQUMxQztJQUNBQyxxQkFBcUI7UUFDbkJSLE9BQU1DLElBQUk7WUFDUixNQUFNUSxVQUFVQyxLQUFLLEtBQUtKLEtBQUtMLEtBQUtVLG1CQUFtQixFQUFFLE9BQU87WUFDaEUsTUFBTUMsU0FBU04sS0FDYjtnQkFDRUwsS0FBS1ksU0FBUztnQkFDZFAsS0FBSztvQkFBQ0wsS0FBS0csSUFBSTtvQkFBRUs7aUJBQVE7Z0JBQ3pCSCxLQUFLTCxLQUFLYSxVQUFVLEVBQUU7YUFDdkIsRUFDRCxNQUNDLHVFQUF1RTtZQUMxRSx3QkFBd0I7WUFFeEIsT0FBTyxDQUFDRixXQUFXLFVBQVUsS0FBS0EsU0FBUyxHQUFFLElBQUtYLEtBQUtjLFlBQVk7UUFDckU7SUFDRjtJQUNBQyxvQkFBb0I7UUFDbEJoQixPQUFPO2dCQUFDLEVBQUVpQixRQUFRLEVBQUVDLElBQUksRUFBRUMsWUFBWSxFQUFFTCxVQUFVLEVBQUU7bUJBQ2xERyxXQUNBLE9BQ0FDLE9BQ0FSLEtBQUssT0FBT1MsZ0JBQ1pULEtBQUssS0FBS0osS0FBS1EsWUFBWTs7SUFDL0I7SUFDQU0sY0FBYztRQUNacEIsT0FBTztnQkFB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ZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50ZXIubWpzP2M5YzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJpbnRCbG9ja1N0cmluZyB9IGZyb20gJy4vYmxvY2tTdHJpbmcubWpzJztcbmltcG9ydCB7IHByaW50U3RyaW5nIH0gZnJvbSAnLi9wcmludFN0cmluZy5tanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuL3Zpc2l0b3IubWpzJztcbi8qKlxuICogQ29udmVydHMgYW4gQVNUIGludG8gYSBzdHJpbmcsIHVzaW5nIG9uZSBzZXQgb2YgcmVhc29uYWJsZVxuICogZm9ybWF0dGluZyBydWxlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiB2aXNpdChhc3QsIHByaW50RG9jQVNUUmVkdWNlcik7XG59XG5jb25zdCBNQVhfTElORV9MRU5HVEggPSA4MDtcbmNvbnN0IHByaW50RG9jQVNUUmVkdWNlciA9IHtcbiAgTmFtZToge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gbm9kZS52YWx1ZSxcbiAgfSxcbiAgVmFyaWFibGU6IHtcbiAgICBsZWF2ZTogKG5vZGUpID0+ICckJyArIG5vZGUubmFtZSxcbiAgfSxcbiAgLy8gRG9jdW1lbnRcbiAgRG9jdW1lbnQ6IHtcbiAgICBsZWF2ZTogKG5vZGUpID0+IGpvaW4obm9kZS5kZWZpbml0aW9ucywgJ1xcblxcbicpLFxuICB9LFxuICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgbGVhdmUobm9kZSkge1xuICAgICAgY29uc3QgdmFyRGVmcyA9IHdyYXAoJygnLCBqb2luKG5vZGUudmFyaWFibGVEZWZpbml0aW9ucywgJywgJyksICcpJyk7XG4gICAgICBjb25zdCBwcmVmaXggPSBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgbm9kZS5vcGVyYXRpb24sXG4gICAgICAgICAgam9pbihbbm9kZS5uYW1lLCB2YXJEZWZzXSksXG4gICAgICAgICAgam9pbihub2RlLmRpcmVjdGl2ZXMsICcgJyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICk7IC8vIEFub255bW91cyBxdWVyaWVzIHdpdGggbm8gZGlyZWN0aXZlcyBvciB2YXJpYWJsZSBkZWZpbml0aW9ucyBjYW4gdXNlXG4gICAgICAvLyB0aGUgcXVlcnkgc2hvcnQgZm9ybS5cblxuICAgICAgcmV0dXJuIChwcmVmaXggPT09ICdxdWVyeScgPyAnJyA6IHByZWZpeCArICcgJykgKyBub2RlLnNlbGVjdGlvblNldDtcbiAgICB9LFxuICB9LFxuICBWYXJpYWJsZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgdmFyaWFibGUsIHR5cGUsIGRlZmF1bHRWYWx1ZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgdmFyaWFibGUgK1xuICAgICAgJzogJyArXG4gICAgICB0eXBlICtcbiAgICAgIHdyYXAoJyA9ICcsIGRlZmF1bHRWYWx1ZSkgK1xuICAgICAgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSksXG4gIH0sXG4gIFNlbGVjdGlvblNldDoge1xuICAgIGxlYXZlOiAoeyBzZWxlY3Rpb25zIH0pID0+IGJsb2NrKHNlbGVjdGlvbnMpLFxuICB9LFxuICBGaWVsZDoge1xuICAgIGxlYXZlKHsgYWxpYXMsIG5hbWUsIGFyZ3VtZW50czogYXJncywgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHdyYXAoJycsIGFsaWFzLCAnOiAnKSArIG5hbWU7XG4gICAgICBsZXQgYXJnc0xpbmUgPSBwcmVmaXggKyB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKTtcblxuICAgICAgaWYgKGFyZ3NMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgICBhcmdzTGluZSA9IHByZWZpeCArIHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gam9pbihbYXJnc0xpbmUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgc2VsZWN0aW9uU2V0XSwgJyAnKTtcbiAgICB9LFxuICB9LFxuICBBcmd1bWVudDoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBuYW1lICsgJzogJyArIHZhbHVlLFxuICB9LFxuICAvLyBGcmFnbWVudHNcbiAgRnJhZ21lbnRTcHJlYWQ6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgJy4uLicgKyBuYW1lICsgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSksXG4gIH0sXG4gIElubGluZUZyYWdtZW50OiB7XG4gICAgbGVhdmU6ICh7IHR5cGVDb25kaXRpb24sIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICcuLi4nLFxuICAgICAgICAgIHdyYXAoJ29uICcsIHR5cGVDb25kaXRpb24pLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQsXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoXG4gICAgICB7IG5hbWUsIHR5cGVDb25kaXRpb24sIHZhcmlhYmxlRGVmaW5pdGlvbnMsIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCB9LCAvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZXhwZXJpbWVudGFsIGFuZCBtYXkgYmUgY2hhbmdlZFxuICAgICkgPT5cbiAgICAgIC8vIG9yIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIGBmcmFnbWVudCAke25hbWV9JHt3cmFwKCcoJywgam9pbih2YXJpYWJsZURlZmluaXRpb25zLCAnLCAnKSwgJyknKX0gYCArXG4gICAgICBgb24gJHt0eXBlQ29uZGl0aW9ufSAke3dyYXAoJycsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgJyAnKX1gICtcbiAgICAgIHNlbGVjdGlvblNldCxcbiAgfSxcbiAgLy8gVmFsdWVcbiAgSW50VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWUsXG4gIH0sXG4gIEZsb2F0VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWUsXG4gIH0sXG4gIFN0cmluZ1ZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlLCBibG9jazogaXNCbG9ja1N0cmluZyB9KSA9PlxuICAgICAgaXNCbG9ja1N0cmluZyA/IHByaW50QmxvY2tTdHJpbmcodmFsdWUpIDogcHJpbnRTdHJpbmcodmFsdWUpLFxuICB9LFxuICBCb29sZWFuVmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gKHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyksXG4gIH0sXG4gIE51bGxWYWx1ZToge1xuICAgIGxlYXZlOiAoKSA9PiAnbnVsbCcsXG4gIH0sXG4gIEVudW1WYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSxcbiAgfSxcbiAgTGlzdFZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlcyB9KSA9PiAnWycgKyBqb2luKHZhbHVlcywgJywgJykgKyAnXScsXG4gIH0sXG4gIE9iamVjdFZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IGZpZWxkcyB9KSA9PiAneycgKyBqb2luKGZpZWxkcywgJywgJykgKyAnfScsXG4gIH0sXG4gIE9iamVjdEZpZWxkOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIHZhbHVlIH0pID0+IG5hbWUgKyAnOiAnICsgdmFsdWUsXG4gIH0sXG4gIC8vIERpcmVjdGl2ZVxuICBEaXJlY3RpdmU6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0pID0+XG4gICAgICAnQCcgKyBuYW1lICsgd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJyksXG4gIH0sXG4gIC8vIFR5cGVcbiAgTmFtZWRUeXBlOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUgfSkgPT4gbmFtZSxcbiAgfSxcbiAgTGlzdFR5cGU6IHtcbiAgICBsZWF2ZTogKHsgdHlwZSB9KSA9PiAnWycgKyB0eXBlICsgJ10nLFxuICB9LFxuICBOb25OdWxsVHlwZToge1xuICAgIGxlYXZlOiAoeyB0eXBlIH0pID0+IHR5cGUgKyAnIScsXG4gIH0sXG4gIC8vIFR5cGUgU3lzdGVtIERlZmluaXRpb25zXG4gIFNjaGVtYURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIGRpcmVjdGl2ZXMsIG9wZXJhdGlvblR5cGVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oWydzY2hlbWEnLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKG9wZXJhdGlvblR5cGVzKV0sICcgJyksXG4gIH0sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IG9wZXJhdGlvbiwgdHlwZSB9KSA9PiBvcGVyYXRpb24gKyAnOiAnICsgdHlwZSxcbiAgfSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihbJ3NjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBGaWVsZERlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGFyZ3VtZW50czogYXJncywgdHlwZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBuYW1lICtcbiAgICAgIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKVxuICAgICAgICA/IHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpXG4gICAgICAgIDogd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJykpICtcbiAgICAgICc6ICcgK1xuICAgICAgdHlwZSArXG4gICAgICB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKSxcbiAgfSxcbiAgSW5wdXRWYWx1ZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIHR5cGUsIGRlZmF1bHRWYWx1ZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFxuICAgICAgICBbbmFtZSArICc6ICcgKyB0eXBlLCB3cmFwKCc9ICcsIGRlZmF1bHRWYWx1ZSksIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICdpbnRlcmZhY2UnLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIGJsb2NrKGZpZWxkcyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIHR5cGVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oXG4gICAgICAgIFsndW5pb24nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHdyYXAoJz0gJywgam9pbih0eXBlcywgJyB8ICcpKV0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEVudW1UeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcywgdmFsdWVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oWydlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKSxcbiAgfSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArIGpvaW4oW25hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFsnaW5wdXQnLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpLFxuICB9LFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MsIHJlcGVhdGFibGUsIGxvY2F0aW9ucyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICAnZGlyZWN0aXZlIEAnICtcbiAgICAgIG5hbWUgK1xuICAgICAgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpXG4gICAgICAgID8gd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJylcbiAgICAgICAgOiB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSkgK1xuICAgICAgKHJlcGVhdGFibGUgPyAnIHJlcGVhdGFibGUnIDogJycpICtcbiAgICAgICcgb24gJyArXG4gICAgICBqb2luKGxvY2F0aW9ucywgJyB8ICcpLFxuICB9LFxuICBTY2hlbWFFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgZGlyZWN0aXZlcywgb3BlcmF0aW9uVHlwZXMgfSkgPT5cbiAgICAgIGpvaW4oXG4gICAgICAgIFsnZXh0ZW5kIHNjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgU2NhbGFyVHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICBqb2luKFsnZXh0ZW5kIHNjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIE9iamVjdFR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+XG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJ2V4dGVuZCB0eXBlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICdleHRlbmQgaW50ZXJmYWNlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBVbmlvblR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcywgdHlwZXMgfSkgPT5cbiAgICAgIGpvaW4oXG4gICAgICAgIFtcbiAgICAgICAgICAnZXh0ZW5kIHVuaW9uJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICB3cmFwKCc9ICcsIGpvaW4odHlwZXMsICcgfCAnKSksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIHZhbHVlcyB9KSA9PlxuICAgICAgam9pbihbJ2V4dGVuZCBlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKSxcbiAgfSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgam9pbihbJ2V4dGVuZCBpbnB1dCcsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyksXG4gIH0sXG59O1xuLyoqXG4gKiBHaXZlbiBtYXliZUFycmF5LCBwcmludCBhbiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgbnVsbCBvciBlbXB0eSwgb3RoZXJ3aXNlXG4gKiBwcmludCBhbGwgaXRlbXMgdG9nZXRoZXIgc2VwYXJhdGVkIGJ5IHNlcGFyYXRvciBpZiBwcm92aWRlZFxuICovXG5cbmZ1bmN0aW9uIGpvaW4obWF5YmVBcnJheSwgc2VwYXJhdG9yID0gJycpIHtcbiAgdmFyIF9tYXliZUFycmF5JGZpbHRlciRqbztcblxuICByZXR1cm4gKF9tYXliZUFycmF5JGZpbHRlciRqbyA9XG4gICAgbWF5YmVBcnJheSA9PT0gbnVsbCB8fCBtYXliZUFycmF5ID09PSB2b2lkIDBcbiAgICAgID8gdm9pZCAwXG4gICAgICA6IG1heWJlQXJyYXkuZmlsdGVyKCh4KSA9PiB4KS5qb2luKHNlcGFyYXRvcikpICE9PSBudWxsICYmXG4gICAgX21heWJlQXJyYXkkZmlsdGVyJGpvICE9PSB2b2lkIDBcbiAgICA/IF9tYXliZUFycmF5JGZpbHRlciRqb1xuICAgIDogJyc7XG59XG4vKipcbiAqIEdpdmVuIGFycmF5LCBwcmludCBlYWNoIGl0ZW0gb24gaXRzIG93biBsaW5lLCB3cmFwcGVkIGluIGFuIGluZGVudGVkIGB7IH1gIGJsb2NrLlxuICovXG5cbmZ1bmN0aW9uIGJsb2NrKGFycmF5KSB7XG4gIHJldHVybiB3cmFwKCd7XFxuJywgaW5kZW50KGpvaW4oYXJyYXksICdcXG4nKSksICdcXG59Jyk7XG59XG4vKipcbiAqIElmIG1heWJlU3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LCB0aGVuIHdyYXAgd2l0aCBzdGFydCBhbmQgZW5kLCBvdGhlcndpc2UgcHJpbnQgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nLCBlbmQgPSAnJykge1xuICByZXR1cm4gbWF5YmVTdHJpbmcgIT0gbnVsbCAmJiBtYXliZVN0cmluZyAhPT0gJydcbiAgICA/IHN0YXJ0ICsgbWF5YmVTdHJpbmcgKyBlbmRcbiAgICA6ICcnO1xufVxuXG5mdW5jdGlvbiBpbmRlbnQoc3RyKSB7XG4gIHJldHVybiB3cmFwKCcgICcsIHN0ci5yZXBsYWNlKC9cXG4vZywgJ1xcbiAgJykpO1xufVxuXG5mdW5jdGlvbiBoYXNNdWx0aWxpbmVJdGVtcyhtYXliZUFycmF5KSB7XG4gIHZhciBfbWF5YmVBcnJheSRzb21lO1xuXG4gIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMjAzXG5cbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIChfbWF5YmVBcnJheSRzb21lID1cbiAgICBtYXliZUFycmF5ID09PSBudWxsIHx8IG1heWJlQXJyYXkgPT09IHZvaWQgMFxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogbWF5YmVBcnJheS5zb21lKChzdHIpID0+IHN0ci5pbmNsdWRlcygnXFxuJykpKSAhPT0gbnVsbCAmJlxuICAgIF9tYXliZUFycmF5JHNvbWUgIT09IHZvaWQgMFxuICAgID8gX21heWJlQXJyYXkkc29tZVxuICAgIDogZmFsc2U7XG59XG4iXSwibmFtZXMiOlsicHJpbnRCbG9ja1N0cmluZyIsInByaW50U3RyaW5nIiwidmlzaXQiLCJwcmludCIsImFzdCIsInByaW50RG9jQVNUUmVkdWNlciIsIk1BWF9MSU5FX0xFTkdUSCIsIk5hbWUiLCJsZWF2ZSIsIm5vZGUiLCJ2YWx1ZSIsIlZhcmlhYmxlIiwibmFtZSIsIkRvY3VtZW50Iiwiam9pbiIsImRlZmluaXRpb25zIiwiT3BlcmF0aW9uRGVmaW5pdGlvbiIsInZhckRlZnMiLCJ3cmFwIiwidmFyaWFibGVEZWZpbml0aW9ucyIsInByZWZpeCIsIm9wZXJhdGlvbiIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiLCJWYXJpYWJsZURlZmluaXRpb24iLCJ2YXJpYWJsZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJTZWxlY3Rpb25TZXQiLCJzZWxlY3Rpb25zIiwiYmxvY2siLCJGaWVsZCIsImFsaWFzIiwiYXJndW1lbnRzIiwiYXJncyIsImFyZ3NMaW5lIiwibGVuZ3RoIiwiaW5kZW50IiwiQXJndW1lbnQiLCJGcmFnbWVudFNwcmVhZCIsIklubGluZUZyYWdtZW50IiwidHlwZUNvbmRpdGlvbiIsIkZyYWdtZW50RGVmaW5pdGlvbiIsIkludFZhbHVlIiwiRmxvYXRWYWx1ZSIsIlN0cmluZ1ZhbHVlIiwiaXNCbG9ja1N0cmluZyIsIkJvb2xlYW5WYWx1ZSIsIk51bGxWYWx1ZSIsIkVudW1WYWx1ZSIsIkxpc3RWYWx1ZSIsInZhbHVlcyIsIk9iamVjdFZhbHVlIiwiZmllbGRzIiwiT2JqZWN0RmllbGQiLCJEaXJlY3RpdmUiLCJOYW1lZFR5cGUiLCJMaXN0VHlwZSIsIk5vbk51bGxUeXBlIiwiU2NoZW1hRGVmaW5pdGlvbiIsImRlc2NyaXB0aW9uIiwib3BlcmF0aW9uVHlwZXMiLCJPcGVyYXRpb25UeXBlRGVmaW5pdGlvbiIsIlNjYWxhclR5cGVEZWZpbml0aW9uIiwiT2JqZWN0VHlwZURlZmluaXRpb24iLCJpbnRlcmZhY2VzIiwiRmllbGREZWZpbml0aW9uIiwiaGFzTXVsdGlsaW5lSXRlbXMiLCJJbnB1dFZhbHVlRGVmaW5pdGlvbiIsIkludGVyZmFjZVR5cGVEZWZpbml0aW9uIiwiVW5pb25UeXBlRGVmaW5pdGlvbiIsInR5cGVzIiwiRW51bVR5cGVEZWZpbml0aW9uIiwiRW51bVZhbHVlRGVmaW5pdGlvbiIsIklucHV0T2JqZWN0VHlwZURlZmluaXRpb24iLCJEaXJlY3RpdmVEZWZpbml0aW9uIiwicmVwZWF0YWJsZSIsImxvY2F0aW9ucyIsIlNjaGVtYUV4dGVuc2lvbiIsIlNjYWxhclR5cGVFeHRlbnNpb24iLCJPYmplY3RUeXBlRXh0ZW5zaW9uIiwiSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiIsIlVuaW9uVHlwZUV4dGVuc2lvbiIsIkVudW1UeXBlRXh0ZW5zaW9uIiwiSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIiwibWF5YmVBcnJheSIsInNlcGFyYXRvciIsIl9tYXliZUFycmF5JGZpbHRlciRqbyIsImZpbHRlciIsIngiLCJhcnJheSIsInN0YXJ0IiwibWF5YmVTdHJpbmciLCJlbmQiLCJzdHIiLCJyZXBsYWNlIiwiX21heWJlQXJyYXkkc29tZSIsInNvbWUiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/printer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/visitor.mjs":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/visitor.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BREAK: function() { return /* binding */ BREAK; },\n/* harmony export */   getEnterLeaveForKind: function() { return /* binding */ getEnterLeaveForKind; },\n/* harmony export */   getVisitFn: function() { return /* binding */ getVisitFn; },\n/* harmony export */   visit: function() { return /* binding */ visit; },\n/* harmony export */   visitInParallel: function() { return /* binding */ visitInParallel; }\n/* harmony export */ });\n/* harmony import */ var _jsutils_devAssert_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../jsutils/devAssert.mjs */ \"(app-pages-browser)/./node_modules/graphql/jsutils/devAssert.mjs\");\n/* harmony import */ var _jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../jsutils/inspect.mjs */ \"(app-pages-browser)/./node_modules/graphql/jsutils/inspect.mjs\");\n/* harmony import */ var _ast_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/ast.mjs\");\n/* harmony import */ var _kinds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kinds.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n\n\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */ const BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */ function visit(root, visitor) {\n    let visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _ast_mjs__WEBPACK_IMPORTED_MODULE_0__.QueryDocumentKeys;\n    const enterLeaveMap = new Map();\n    for (const kind of Object.values(_kinds_mjs__WEBPACK_IMPORTED_MODULE_1__.Kind)){\n        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n    }\n    /* eslint-disable no-undef-init */ let stack = undefined;\n    let inArray = Array.isArray(root);\n    let keys = [\n        root\n    ];\n    let index = -1;\n    let edits = [];\n    let node = root;\n    let key = undefined;\n    let parent = undefined;\n    const path = [];\n    const ancestors = [];\n    /* eslint-enable no-undef-init */ do {\n        index++;\n        const isLeaving = index === keys.length;\n        const isEdited = isLeaving && edits.length !== 0;\n        if (isLeaving) {\n            key = ancestors.length === 0 ? undefined : path[path.length - 1];\n            node = parent;\n            parent = ancestors.pop();\n            if (isEdited) {\n                if (inArray) {\n                    node = node.slice();\n                    let editOffset = 0;\n                    for (const [editKey, editValue] of edits){\n                        const arrayKey = editKey - editOffset;\n                        if (editValue === null) {\n                            node.splice(arrayKey, 1);\n                            editOffset++;\n                        } else {\n                            node[arrayKey] = editValue;\n                        }\n                    }\n                } else {\n                    node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));\n                    for (const [editKey, editValue] of edits){\n                        node[editKey] = editValue;\n                    }\n                }\n            }\n            index = stack.index;\n            keys = stack.keys;\n            edits = stack.edits;\n            inArray = stack.inArray;\n            stack = stack.prev;\n        } else if (parent) {\n            key = inArray ? index : keys[index];\n            node = parent[key];\n            if (node === null || node === undefined) {\n                continue;\n            }\n            path.push(key);\n        }\n        let result;\n        if (!Array.isArray(node)) {\n            var _enterLeaveMap$get, _enterLeaveMap$get2;\n            (0,_ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(node) || (0,_jsutils_devAssert_mjs__WEBPACK_IMPORTED_MODULE_2__.devAssert)(false, \"Invalid AST Node: \".concat((0,_jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_3__.inspect)(node), \".\"));\n            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n            if (result === BREAK) {\n                break;\n            }\n            if (result === false) {\n                if (!isLeaving) {\n                    path.pop();\n                    continue;\n                }\n            } else if (result !== undefined) {\n                edits.push([\n                    key,\n                    result\n                ]);\n                if (!isLeaving) {\n                    if ((0,_ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(result)) {\n                        node = result;\n                    } else {\n                        path.pop();\n                        continue;\n                    }\n                }\n            }\n        }\n        if (result === undefined && isEdited) {\n            edits.push([\n                key,\n                node\n            ]);\n        }\n        if (isLeaving) {\n            path.pop();\n        } else {\n            var _node$kind;\n            stack = {\n                inArray,\n                index,\n                keys,\n                edits,\n                prev: stack\n            };\n            inArray = Array.isArray(node);\n            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n            index = -1;\n            edits = [];\n            if (parent) {\n                ancestors.push(parent);\n            }\n            parent = node;\n        }\n    }while (stack !== undefined);\n    if (edits.length !== 0) {\n        // New root\n        return edits[edits.length - 1][1];\n    }\n    return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */ function visitInParallel(visitors) {\n    const skipping = new Array(visitors.length).fill(null);\n    const mergedVisitor = Object.create(null);\n    for (const kind of Object.values(_kinds_mjs__WEBPACK_IMPORTED_MODULE_1__.Kind)){\n        let hasVisitor = false;\n        const enterList = new Array(visitors.length).fill(undefined);\n        const leaveList = new Array(visitors.length).fill(undefined);\n        for(let i = 0; i < visitors.length; ++i){\n            const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n            hasVisitor || (hasVisitor = enter != null || leave != null);\n            enterList[i] = enter;\n            leaveList[i] = leave;\n        }\n        if (!hasVisitor) {\n            continue;\n        }\n        const mergedEnterLeave = {\n            enter () {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const node = args[0];\n                for(let i = 0; i < visitors.length; i++){\n                    if (skipping[i] === null) {\n                        var _enterList$i;\n                        const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);\n                        if (result === false) {\n                            skipping[i] = node;\n                        } else if (result === BREAK) {\n                            skipping[i] = BREAK;\n                        } else if (result !== undefined) {\n                            return result;\n                        }\n                    }\n                }\n            },\n            leave () {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const node = args[0];\n                for(let i = 0; i < visitors.length; i++){\n                    if (skipping[i] === null) {\n                        var _leaveList$i;\n                        const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);\n                        if (result === BREAK) {\n                            skipping[i] = BREAK;\n                        } else if (result !== undefined && result !== false) {\n                            return result;\n                        }\n                    } else if (skipping[i] === node) {\n                        skipping[i] = null;\n                    }\n                }\n            }\n        };\n        mergedVisitor[kind] = mergedEnterLeave;\n    }\n    return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */ function getEnterLeaveForKind(visitor, kind) {\n    const kindVisitor = visitor[kind];\n    if (typeof kindVisitor === \"object\") {\n        // { Kind: { enter() {}, leave() {} } }\n        return kindVisitor;\n    } else if (typeof kindVisitor === \"function\") {\n        // { Kind() {} }\n        return {\n            enter: kindVisitor,\n            leave: undefined\n        };\n    } // { enter() {}, leave() {} }\n    return {\n        enter: visitor.enter,\n        leave: visitor.leave\n    };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */ /* c8 ignore next 8 */ function getVisitFn(visitor, kind, isLeaving) {\n    const { enter, leave } = getEnterLeaveForKind(visitor, kind);\n    return isLeaving ? leave : enter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNKO0FBQ0s7QUFDbkI7QUFDbkM7OztDQUdDLEdBRU0sTUFBTUssUUFBUUMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRztBQUN2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2RUMsR0FFTSxTQUFTQyxNQUFNQyxJQUFJLEVBQUVDLE9BQU87UUFBRUMsY0FBQUEsaUVBQWNSLHVEQUFpQkE7SUFDbEUsTUFBTVMsZ0JBQWdCLElBQUlDO0lBRTFCLEtBQUssTUFBTUMsUUFBUVIsT0FBT1MsTUFBTSxDQUFDWCw0Q0FBSUEsRUFBRztRQUN0Q1EsY0FBY0ksR0FBRyxDQUFDRixNQUFNRyxxQkFBcUJQLFNBQVNJO0lBQ3hEO0lBQ0EsZ0NBQWdDLEdBRWhDLElBQUlJLFFBQVFDO0lBQ1osSUFBSUMsVUFBVUMsTUFBTUMsT0FBTyxDQUFDYjtJQUM1QixJQUFJYyxPQUFPO1FBQUNkO0tBQUs7SUFDakIsSUFBSWUsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsUUFBUSxFQUFFO0lBQ2QsSUFBSUMsT0FBT2pCO0lBQ1gsSUFBSWtCLE1BQU1SO0lBQ1YsSUFBSVMsU0FBU1Q7SUFDYixNQUFNVSxPQUFPLEVBQUU7SUFDZixNQUFNQyxZQUFZLEVBQUU7SUFDcEIsK0JBQStCLEdBRS9CLEdBQUc7UUFDRE47UUFDQSxNQUFNTyxZQUFZUCxVQUFVRCxLQUFLUyxNQUFNO1FBQ3ZDLE1BQU1DLFdBQVdGLGFBQWFOLE1BQU1PLE1BQU0sS0FBSztRQUUvQyxJQUFJRCxXQUFXO1lBQ2JKLE1BQU1HLFVBQVVFLE1BQU0sS0FBSyxJQUFJYixZQUFZVSxJQUFJLENBQUNBLEtBQUtHLE1BQU0sR0FBRyxFQUFFO1lBQ2hFTixPQUFPRTtZ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QUFJd0MsV0FBVzFCLGFBQWEwQixXQUFXLE9BQU87NEJBQ25ELE9BQU9BO3dCQUNUO29CQUNGLE9BQU8sSUFBSVcsUUFBUSxDQUFDTyxFQUFFLEtBQUtyQyxNQUFNO3dCQUMvQjhCLFFBQVEsQ0FBQ08sRUFBRSxHQUFHO29CQUNoQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQUwsYUFBYSxDQUFDNUMsS0FBSyxHQUFHa0Q7SUFDeEI7SUFFQSxPQUFPTjtBQUNUO0FBQ0E7O0NBRUMsR0FFTSxTQUFTekMscUJBQXFCUCxPQUFPLEVBQUVJLElBQUk7SUFDaEQsTUFBTXVELGNBQWMzRCxPQUFPLENBQUNJLEtBQUs7SUFFakMsSUFBSSxPQUFPdUQsZ0JBQWdCLFVBQVU7UUFDbkMsdUNBQXVDO1FBQ3ZDLE9BQU9BO0lBQ1QsT0FBTyxJQUFJLE9BQU9BLGdCQUFnQixZQUFZO1FBQzVDLGdCQUFnQjtRQUNoQixPQUFPO1lBQ0xsQixPQUFPa0I7WUFDUG5CLE9BQU8vQjtRQUNUO0lBQ0YsRUFBRSw2QkFBNkI7SUFFL0IsT0FBTztRQUNMZ0MsT0FBT3pDLFFBQVF5QyxLQUFLO1FBQ3BCRCxPQUFPeEMsUUFBUXdDLEtBQUs7SUFDdEI7QUFDRjtBQUNBOzs7OztDQUtDLEdBRUQsb0JBQW9CLEdBRWIsU0FBU29CLFdBQVc1RCxPQUFPLEVBQUVJLElBQUksRUFBRWlCLFNBQVM7SUFDakQsTUFBTSxFQUFFb0IsS0FBSyxFQUFFRCxLQUFLLEVBQUUsR0FBR2pDLHFCQUFxQlAsU0FBU0k7SUFDdkQsT0FBT2lCLFlBQVltQixRQUFRQztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS92aXNpdG9yLm1qcz8zYTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRldkFzc2VydCB9IGZyb20gJy4uL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qcyc7XG5pbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnLi4vanN1dGlscy9pbnNwZWN0Lm1qcyc7XG5pbXBvcnQgeyBpc05vZGUsIFF1ZXJ5RG9jdW1lbnRLZXlzIH0gZnJvbSAnLi9hc3QubWpzJztcbmltcG9ydCB7IEtpbmQgfSBmcm9tICcuL2tpbmRzLm1qcyc7XG4vKipcbiAqIEEgdmlzaXRvciBpcyBwcm92aWRlZCB0byB2aXNpdCwgaXQgY29udGFpbnMgdGhlIGNvbGxlY3Rpb24gb2ZcbiAqIHJlbGV2YW50IGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB2aXNpdG9yJ3MgdHJhdmVyc2FsLlxuICovXG5cbmV4cG9ydCBjb25zdCBCUkVBSyA9IE9iamVjdC5mcmVlemUoe30pO1xuLyoqXG4gKiB2aXNpdCgpIHdpbGwgd2FsayB0aHJvdWdoIGFuIEFTVCB1c2luZyBhIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCwgY2FsbGluZ1xuICogdGhlIHZpc2l0b3IncyBlbnRlciBmdW5jdGlvbiBhdCBlYWNoIG5vZGUgaW4gdGhlIHRyYXZlcnNhbCwgYW5kIGNhbGxpbmcgdGhlXG4gKiBsZWF2ZSBmdW5jdGlvbiBhZnRlciB2aXNpdGluZyB0aGF0IG5vZGUgYW5kIGFsbCBvZiBpdHMgY2hpbGQgbm9kZXMuXG4gKlxuICogQnkgcmV0dXJuaW5nIGRpZmZlcmVudCB2YWx1ZXMgZnJvbSB0aGUgZW50ZXIgYW5kIGxlYXZlIGZ1bmN0aW9ucywgdGhlXG4gKiBiZWhhdmlvciBvZiB0aGUgdmlzaXRvciBjYW4gYmUgYWx0ZXJlZCwgaW5jbHVkaW5nIHNraXBwaW5nIG92ZXIgYSBzdWItdHJlZSBvZlxuICogdGhlIEFTVCAoYnkgcmV0dXJuaW5nIGZhbHNlKSwgZWRpdGluZyB0aGUgQVNUIGJ5IHJldHVybmluZyBhIHZhbHVlIG9yIG51bGxcbiAqIHRvIHJlbW92ZSB0aGUgdmFsdWUsIG9yIHRvIHN0b3AgdGhlIHdob2xlIHRyYXZlcnNhbCBieSByZXR1cm5pbmcgQlJFQUsuXG4gKlxuICogV2hlbiB1c2luZyB2aXNpdCgpIHRvIGVkaXQgYW4gQVNULCB0aGUgb3JpZ2luYWwgQVNUIHdpbGwgbm90IGJlIG1vZGlmaWVkLCBhbmRcbiAqIGEgbmV3IHZlcnNpb24gb2YgdGhlIEFTVCB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZVxuICogdmlzaXQgZnVuY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGVkaXRlZEFTVCA9IHZpc2l0KGFzdCwge1xuICogICBlbnRlcihub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKSB7XG4gKiAgICAgLy8gQHJldHVyblxuICogICAgIC8vICAgdW5kZWZpbmVkOiBubyBhY3Rpb25cbiAqICAgICAvLyAgIGZhbHNlOiBza2lwIHZpc2l0aW5nIHRoaXMgbm9kZVxuICogICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgIH0sXG4gKiAgIGxlYXZlKG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpIHtcbiAqICAgICAvLyBAcmV0dXJuXG4gKiAgICAgLy8gICB1bmRlZmluZWQ6IG5vIGFjdGlvblxuICogICAgIC8vICAgZmFsc2U6IG5vIGFjdGlvblxuICogICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQWx0ZXJuYXRpdmVseSB0byBwcm92aWRpbmcgZW50ZXIoKSBhbmQgbGVhdmUoKSBmdW5jdGlvbnMsIGEgdmlzaXRvciBjYW5cbiAqIGluc3RlYWQgcHJvdmlkZSBmdW5jdGlvbnMgbmFtZWQgdGhlIHNhbWUgYXMgdGhlIGtpbmRzIG9mIEFTVCBub2Rlcywgb3JcbiAqIGVudGVyL2xlYXZlIHZpc2l0b3JzIGF0IGEgbmFtZWQga2V5LCBsZWFkaW5nIHRvIHRocmVlIHBlcm11dGF0aW9ucyBvZiB0aGVcbiAqIHZpc2l0b3IgQVBJOlxuICpcbiAqIDEpIE5hbWVkIHZpc2l0b3JzIHRyaWdnZXJlZCB3aGVuIGVudGVyaW5nIGEgbm9kZSBvZiBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogYGBgdHNcbiAqIHZpc2l0KGFzdCwge1xuICogICBLaW5kKG5vZGUpIHtcbiAqICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogMikgTmFtZWQgdmlzaXRvcnMgdGhhdCB0cmlnZ2VyIHVwb24gZW50ZXJpbmcgYW5kIGxlYXZpbmcgYSBub2RlIG9mIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiBgYGB0c1xuICogdmlzaXQoYXN0LCB7XG4gKiAgIEtpbmQ6IHtcbiAqICAgICBlbnRlcihub2RlKSB7XG4gKiAgICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgIH1cbiAqICAgICBsZWF2ZShub2RlKSB7XG4gKiAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIDMpIEdlbmVyaWMgdmlzaXRvcnMgdGhhdCB0cmlnZ2VyIHVwb24gZW50ZXJpbmcgYW5kIGxlYXZpbmcgYW55IG5vZGUuXG4gKlxuICogYGBgdHNcbiAqIHZpc2l0KGFzdCwge1xuICogICBlbnRlcihub2RlKSB7XG4gKiAgICAgLy8gZW50ZXIgYW55IG5vZGVcbiAqICAgfSxcbiAqICAgbGVhdmUobm9kZSkge1xuICogICAgIC8vIGxlYXZlIGFueSBub2RlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvciwgdmlzaXRvcktleXMgPSBRdWVyeURvY3VtZW50S2V5cykge1xuICBjb25zdCBlbnRlckxlYXZlTWFwID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3Qga2luZCBvZiBPYmplY3QudmFsdWVzKEtpbmQpKSB7XG4gICAgZW50ZXJMZWF2ZU1hcC5zZXQoa2luZCwgZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCkpO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLWluaXQgKi9cblxuICBsZXQgc3RhY2sgPSB1bmRlZmluZWQ7XG4gIGxldCBpbkFycmF5ID0gQXJyYXkuaXNBcnJheShyb290KTtcbiAgbGV0IGtleXMgPSBbcm9vdF07XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgZWRpdHMgPSBbXTtcbiAgbGV0IG5vZGUgPSByb290O1xuICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICBsZXQgcGFyZW50ID0gdW5kZWZpbmVkO1xuICBjb25zdCBwYXRoID0gW107XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmLWluaXQgKi9cblxuICBkbyB7XG4gICAgaW5kZXgrKztcbiAgICBjb25zdCBpc0xlYXZpbmcgPSBpbmRleCA9PT0ga2V5cy5sZW5ndGg7XG4gICAgY29uc3QgaXNFZGl0ZWQgPSBpc0xlYXZpbmcgJiYgZWRpdHMubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAga2V5ID0gYW5jZXN0b3JzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBhbmNlc3RvcnMucG9wKCk7XG5cbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgICAgbGV0IGVkaXRPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBbZWRpdEtleSwgZWRpdFZhbHVlXSBvZiBlZGl0cykge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlLZXkgPSBlZGl0S2V5IC0gZWRpdE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKGVkaXRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBub2RlLnNwbGljZShhcnJheUtleSwgMSk7XG4gICAgICAgICAgICAgIGVkaXRPZmZzZXQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGVbYXJyYXlLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtlZGl0S2V5LCBlZGl0VmFsdWVdIG9mIGVkaXRzKSB7XG4gICAgICAgICAgICBub2RlW2VkaXRLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIGtleSA9IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdO1xuICAgICAgbm9kZSA9IHBhcmVudFtrZXldO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIHZhciBfZW50ZXJMZWF2ZU1hcCRnZXQsIF9lbnRlckxlYXZlTWFwJGdldDI7XG5cbiAgICAgIGlzTm9kZShub2RlKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGBJbnZhbGlkIEFTVCBOb2RlOiAke2luc3BlY3Qobm9kZSl9LmApO1xuICAgICAgY29uc3QgdmlzaXRGbiA9IGlzTGVhdmluZ1xuICAgICAgICA/IChfZW50ZXJMZWF2ZU1hcCRnZXQgPSBlbnRlckxlYXZlTWFwLmdldChub2RlLmtpbmQpKSA9PT0gbnVsbCB8fFxuICAgICAgICAgIF9lbnRlckxlYXZlTWFwJGdldCA9PT0gdm9pZCAwXG4gICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICA6IF9lbnRlckxlYXZlTWFwJGdldC5sZWF2ZVxuICAgICAgICA6IChfZW50ZXJMZWF2ZU1hcCRnZXQyID0gZW50ZXJMZWF2ZU1hcC5nZXQobm9kZS5raW5kKSkgPT09IG51bGwgfHxcbiAgICAgICAgICBfZW50ZXJMZWF2ZU1hcCRnZXQyID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBfZW50ZXJMZWF2ZU1hcCRnZXQyLmVudGVyO1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgdmlzaXRGbiA9PT0gbnVsbCB8fCB2aXNpdEZuID09PSB2b2lkIDBcbiAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgIDogdmlzaXRGbi5jYWxsKHZpc2l0b3IsIG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkaXRzLnB1c2goW2tleSwgcmVzdWx0XSk7XG5cbiAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICBpZiAoaXNOb2RlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgaXNFZGl0ZWQpIHtcbiAgICAgIGVkaXRzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0xlYXZpbmcpIHtcbiAgICAgIHBhdGgucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbm9kZSRraW5kO1xuXG4gICAgICBzdGFjayA9IHtcbiAgICAgICAgaW5BcnJheSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGtleXMsXG4gICAgICAgIGVkaXRzLFxuICAgICAgICBwcmV2OiBzdGFjayxcbiAgICAgIH07XG4gICAgICBpbkFycmF5ID0gQXJyYXkuaXNBcnJheShub2RlKTtcbiAgICAgIGtleXMgPSBpbkFycmF5XG4gICAgICAgID8gbm9kZVxuICAgICAgICA6IChfbm9kZSRraW5kID0gdmlzaXRvcktleXNbbm9kZS5raW5kXSkgIT09IG51bGwgJiZcbiAgICAgICAgICBfbm9kZSRraW5kICE9PSB2b2lkIDBcbiAgICAgICAgPyBfbm9kZSRraW5kXG4gICAgICAgIDogW107XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgZWRpdHMgPSBbXTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBub2RlO1xuICAgIH1cbiAgfSB3aGlsZSAoc3RhY2sgIT09IHVuZGVmaW5lZCk7XG5cbiAgaWYgKGVkaXRzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIE5ldyByb290XG4gICAgcmV0dXJuIGVkaXRzW2VkaXRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmlzaXRvciBpbnN0YW5jZSB3aGljaCBkZWxlZ2F0ZXMgdG8gbWFueSB2aXNpdG9ycyB0byBydW4gaW5cbiAqIHBhcmFsbGVsLiBFYWNoIHZpc2l0b3Igd2lsbCBiZSB2aXNpdGVkIGZvciBlYWNoIG5vZGUgYmVmb3JlIG1vdmluZyBvbi5cbiAqXG4gKiBJZiBhIHByaW9yIHZpc2l0b3IgZWRpdHMgYSBub2RlLCBubyBmb2xsb3dpbmcgdmlzaXRvcnMgd2lsbCBzZWUgdGhhdCBub2RlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdEluUGFyYWxsZWwodmlzaXRvcnMpIHtcbiAgY29uc3Qgc2tpcHBpbmcgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBjb25zdCBtZXJnZWRWaXNpdG9yID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKGNvbnN0IGtpbmQgb2YgT2JqZWN0LnZhbHVlcyhLaW5kKSkge1xuICAgIGxldCBoYXNWaXNpdG9yID0gZmFsc2U7XG4gICAgY29uc3QgZW50ZXJMaXN0ID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICAgIGNvbnN0IGxlYXZlTGlzdCA9IG5ldyBBcnJheSh2aXNpdG9ycy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHsgZW50ZXIsIGxlYXZlIH0gPSBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yc1tpXSwga2luZCk7XG4gICAgICBoYXNWaXNpdG9yIHx8IChoYXNWaXNpdG9yID0gZW50ZXIgIT0gbnVsbCB8fCBsZWF2ZSAhPSBudWxsKTtcbiAgICAgIGVudGVyTGlzdFtpXSA9IGVudGVyO1xuICAgICAgbGVhdmVMaXN0W2ldID0gbGVhdmU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNWaXNpdG9yKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRFbnRlckxlYXZlID0ge1xuICAgICAgZW50ZXIoLi4uYXJncykge1xuICAgICAgICBjb25zdCBub2RlID0gYXJnc1swXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNraXBwaW5nW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2VudGVyTGlzdCRpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPVxuICAgICAgICAgICAgICAoX2VudGVyTGlzdCRpID0gZW50ZXJMaXN0W2ldKSA9PT0gbnVsbCB8fCBfZW50ZXJMaXN0JGkgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBfZW50ZXJMaXN0JGkuYXBwbHkodmlzaXRvcnNbaV0sIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlYXZlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChza2lwcGluZ1tpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9sZWF2ZUxpc3QkaTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgICAgICAgKF9sZWF2ZUxpc3QkaSA9IGxlYXZlTGlzdFtpXSkgPT09IG51bGwgfHwgX2xlYXZlTGlzdCRpID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgIDogX2xlYXZlTGlzdCRpLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcHBpbmdbaV0gPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHNraXBwaW5nW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgICBtZXJnZWRWaXNpdG9yW2tpbmRdID0gbWVyZ2VkRW50ZXJMZWF2ZTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZWRWaXNpdG9yO1xufVxuLyoqXG4gKiBHaXZlbiBhIHZpc2l0b3IgaW5zdGFuY2UgYW5kIGEgbm9kZSBraW5kLCByZXR1cm4gRW50ZXJMZWF2ZVZpc2l0b3IgZm9yIHRoYXQga2luZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCkge1xuICBjb25zdCBraW5kVmlzaXRvciA9IHZpc2l0b3Jba2luZF07XG5cbiAgaWYgKHR5cGVvZiBraW5kVmlzaXRvciA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyB7IEtpbmQ6IHsgZW50ZXIoKSB7fSwgbGVhdmUoKSB7fSB9IH1cbiAgICByZXR1cm4ga2luZFZpc2l0b3I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtpbmRWaXNpdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8geyBLaW5kKCkge30gfVxuICAgIHJldHVybiB7XG4gICAgICBlbnRlcjoga2luZFZpc2l0b3IsXG4gICAgICBsZWF2ZTogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gLy8geyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH1cblxuICByZXR1cm4ge1xuICAgIGVudGVyOiB2aXNpdG9yLmVudGVyLFxuICAgIGxlYXZlOiB2aXNpdG9yLmxlYXZlLFxuICB9O1xufVxuLyoqXG4gKiBHaXZlbiBhIHZpc2l0b3IgaW5zdGFuY2UsIGlmIGl0IGlzIGxlYXZpbmcgb3Igbm90LCBhbmQgYSBub2RlIGtpbmQsIHJldHVyblxuICogdGhlIGZ1bmN0aW9uIHRoZSB2aXNpdG9yIHJ1bnRpbWUgc2hvdWxkIGNhbGwuXG4gKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgZ2V0RW50ZXJMZWF2ZUZvcktpbmRgIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MTdcbiAqL1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA4ICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpdEZuKHZpc2l0b3IsIGtpbmQsIGlzTGVhdmluZykge1xuICBjb25zdCB7IGVudGVyLCBsZWF2ZSB9ID0gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCk7XG4gIHJldHVybiBpc0xlYXZpbmcgPyBsZWF2ZSA6IGVudGVyO1xufVxuIl0sIm5hbWVzIjpbImRldkFzc2VydCIsImluc3BlY3QiLCJpc05vZGUiLCJRdWVyeURvY3VtZW50S2V5cyIsIktpbmQiLCJCUkVBSyIsIk9iamVjdCIsImZyZWV6ZSIsInZpc2l0Iiwicm9vdCIsInZpc2l0b3IiLCJ2aXNpdG9yS2V5cyIsImVudGVyTGVhdmVNYXAiLCJNYXAiLCJraW5kIiwidmFsdWVzIiwic2V0IiwiZ2V0RW50ZXJMZWF2ZUZvcktpbmQiLCJzdGFjayIsInVuZGVmaW5lZCIsImluQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiaW5kZXgiLCJlZGl0cyIsIm5vZGUiLCJrZXkiLCJwYXJlbnQiLCJwYXRoIiwiYW5jZXN0b3JzIiwiaXNMZWF2aW5nIiwibGVuZ3RoIiwiaXNFZGl0ZWQiLCJwb3AiLCJzbGljZSIsImVkaXRPZmZzZXQiLCJlZGl0S2V5IiwiZWRpdFZhbHVlIiwiYXJyYXlLZXkiLCJzcGxpY2UiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInByZXYiLCJwdXNoIiwicmVzdWx0IiwiX2VudGVyTGVhdmVNYXAkZ2V0IiwiX2VudGVyTGVhdmVNYXAkZ2V0MiIsInZpc2l0Rm4iLCJnZXQiLCJsZWF2ZSIsImVudGVyIiwiY2FsbCIsIl9ub2RlJGtpbmQiLCJ2aXNpdEluUGFyYWxsZWwiLCJ2aXNpdG9ycyIsInNraXBwaW5nIiwiZmlsbCIsIm1lcmdlZFZpc2l0b3IiLCJjcmVhdGUiLCJoYXNWaXNpdG9yIiwiZW50ZXJMaXN0IiwibGVhdmVMaXN0IiwiaSIsIm1lcmdlZEVudGVyTGVhdmUiLCJhcmdzIiwiX2VudGVyTGlzdCRpIiwiYXBwbHkiLCJfbGVhdmVMaXN0JGkiLCJraW5kVmlzaXRvciIsImdldFZpc2l0Rm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/context.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/context.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: function() { return /* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot; },\n/* harmony export */   asyncFromGen: function() { return /* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.asyncFromGen; },\n/* harmony export */   bindContext: function() { return /* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.bind; },\n/* harmony export */   noContext: function() { return /* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.noContext; },\n/* harmony export */   nonReactive: function() { return /* binding */ nonReactive; },\n/* harmony export */   parentEntrySlot: function() { return /* binding */ parentEntrySlot; },\n/* harmony export */   setTimeout: function() { return /* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.setTimeout; }\n/* harmony export */ });\n/* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/context */ \"(app-pages-browser)/./node_modules/@wry/context/lib/index.js\");\n\nconst parentEntrySlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot();\nfunction nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\n\n //# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUM3QixNQUFNQyxrQkFBa0IsSUFBSUQsOENBQUlBLEdBQUc7QUFDbkMsU0FBU0UsWUFBWUMsRUFBRTtJQUMxQixPQUFPRixnQkFBZ0JHLFNBQVMsQ0FBQyxLQUFLLEdBQUdEO0FBQzdDO0FBQ2dCO0FBQ3lFLENBQ3pGLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2NvbnRleHQuanM/NjllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbG90IH0gZnJvbSBcIkB3cnkvY29udGV4dFwiO1xuZXhwb3J0IGNvbnN0IHBhcmVudEVudHJ5U2xvdCA9IG5ldyBTbG90KCk7XG5leHBvcnQgZnVuY3Rpb24gbm9uUmVhY3RpdmUoZm4pIHtcbiAgICByZXR1cm4gcGFyZW50RW50cnlTbG90LndpdGhWYWx1ZSh2b2lkIDAsIGZuKTtcbn1cbmV4cG9ydCB7IFNsb3QgfTtcbmV4cG9ydCB7IGJpbmQgYXMgYmluZENvbnRleHQsIG5vQ29udGV4dCwgc2V0VGltZW91dCwgYXN5bmNGcm9tR2VuLCB9IGZyb20gXCJAd3J5L2NvbnRleHRcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIlNsb3QiLCJwYXJlbnRFbnRyeVNsb3QiLCJub25SZWFjdGl2ZSIsImZuIiwid2l0aFZhbHVlIiwiYmluZCIsImJpbmRDb250ZXh0Iiwibm9Db250ZXh0Iiwic2V0VGltZW91dCIsImFzeW5jRnJvbUdlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/dep.js":
/*!******************************************!*\
  !*** ./node_modules/optimism/lib/dep.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dep: function() { return /* binding */ dep; }\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true\n};\nfunction dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = entryMethodName && _helpers_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(dep).forEach((entry)=>entry[m]());\n            depsByKey.delete(key);\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n        }\n    };\n    return depend;\n} //# sourceMappingURL=dep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvZGVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNnQztBQUMvRSxNQUFNSSxlQUFlO0lBQ2pCQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsUUFBUTtBQUNaO0FBQ08sU0FBU0MsSUFBSUMsT0FBTztJQUN2QixNQUFNQyxZQUFZLElBQUlDO0lBQ3RCLE1BQU1DLFlBQVlILFdBQVdBLFFBQVFHLFNBQVM7SUFDOUMsU0FBU0MsT0FBT0MsR0FBRztRQUNmLE1BQU1DLFNBQVNmLHdEQUFlQSxDQUFDZ0IsUUFBUTtRQUN2QyxJQUFJRCxRQUFRO1lBQ1IsSUFBSVAsTUFBTUUsVUFBVU8sR0FBRyxDQUFDSDtZQUN4QixJQUFJLENBQUNOLEtBQUs7Z0JBQ05FLFVBQVVRLEdBQUcsQ0FBQ0osS0FBS04sTUFBTSxJQUFJVztZQUNqQztZQUNBSixPQUFPSyxRQUFRLENBQUNaO1lBQ2hCLElBQUksT0FBT0ksY0FBYyxZQUFZO2dCQUNqQ1YsNkRBQWdCQSxDQUFDTTtnQkFDakJBLElBQUlhLFdBQVcsR0FBR1QsVUFBVUU7WUFDaEM7UUFDSjtJQUNKO0lBQ0FELE9BQU9TLEtBQUssR0FBRyxTQUFTQSxNQUFNUixHQUFHLEVBQUVTLGVBQWU7UUFDOUMsTUFBTWYsTUFBTUUsVUFBVU8sR0FBRyxDQUFDSDtRQUMxQixJQUFJTixLQUFLO1lBQ0wsTUFBTWdCLElBQUksbUJBQ052Qix1REFBY0EsQ0FBQ3dCLElBQUksQ0FBQ3JCLGNBQWNtQixtQkFBb0JBLGtCQUFrQjtZQUM1RSxtRUFBbUU7WUFDbkUsd0VBQXdFO1lBQ3hFLHdFQUF3RTtZQUN4RXBCLHlEQUFZQSxDQUFDSyxLQUFLa0IsT0FBTyxDQUFDQyxDQUFBQSxRQUFTQSxLQUFLLENBQUNILEVBQUU7WUFDM0NkLFVBQVVrQixNQUFNLENBQUNkO1lBQ2pCWiw2REFBZ0JBLENBQUNNO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPSztBQUNYLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvZGVwLmpzPzNjZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyZW50RW50cnlTbG90IH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgaGFzT3duUHJvcGVydHksIG1heWJlVW5zdWJzY3JpYmUsIGFycmF5RnJvbVNldCwgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5jb25zdCBFbnRyeU1ldGhvZHMgPSB7XG4gICAgc2V0RGlydHk6IHRydWUsXG4gICAgZGlzcG9zZTogdHJ1ZSxcbiAgICBmb3JnZXQ6IHRydWUsIC8vIEZ1bGx5IHJlbW92ZSBwYXJlbnQgRW50cnkgZnJvbSBMUlUgY2FjaGUgYW5kIGNvbXB1dGF0aW9uIGdyYXBoXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGRlcChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVwc0J5S2V5ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zdWJzY3JpYmU7XG4gICAgZnVuY3Rpb24gZGVwZW5kKGtleSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRFbnRyeVNsb3QuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgbGV0IGRlcCA9IGRlcHNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghZGVwKSB7XG4gICAgICAgICAgICAgICAgZGVwc0J5S2V5LnNldChrZXksIGRlcCA9IG5ldyBTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmRlcGVuZE9uKGRlcCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVVbnN1YnNjcmliZShkZXApO1xuICAgICAgICAgICAgICAgIGRlcC51bnN1YnNjcmliZSA9IHN1YnNjcmliZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlcGVuZC5kaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGtleSwgZW50cnlNZXRob2ROYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlcCA9IGRlcHNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgY29uc3QgbSA9IChlbnRyeU1ldGhvZE5hbWUgJiZcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKEVudHJ5TWV0aG9kcywgZW50cnlNZXRob2ROYW1lKSkgPyBlbnRyeU1ldGhvZE5hbWUgOiBcInNldERpcnR5XCI7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHVzZSBhcnJheUZyb21TZXQoZGVwKS5mb3JFYWNoIGluc3RlYWQgb2YgZGVwLmZvckVhY2gsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG1vZGlmeWluZyBhIFNldCB3aGlsZSBpdGVyYXRpbmcgb3ZlciBpdCBjYW4gY2F1c2UgZWxlbWVudHMgaW5cbiAgICAgICAgICAgIC8vIHRoZSBTZXQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBTZXQgYmVmb3JlIHRoZXkndmUgYmVlbiBpdGVyYXRlZCBvdmVyLlxuICAgICAgICAgICAgYXJyYXlGcm9tU2V0KGRlcCkuZm9yRWFjaChlbnRyeSA9PiBlbnRyeVttXSgpKTtcbiAgICAgICAgICAgIGRlcHNCeUtleS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZGVwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGRlcGVuZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcC5qcy5tYXAiXSwibmFtZXMiOlsicGFyZW50RW50cnlTbG90IiwiaGFzT3duUHJvcGVydHkiLCJtYXliZVVuc3Vic2NyaWJlIiwiYXJyYXlGcm9tU2V0IiwiRW50cnlNZXRob2RzIiwic2V0RGlydHkiLCJkaXNwb3NlIiwiZm9yZ2V0IiwiZGVwIiwib3B0aW9ucyIsImRlcHNCeUtleSIsIk1hcCIsInN1YnNjcmliZSIsImRlcGVuZCIsImtleSIsInBhcmVudCIsImdldFZhbHVlIiwiZ2V0Iiwic2V0IiwiU2V0IiwiZGVwZW5kT24iLCJ1bnN1YnNjcmliZSIsImRpcnR5IiwiZW50cnlNZXRob2ROYW1lIiwibSIsImNhbGwiLCJmb3JFYWNoIiwiZW50cnkiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/dep.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/entry.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/entry.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Entry: function() { return /* binding */ Entry; }\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return(// Unknown values are not equal to each other.\n    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length && // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch(value.length){\n        case 0:\n            throw new Error(\"unknown value\");\n        case 1:\n            return value[0];\n        case 2:\n            throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nclass Entry {\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty) return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child)=>{\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(this.deps).forEach((dep)=>dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n    constructor(fn){\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        } else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.withValue(entry, recomputeNewValue, [\n        entry,\n        args\n    ]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            } catch (_a) {\n            // If normalizeResult throws, just use the newer value, rather than\n            // saving the exception as entry.value[1].\n            }\n        }\n    } catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(child.parents);\n        for(let i = 0; i < parentCount; ++i){\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    } else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    } else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child)=>{\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        } catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n} //# sourceMappingURL=entry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvZW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ2U7QUFDOUQsTUFBTUcsZUFBZSxFQUFFO0FBQ3ZCLE1BQU1DLG1CQUFtQjtBQUN6Qix1RUFBdUU7QUFDdkUsK0JBQStCO0FBQy9CLFNBQVNDLE9BQU9DLFNBQVMsRUFBRUMsZUFBZTtJQUN0QyxJQUFJLENBQUNELFdBQVc7UUFDWixNQUFNLElBQUlFLE1BQU1ELG1CQUFtQjtJQUN2QztBQUNKO0FBQ0EsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2pCLE1BQU1DLE1BQU1GLEVBQUVHLE1BQU07SUFDcEIsT0FDQSw4Q0FBOEM7SUFDOUNELE1BQU0sS0FDRixrRUFBa0U7SUFDbEVBLFFBQVFELEVBQUVFLE1BQU0sSUFDaEIsc0RBQXNEO0lBQ3RESCxDQUFDLENBQUNFLE1BQU0sRUFBRSxLQUFLRCxDQUFDLENBQUNDLE1BQU0sRUFBRTtBQUNqQztBQUNBLFNBQVNFLFNBQVNDLEtBQUs7SUFDbkIsT0FBUUEsTUFBTUYsTUFBTTtRQUNoQixLQUFLO1lBQUcsTUFBTSxJQUFJTCxNQUFNO1FBQ3hCLEtBQUs7WUFBRyxPQUFPTyxLQUFLLENBQUMsRUFBRTtRQUN2QixLQUFLO1lBQUcsTUFBTUEsS0FBSyxDQUFDLEVBQUU7SUFDMUI7QUFDSjtBQUNBLFNBQVNDLFVBQVVELEtBQUs7SUFDcEIsT0FBT0EsTUFBTUUsS0FBSyxDQUFDO0FBQ3ZCO0FBQ08sTUFBTUM7SUFlVEMsT0FBTztRQUNILElBQUksSUFBSSxDQUFDSixLQUFLLENBQUNGLE1BQU0sS0FBSyxLQUFLLENBQUNPLGFBQWEsSUFBSSxHQUFHO1lBQ2hEQyxlQUFlLElBQUk7WUFDbkIsT0FBTyxJQUFJLENBQUNOLEtBQUssQ0FBQyxFQUFFO1FBQ3hCO0lBQ0o7SUFDQSxpRUFBaUU7SUFDakUsd0VBQXdFO0lBQ3hFLHVFQUF1RTtJQUN2RSx3RUFBd0U7SUFD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MkMsSUFBSSxDQUFDZ0M7WUFDdEI7WUFDQTlDLE9BQU9vQixhQUFhLEdBQUc7UUFDM0I7SUFDSjtBQUNKO0FBQ0EsbUVBQW1FO0FBQ25FLG9CQUFvQjtBQUNwQixTQUFTdEIsZUFBZUUsTUFBTTtJQUMxQixJQUFJQSxPQUFPa0IsV0FBVyxDQUFDbUIsSUFBSSxHQUFHLEdBQUc7UUFDN0JyQyxPQUFPa0IsV0FBVyxDQUFDUCxPQUFPLENBQUMsQ0FBQ29DLFFBQVE5QztZQUNoQ0MsWUFBWUYsUUFBUUM7UUFDeEI7SUFDSjtJQUNBLHNFQUFzRTtJQUN0RSxtQkFBbUI7SUFDbkJELE9BQU9VLFVBQVU7SUFDakIscUVBQXFFO0lBQ3JFLDhDQUE4QztJQUM5Q3JDLE9BQU8yQixPQUFPb0IsYUFBYSxLQUFLO0FBQ3BDO0FBQ0EsU0FBU2xCLFlBQVlGLE1BQU0sRUFBRUMsS0FBSztJQUM5QkEsTUFBTWdCLE9BQU8sQ0FBQ0wsTUFBTSxDQUFDWjtJQUNyQkEsT0FBT2tCLFdBQVcsQ0FBQ04sTUFBTSxDQUFDWDtJQUMxQjRDLGlCQUFpQjdDLFFBQVFDO0FBQzdCO0FBQ0EsU0FBUzZCLGVBQWVILEtBQUssRUFBRXBDLElBQUk7SUFDL0IsSUFBSSxPQUFPb0MsTUFBTXFCLFNBQVMsS0FBSyxZQUFZO1FBQ3ZDLElBQUk7WUFDQS9FLDZEQUFnQkEsQ0FBQzBELFFBQVEsZ0NBQWdDO1lBQ3pEQSxNQUFNc0IsV0FBVyxHQUFHdEIsTUFBTXFCLFNBQVMsQ0FBQ2QsS0FBSyxDQUFDLE1BQU0zQztRQUNwRCxFQUNBLE9BQU82QyxHQUFHO1lBQ04sbUVBQW1FO1lBQ25FLGtFQUFrRTtZQUNsRSxrRUFBa0U7WUFDbEUsb0RBQW9EO1lBQ3BEVCxNQUFNakMsUUFBUTtZQUNkLE9BQU87UUFDWDtJQUNKO0lBQ0Esb0VBQW9FO0lBQ3BFLGlDQUFpQztJQUNqQyxPQUFPO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29wdGltaXNtL2xpYi9lbnRyeS5qcz85YjgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcmVudEVudHJ5U2xvdCB9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IG1heWJlVW5zdWJzY3JpYmUsIGFycmF5RnJvbVNldCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmNvbnN0IGVtcHR5U2V0UG9vbCA9IFtdO1xuY29uc3QgUE9PTF9UQVJHRVRfU0laRSA9IDEwMDtcbi8vIFNpbmNlIHRoaXMgcGFja2FnZSBtaWdodCBiZSB1c2VkIGJyb3dzZXJzLCB3ZSBzaG91bGQgYXZvaWQgdXNpbmcgdGhlXG4vLyBOb2RlIGJ1aWx0LWluIGFzc2VydCBtb2R1bGUuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBvcHRpb25hbE1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9uYWxNZXNzYWdlIHx8IFwiYXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsdWVJcyhhLCBiKSB7XG4gICAgY29uc3QgbGVuID0gYS5sZW5ndGg7XG4gICAgcmV0dXJuIChcbiAgICAvLyBVbmtub3duIHZhbHVlcyBhcmUgbm90IGVxdWFsIHRvIGVhY2ggb3RoZXIuXG4gICAgbGVuID4gMCAmJlxuICAgICAgICAvLyBCb3RoIHZhbHVlcyBtdXN0IGJlIG9yZGluYXJ5IChvciBib3RoIGV4Y2VwdGlvbmFsKSB0byBiZSBlcXVhbC5cbiAgICAgICAgbGVuID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAvLyBUaGUgdW5kZXJseWluZyB2YWx1ZSBvciBleGNlcHRpb24gbXVzdCBiZSB0aGUgc2FtZS5cbiAgICAgICAgYVtsZW4gLSAxXSA9PT0gYltsZW4gLSAxXSk7XG59XG5mdW5jdGlvbiB2YWx1ZUdldCh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZVwiKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gdmFsdWVbMF07XG4gICAgICAgIGNhc2UgMjogdGhyb3cgdmFsdWVbMV07XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsdWVDb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKDApO1xufVxuZXhwb3J0IGNsYXNzIEVudHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihmbikge1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMucGFyZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZFZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gV2hlbiB0aGlzIEVudHJ5IGhhcyBjaGlsZHJlbiB0aGF0IGFyZSBkaXJ0eSwgdGhpcyBwcm9wZXJ0eSBiZWNvbWVzXG4gICAgICAgIC8vIGEgU2V0IGNvbnRhaW5pbmcgb3RoZXIgRW50cnkgb2JqZWN0cywgYm9ycm93ZWQgZnJvbSBlbXB0eVNldFBvb2wuXG4gICAgICAgIC8vIFdoZW4gdGhlIHNldCBiZWNvbWVzIGVtcHR5LCBpdCBnZXRzIHJlY3ljbGVkIGJhY2sgdG8gZW1wdHlTZXRQb29sLlxuICAgICAgICB0aGlzLmRpcnR5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNvbXB1dGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMuZGVwcyA9IG51bGw7XG4gICAgICAgICsrRW50cnkuY291bnQ7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiAhbWlnaHRCZURpcnR5KHRoaXMpKSB7XG4gICAgICAgICAgICByZW1lbWJlclBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IG1ldGhvZCBvZiB0aGUgRW50cnkgQVBJLCBiZWNhdXNlIGl0XG4gICAgLy8gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYWNoZWQgdGhpcy52YWx1ZSBjYW4gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHksXG4gICAgLy8gb3IgbXVzdCBiZSByZWNvbXB1dGVkLiBUaGUgb3ZlcmFsbCBwZXJmb3JtYW5jZSBvZiB0aGUgY2FjaGluZyBzeXN0ZW1cbiAgICAvLyBkZXBlbmRzIG9uIHRoZSB0cnV0aCBvZiB0aGUgZm9sbG93aW5nIG9ic2VydmF0aW9uczogKDEpIHRoaXMuZGlydHkgaXNcbiAgICAvLyB1c3VhbGx5IGZhbHNlLCAoMikgdGhpcy5kaXJ0eUNoaWxkcmVuIGlzIHVzdWFsbHkgbnVsbC9lbXB0eSwgYW5kIHRodXNcbiAgICAvLyAoMykgdmFsdWVHZXQodGhpcy52YWx1ZSkgaXMgdXN1YWxseSByZXR1cm5lZCB3aXRob3V0IHJlY29tcHV0YXRpb24uXG4gICAgcmVjb21wdXRlKGFyZ3MpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlY29tcHV0aW5nLCBcImFscmVhZHkgcmVjb21wdXRpbmdcIik7XG4gICAgICAgIHJlbWVtYmVyUGFyZW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gbWlnaHRCZURpcnR5KHRoaXMpXG4gICAgICAgICAgICA/IHJlYWxseVJlY29tcHV0ZSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgOiB2YWx1ZUdldCh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgc2V0RGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmVwb3J0RGlydHkodGhpcyk7XG4gICAgICAgIC8vIFdlIGNhbiBnbyBhaGVhZCBhbmQgdW5zdWJzY3JpYmUgaGVyZSwgc2luY2UgYW55IGZ1cnRoZXIgZGlydHlcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyB3ZSByZWNlaXZlIHdpbGwgYmUgcmVkdW5kYW50LCBhbmQgdW5zdWJzY3JpYmluZyBtYXlcbiAgICAgICAgLy8gZnJlZSB1cCBzb21lIHJlc291cmNlcywgZS5nLiBmaWxlIHdhdGNoZXJzLlxuICAgICAgICBtYXliZVVuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnNldERpcnR5KCk7XG4gICAgICAgIC8vIFNldmVyIGFueSBkZXBlbmRlbmN5IHJlbGF0aW9uc2hpcHMgd2l0aCBvdXIgb3duIGNoaWxkcmVuLCBzbyB0aG9zZVxuICAgICAgICAvLyBjaGlsZHJlbiBkb24ndCByZXRhaW4gdGhpcyBwYXJlbnQgRW50cnkgaW4gdGhlaXIgY2hpbGQucGFyZW50cyBzZXRzLFxuICAgICAgICAvLyB0aGVyZWJ5IHByZXZlbnRpbmcgaXQgZnJvbSBiZWluZyBmdWxseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgZm9yZ2V0Q2hpbGRyZW4odGhpcyk7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBlbnRyeSBoYXMgYmVlbiBraWNrZWQgb3V0IG9mIHRoZSBjYWNoZSAoaW4gaW5kZXguanMpLFxuICAgICAgICAvLyB3ZSd2ZSBsb3N0IHRoZSBhYmlsaXR5IHRvIGZpbmQgb3V0IGlmL3doZW4gdGhpcyBlbnRyeSBiZWNvbWVzIGRpcnR5LFxuICAgICAgICAvLyB3aGV0aGVyIHRoYXQgaGFwcGVucyB0aHJvdWdoIGEgc3Vic2NyaXB0aW9uLCBiZWNhdXNlIG9mIGEgZGlyZWN0IGNhbGxcbiAgICAgICAgLy8gdG8gZW50cnkuc2V0RGlydHkoKSwgb3IgYmVjYXVzZSBvbmUgb2YgaXRzIGNoaWxkcmVuIGJlY29tZXMgZGlydHkuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBsb3NzIG9mIGZ1dHVyZSBpbmZvcm1hdGlvbiwgd2UgaGF2ZSB0byBhc3N1bWUgdGhlXG4gICAgICAgIC8vIHdvcnN0ICh0aGF0IHRoaXMgZW50cnkgbWlnaHQgaGF2ZSBiZWNvbWUgZGlydHkgdmVyeSBzb29uKSwgc28gd2UgbXVzdFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBtYXJrIHRoaXMgZW50cnkncyBwYXJlbnRzIGFzIGRpcnR5LiBOb3JtYWxseSB3ZSBjb3VsZFxuICAgICAgICAvLyBqdXN0IGNhbGwgZW50cnkuc2V0RGlydHkoKSByYXRoZXIgdGhhbiBjYWxsaW5nIHBhcmVudC5zZXREaXJ0eSgpIGZvclxuICAgICAgICAvLyBlYWNoIHBhcmVudCwgYnV0IHRoYXQgd291bGQgbGVhdmUgdGhpcyBlbnRyeSBpbiBwYXJlbnQuY2hpbGRWYWx1ZXNcbiAgICAgICAgLy8gYW5kIHBhcmVudC5kaXJ0eUNoaWxkcmVuLCB3aGljaCB3b3VsZCBwcmV2ZW50IHRoZSBjaGlsZCBmcm9tIGJlaW5nXG4gICAgICAgIC8vIHRydWx5IGZvcmdvdHRlbi5cbiAgICAgICAgZWFjaFBhcmVudCh0aGlzLCAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgcGFyZW50LnNldERpcnR5KCk7XG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yZ2V0KCkge1xuICAgICAgICAvLyBUaGUgY29kZSB0aGF0IGNyZWF0ZXMgRW50cnkgb2JqZWN0cyBpbiBpbmRleC50cyB3aWxsIHJlcGxhY2UgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gd2l0aCBvbmUgdGhhdCBhY3R1YWxseSByZW1vdmVzIHRoZSBFbnRyeSBmcm9tIHRoZSBjYWNoZSwgd2hpY2ggd2lsbCBhbHNvXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGVudHJ5LmRpc3Bvc2UgbWV0aG9kLlxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZGVwZW5kT24oZGVwKSB7XG4gICAgICAgIGRlcC5hZGQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5kZXBzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHMgPSBlbXB0eVNldFBvb2wucG9wKCkgfHwgbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVwcy5hZGQoZGVwKTtcbiAgICB9XG4gICAgZm9yZ2V0RGVwcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwcykge1xuICAgICAgICAgICAgYXJyYXlGcm9tU2V0KHRoaXMuZGVwcykuZm9yRWFjaChkZXAgPT4gZGVwLmRlbGV0ZSh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmRlcHMuY2xlYXIoKTtcbiAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKHRoaXMuZGVwcyk7XG4gICAgICAgICAgICB0aGlzLmRlcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuRW50cnkuY291bnQgPSAwO1xuZnVuY3Rpb24gcmVtZW1iZXJQYXJlbnQoY2hpbGQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRFbnRyeVNsb3QuZ2V0VmFsdWUoKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNoaWxkLnBhcmVudHMuYWRkKHBhcmVudCk7XG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5zZXQoY2hpbGQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlnaHRCZURpcnR5KGNoaWxkKSkge1xuICAgICAgICAgICAgcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFsbHlSZWNvbXB1dGUoZW50cnksIGFyZ3MpIHtcbiAgICBmb3JnZXRDaGlsZHJlbihlbnRyeSk7XG4gICAgLy8gU2V0IGVudHJ5IGFzIHRoZSBwYXJlbnQgZW50cnkgd2hpbGUgY2FsbGluZyByZWNvbXB1dGVOZXdWYWx1ZShlbnRyeSkuXG4gICAgcGFyZW50RW50cnlTbG90LndpdGhWYWx1ZShlbnRyeSwgcmVjb21wdXRlTmV3VmFsdWUsIFtlbnRyeSwgYXJnc10pO1xuICAgIGlmIChtYXliZVN1YnNjcmliZShlbnRyeSwgYXJncykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc3VjY2Vzc2Z1bGx5IHJlY29tcHV0ZWQgZW50cnkudmFsdWUgYW5kIGRpZCBub3QgZmFpbCB0b1xuICAgICAgICAvLyAocmUpc3Vic2NyaWJlLCB0aGVuIHRoaXMgRW50cnkgaXMgbm8gbG9uZ2VyIGV4cGxpY2l0bHkgZGlydHkuXG4gICAgICAgIHNldENsZWFuKGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlR2V0KGVudHJ5LnZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5LCBhcmdzKSB7XG4gICAgZW50cnkucmVjb21wdXRpbmcgPSB0cnVlO1xuICAgIGNvbnN0IHsgbm9ybWFsaXplUmVzdWx0IH0gPSBlbnRyeTtcbiAgICBsZXQgb2xkVmFsdWVDb3B5O1xuICAgIGlmIChub3JtYWxpemVSZXN1bHQgJiYgZW50cnkudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG9sZFZhbHVlQ29weSA9IHZhbHVlQ29weShlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIC8vIE1ha2UgZW50cnkudmFsdWUgYW4gZW1wdHkgYXJyYXksIHJlcHJlc2VudGluZyBhbiB1bmtub3duIHZhbHVlLlxuICAgIGVudHJ5LnZhbHVlLmxlbmd0aCA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgZW50cnkuZm4gc3VjY2VlZHMsIGVudHJ5LnZhbHVlIHdpbGwgYmVjb21lIGEgbm9ybWFsIFZhbHVlLlxuICAgICAgICBlbnRyeS52YWx1ZVswXSA9IGVudHJ5LmZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmlhYmxlIG9sZFZhbHVlQ29weSB0byBjb21wYXJlIHdpdGggdGhlIChzdWNjZXNzZnVsbHlcbiAgICAgICAgLy8gcmVjb21wdXRlZCkgbmV3IGVudHJ5LnZhbHVlLCBhbmQgdGhleSBhcmUgbm90IGFscmVhZHkgPT09IGlkZW50aWNhbCwgZ2l2ZVxuICAgICAgICAvLyBub3JtYWxpemVSZXN1bHQgYSBjaGFuY2UgdG8gcGljay9jaG9vc2UvcmV1c2UgcGFydHMgb2Ygb2xkVmFsdWVDb3B5WzBdXG4gICAgICAgIC8vIGFuZC9vciBlbnRyeS52YWx1ZVswXSB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIGNhY2hlZCBlbnRyeS52YWx1ZS5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZVJlc3VsdCAmJiBvbGRWYWx1ZUNvcHkgJiYgIXZhbHVlSXMob2xkVmFsdWVDb3B5LCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWVbMF0gPSBub3JtYWxpemVSZXN1bHQoZW50cnkudmFsdWVbMF0sIG9sZFZhbHVlQ29weVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3JtYWxpemVSZXN1bHQgdGhyb3dzLCBqdXN0IHVzZSB0aGUgbmV3ZXIgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgICAgLy8gc2F2aW5nIHRoZSBleGNlcHRpb24gYXMgZW50cnkudmFsdWVbMV0uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgZW50cnkuZm4gdGhyb3dzLCBlbnRyeS52YWx1ZSB3aWxsIGhvbGQgdGhhdCBleGNlcHRpb24uXG4gICAgICAgIGVudHJ5LnZhbHVlWzFdID0gZTtcbiAgICB9XG4gICAgLy8gRWl0aGVyIHdheSwgdGhpcyBsaW5lIGlzIGFsd2F5cyByZWFjaGVkLlxuICAgIGVudHJ5LnJlY29tcHV0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBtaWdodEJlRGlydHkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuZGlydHkgfHwgISEoZW50cnkuZGlydHlDaGlsZHJlbiAmJiBlbnRyeS5kaXJ0eUNoaWxkcmVuLnNpemUpO1xufVxuZnVuY3Rpb24gc2V0Q2xlYW4oZW50cnkpIHtcbiAgICBlbnRyeS5kaXJ0eSA9IGZhbHNlO1xuICAgIGlmIChtaWdodEJlRGlydHkoZW50cnkpKSB7XG4gICAgICAgIC8vIFRoaXMgRW50cnkgbWF5IHN0aWxsIGhhdmUgZGlydHkgY2hpbGRyZW4sIGluIHdoaWNoIGNhc2Ugd2UgY2FuJ3RcbiAgICAgICAgLy8gbGV0IG91ciBwYXJlbnRzIGtub3cgd2UncmUgY2xlYW4ganVzdCB5ZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVwb3J0Q2xlYW4oZW50cnkpO1xufVxuZnVuY3Rpb24gcmVwb3J0RGlydHkoY2hpbGQpIHtcbiAgICBlYWNoUGFyZW50KGNoaWxkLCByZXBvcnREaXJ0eUNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlcG9ydENsZWFuKGNoaWxkKSB7XG4gICAgZWFjaFBhcmVudChjaGlsZCwgcmVwb3J0Q2xlYW5DaGlsZCk7XG59XG5mdW5jdGlvbiBlYWNoUGFyZW50KGNoaWxkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHBhcmVudENvdW50ID0gY2hpbGQucGFyZW50cy5zaXplO1xuICAgIGlmIChwYXJlbnRDb3VudCkge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gYXJyYXlGcm9tU2V0KGNoaWxkLnBhcmVudHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmVudHNbaV0sIGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIExldCBhIHBhcmVudCBFbnRyeSBrbm93IHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbiBtYXkgYmUgZGlydHkuXG5mdW5jdGlvbiByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICAvLyBNdXN0IGhhdmUgY2FsbGVkIHJlbWVtYmVyUGFyZW50KGNoaWxkKSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkuXG4gICAgYXNzZXJ0KHBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKTtcbiAgICBhc3NlcnQobWlnaHRCZURpcnR5KGNoaWxkKSk7XG4gICAgY29uc3QgcGFyZW50V2FzQ2xlYW4gPSAhbWlnaHRCZURpcnR5KHBhcmVudCk7XG4gICAgaWYgKCFwYXJlbnQuZGlydHlDaGlsZHJlbikge1xuICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQuZGlydHlDaGlsZHJlbi5oYXMoY2hpbGQpKSB7XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyB0aGlzIGNoaWxkIGlzIGRpcnR5LCB0aGVuIHdlIG11c3QgaGF2ZSBhbHJlYWR5XG4gICAgICAgIC8vIGluZm9ybWVkIG91ciBvd24gcGFyZW50cyB0aGF0IHdlIGFyZSBkaXJ0eSwgc28gd2UgY2FuIHRlcm1pbmF0ZVxuICAgICAgICAvLyB0aGUgcmVjdXJzaW9uIGVhcmx5LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgLy8gSWYgcGFyZW50IHdhcyBjbGVhbiBiZWZvcmUsIGl0IGp1c3QgYmVjYW1lIChwb3NzaWJseSkgZGlydHkgKGFjY29yZGluZyB0b1xuICAgIC8vIG1pZ2h0QmVEaXJ0eSksIHNpbmNlIHdlIGp1c3QgYWRkZWQgY2hpbGQgdG8gcGFyZW50LmRpcnR5Q2hpbGRyZW4uXG4gICAgaWYgKHBhcmVudFdhc0NsZWFuKSB7XG4gICAgICAgIHJlcG9ydERpcnR5KHBhcmVudCk7XG4gICAgfVxufVxuLy8gTGV0IGEgcGFyZW50IEVudHJ5IGtub3cgdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzIG5vIGxvbmdlciBkaXJ0eS5cbmZ1bmN0aW9uIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJDaGlsZChjaGlsZCkgYmVmb3JlIGNhbGxpbmdcbiAgICAvLyByZXBvcnRDbGVhbkNoaWxkKHBhcmVudCwgY2hpbGQpLlxuICAgIGFzc2VydChwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSk7XG4gICAgYXNzZXJ0KCFtaWdodEJlRGlydHkoY2hpbGQpKTtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gcGFyZW50LmNoaWxkVmFsdWVzLmdldChjaGlsZCk7XG4gICAgaWYgKGNoaWxkVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5zZXQoY2hpbGQsIHZhbHVlQ29weShjaGlsZC52YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdmFsdWVJcyhjaGlsZFZhbHVlLCBjaGlsZC52YWx1ZSkpIHtcbiAgICAgICAgcGFyZW50LnNldERpcnR5KCk7XG4gICAgfVxuICAgIHJlbW92ZURpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCk7XG4gICAgaWYgKG1pZ2h0QmVEaXJ0eShwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVwb3J0Q2xlYW4ocGFyZW50KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZURpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIGNvbnN0IGRjID0gcGFyZW50LmRpcnR5Q2hpbGRyZW47XG4gICAgaWYgKGRjKSB7XG4gICAgICAgIGRjLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgIGlmIChkYy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZW1wdHlTZXRQb29sLmxlbmd0aCA8IFBPT0xfVEFSR0VUX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBlbXB0eVNldFBvb2wucHVzaChkYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgZW50cnkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlXG4vLyByZW1vdmVkIGNoaWxkcmVuLlxuZnVuY3Rpb24gZm9yZ2V0Q2hpbGRyZW4ocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5jaGlsZFZhbHVlcy5zaXplID4gMCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuZm9yRWFjaCgoX3ZhbHVlLCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgZm9yZ2V0Q2hpbGQocGFyZW50LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhpcyBwYXJlbnQgRW50cnkgZnJvbSBhbnkgc2V0cyB0byB3aGljaCBpdCB3YXMgYWRkZWQgYnkgdGhlXG4gICAgLy8gYWRkVG9TZXQgbWV0aG9kLlxuICAgIHBhcmVudC5mb3JnZXREZXBzKCk7XG4gICAgLy8gQWZ0ZXIgd2UgZm9yZ2V0IGFsbCBvdXIgY2hpbGRyZW4sIHRoaXMuZGlydHlDaGlsZHJlbiBtdXN0IGJlIGVtcHR5XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBtdXN0IGhhdmUgYmVlbiByZXNldCB0byBudWxsLlxuICAgIGFzc2VydChwYXJlbnQuZGlydHlDaGlsZHJlbiA9PT0gbnVsbCk7XG59XG5mdW5jdGlvbiBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50cy5kZWxldGUocGFyZW50KTtcbiAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuZGVsZXRlKGNoaWxkKTtcbiAgICByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gbWF5YmVTdWJzY3JpYmUoZW50cnksIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVudHJ5LnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGVudHJ5KTsgLy8gUHJldmVudCBkb3VibGUgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZW50cnkuc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIEVudHJ5IGhhcyBhIHN1YnNjcmliZSBmdW5jdGlvbiBhbmQgaXQgdGhyZXcgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyAob3IgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gaXQgcHJldmlvdXNseSByZXR1cm5lZCBub3cgdGhyb3dzKSxcbiAgICAgICAgICAgIC8vIHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdlIHdlcmUgbm90IGFibGUgdG8gc3Vic2NyaWJlIChvclxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUpLCBhbmQgdGhpcyBFbnRyeSBzaG91bGQgcmVtYWluIGRpcnR5LlxuICAgICAgICAgICAgZW50cnkuc2V0RGlydHkoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5pbmcgdHJ1ZSBpbmRpY2F0ZXMgZWl0aGVyIHRoYXQgdGhlcmUgd2FzIG5vIGVudHJ5LnN1YnNjcmliZVxuICAgIC8vIGZ1bmN0aW9uIG9yIHRoYXQgaXQgc3VjY2VlZGVkLlxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50cnkuanMubWFwIl0sIm5hbWVzIjpbInBhcmVudEVudHJ5U2xvdCIsIm1heWJlVW5zdWJzY3JpYmUiLCJhcnJheUZyb21TZXQiLCJlbXB0eVNldFBvb2wiLCJQT09MX1RBUkdFVF9TSVpFIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwib3B0aW9uYWxNZXNzYWdlIiwiRXJyb3IiLCJ2YWx1ZUlzIiwiYSIsImIiLCJsZW4iLCJsZW5ndGgiLCJ2YWx1ZUdldCIsInZhbHVlIiwidmFsdWVDb3B5Iiwic2xpY2UiLCJFbnRyeSIsInBlZWsiLCJtaWdodEJlRGlydHkiLCJyZW1lbWJlclBhcmVudCIsInJlY29tcHV0ZSIsImFyZ3MiLCJyZWNvbXB1dGluZyIsInJlYWxseVJlY29tcHV0ZSIsInNldERpcnR5IiwiZGlydHkiLCJyZXBvcnREaXJ0eSIsImRpc3Bvc2UiLCJmb3JnZXRDaGlsZHJlbiIsImVhY2hQYXJlbnQiLCJwYXJlbnQiLCJjaGlsZCIsImZvcmdldENoaWxkIiwiZm9yZ2V0IiwiZGVwZW5kT24iLCJkZXAiLCJhZGQiLCJkZXBzIiwicG9wIiwiU2V0IiwiZm9yZ2V0RGVwcyIsImZvckVhY2giLCJkZWxldGUiLCJjbGVhciIsInB1c2giLCJjb25zdHJ1Y3RvciIsImZuIiwicGFyZW50cyIsImNoaWxkVmFsdWVzIiwiTWFwIiwiZGlydHlDaGlsZHJlbiIsImNvdW50IiwiZ2V0VmFsdWUiLCJoYXMiLCJzZXQiLCJyZXBvcnREaXJ0eUNoaWxkIiwicmVwb3J0Q2xlYW5DaGlsZCIsImVudHJ5Iiwid2l0aFZhbHVlIiwicmVjb21wdXRlTmV3VmFsdWUiLCJtYXliZVN1YnNjcmliZSIsInNldENsZWFuIiwibm9ybWFsaXplUmVzdWx0Iiwib2xkVmFsdWVDb3B5IiwiYXBwbHkiLCJfYSIsImUiLCJzaXplIiwicmVwb3J0Q2xlYW4iLCJjYWxsYmFjayIsInBhcmVudENvdW50IiwiaSIsInBhcmVudFdhc0NsZWFuIiwiY2hpbGRWYWx1ZSIsImdldCIsInJlbW92ZURpcnR5Q2hpbGQiLCJkYyIsIl92YWx1ZSIsInN1YnNjcmliZSIsInVuc3Vic2NyaWJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/entry.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/helpers.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayFromSet: function() { return /* binding */ arrayFromSet; },\n/* harmony export */   hasOwnProperty: function() { return /* binding */ hasOwnProperty; },\n/* harmony export */   maybeUnsubscribe: function() { return /* binding */ maybeUnsubscribe; }\n/* harmony export */ });\nconst { hasOwnProperty } = Object.prototype;\nconst arrayFromSet = Array.from || function(set) {\n    const array = [];\n    set.forEach((item)=>array.push(item));\n    return array;\n};\nfunction maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTyxNQUFNLEVBQUVBLGNBQWMsRUFBRyxHQUFHQyxPQUFPQyxTQUFTLENBQUM7QUFDN0MsTUFBTUMsZUFBZUMsTUFBTUMsSUFBSSxJQUNsQyxTQUFVQyxHQUFHO0lBQ1QsTUFBTUMsUUFBUSxFQUFFO0lBQ2hCRCxJQUFJRSxPQUFPLENBQUNDLENBQUFBLE9BQVFGLE1BQU1HLElBQUksQ0FBQ0Q7SUFDL0IsT0FBT0Y7QUFDWCxFQUFFO0FBQ0MsU0FBU0ksaUJBQWlCQyxVQUFVO0lBQ3ZDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdEO0lBQ3hCLElBQUksT0FBT0MsZ0JBQWdCLFlBQVk7UUFDbkNELFdBQVdDLFdBQVcsR0FBRyxLQUFLO1FBQzlCQTtJQUNKO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29wdGltaXNtL2xpYi9oZWxwZXJzLmpzPzJjMDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHsgaGFzT3duUHJvcGVydHksIH0gPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IGNvbnN0IGFycmF5RnJvbVNldCA9IEFycmF5LmZyb20gfHxcbiAgICBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIHNldC5mb3JFYWNoKGl0ZW0gPT4gYXJyYXkucHVzaChpdGVtKSk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVW5zdWJzY3JpYmUoZW50cnlPckRlcCkge1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IGVudHJ5T3JEZXA7XG4gICAgaWYgKHR5cGVvZiB1bnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVudHJ5T3JEZXAudW5zdWJzY3JpYmUgPSB2b2lkIDA7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJhcnJheUZyb21TZXQiLCJBcnJheSIsImZyb20iLCJzZXQiLCJhcnJheSIsImZvckVhY2giLCJpdGVtIiwicHVzaCIsIm1heWJlVW5zdWJzY3JpYmUiLCJlbnRyeU9yRGVwIiwidW5zdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyTrie: function() { return /* reexport safe */ _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie; },\n/* harmony export */   Slot: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.Slot; },\n/* harmony export */   asyncFromGen: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.asyncFromGen; },\n/* harmony export */   bindContext: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.bindContext; },\n/* harmony export */   defaultMakeCacheKey: function() { return /* binding */ defaultMakeCacheKey; },\n/* harmony export */   dep: function() { return /* reexport safe */ _dep_js__WEBPACK_IMPORTED_MODULE_3__.dep; },\n/* harmony export */   noContext: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.noContext; },\n/* harmony export */   nonReactive: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.nonReactive; },\n/* harmony export */   setTimeout: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.setTimeout; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/optimism/node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/strong.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entry.js */ \"(app-pages-browser)/./node_modules/optimism/lib/entry.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _dep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dep.js */ \"(app-pages-browser)/./node_modules/optimism/lib/dep.js\");\n\n\n\n\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\n\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nfunction defaultMakeCacheKey() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const trie = defaultKeyTrie || (defaultKeyTrie = new _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\n\n;\nconst caches = new Set();\nfunction wrap(originalFunction) {\n    let { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = _wry_caches__WEBPACK_IMPORTED_MODULE_4__.StrongCache } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object.create(null);\n    const cache = typeof cacheOption === \"function\" ? new cacheOption(max, (entry)=>entry.dispose()) : cacheOption;\n    const optimistic = function() {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new _entry_js__WEBPACK_IMPORTED_MODULE_1__.Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = ()=>cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!_context_js__WEBPACK_IMPORTED_MODULE_2__.parentEntrySlot.hasValue()) {\n            caches.forEach((cache)=>cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: ()=>cache.size,\n        configurable: false,\n        enumerable: false\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ1M7QUFDUDtBQUNZO0FBQy9DLHFFQUFxRTtBQUNyRSxxRUFBcUU7QUFDckUseUVBQXlFO0FBQ3pFLHNFQUFzRTtBQUN0RSx5RUFBeUU7QUFDekUsc0VBQXNFO0FBQzhCO0FBQ3BHLDRFQUE0RTtBQUM1RSw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFLCtDQUErQztBQUNoQjtBQUMvQiw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLDBFQUEwRTtBQUMxRSw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsSUFBSVc7QUFDRyxTQUFTQztJQUFvQjtRQUFHQyxLQUFILHVCQUFPOztJQUN2QyxNQUFNQyxPQUFPSCxrQkFBbUJBLENBQUFBLGlCQUFpQixJQUFJWCwyQ0FBSUEsQ0FBQyxPQUFPZSxZQUFZLFdBQVU7SUFDdkYsT0FBT0QsS0FBS0UsV0FBVyxDQUFDSDtBQUM1QjtBQUNBLDRFQUE0RTtBQUM1RSwwRUFBMEU7QUFDMUUsb0RBQW9EO0FBQ3pCOztBQUUzQixNQUFNSyxTQUFTLElBQUlDO0FBQ1osU0FBU0MsS0FBS0MsZ0JBQWdCO1FBQUUsRUFBRUMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLGVBQWVkLG1CQUFtQixFQUFFZSxlQUFlLEVBQUVDLFNBQVMsRUFBRUMsT0FBT0MsY0FBYzdCLG9EQUFXLEVBQUcsR0FBckksaUVBQXdJOEIsT0FBT0MsTUFBTSxDQUFDO0lBQ3pMLE1BQU1ILFFBQVEsT0FBT0MsZ0JBQWdCLGFBQy9CLElBQUlBLFlBQVlSLEtBQUtXLENBQUFBLFFBQVNBLE1BQU1DLE9BQU8sTUFDM0NKO0lBQ04sTUFBTUssYUFBYTtRQUNmLE1BQU1DLE1BQU1WLGFBQWFXLEtBQUssQ0FBQyxNQUFNWixVQUFVQSxRQUFRWSxLQUFLLENBQUMsTUFBTUMsYUFBYUE7UUFDaEYsSUFBSUYsUUFBUSxLQUFLLEdBQUc7WUFDaEIsT0FBT2YsaUJBQWlCZ0IsS0FBSyxDQUFDLE1BQU1DO1FBQ3hDO1FBQ0EsSUFBSUwsUUFBUUosTUFBTVUsR0FBRyxDQUFDSDtRQUN0QixJQUFJLENBQUNILE9BQU87WUFDUkosTUFBTVcsR0FBRyxDQUFDSixLQUFLSCxRQUFRLElBQUkvQiw0Q0FBS0EsQ0FBQ21CO1lBQ2pDWSxNQUFNTixlQUFlLEdBQUdBO1lBQ3hCTSxNQUFNTCxTQUFTLEdBQUdBO1lBQ2xCLHVFQUF1RTtZQUN2RSxxREFBcUQ7WUFDckRLLE1BQU1RLE1BQU0sR0FBRyxJQUFNWixNQUFNYSxNQUFNLENBQUNOO1FBQ3RDO1FBQ0EsTUFBTU8sUUFBUVYsTUFBTVcsU0FBUyxDQUFDQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDVjtRQUN6RCxpRUFBaUU7UUFDakUsOENBQThDO1FBQzlDVCxNQUFNVyxHQUFHLENBQUNKLEtBQUtIO1FBQ2ZmLE9BQU8rQixHQUFHLENBQUNwQjtRQUNYLG9FQUFvRTtRQUNwRSxtRUFBbUU7UUFDbkUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQzFCLHdEQUFlQSxDQUFDK0MsUUFBUSxJQUFJO1lBQzdCaEMsT0FBT2lDLE9BQU8sQ0FBQ3RCLENBQUFBLFFBQVNBLE1BQU11QixLQUFLO1lBQ25DbEMsT0FBT21DLEtBQUs7UUFDaEI7UUFDQSxPQUFPVjtJQUNYO0lBQ0FaLE9BQU91QixjQUFjLENBQUNuQixZQUFZLFFBQVE7UUFDdENJLEtBQUssSUFBTVYsTUFBTTBCLElBQUk7UUFDckJDLGNBQWM7UUFDZEMsWUFBWTtJQUNoQjtJQUNBMUIsT0FBTzJCLE1BQU0sQ0FBQ3ZCLFdBQVd3QixPQUFPLEdBQUc7UUFDL0JyQztRQUNBRztRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsU0FBUytCLFNBQVN4QixHQUFHO1FBQ2pCLE1BQU1ILFFBQVFHLE9BQU9QLE1BQU1VLEdBQUcsQ0FBQ0g7UUFDL0IsSUFBSUgsT0FBTztZQUNQQSxNQUFNNEIsUUFBUTtRQUNsQjtJQUNKO0lBQ0ExQixXQUFXeUIsUUFBUSxHQUFHQTtJQUN0QnpCLFdBQVcyQixLQUFLLEdBQUcsU0FBU0E7UUFDeEJGLFNBQVNsQyxhQUFhVyxLQUFLLENBQUMsTUFBTUM7SUFDdEM7SUFDQSxTQUFTeUIsUUFBUTNCLEdBQUc7UUFDaEIsTUFBTUgsUUFBUUcsT0FBT1AsTUFBTVUsR0FBRyxDQUFDSDtRQUMvQixJQUFJSCxPQUFPO1lBQ1AsT0FBT0EsTUFBTStCLElBQUk7UUFDckI7SUFDSjtJQUNBN0IsV0FBVzRCLE9BQU8sR0FBR0E7SUFDckI1QixXQUFXNkIsSUFBSSxHQUFHLFNBQVNBO1FBQ3ZCLE9BQU9ELFFBQVFyQyxhQUFhVyxLQUFLLENBQUMsTUFBTUM7SUFDNUM7SUFDQSxTQUFTMkIsVUFBVTdCLEdBQUc7UUFDbEIsT0FBT0EsTUFBTVAsTUFBTWEsTUFBTSxDQUFDTixPQUFPO0lBQ3JDO0lBQ0FELFdBQVc4QixTQUFTLEdBQUdBO0lBQ3ZCOUIsV0FBV00sTUFBTSxHQUFHLFNBQVNBO1FBQ3pCLE9BQU93QixVQUFVdkMsYUFBYVcsS0FBSyxDQUFDLE1BQU1DO0lBQzlDO0lBQ0FILFdBQVdULFlBQVksR0FBR0E7SUFDMUJTLFdBQVcrQixNQUFNLEdBQUd6QyxVQUFVLFNBQVN5QztRQUNuQyxPQUFPeEMsYUFBYVcsS0FBSyxDQUFDLE1BQU1aLFFBQVFZLEtBQUssQ0FBQyxNQUFNQztJQUN4RCxJQUFJWjtJQUNKLE9BQU9LLE9BQU8yQixNQUFNLENBQUN2QjtBQUN6QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2luZGV4LmpzPzM2NWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJpZSB9IGZyb20gXCJAd3J5L3RyaWVcIjtcbmltcG9ydCB7IFN0cm9uZ0NhY2hlIH0gZnJvbSBcIkB3cnkvY2FjaGVzXCI7XG5pbXBvcnQgeyBFbnRyeSB9IGZyb20gXCIuL2VudHJ5LmpzXCI7XG5pbXBvcnQgeyBwYXJlbnRFbnRyeVNsb3QgfSBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG4vLyBUaGVzZSBoZWxwZXIgZnVuY3Rpb25zIGFyZSBpbXBvcnRhbnQgZm9yIG1ha2luZyBvcHRpbWlzbSB3b3JrIHdpdGhcbi8vIGFzeW5jaHJvbm91cyBjb2RlLiBJbiBvcmRlciB0byByZWdpc3RlciBwYXJlbnQtY2hpbGQgZGVwZW5kZW5jaWVzLFxuLy8gb3B0aW1pc20gbmVlZHMgdG8ga25vdyBhYm91dCBhbnkgY3VycmVudGx5IGFjdGl2ZSBwYXJlbnQgY29tcHV0YXRpb25zLlxuLy8gSW4gb3JkaW5hcnkgc3luY2hyb25vdXMgY29kZSwgdGhlIHBhcmVudCBjb250ZXh0IGlzIGltcGxpY2l0IGluIHRoZVxuLy8gZXhlY3V0aW9uIHN0YWNrLCBidXQgYXN5bmNocm9ub3VzIGNvZGUgcmVxdWlyZXMgc29tZSBleHRyYSBndWlkYW5jZSBpblxuLy8gb3JkZXIgdG8gcHJvcGFnYXRlIGNvbnRleHQgZnJvbSBvbmUgYXN5bmMgdGFzayBzZWdtZW50IHRvIHRoZSBuZXh0LlxuZXhwb3J0IHsgYmluZENvbnRleHQsIG5vQ29udGV4dCwgbm9uUmVhY3RpdmUsIHNldFRpbWVvdXQsIGFzeW5jRnJvbUdlbiwgU2xvdCwgfSBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG4vLyBBIGxpZ2h0ZXItd2VpZ2h0IGRlcGVuZGVuY3ksIHNpbWlsYXIgdG8gT3B0aW1pc3RpY1dyYXBwZXJGdW5jdGlvbiwgZXhjZXB0XG4vLyB3aXRoIG9ubHkgb25lIGFyZ3VtZW50LCBubyBtYWtlQ2FjaGVLZXksIG5vIHdyYXBwZWQgZnVuY3Rpb24gdG8gcmVjb21wdXRlLFxuLy8gYW5kIG5vIHJlc3VsdCB2YWx1ZS4gVXNlZnVsIGZvciByZXByZXNlbnRpbmcgZGVwZW5kZW5jeSBsZWF2ZXMgaW4gdGhlIGdyYXBoXG4vLyBvZiBjb21wdXRhdGlvbi4gU3Vic2NyaXB0aW9ucyBhcmUgc3VwcG9ydGVkLlxuZXhwb3J0IHsgZGVwIH0gZnJvbSBcIi4vZGVwLmpzXCI7XG4vLyBUaGUgZGVmYXVsdE1ha2VDYWNoZUtleSBmdW5jdGlvbiBpcyByZW1hcmthYmx5IHBvd2VyZnVsLCBiZWNhdXNlIGl0IGdpdmVzXG4vLyBhIHVuaXF1ZSBvYmplY3QgZm9yIGFueSBzaGFsbG93LWlkZW50aWNhbCBsaXN0IG9mIGFyZ3VtZW50cy4gSWYgeW91IG5lZWRcbi8vIHRvIGltcGxlbWVudCBhIGN1c3RvbSBtYWtlQ2FjaGVLZXkgZnVuY3Rpb24sIHlvdSBtYXkgZmluZCBpdCBoZWxwZnVsIHRvXG4vLyBkZWxlZ2F0ZSB0aGUgZmluYWwgd29yayB0byBkZWZhdWx0TWFrZUNhY2hlS2V5LCB3aGljaCBpcyB3aHkgd2UgZXhwb3J0IGl0XG4vLyBoZXJlLiBIb3dldmVyLCB5b3UgbWF5IHdhbnQgdG8gYXZvaWQgZGVmYXVsdE1ha2VDYWNoZUtleSBpZiB5b3VyIHJ1bnRpbWVcbi8vIGRvZXMgbm90IHN1cHBvcnQgV2Vha01hcCwgb3IgeW91IGhhdmUgdGhlIGFiaWxpdHkgdG8gcmV0dXJuIGEgc3RyaW5nIGtleS5cbi8vIEluIHRob3NlIGNhc2VzLCBqdXN0IHdyaXRlIHlvdXIgb3duIGN1c3RvbSBtYWtlQ2FjaGVLZXkgZnVuY3Rpb25zLlxubGV0IGRlZmF1bHRLZXlUcmllO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNYWtlQ2FjaGVLZXkoLi4uYXJncykge1xuICAgIGNvbnN0IHRyaWUgPSBkZWZhdWx0S2V5VHJpZSB8fCAoZGVmYXVsdEtleVRyaWUgPSBuZXcgVHJpZSh0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiKSk7XG4gICAgcmV0dXJuIHRyaWUubG9va3VwQXJyYXkoYXJncyk7XG59XG4vLyBJZiB5b3UncmUgcGFyYW5vaWQgYWJvdXQgbWVtb3J5IGxlYWtzLCBvciB5b3Ugd2FudCB0byBhdm9pZCB1c2luZyBXZWFrTWFwXG4vLyB1bmRlciB0aGUgaG9vZCwgYnV0IHlvdSBzdGlsbCBuZWVkIHRoZSBiZWhhdmlvciBvZiBkZWZhdWx0TWFrZUNhY2hlS2V5LFxuLy8gaW1wb3J0IHRoaXMgY29uc3RydWN0b3IgdG8gY3JlYXRlIHlvdXIgb3duIHRyaWVzLlxuZXhwb3J0IHsgVHJpZSBhcyBLZXlUcmllIH07XG47XG5jb25zdCBjYWNoZXMgPSBuZXcgU2V0KCk7XG5leHBvcnQgZnVuY3Rpb24gd3JhcChvcmlnaW5hbEZ1bmN0aW9uLCB7IG1heCA9IE1hdGgucG93KDIsIDE2KSwga2V5QXJncywgbWFrZUNhY2hlS2V5ID0gZGVmYXVsdE1ha2VDYWNoZUtleSwgbm9ybWFsaXplUmVzdWx0LCBzdWJzY3JpYmUsIGNhY2hlOiBjYWNoZU9wdGlvbiA9IFN0cm9uZ0NhY2hlLCB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKSkge1xuICAgIGNvbnN0IGNhY2hlID0gdHlwZW9mIGNhY2hlT3B0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBuZXcgY2FjaGVPcHRpb24obWF4LCBlbnRyeSA9PiBlbnRyeS5kaXNwb3NlKCkpXG4gICAgICAgIDogY2FjaGVPcHRpb247XG4gICAgY29uc3Qgb3B0aW1pc3RpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGtleUFyZ3MgPyBrZXlBcmdzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5ID0gbmV3IEVudHJ5KG9yaWdpbmFsRnVuY3Rpb24pKTtcbiAgICAgICAgICAgIGVudHJ5Lm5vcm1hbGl6ZVJlc3VsdCA9IG5vcm1hbGl6ZVJlc3VsdDtcbiAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgICAgIC8vIEdpdmUgdGhlIEVudHJ5IHRoZSBhYmlsaXR5IHRvIHRyaWdnZXIgY2FjaGUuZGVsZXRlKGtleSksIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAvLyB0aGUgRW50cnkgaXRzZWxmIGRvZXMgbm90IGtub3cgYWJvdXQga2V5IG9yIGNhY2hlLlxuICAgICAgICAgICAgZW50cnkuZm9yZ2V0ID0gKCkgPT4gY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbnRyeS5yZWNvbXB1dGUoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIC8vIE1vdmUgdGhpcyBlbnRyeSB0byB0aGUgZnJvbnQgb2YgdGhlIGxlYXN0LXJlY2VudGx5IHVzZWQgcXVldWUsXG4gICAgICAgIC8vIHNpbmNlIHdlIGp1c3QgZmluaXNoZWQgY29tcHV0aW5nIGl0cyB2YWx1ZS5cbiAgICAgICAgY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgICAgICBjYWNoZXMuYWRkKGNhY2hlKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYW55IGV4Y2VzcyBlbnRyaWVzIGluIHRoZSBjYWNoZSwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gYWN0aXZlIHBhcmVudCBlbnRyeSwgbWVhbmluZyB3ZSdyZSBub3QgaW4gdGhlIG1pZGRsZSBvZiBhIGxhcmdlclxuICAgICAgICAvLyBjb21wdXRhdGlvbiB0aGF0IG1pZ2h0IGJlIGZsdW1tb3hlZCBieSB0aGUgY2xlYW5pbmcuXG4gICAgICAgIGlmICghcGFyZW50RW50cnlTbG90Lmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNhY2hlcy5mb3JFYWNoKGNhY2hlID0+IGNhY2hlLmNsZWFuKCkpO1xuICAgICAgICAgICAgY2FjaGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGltaXN0aWMsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gY2FjaGUuc2l6ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgT2JqZWN0LmZyZWV6ZShvcHRpbWlzdGljLm9wdGlvbnMgPSB7XG4gICAgICAgIG1heCxcbiAgICAgICAga2V5QXJncyxcbiAgICAgICAgbWFrZUNhY2hlS2V5LFxuICAgICAgICBub3JtYWxpemVSZXN1bHQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgY2FjaGUsXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZGlydHlLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ga2V5ICYmIGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5LnNldERpcnR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3B0aW1pc3RpYy5kaXJ0eUtleSA9IGRpcnR5S2V5O1xuICAgIG9wdGltaXN0aWMuZGlydHkgPSBmdW5jdGlvbiBkaXJ0eSgpIHtcbiAgICAgICAgZGlydHlLZXkobWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGVla0tleShrZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBrZXkgJiYgY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnBlZWsoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHRpbWlzdGljLnBlZWtLZXkgPSBwZWVrS2V5O1xuICAgIG9wdGltaXN0aWMucGVlayA9IGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiBwZWVrS2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvcmdldEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGNhY2hlLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIG9wdGltaXN0aWMuZm9yZ2V0S2V5ID0gZm9yZ2V0S2V5O1xuICAgIG9wdGltaXN0aWMuZm9yZ2V0ID0gZnVuY3Rpb24gZm9yZ2V0KCkge1xuICAgICAgICByZXR1cm4gZm9yZ2V0S2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIG9wdGltaXN0aWMubWFrZUNhY2hlS2V5ID0gbWFrZUNhY2hlS2V5O1xuICAgIG9wdGltaXN0aWMuZ2V0S2V5ID0ga2V5QXJncyA/IGZ1bmN0aW9uIGdldEtleSgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBrZXlBcmdzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH0gOiBtYWtlQ2FjaGVLZXk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob3B0aW1pc3RpYyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiVHJpZSIsIlN0cm9uZ0NhY2hlIiwiRW50cnkiLCJwYXJlbnRFbnRyeVNsb3QiLCJiaW5kQ29udGV4dCIsIm5vQ29udGV4dCIsIm5vblJlYWN0aXZlIiwic2V0VGltZW91dCIsImFzeW5jRnJvbUdlbiIsIlNsb3QiLCJkZXAiLCJkZWZhdWx0S2V5VHJpZSIsImRlZmF1bHRNYWtlQ2FjaGVLZXkiLCJhcmdzIiwidHJpZSIsIldlYWtNYXAiLCJsb29rdXBBcnJheSIsIktleVRyaWUiLCJjYWNoZXMiLCJTZXQiLCJ3cmFwIiwib3JpZ2luYWxGdW5jdGlvbiIsIm1heCIsIk1hdGgiLCJwb3ciLCJrZXlBcmdzIiwibWFrZUNhY2hlS2V5Iiwibm9ybWFsaXplUmVzdWx0Iiwic3Vic2NyaWJlIiwiY2FjaGUiLCJjYWNoZU9wdGlvbiIsIk9iamVjdCIsImNyZWF0ZSIsImVudHJ5IiwiZGlzcG9zZSIsIm9wdGltaXN0aWMiLCJrZXkiLCJhcHBseSIsImFyZ3VtZW50cyIsImdldCIsInNldCIsImZvcmdldCIsImRlbGV0ZSIsInZhbHVlIiwicmVjb21wdXRlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhZGQiLCJoYXNWYWx1ZSIsImZvckVhY2giLCJjbGVhbiIsImNsZWFyIiwiZGVmaW5lUHJvcGVydHkiLCJzaXplIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsIm9wdGlvbnMiLCJkaXJ0eUtleSIsInNldERpcnR5IiwiZGlydHkiLCJwZWVrS2V5IiwicGVlayIsImZvcmdldEtleSIsImdldEtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/node_modules/@wry/trie/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/optimism/node_modules/@wry/trie/lib/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Trie: function() { return /* binding */ Trie; }\n/* harmony export */ });\n// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = ()=>Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nclass Trie {\n    lookup() {\n        for(var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++){\n            array[_key] = arguments[_key];\n        }\n        return this.lookupArray(array);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, (key)=>node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        for(var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++){\n            array[_key] = arguments[_key];\n        }\n        return this.peekArray(array);\n    }\n    peekArray(array) {\n        let node = this;\n        for(let i = 0, len = array.length; node && i < len; ++i){\n            const map = this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    getChildTrie(key) {\n        const map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());\n        let child = map.get(key);\n        if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    constructor(weakness = true, makeData = defaultMakeData){\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n}\nfunction isObjRef(value) {\n    switch(typeof value){\n        case \"object\":\n            if (value === null) break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9ub2RlX21vZHVsZXMvQHdyeS90cmllL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEseUVBQXlFO0FBQ3pFLG9FQUFvRTtBQUNwRSxvQkFBb0I7QUFDcEIsNEVBQTRFO0FBQzVFLHlCQUF5QjtBQUN6QixNQUFNQSxrQkFBa0IsSUFBTUMsT0FBT0MsTUFBTSxDQUFDO0FBQzVDLDZEQUE2RDtBQUM3RCxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUdDLE1BQU1DLFNBQVM7QUFDMUMsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR04sT0FBT0ssU0FBUztBQUNwQyxNQUFNRTtJQUtUQyxTQUFpQjtRQUFWO1lBQUdDLE1BQUgsdUJBQVE7O1FBQ1gsT0FBTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Q7SUFDNUI7SUFDQUMsWUFBWUQsS0FBSyxFQUFFO1FBQ2YsSUFBSUUsT0FBTyxJQUFJO1FBQ2ZULFFBQVFVLElBQUksQ0FBQ0gsT0FBT0ksQ0FBQUEsTUFBT0YsT0FBT0EsS0FBS0csWUFBWSxDQUFDRDtRQUNwRCxPQUFPUCxlQUFlTSxJQUFJLENBQUNELE1BQU0sVUFDM0JBLEtBQUtJLElBQUksR0FDVEosS0FBS0ksSUFBSSxHQUFHLElBQUksQ0FBQ0MsUUFBUSxDQUFDYixNQUFNUyxJQUFJLENBQUNIO0lBQy9DO0lBQ0FRLE9BQWU7UUFBVjtZQUFHUixNQUFILHVCQUFROztRQUNULE9BQU8sSUFBSSxDQUFDUyxTQUFTLENBQUNUO0lBQzFCO0lBQ0FTLFVBQVVULEtBQUssRUFBRTtRQUNiLElBQUlFLE9BQU8sSUFBSTtRQUNmLElBQUssSUFBSVEsSUFBSSxHQUFHQyxNQUFNWCxNQUFNWSxNQUFNLEVBQUVWLFFBQVFRLElBQUlDLEtBQUssRUFBRUQsRUFBRztZQUN0RCxNQUFNRyxNQUFNLElBQUksQ0FBQ0MsUUFBUSxJQUFJQyxTQUFTZixLQUFLLENBQUNVLEVBQUUsSUFBSVIsS0FBS2MsSUFBSSxHQUFHZCxLQUFLZSxNQUFNO1lBQ3pFZixPQUFPVyxPQUFPQSxJQUFJSyxHQUFHLENBQUNsQixLQUFLLENBQUNVLEVBQUU7UUFDbEM7UUFDQSxPQUFPUixRQUFRQSxLQUFLSSxJQUFJO0lBQzVCO0lBQ0FELGFBQWFELEdBQUcsRUFBRTtRQUNkLE1BQU1TLE1BQU0sSUFBSSxDQUFDQyxRQUFRLElBQUlDLFNBQVNYLE9BQ2hDLElBQUksQ0FBQ1ksSUFBSSxJQUFLLEtBQUksQ0FBQ0EsSUFBSSxHQUFHLElBQUlHLFNBQVEsSUFDdEMsSUFBSSxDQUFDRixNQUFNLElBQUssS0FBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSUcsS0FBSTtRQUM1QyxJQUFJQyxRQUFRUixJQUFJSyxHQUFHLENBQUNkO1FBQ3BCLElBQUksQ0FBQ2lCLE9BQ0RSLElBQUlTLEdBQUcsQ0FBQ2xCLEtBQUtpQixRQUFRLElBQUl2QixLQUFLLElBQUksQ0FBQ2dCLFFBQVEsRUFBRSxJQUFJLENBQUNQLFFBQVE7UUFDOUQsT0FBT2M7SUFDWDtJQWpDQUUsWUFBWVQsV0FBVyxJQUFJLEVBQUVQLFdBQVdqQixlQUFlLENBQUU7UUFDckQsSUFBSSxDQUFDd0IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNQLFFBQVEsR0FBR0E7SUFDcEI7QUErQko7QUFDQSxTQUFTUSxTQUFTUyxLQUFLO0lBQ25CLE9BQVEsT0FBT0E7UUFDWCxLQUFLO1lBQ0QsSUFBSUEsVUFBVSxNQUNWO1FBQ1IsaUNBQWlDO1FBQ2pDLEtBQUs7WUFDRCxPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29wdGltaXNtL25vZGVfbW9kdWxlcy9Ad3J5L3RyaWUvbGliL2luZGV4LmpzPzQyODIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBbdHJpZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpZSkgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBob2xkc1xuLy8gb2JqZWN0IGtleXMgd2Vha2x5LCB5ZXQgY2FuIGFsc28gaG9sZCBub24tb2JqZWN0IGtleXMsIHVubGlrZSB0aGVcbi8vIG5hdGl2ZSBgV2Vha01hcGAuXG4vLyBJZiBubyBtYWtlRGF0YSBmdW5jdGlvbiBpcyBzdXBwbGllZCwgdGhlIGxvb2tlZC11cCBkYXRhIHdpbGwgYmUgYW4gZW1wdHksXG4vLyBudWxsLXByb3RvdHlwZSBPYmplY3QuXG5jb25zdCBkZWZhdWx0TWFrZURhdGEgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVXNlZnVsIGZvciBwcm9jZXNzaW5nIGFyZ3VtZW50cyBvYmplY3RzIGFzIHdlbGwgYXMgYXJyYXlzLlxuY29uc3QgeyBmb3JFYWNoLCBzbGljZSB9ID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmV4cG9ydCBjbGFzcyBUcmllIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWFrbmVzcyA9IHRydWUsIG1ha2VEYXRhID0gZGVmYXVsdE1ha2VEYXRhKSB7XG4gICAgICAgIHRoaXMud2Vha25lc3MgPSB3ZWFrbmVzcztcbiAgICAgICAgdGhpcy5tYWtlRGF0YSA9IG1ha2VEYXRhO1xuICAgIH1cbiAgICBsb29rdXAoLi4uYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBsb29rdXBBcnJheShhcnJheSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgICAgIGZvckVhY2guY2FsbChhcnJheSwga2V5ID0+IG5vZGUgPSBub2RlLmdldENoaWxkVHJpZShrZXkpKTtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJkYXRhXCIpXG4gICAgICAgICAgICA/IG5vZGUuZGF0YVxuICAgICAgICAgICAgOiBub2RlLmRhdGEgPSB0aGlzLm1ha2VEYXRhKHNsaWNlLmNhbGwoYXJyYXkpKTtcbiAgICB9XG4gICAgcGVlayguLi5hcnJheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBwZWVrQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBub2RlICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gdGhpcy53ZWFrbmVzcyAmJiBpc09ialJlZihhcnJheVtpXSkgPyBub2RlLndlYWsgOiBub2RlLnN0cm9uZztcbiAgICAgICAgICAgIG5vZGUgPSBtYXAgJiYgbWFwLmdldChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5kYXRhO1xuICAgIH1cbiAgICBnZXRDaGlsZFRyaWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMud2Vha25lc3MgJiYgaXNPYmpSZWYoa2V5KVxuICAgICAgICAgICAgPyB0aGlzLndlYWsgfHwgKHRoaXMud2VhayA9IG5ldyBXZWFrTWFwKCkpXG4gICAgICAgICAgICA6IHRoaXMuc3Ryb25nIHx8ICh0aGlzLnN0cm9uZyA9IG5ldyBNYXAoKSk7XG4gICAgICAgIGxldCBjaGlsZCA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBjaGlsZCA9IG5ldyBUcmllKHRoaXMud2Vha25lc3MsIHRoaXMubWFrZURhdGEpKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT2JqUmVmKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gcmV0dXJuIHRydWUuLi5cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHRNYWtlRGF0YSIsIk9iamVjdCIsImNyZWF0ZSIsImZvckVhY2giLCJzbGljZSIsIkFycmF5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJUcmllIiwibG9va3VwIiwiYXJyYXkiLCJsb29rdXBBcnJheSIsIm5vZGUiLCJjYWxsIiwia2V5IiwiZ2V0Q2hpbGRUcmllIiwiZGF0YSIsIm1ha2VEYXRhIiwicGVlayIsInBlZWtBcnJheSIsImkiLCJsZW4iLCJsZW5ndGgiLCJtYXAiLCJ3ZWFrbmVzcyIsImlzT2JqUmVmIiwid2VhayIsInN0cm9uZyIsImdldCIsIldlYWtNYXAiLCJNYXAiLCJjaGlsZCIsInNldCIsImNvbnN0cnVjdG9yIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/node_modules/@wry/trie/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ts-invariant/lib/invariant.js":
/*!****************************************************!*\
  !*** ./node_modules/ts-invariant/lib/invariant.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvariantError: function() { return /* binding */ InvariantError; },\n/* harmony export */   invariant: function() { return /* binding */ invariant; },\n/* harmony export */   setVerbosity: function() { return /* binding */ setVerbosity; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n\nvar genericMessage = \"Invariant Violation\";\nvar _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n} : _a;\nvar InvariantError = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(InvariantError, _super);\n    function InvariantError(message) {\n        if (message === void 0) {\n            message = genericMessage;\n        }\n        var _this = _super.call(this, typeof message === \"number\" ? genericMessage + \": \" + message + \" (see https://github.com/apollographql/invariant-packages)\" : message) || this;\n        _this.framesToPop = 1;\n        _this.name = genericMessage;\n        setPrototypeOf(_this, InvariantError.prototype);\n        return _this;\n    }\n    return InvariantError;\n}(Error);\n\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new InvariantError(message);\n    }\n}\nvar verbosityLevels = [\n    \"debug\",\n    \"log\",\n    \"warn\",\n    \"error\",\n    \"silent\"\n];\nvar verbosityLevel = verbosityLevels.indexOf(\"log\");\nfunction wrapConsoleMethod(name) {\n    return function() {\n        if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n            // Default to console.log if this host environment happens not to provide\n            // all the console.* methods we need.\n            var method = console[name] || console.log;\n            return method.apply(console, arguments);\n        }\n    };\n}\n(function(invariant) {\n    invariant.debug = wrapConsoleMethod(\"debug\");\n    invariant.log = wrapConsoleMethod(\"log\");\n    invariant.warn = wrapConsoleMethod(\"warn\");\n    invariant.error = wrapConsoleMethod(\"error\");\n})(invariant || (invariant = {}));\nfunction setVerbosity(level) {\n    var old = verbosityLevels[verbosityLevel];\n    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n    return old;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (invariant); //# sourceMappingURL=invariant.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cy1pbnZhcmlhbnQvbGliL2ludmFyaWFudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2xDLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxLQUFLQyxPQUFPQyxjQUFjLEVBQUVBLGlCQUFpQkYsT0FBTyxLQUFLLElBQUksU0FBVUcsR0FBRyxFQUFFQyxLQUFLO0lBQ2pGRCxJQUFJRSxTQUFTLEdBQUdEO0lBQ2hCLE9BQU9EO0FBQ1gsSUFBSUg7QUFDSixJQUFJTSxpQkFBaUIsV0FBVyxHQUFJLFNBQVVDLE1BQU07SUFDaERULGdEQUFTQSxDQUFDUSxnQkFBZ0JDO0lBQzFCLFNBQVNELGVBQWVFLE9BQU87UUFDM0IsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFBRUEsVUFBVVQ7UUFBZ0I7UUFDcEQsSUFBSVUsUUFBUUYsT0FBT0csSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPRixZQUFZLFdBQzNDVCxpQkFBaUIsT0FBT1MsVUFBVSwrREFDbENBLFlBQVksSUFBSTtRQUN0QkMsTUFBTUUsV0FBVyxHQUFHO1FBQ3BCRixNQUFNRyxJQUFJLEdBQUdiO1FBQ2JHLGVBQWVPLE9BQU9ILGVBQWVPLFNBQVM7UUFDOUMsT0FBT0o7SUFDWDtJQUNBLE9BQU9IO0FBQ1gsRUFBRVE7QUFDd0I7QUFDbkIsU0FBU0MsVUFBVUMsU0FBUyxFQUFFUixPQUFPO0lBQ3hDLElBQUksQ0FBQ1EsV0FBVztRQUNaLE1BQU0sSUFBSVYsZUFBZUU7SUFDN0I7QUFDSjtBQUNBLElBQUlTLGtCQUFrQjtJQUFDO0lBQVM7SUFBTztJQUFRO0lBQVM7Q0FBUztBQUNqRSxJQUFJQyxpQkFBaUJELGdCQUFnQkUsT0FBTyxDQUFDO0FBQzdDLFNBQVNDLGtCQUFrQlIsSUFBSTtJQUMzQixPQUFPO1FBQ0gsSUFBSUssZ0JBQWdCRSxPQUFPLENBQUNQLFNBQVNNLGdCQUFnQjtZQUNqRCx5RUFBeUU7WUFDekUscUNBQXFDO1lBQ3JDLElBQUlHLFNBQVNDLE9BQU8sQ0FBQ1YsS0FBSyxJQUFJVSxRQUFRQyxHQUFHO1lBQ3pDLE9BQU9GLE9BQU9HLEtBQUssQ0FBQ0YsU0FBU0c7UUFDakM7SUFDSjtBQUNKO0FBQ0MsVUFBVVYsU0FBUztJQUNoQkEsVUFBVVcsS0FBSyxHQUFHTixrQkFBa0I7SUFDcENMLFVBQVVRLEdBQUcsR0FBR0gsa0JBQWtCO0lBQ2xDTCxVQUFVWSxJQUFJLEdBQUdQLGtCQUFrQjtJQUNuQ0wsVUFBVWEsS0FBSyxHQUFHUixrQkFBa0I7QUFDeEMsR0FBR0wsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQ3ZCLFNBQVNjLGFBQWFDLEtBQUs7SUFDOUIsSUFBSUMsTUFBTWQsZUFBZSxDQUFDQyxlQUFlO0lBQ3pDQSxpQkFBaUJjLEtBQUtDLEdBQUcsQ0FBQyxHQUFHaEIsZ0JBQWdCRSxPQUFPLENBQUNXO0lBQ3JELE9BQU9DO0FBQ1g7QUFDQSwrREFBZWhCLFNBQVNBLEVBQUMsQ0FDekIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cy1pbnZhcmlhbnQvbGliL2ludmFyaWFudC5qcz83NjgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xudmFyIGdlbmVyaWNNZXNzYWdlID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7XG52YXIgX2EgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIHNldFByb3RvdHlwZU9mID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChvYmosIHByb3RvKSB7XG4gICAgb2JqLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBvYmo7XG59IDogX2E7XG52YXIgSW52YXJpYW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludmFyaWFudEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludmFyaWFudEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gZ2VuZXJpY01lc3NhZ2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZW9mIG1lc3NhZ2UgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8gZ2VuZXJpY01lc3NhZ2UgKyBcIjogXCIgKyBtZXNzYWdlICsgXCIgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9pbnZhcmlhbnQtcGFja2FnZXMpXCJcbiAgICAgICAgICAgIDogbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZnJhbWVzVG9Qb3AgPSAxO1xuICAgICAgICBfdGhpcy5uYW1lID0gZ2VuZXJpY01lc3NhZ2U7XG4gICAgICAgIHNldFByb3RvdHlwZU9mKF90aGlzLCBJbnZhcmlhbnRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbnZhcmlhbnRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydCB7IEludmFyaWFudEVycm9yIH07XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG52YXIgdmVyYm9zaXR5TGV2ZWxzID0gW1wiZGVidWdcIiwgXCJsb2dcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJzaWxlbnRcIl07XG52YXIgdmVyYm9zaXR5TGV2ZWwgPSB2ZXJib3NpdHlMZXZlbHMuaW5kZXhPZihcImxvZ1wiKTtcbmZ1bmN0aW9uIHdyYXBDb25zb2xlTWV0aG9kKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodmVyYm9zaXR5TGV2ZWxzLmluZGV4T2YobmFtZSkgPj0gdmVyYm9zaXR5TGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY29uc29sZS5sb2cgaWYgdGhpcyBob3N0IGVudmlyb25tZW50IGhhcHBlbnMgbm90IHRvIHByb3ZpZGVcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgY29uc29sZS4qIG1ldGhvZHMgd2UgbmVlZC5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBjb25zb2xlW25hbWVdIHx8IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbihmdW5jdGlvbiAoaW52YXJpYW50KSB7XG4gICAgaW52YXJpYW50LmRlYnVnID0gd3JhcENvbnNvbGVNZXRob2QoXCJkZWJ1Z1wiKTtcbiAgICBpbnZhcmlhbnQubG9nID0gd3JhcENvbnNvbGVNZXRob2QoXCJsb2dcIik7XG4gICAgaW52YXJpYW50Lndhcm4gPSB3cmFwQ29uc29sZU1ldGhvZChcIndhcm5cIik7XG4gICAgaW52YXJpYW50LmVycm9yID0gd3JhcENvbnNvbGVNZXRob2QoXCJlcnJvclwiKTtcbn0pKGludmFyaWFudCB8fCAoaW52YXJpYW50ID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRWZXJib3NpdHkobGV2ZWwpIHtcbiAgICB2YXIgb2xkID0gdmVyYm9zaXR5TGV2ZWxzW3ZlcmJvc2l0eUxldmVsXTtcbiAgICB2ZXJib3NpdHlMZXZlbCA9IE1hdGgubWF4KDAsIHZlcmJvc2l0eUxldmVscy5pbmRleE9mKGxldmVsKSk7XG4gICAgcmV0dXJuIG9sZDtcbn1cbmV4cG9ydCBkZWZhdWx0IGludmFyaWFudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFyaWFudC5qcy5tYXAiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZ2VuZXJpY01lc3NhZ2UiLCJfYSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwib2JqIiwicHJvdG8iLCJfX3Byb3RvX18iLCJJbnZhcmlhbnRFcnJvciIsIl9zdXBlciIsIm1lc3NhZ2UiLCJfdGhpcyIsImNhbGwiLCJmcmFtZXNUb1BvcCIsIm5hbWUiLCJwcm90b3R5cGUiLCJFcnJvciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsInZlcmJvc2l0eUxldmVscyIsInZlcmJvc2l0eUxldmVsIiwiaW5kZXhPZiIsIndyYXBDb25zb2xlTWV0aG9kIiwibWV0aG9kIiwiY29uc29sZSIsImxvZyIsImFwcGx5IiwiYXJndW1lbnRzIiwiZGVidWciLCJ3YXJuIiwiZXJyb3IiLCJzZXRWZXJib3NpdHkiLCJsZXZlbCIsIm9sZCIsIk1hdGgiLCJtYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ts-invariant/lib/invariant.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: function() { return /* binding */ __addDisposableResource; },\n/* harmony export */   __assign: function() { return /* binding */ __assign; },\n/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },\n/* harmony export */   __await: function() { return /* binding */ __await; },\n/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },\n/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },\n/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },\n/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },\n/* harmony export */   __decorate: function() { return /* binding */ __decorate; },\n/* harmony export */   __disposeResources: function() { return /* binding */ __disposeResources; },\n/* harmony export */   __esDecorate: function() { return /* binding */ __esDecorate; },\n/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },\n/* harmony export */   __extends: function() { return /* binding */ __extends; },\n/* harmony export */   __generator: function() { return /* binding */ __generator; },\n/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },\n/* harmony export */   __importStar: function() { return /* binding */ __importStar; },\n/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   __metadata: function() { return /* binding */ __metadata; },\n/* harmony export */   __param: function() { return /* binding */ __param; },\n/* harmony export */   __propKey: function() { return /* binding */ __propKey; },\n/* harmony export */   __read: function() { return /* binding */ __read; },\n/* harmony export */   __rest: function() { return /* binding */ __rest; },\n/* harmony export */   __rewriteRelativeImportExtension: function() { return /* binding */ __rewriteRelativeImportExtension; },\n/* harmony export */   __runInitializers: function() { return /* binding */ __runInitializers; },\n/* harmony export */   __setFunctionName: function() { return /* binding */ __setFunctionName; },\n/* harmony export */   __spread: function() { return /* binding */ __spread; },\n/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },\n/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },\n/* harmony export */   __values: function() { return /* binding */ __values; }\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n}\n;\nfunction __runInitializers(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++){\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n}\n;\nfunction __propKey(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n}\n;\nfunction __setFunctionName(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", {\n        configurable: true,\n        value: prefix ? \"\".concat(prefix, \" \", name) : name\n    });\n}\n;\nfunction __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __createBinding = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction __exportStar(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\n/** @deprecated */ function __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\n;\nvar __setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nvar ownKeys = function(o) {\n    ownKeys = Object.getOwnPropertyNames || function(o) {\n        var ar = [];\n        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n        return ar;\n    };\n    return ownKeys(o);\n};\nfunction __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n}\nfunction __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\nfunction __addDisposableResource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction __disposeResources(env) {\n    function fail(e) {\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n        env.hasError = true;\n    }\n    var r, s = 0;\n    function next() {\n        while(r = env.stack.pop()){\n            try {\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                if (r.dispose) {\n                    var result = r.dispose.call(r.value);\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                        fail(e);\n                        return next();\n                    });\n                } else s |= 1;\n            } catch (e) {\n                fail(e);\n            }\n        }\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n        if (env.hasError) throw env.error;\n    }\n    return next();\n}\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : d + ext + \".\" + cm.toLowerCase() + \"js\";\n        });\n    }\n    return path;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    __extends,\n    __assign,\n    __rest,\n    __decorate,\n    __param,\n    __esDecorate,\n    __runInitializers,\n    __propKey,\n    __setFunctionName,\n    __metadata,\n    __awaiter,\n    __generator,\n    __createBinding,\n    __exportStar,\n    __values,\n    __read,\n    __spread,\n    __spreadArrays,\n    __spreadArray,\n    __await,\n    __asyncGenerator,\n    __asyncDelegator,\n    __asyncValues,\n    __makeTemplateObject,\n    __importStar,\n    __importDefault,\n    __classPrivateFieldGet,\n    __classPrivateFieldSet,\n    __classPrivateFieldIn,\n    __addDisposableResource,\n    __disposeResources,\n    __rewriteRelativeImportExtension\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUU5RCxJQUFJQSxnQkFBZ0IsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQy9CRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7UUFBRUMsV0FBVyxFQUFFO0lBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUksU0FBUyxHQUFHSDtJQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQUU7SUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7QUFDMUI7QUFFTyxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDNUIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJVSxVQUFVLHlCQUF5QkMsT0FBT1gsS0FBSztJQUM3REYsY0FBY0MsR0FBR0M7SUFDakIsU0FBU1k7UUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2Q7SUFBRztJQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9hLE1BQU0sQ0FBQ2QsS0FBTVksQ0FBQUEsR0FBR04sU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSU0sSUFBRztBQUNwRjtBQUVPLElBQUlHLFdBQVc7SUFDcEJBLFdBQVdkLE9BQU9lLE1BQU0sSUFBSSxTQUFTRCxTQUFTRSxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVB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T0YsTUFBTUgsY0FBYyxTQUFTLFFBQVFwTCxLQUFNLEVBQUN3TCxPQUFPLENBQUNDLEVBQUMsSUFBSzFFLElBQUsvRyxJQUFJd0wsTUFBTSxNQUFNQyxHQUFHQyxXQUFXLEtBQUs7UUFDN0c7SUFDSjtJQUNBLE9BQU9QO0FBQ1Q7QUFFQSwrREFBZTtJQUNieks7SUFDQU07SUFDQVM7SUFDQUs7SUFDQVc7SUFDQUc7SUFDQXNCO0lBQ0FJO0lBQ0FHO0lBQ0FJO0lBQ0FJO0lBQ0FhO0lBQ0FlO0lBQ0FTO0lBQ0FDO0lBQ0FDO0lBQ0FHO0lBQ0FDO0lBQ0FLO0lBQ0FNO0lBQ0FDO0lBQ0FTO0lBQ0FDO0lBQ0FDO0lBQ0FNO0lBQ0FFO0lBQ0FFO0lBQ0FJO0lBQ0FDO0lBQ0FDO0lBQ0FZO0lBQ0FHO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzPzY3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIl0sIm5hbWVzIjpbImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19yZXN0IiwiZSIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fZXNEZWNvcmF0ZSIsImN0b3IiLCJkZXNjcmlwdG9ySW4iLCJjb250ZXh0SW4iLCJpbml0aWFsaXplcnMiLCJleHRyYUluaXRpYWxpemVycyIsImFjY2VwdCIsImYiLCJraW5kIiwiZGVzY3JpcHRvciIsIm5hbWUiLCJfIiwiZG9uZSIsImNvbnRleHQiLCJhY2Nlc3MiLCJhZGRJbml0aWFsaXplciIsInB1c2giLCJyZXN1bHQiLCJnZXQiLCJzZXQiLCJpbml0IiwidW5zaGlmdCIsIl9fcnVuSW5pdGlhbGl6ZXJzIiwidGhpc0FyZyIsInZhbHVlIiwidXNlVmFsdWUiLCJfX3Byb3BLZXkiLCJ4IiwiY29uY2F0IiwiX19zZXRGdW5jdGlvbk5hbWUiLCJwcmVmaXgiLCJkZXNjcmlwdGlvbiIsImNvbmZpZ3VyYWJsZSIsIl9fbWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJtZXRhZGF0YSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsInkiLCJnIiwiSXRlcmF0b3IiLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2Iiwib3AiLCJwb3AiLCJfX2NyZWF0ZUJpbmRpbmciLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJfX2V4cG9ydFN0YXIiLCJfX3ZhbHVlcyIsIl9fcmVhZCIsImFyIiwiZXJyb3IiLCJfX3NwcmVhZCIsIl9fc3ByZWFkQXJyYXlzIiwiaWwiLCJhIiwiaiIsImpsIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwic2xpY2UiLCJfX2F3YWl0IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJxIiwiQXN5bmNJdGVyYXRvciIsImF3YWl0UmV0dXJuIiwicmVzdW1lIiwic2V0dGxlIiwiZnVsZmlsbCIsInNoaWZ0IiwiX19hc3luY0RlbGVnYXRvciIsIl9fYXN5bmNWYWx1ZXMiLCJfX21ha2VUZW1wbGF0ZU9iamVjdCIsImNvb2tlZCIsInJhdyIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19pbXBvcnRTdGFyIiwibW9kIiwiX19pbXBvcnREZWZhdWx0IiwiZGVmYXVsdCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwiaGFzIiwiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRJbiIsIl9fYWRkRGlzcG9zYWJsZVJlc291cmNlIiwiZW52IiwiYXN5bmMiLCJkaXNwb3NlIiwiaW5uZXIiLCJhc3luY0Rpc3Bvc2UiLCJzdGFjayIsIl9TdXBwcmVzc2VkRXJyb3IiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwiX19kaXNwb3NlUmVzb3VyY2VzIiwiZmFpbCIsImhhc0Vycm9yIiwiX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24iLCJwYXRoIiwicHJlc2VydmVKc3giLCJ0ZXN0IiwicmVwbGFjZSIsInRzeCIsImV4dCIsImNtIiwidG9Mb3dlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zen-observable-ts/module.js":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/module.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: function() { return /* binding */ Observable; }\n/* harmony export */ });\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\n// === Symbol Support ===\nvar hasSymbols = function() {\n    return typeof Symbol === \"function\";\n};\nvar hasSymbol = function(name) {\n    return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n};\nif (hasSymbols() && !hasSymbol(\"observable\")) {\n    Symbol.observable = Symbol(\"observable\");\n}\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\nfunction getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n}\nfunction getSpecies(obj) {\n    var ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(e) {\n    if (hostReportError.log) {\n        hostReportError.log(e);\n    } else {\n        setTimeout(function() {\n            throw e;\n        });\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(function() {\n        try {\n            fn();\n        } catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    var cleanup = subscription._cleanup;\n    if (cleanup === undefined) return;\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        } else {\n            var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    var queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for(var i = 0; i < queue.length; ++i){\n        notifySubscription(subscription, queue[i].type, queue[i].value);\n        if (subscription._state === \"closed\") break;\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    var observer = subscription._observer;\n    try {\n        var m = getMethod(observer, type);\n        switch(type){\n            case \"next\":\n                if (m) m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m) m.call(observer, value);\n                else throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m) m.call(observer);\n                break;\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") cleanupSubscription(subscription);\n    else if (subscription._state === \"running\") subscription._state = \"ready\";\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") return;\n    if (subscription._state === \"buffering\") {\n        subscription._queue.push({\n            type: type,\n            value: value\n        });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [\n            {\n                type: type,\n                value: value\n            }\n        ];\n        enqueue(function() {\n            return flushSubscription(subscription);\n        });\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nvar Subscription = /*#__PURE__*/ function() {\n    function Subscription(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        var subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        } catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") this._state = \"ready\";\n    }\n    var _proto = Subscription.prototype;\n    _proto.unsubscribe = function unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    };\n    _createClass(Subscription, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._state === \"closed\";\n            }\n        }\n    ]);\n    return Subscription;\n}();\nvar SubscriptionObserver = /*#__PURE__*/ function() {\n    function SubscriptionObserver(subscription) {\n        this._subscription = subscription;\n    }\n    var _proto2 = SubscriptionObserver.prototype;\n    _proto2.next = function next(value) {\n        onNotify(this._subscription, \"next\", value);\n    };\n    _proto2.error = function error(value) {\n        onNotify(this._subscription, \"error\", value);\n    };\n    _proto2.complete = function complete() {\n        onNotify(this._subscription, \"complete\");\n    };\n    _createClass(SubscriptionObserver, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._subscription._state === \"closed\";\n            }\n        }\n    ]);\n    return SubscriptionObserver;\n}();\nvar Observable = /*#__PURE__*/ function() {\n    function Observable(subscriber) {\n        if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\");\n        if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n        this._subscriber = subscriber;\n    }\n    var _proto3 = Observable.prototype;\n    _proto3.subscribe = function subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n            observer = {\n                next: observer,\n                error: arguments[1],\n                complete: arguments[2]\n            };\n        }\n        return new Subscription(observer, this._subscriber);\n    };\n    _proto3.forEach = function forEach(fn) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve();\n            }\n            var subscription = _this.subscribe({\n                next: function(value) {\n                    try {\n                        fn(value, done);\n                    } catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve\n            });\n        });\n    };\n    _proto3.map = function map(fn) {\n        var _this2 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this2.subscribe({\n                next: function(value) {\n                    try {\n                        value = fn(value);\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.filter = function filter(fn) {\n        var _this3 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this3.subscribe({\n                next: function(value) {\n                    try {\n                        if (!fn(value)) return;\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.reduce = function reduce(fn) {\n        var _this4 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        var hasSeed = arguments.length > 1;\n        var hasValue = false;\n        var seed = arguments[1];\n        var acc = seed;\n        return new C(function(observer) {\n            return _this4.subscribe({\n                next: function(value) {\n                    var first = !hasValue;\n                    hasValue = true;\n                    if (!first || hasSeed) {\n                        try {\n                            acc = fn(acc, value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    } else {\n                        acc = value;\n                    }\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    if (!hasValue && !hasSeed) return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                    observer.next(acc);\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.concat = function concat() {\n        var _this5 = this;\n        for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n            sources[_key] = arguments[_key];\n        }\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscription;\n            var index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next: function(v) {\n                        observer.next(v);\n                    },\n                    error: function(e) {\n                        observer.error(e);\n                    },\n                    complete: function() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        } else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    }\n                });\n            }\n            startNext(_this5);\n            return function() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    };\n    _proto3.flatMap = function flatMap(fn) {\n        var _this6 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscriptions = [];\n            var outer = _this6.subscribe({\n                next: function(value) {\n                    if (fn) {\n                        try {\n                            value = fn(value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    var inner = C.from(value).subscribe({\n                        next: function(value) {\n                            observer.next(value);\n                        },\n                        error: function(e) {\n                            observer.error(e);\n                        },\n                        complete: function() {\n                            var i = subscriptions.indexOf(inner);\n                            if (i >= 0) subscriptions.splice(i, 1);\n                            completeIfDone();\n                        }\n                    });\n                    subscriptions.push(inner);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    completeIfDone();\n                }\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) observer.complete();\n            }\n            return function() {\n                subscriptions.forEach(function(s) {\n                    return s.unsubscribe();\n                });\n                outer.unsubscribe();\n            };\n        });\n    };\n    _proto3[SymbolObservable] = function() {\n        return this;\n    };\n    Observable.from = function from(x) {\n        var C = typeof this === \"function\" ? this : Observable;\n        if (x == null) throw new TypeError(x + \" is not an object\");\n        var method = getMethod(x, SymbolObservable);\n        if (method) {\n            var observable = method.call(x);\n            if (Object(observable) !== observable) throw new TypeError(observable + \" is not an object\");\n            if (isObservable(observable) && observable.constructor === C) return observable;\n            return new C(function(observer) {\n                return observable.subscribe(observer);\n            });\n        }\n        if (hasSymbol(\"iterator\")) {\n            method = getMethod(x, SymbolIterator);\n            if (method) {\n                return new C(function(observer) {\n                    enqueue(function() {\n                        if (observer.closed) return;\n                        for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){\n                            var item = _step.value;\n                            observer.next(item);\n                            if (observer.closed) return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(function(observer) {\n                enqueue(function() {\n                    if (observer.closed) return;\n                    for(var i = 0; i < x.length; ++i){\n                        observer.next(x[i]);\n                        if (observer.closed) return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    };\n    Observable.of = function of() {\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        var C = typeof this === \"function\" ? this : Observable;\n        return new C(function(observer) {\n            enqueue(function() {\n                if (observer.closed) return;\n                for(var i = 0; i < items.length; ++i){\n                    observer.next(items[i]);\n                    if (observer.closed) return;\n                }\n                observer.complete();\n            });\n        });\n    };\n    _createClass(Observable, null, [\n        {\n            key: SymbolSpecies,\n            get: function() {\n                return this;\n            }\n        }\n    ]);\n    return Observable;\n}();\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError: hostReportError\n        },\n        configurable: true\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96ZW4tb2JzZXJ2YWJsZS10cy9tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLGdDQUFnQ0MsQ0FBQyxFQUFFQyxjQUFjO0lBQUksSUFBSUMsS0FBSyxPQUFPQyxXQUFXLGVBQWVILENBQUMsQ0FBQ0csT0FBT0MsUUFBUSxDQUFDLElBQUlKLENBQUMsQ0FBQyxhQUFhO0lBQUUsSUFBSUUsSUFBSSxPQUFPLENBQUNBLEtBQUtBLEdBQUdHLElBQUksQ0FBQ0wsRUFBQyxFQUFHTSxJQUFJLENBQUNDLElBQUksQ0FBQ0w7SUFBSyxJQUFJTSxNQUFNQyxPQUFPLENBQUNULE1BQU9FLENBQUFBLEtBQUtRLDRCQUE0QlYsRUFBQyxLQUFNQyxrQkFBa0JELEtBQUssT0FBT0EsRUFBRVcsTUFBTSxLQUFLLFVBQVU7UUFBRSxJQUFJVCxJQUFJRixJQUFJRTtRQUFJLElBQUlVLElBQUk7UUFBRyxPQUFPO1lBQWMsSUFBSUEsS0FBS1osRUFBRVcsTUFBTSxFQUFFLE9BQU87Z0JBQUVFLE1BQU07WUFBSztZQUFHLE9BQU87Z0JBQUVBLE1BQU07Z0JBQU9DLE9BQU9kLENBQUMsQ0FBQ1ksSUFBSTtZQUFDO1FBQUc7SUFBRztJQUFFLE1BQU0sSUFBSUcsVUFBVTtBQUEwSTtBQUUzbEIsU0FBU0wsNEJBQTRCVixDQUFDLEVBQUVnQixNQUFNO0lBQUksSUFBSSxDQUFDaEIsR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9pQixrQkFBa0JqQixHQUFHZ0I7SUFBUyxJQUFJRSxJQUFJQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ2hCLElBQUksQ0FBQ0wsR0FBR3NCLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJSixNQUFNLFlBQVlsQixFQUFFdUIsV0FBVyxFQUFFTCxJQUFJbEIsRUFBRXVCLFdBQVcsQ0FBQ0MsSUFBSTtJQUFFLElBQUlOLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9B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LGNBQWM7SUFDaEJ4QixPQUFPa0IsY0FBYyxDQUFDbUIsWUFBWXJELE9BQU8sZUFBZTtRQUN0RFcsT0FBTztZQUNMOEgsUUFBUTNGO1lBQ1JVLGlCQUFpQkE7UUFDbkI7UUFDQXhCLGNBQWM7SUFDaEI7QUFDRjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvbW9kdWxlLmpzP2Y3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gPT09IFN5bWJvbCBTdXBwb3J0ID09PVxudmFyIGhhc1N5bWJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGhhc1N5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2xzKCkgJiYgQm9vbGVhbihTeW1ib2xbbmFtZV0pO1xufTtcblxudmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2wobmFtZSkgPyBTeW1ib2xbbmFtZV0gOiAnQEAnICsgbmFtZTtcbn07XG5cbmlmIChoYXNTeW1ib2xzKCkgJiYgIWhhc1N5bWJvbCgnb2JzZXJ2YWJsZScpKSB7XG4gIFN5bWJvbC5vYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG59XG5cbnZhciBTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sKCdvYnNlcnZhYmxlJyk7XG52YXIgU3ltYm9sU3BlY2llcyA9IGdldFN5bWJvbCgnc3BlY2llcycpOyAvLyA9PT0gQWJzdHJhY3QgT3BlcmF0aW9ucyA9PT1cblxuZnVuY3Rpb24gZ2V0TWV0aG9kKG9iaiwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWVzKG9iaikge1xuICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAoY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3RvciA9IGN0b3JbU3ltYm9sU3BlY2llc107XG5cbiAgICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgICAgY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3RvciAhPT0gdW5kZWZpbmVkID8gY3RvciA6IE9ic2VydmFibGU7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgT2JzZXJ2YWJsZTsgLy8gU1BFQzogQnJhbmQgY2hlY2tcbn1cblxuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGUpIHtcbiAgaWYgKGhvc3RSZXBvcnRFcnJvci5sb2cpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IubG9nKGUpO1xuICB9IGVsc2Uge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlKGZuKSB7XG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fY2xlYW51cDtcbiAgaWYgKGNsZWFudXAgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBzdWJzY3JpcHRpb24uX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFjbGVhbnVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2V0TWV0aG9kKGNsZWFudXAsICd1bnN1YnNjcmliZScpO1xuXG4gICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdW5zdWJzY3JpYmUuY2FsbChjbGVhbnVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnY2xvc2VkJztcbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBxdWV1ZSA9IHN1YnNjcmlwdGlvbi5fcXVldWU7XG5cbiAgaWYgKCFxdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBxdWV1ZVtpXS50eXBlLCBxdWV1ZVtpXS52YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSkge1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3J1bm5pbmcnO1xuICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX29ic2VydmVyO1xuXG4gIHRyeSB7XG4gICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIsIHR5cGUpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7ZWxzZSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO2Vsc2UgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdydW5uaW5nJykgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdyZWFkeSc7XG59XG5cbmZ1bmN0aW9uIG9uTm90aWZ5KHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSByZXR1cm47XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdidWZmZXJpbmcnKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9xdWV1ZS5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlICE9PSAncmVhZHknKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdidWZmZXJpbmcnO1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUgPSBbe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH1dO1xuICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpO1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gICAgLy8gQVNTRVJUOiBvYnNlcnZlciBpcyBhbiBvYmplY3RcbiAgICAvLyBBU1NFUlQ6IHN1YnNjcmliZXIgaXMgY2FsbGFibGVcbiAgICB0aGlzLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5pdGlhbGl6aW5nJztcbiAgICB2YXIgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2xlYW51cCA9IHN1YnNjcmliZXIuY2FsbCh1bmRlZmluZWQsIHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpcHRpb25PYnNlcnZlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdpbml0aWFsaXppbmcnKSB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTtcbiAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJzY3JpcHRpb24sIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb25PYnNlcnZlcihzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLm5leHQgPSBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnbmV4dCcsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmVycm9yID0gZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdlcnJvcicsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnY29tcGxldGUnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb25PYnNlcnZlcjtcbn0oKTtcblxudmFyIE9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmFibGUgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGluaXRpYWxpemVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogb2JzZXJ2ZXIsXG4gICAgICAgIGVycm9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGNvbXBsZXRlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX3N1YnNjcmliZXIpO1xuICB9O1xuXG4gIF9wcm90bzMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odmFsdWUsIGRvbmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZuKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWZuKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5yZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoZm4pIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGFjYyA9IHNlZWQ7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFmaXJzdCB8fCBoYXNTZWVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhY2MgPSBmbihhY2MsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUgJiYgIWhhc1NlZWQpIHJldHVybiBvYnNlcnZlci5lcnJvcihuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVkdWNlIGFuIGVtcHR5IHNlcXVlbmNlJykpO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dChuZXh0KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5leHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydE5leHQoQy5mcm9tKHNvdXJjZXNbaW5kZXgrK10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGFydE5leHQoX3RoaXM1KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5mbGF0TWFwID0gZnVuY3Rpb24gZmxhdE1hcChmbikge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIG91dGVyID0gX3RoaXM2LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5uZXIgPSBDLmZyb20odmFsdWUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGlubmVyKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gMCkgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcGxldGVJZkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlSWZEb25lKCkge1xuICAgICAgICBpZiAob3V0ZXIuY2xvc2VkICYmIHN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvM1tTeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xPYnNlcnZhYmxlKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbWV0aG9kLmNhbGwoeCk7XG4gICAgICBpZiAoT2JqZWN0KG9ic2VydmFibGUpICE9PSBvYnNlcnZhYmxlKSB0aHJvdyBuZXcgVHlwZUVycm9yKG9ic2VydmFibGUgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIGlmIChpc09ic2VydmFibGUob2JzZXJ2YWJsZSkgJiYgb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3ltYm9sKCdpdGVyYXRvcicpKSB7XG4gICAgICBtZXRob2QgPSBnZXRNZXRob2QoeCwgU3ltYm9sSXRlcmF0b3IpO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShtZXRob2QuY2FsbCh4KSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbSk7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaV0pO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICB9O1xuXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogT2JzZXJ2YWJsZTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGUsIG51bGwsIFt7XG4gICAga2V5OiBTeW1ib2xTcGVjaWVzLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbmlmIChoYXNTeW1ib2xzKCkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIFN5bWJvbCgnZXh0ZW5zaW9ucycpLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHN5bWJvbDogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICAgIGhvc3RSZXBvcnRFcnJvcjogaG9zdFJlcG9ydEVycm9yXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGUgfTtcbiJdLCJuYW1lcyI6WyJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwibyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNhbGwiLCJuZXh0IiwiYmluZCIsIkFycmF5IiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImxlbmd0aCIsImkiLCJkb25lIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiaGFzU3ltYm9scyIsImhhc1N5bWJvbCIsIkJvb2xlYW4iLCJnZXRTeW1ib2wiLCJvYnNlcnZhYmxlIiwiU3ltYm9sSXRlcmF0b3IiLCJTeW1ib2xPYnNlcnZhYmxlIiwiU3ltYm9sU3BlY2llcyIsImdldE1ldGhvZCIsIm9iaiIsInVuZGVmaW5lZCIsImdldFNwZWNpZXMiLCJjdG9yIiwiT2JzZXJ2YWJsZSIsImlzT2JzZXJ2YWJsZSIsIngiLCJob3N0UmVwb3J0RXJyb3IiLCJlIiwibG9nIiwic2V0VGltZW91dCIsImVucXVldWUiLCJmbiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwiX2NsZWFudXAiLCJ1bnN1YnNjcmliZSIsImNsb3NlU3Vic2NyaXB0aW9uIiwiX29ic2VydmVyIiwiX3F1ZXVlIiwiX3N0YXRlIiwiZmx1c2hTdWJzY3JpcHRpb24iLCJxdWV1ZSIsIm5vdGlmeVN1YnNjcmlwdGlvbiIsInR5cGUiLCJvYnNlcnZlciIsIm0iLCJvbk5vdGlmeSIsInB1c2giLCJTdWJzY3JpcHRpb24iLCJzdWJzY3JpYmVyIiwic3Vic2NyaXB0aW9uT2JzZXJ2ZXIiLCJTdWJzY3JpcHRpb25PYnNlcnZlciIsImVycm9yIiwiX3Byb3RvIiwiZ2V0IiwiX3N1YnNjcmlwdGlvbiIsIl9wcm90bzIiLCJjb21wbGV0ZSIsIl9zdWJzY3JpYmVyIiwiX3Byb3RvMyIsInN1YnNjcmliZSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfdGhpcyIsInJlamVjdCIsIm1hcCIsIl90aGlzMiIsIkMiLCJmaWx0ZXIiLCJfdGhpczMiLCJyZWR1Y2UiLCJfdGhpczQiLCJoYXNTZWVkIiwiaGFzVmFsdWUiLCJzZWVkIiwiYWNjIiwiZmlyc3QiLCJjb25jYXQiLCJfdGhpczUiLCJfbGVuIiwic291cmNlcyIsIl9rZXkiLCJpbmRleCIsInN0YXJ0TmV4dCIsInYiLCJmbGF0TWFwIiwiX3RoaXM2Iiwic3Vic2NyaXB0aW9ucyIsIm91dGVyIiwiaW5uZXIiLCJpbmRleE9mIiwic3BsaWNlIiwiY29tcGxldGVJZkRvbmUiLCJjbG9zZWQiLCJzIiwibWV0aG9kIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJpdGVtIiwib2YiLCJfbGVuMiIsIml0ZW1zIiwiX2tleTIiLCJzeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zen-observable-ts/module.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fapp%2Fcomponents%2FApolloWrapper.js&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.js%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fmanuelnavarro%2Froar-headless%2Fstyles%2Fglobals.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);